/* automatically generated by JSCoverage - do not edit */
if (typeof _$jscoverage === 'undefined') _$jscoverage = {};
if (! _$jscoverage['class/composition.js']) {
  _$jscoverage['class/composition.js'] = [];
  _$jscoverage['class/composition.js'][1] = 0;
  _$jscoverage['class/composition.js'][66] = 0;
  _$jscoverage['class/composition.js'][67] = 0;
  _$jscoverage['class/composition.js'][70] = 0;
  _$jscoverage['class/composition.js'][71] = 0;
  _$jscoverage['class/composition.js'][72] = 0;
  _$jscoverage['class/composition.js'][75] = 0;
  _$jscoverage['class/composition.js'][78] = 0;
  _$jscoverage['class/composition.js'][139] = 0;
  _$jscoverage['class/composition.js'][140] = 0;
  _$jscoverage['class/composition.js'][144] = 0;
  _$jscoverage['class/composition.js'][148] = 0;
  _$jscoverage['class/composition.js'][149] = 0;
  _$jscoverage['class/composition.js'][151] = 0;
  _$jscoverage['class/composition.js'][152] = 0;
  _$jscoverage['class/composition.js'][168] = 0;
  _$jscoverage['class/composition.js'][171] = 0;
  _$jscoverage['class/composition.js'][233] = 0;
  _$jscoverage['class/composition.js'][234] = 0;
  _$jscoverage['class/composition.js'][235] = 0;
  _$jscoverage['class/composition.js'][236] = 0;
  _$jscoverage['class/composition.js'][237] = 0;
  _$jscoverage['class/composition.js'][241] = 0;
  _$jscoverage['class/composition.js'][245] = 0;
  _$jscoverage['class/composition.js'][250] = 0;
  _$jscoverage['class/composition.js'][251] = 0;
  _$jscoverage['class/composition.js'][253] = 0;
  _$jscoverage['class/composition.js'][255] = 0;
  _$jscoverage['class/composition.js'][256] = 0;
  _$jscoverage['class/composition.js'][260] = 0;
  _$jscoverage['class/composition.js'][266] = 0;
  _$jscoverage['class/composition.js'][270] = 0;
}
_$jscoverage['class/composition.js'][1]++;
var obj = require("../object"), array = require("../array"), apply = obj.apply, mix = obj.mix, oFilter = obj.filter, emptyFn = "../function".emptyFn, is = require("../is");
_$jscoverage['class/composition.js'][66]++;
function Composition(c) {
  _$jscoverage['class/composition.js'][67]++;
  var defaults = c.defaults, config = c;
  _$jscoverage['class/composition.js'][70]++;
  if (defaults) {
    _$jscoverage['class/composition.js'][71]++;
    mix(config, config.defaults);
    _$jscoverage['class/composition.js'][72]++;
    delete config.defaults;
  }
  _$jscoverage['class/composition.js'][75]++;
  apply(this, config);
}
_$jscoverage['class/composition.js'][78]++;
Composition.prototype = {create: (function () {
  _$jscoverage['class/composition.js'][139]++;
  var Constructor = this.Constructor;
  _$jscoverage['class/composition.js'][140]++;
  return new Constructor();
}), getInstance: (function () {
  _$jscoverage['class/composition.js'][144]++;
  return this.create();
}), validate: (function () {
  _$jscoverage['class/composition.js'][148]++;
  if (this.name === undefined) {
    _$jscoverage['class/composition.js'][149]++;
    throw new Error("A name must be defined");
  }
  _$jscoverage['class/composition.js'][151]++;
  if (! is.isFunction(this.Constructor) && this.create === Composition.prototype.create) {
    _$jscoverage['class/composition.js'][152]++;
    throw new Error("The Constructor must be function if create is not overridden");
  }
}), filterMethodFns: {allMethods: (function (key, value) {
  _$jscoverage['class/composition.js'][168]++;
  return is.isFunction(value);
}), publicMethods: (function (key, value) {
  _$jscoverage['class/composition.js'][171]++;
  return is.isFunction(value) && key.charAt(0) !== "_";
})}, methods: emptyFn, ignoreMethods: undefined, getObjectWithMethods: (function () {
  _$jscoverage['class/composition.js'][233]++;
  var methodsObj = this.Constructor && this.Constructor.prototype;
  _$jscoverage['class/composition.js'][234]++;
  if (this.ignoreMethods) {
    _$jscoverage['class/composition.js'][235]++;
    methodsObj = apply({}, methodsObj);
    _$jscoverage['class/composition.js'][236]++;
    array.each(this.ignoreMethods, (function (value) {
  _$jscoverage['class/composition.js'][237]++;
  delete methodsObj[value];
}));
  }
  _$jscoverage['class/composition.js'][241]++;
  return methodsObj;
}), getMethodsToCompose: (function () {
  _$jscoverage['class/composition.js'][245]++;
  var methods = this.methods, pairsToAdd, filterFn;
  _$jscoverage['class/composition.js'][250]++;
  if (is.isArray(methods)) {
    _$jscoverage['class/composition.js'][251]++;
    pairsToAdd = methods;
  }
  else {
    _$jscoverage['class/composition.js'][253]++;
    filterFn = methods;
    _$jscoverage['class/composition.js'][255]++;
    if (is.isString(methods)) {
      _$jscoverage['class/composition.js'][256]++;
      filterFn = this.filterMethodFns[methods];
    }
    _$jscoverage['class/composition.js'][260]++;
    pairsToAdd = oFilter(this.getObjectWithMethods(), filterFn, this, {ownProperties: false, keys: true});
  }
  _$jscoverage['class/composition.js'][266]++;
  return pairsToAdd;
})};
_$jscoverage['class/composition.js'][270]++;
module.exports = Composition;
_$jscoverage['class/composition.js'].source = ["var obj = require('../object'),","    array = require('../array'),","    apply = obj.apply,","    mix = obj.mix,","    oFilter = obj.filter,","    emptyFn = ('../function').emptyFn,","    is = require('../is');","","/**"," * @class  Luc.Composition"," * @protected"," * Class that wraps {@link Luc.define#$compositions composition} config objects"," * to conform to an api. This class is not available externally.  The config object"," * will override any protected methods and default configs.  Defaults"," * can be used for often used configs, keys that are not defaults will"," * override the defaults."," *","    var C = Luc.define({","        $compositions: {","            defaults: Luc.compositionEnums.EventEmitter,","            methods: ['emit']","        }","    });","","    var c = new C()","    typeof c.emit","    &gt;\"function\"","    typeof c.on","    &gt;\"undefined\""," *"," * If you want to add your own composition all you need to have is"," * a name and a Constructor, the rest of the configs of this class and Luc.Composition.create"," * can be used to inject behavior if needed."," * ","     function Counter() {","        this.count = 0;","     };","","     Counter.prototype = {","        getCount: function() {","            return this.count;","        },","        increaseCount: function() {","            this.count++;","        }","     }","","     var C = Luc.define({","            $compositions: {","                name: 'counter',","                Constructor: Counter,","                methods: 'allMethods'","            }","    });","","    var c = new C()","","    c.increaseCount();","    c.increaseCount();","    c.increaseCount();","    c.getCount();","    &gt;3","    c.count","    &gt;undefined"," */","function Composition(c) {","    var defaults = c.defaults,","        config = c;","","    if(defaults) {","        mix(config, config.defaults);","        delete config.defaults;","    }","","    apply(this, config);","}","","Composition.prototype = {","    /**","     * @cfg {String} name (required) the name","     */","    ","    /**","     * @cfg {Object} defaults","     */","    ","    /**","     * @cfg {Boolean} initAfter  defaults to false","     * pass in true to init the composition instance after the ","     * superclass has been called.","     */","","    /**","     * @cfg {Function} Constructor (required) the Constructor","     * to use when creating the composition instance.  This","     * is required if Luc.Composition.create is not overwritten by","     * the passed in composition config object.","     */","    ","    /**","     * @protected","     * By default just return a newly created Constructor instance.","     * ","     * When create is called the following properties can be used :","     * ","     * this.instance The instance that is creating","     * the composition.","     * ","     * this.Constructor the constructor that is passed in from","     * the composition config. ","     *","     * this.instanceArgs the arguments passed into the instance when it ","     * is being created.  For example","","        new MyClassWithAComposition({plugins: []})","        //inside of the create method","        this.instanceArgs","        &gt;[{plugins: []}]","","     * @return {Object} ","     * the composition instance.","     *","     * For example set the emitters maxListeners","     * to what the instance has configed.","      ","        maxListeners: 100,","        $compositions: {","            Constructor: Luc.EventEmitter,","            create: function() {","                var emitter = new this.Constructor();","                emitter.setMaxListeners(this.instance.maxListeners);","                return emitter;","            },","            name: 'emitter'","        }","","     */","    create: function() {","        var Constructor = this.Constructor;","        return new Constructor();","    },","","    getInstance: function() {","        return this.create();","    },","","    validate: function() {","        if(this.name  === undefined) {","            throw new Error('A name must be defined');","        }","        if(!is.isFunction(this.Constructor) &amp;&amp; this.create === Composition.prototype.create) {","            throw new Error('The Constructor must be function if create is not overridden');","        }","    },","","    /**","     * @property filterMethodFns","     * @type {Object}","     * @property filterMethodFns.allMethods return all methods from the","     * constructors prototype","     * @property filterMethodFns.public return all methods that don't","     * start with _.  We know not everyone follows this convention, but we","     * do and so do many others.","     * @type {Function}","     */","    filterMethodFns: {","        allMethods: function(key, value) {","            return is.isFunction(value);","        },","        publicMethods: function(key, value) {","            return is.isFunction(value) &amp;&amp; key.charAt(0) !== '_';","        }","    },","","    /**","     * @cfg {Function/String/Array[]} methods","     * The keys to add to the definers prototype that will in turn call","     * the compositions method.","     * ","     * Defaults to Luc.emptyFn. ","     * If an array is passed it will just use that Array.","     * ","     * If a string is passed and matches a method from ","     * Luc.Composition.filterMethodFns it will call that instead.","     * ","     * If a function is defined it","     * will get called while iterating over each key value pair of the ","     * Constructor's prototype, if a truthy value is ","     * returned the property will be added to the defining","     * classes prototype.","     * ","     * For example this config will only expose the emit method ","     * to the defining class","     ","        $compositions: {","            Constructor: Luc.EventEmitter,","            methods: function(key, value) {","                return key === 'emit';","            },","            name: 'emitter'","        }","     * this is also a valid config","     * ","        $compositions: {","            Constructor: Luc.EventEmitter,","            methods: ['emitter'],","            name: 'emitter'","        }","     * ","     */","    methods: emptyFn,","","    /**","     * @cfg {String[]/String} ignoreMethods methods that will always","     * be ignored if methods is not an Array.","     *","        ","        var C = Luc.define({","                $compositions: {","                    defaults: Luc.compositionEnums.EventEmitter,","                    methods: 'allMethods',","                    ignoreMethods: ['emit']","                }","            });","","            var c = new C();","            typeof c.emit","            &gt;\"undefined\"","     */","    ignoreMethods: undefined,","","    getObjectWithMethods: function() {","        var methodsObj = this.Constructor &amp;&amp; this.Constructor.prototype;","        if (this.ignoreMethods) {","            methodsObj = apply({}, methodsObj);","            array.each(this.ignoreMethods, function(value) {","                delete methodsObj[value];","            });","        }","","        return methodsObj;","    },","","    getMethodsToCompose: function() {","        var methods = this.methods,","            pairsToAdd,","            filterFn;","","","        if (is.isArray(methods)) {","            pairsToAdd = methods;","        } else {","            filterFn = methods;","","            if (is.isString(methods)) {","                filterFn = this.filterMethodFns[methods];","            }","","            //Constructors are not needed if create is overwritten","            pairsToAdd = oFilter(this.getObjectWithMethods(), filterFn, this, {","                ownProperties: false,","                keys: true","            });","        }","","        return pairsToAdd;","    }","};","","module.exports = Composition;"];
