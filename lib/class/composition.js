var obj = require('../object'),
    apply = obj.apply,
    oFilter = obj.filter;

/**
 * @class  Luc.Composition
 * @private
 * class that wraps $composition config objects
 * to conform to an api. The config object
 * will override any protected methods.
 */
function Composition(config) {
    apply(this, config);
}

Composition.prototype = {
    /**
     * @cfg {String} name (required) the name
     */
    
    /**
     * @cfg {Function} Constructor (required) the Constructor
     * to use when creating the composition instance.  This
     * is required if Luc.Composition.create is not overrwitten by
     * the passed in composition config object.
     */
    
    /**
     * @protected
     * By default just return a newly created Constructor instance.
     * 
     * When create is called the following properties can be used :
     * 
     * this.instance The instance that is creating
     * the composition.
     * 
     * this.Constructor the constructor that is passed in from
     * the composition config. 
     *
     * this.instanceArgs the arguments passed into the instance when it 
     * is being created.  For example

        new MyClassWithAComposition({plugins: []})
        //inside of the create method
        this.instanceArgs
        >[{plugins: []}]

     * @return {Object} 
     * the composition instance.
     *
     * For example set the emitters maxListeners
     * to what the instance has configed.
      
        maxListeners: 100,
        $compositions: {
            Constructor: Luc.EventEmitter,
            create: function() {
                var emitter = new this.Constructor();
                emitter.setMaxListeners(this.instance.maxListeners);
                return emitter;
            },
            name: 'emitter'
        }

     */
    create: function() {
        var Constructor = this.Constructor;
        return new Constructor();
    },

    getInstance: function() {
        return this.create();
    },

    validate: function() {
        if(this.name  === undefined) {
            throw new Error('A name must be defined');
        }
        if(typeof this.Constructor !== 'function' && this.create === Composition.prototype.create) {
            throw new Error('The Constructor must be function if create is not overriden');
        }
    },

    /**
     * @protected
     * Iterate over each key of the Constructor's prototype
     * calling this method.  If a truthy value is 
     * returned the method will be added to the defining
     * classes prototype.  By default all functions
     * will be added.
     * 
     * 
     * @param  {String} 
     * @param  {Object} value
     * @return {Boolean}
     * 
     *
     * For example this config will only expose the emit method 
     * to the defining class
     
        $compositions: {
            Constructor: Luc.EventEmitter,
            filterKeys: function(key, value) {
                return key === 'emit';
            },
            name: 'emitter'
        }
     *
     */
    filterKeys: function(key, value) {
        return typeof value === 'function';
    },

    getMethodsToCompose: function() {
        //Constructors are not needed if create is overwritten
        var pairsToAdd = oFilter(this.Constructor && this.Constructor.prototype, this.filterKeys, this, {
            ownProperties: false
        });

        return pairsToAdd.map(function(pair) {
            return pair.key;
        });
    }
};

module.exports = Composition;