Ext.data.JsonP.Luc_define({"tagname":"class","name":"Luc.define","extends":null,"mixins":[],"alternateClassNames":[],"aliases":{},"singleton":false,"requires":[],"uses":[],"enum":null,"override":null,"inheritable":null,"inheritdoc":null,"meta":{},"private":null,"id":"class-Luc.define","members":{"cfg":[{"name":"$compositions","tagname":"cfg","owner":"Luc.define","meta":{},"id":"cfg-S-compositions"},{"name":"$mixins","tagname":"cfg","owner":"Luc.define","meta":{},"id":"cfg-S-mixins"},{"name":"$statics","tagname":"cfg","owner":"Luc.define","meta":{},"id":"cfg-S-statics"},{"name":"$super","tagname":"cfg","owner":"Luc.define","meta":{},"id":"cfg-S-super"}],"property":[{"name":"$class","tagname":"property","owner":"Luc.define","meta":{},"id":"property-S-class"},{"name":"$super","tagname":"property","owner":"Luc.define","meta":{},"id":"property-S-super"},{"name":"$superclass","tagname":"property","owner":"Luc.define","meta":{},"id":"property-S-superclass"},{"name":"getComposition","tagname":"property","owner":"Luc.define","meta":{},"id":"property-getComposition"},{"name":"getStaticValue","tagname":"property","owner":"Luc.define","meta":{},"id":"property-getStaticValue"}],"method":[{"name":"define","tagname":"method","owner":"Luc.define","meta":{},"id":"method-define"}],"event":[],"css_var":[],"css_mixin":[]},"linenr":305,"files":[{"filename":"definer.js","href":"definer.html#Luc-define"}],"html_meta":{},"statics":{"cfg":[],"property":[],"method":[],"event":[],"css_var":[],"css_mixin":[]},"component":false,"superclasses":[],"subclasses":[],"mixedInto":[],"parentMixins":[],"html":"<div><pre class=\"hierarchy\"><h4>Files</h4><div class='dependency'><a href='source/definer.html#Luc-define' target='_blank'>definer.js</a></div></pre><div class='doc-contents'><p>This is actually a function but has a lot of decent amount of important options\nso we are documenting it like it is a class.  Properties are things that will get\napplied to instances of classes defined with <a href=\"#!/api/Luc.define-method-define\" rel=\"Luc.define-method-define\" class=\"docClass\">define</a>.  No\nare needed for <a href=\"#!/api/Luc.define-method-define\" rel=\"Luc.define-method-define\" class=\"docClass\">defining</a> a class.  <a href=\"#!/api/Luc.define-method-define\" rel=\"Luc.define-method-define\" class=\"docClass\">define</a>\njust takes the passed in config and puts the properties on the prototype and returns\na Constructor.</p>\n\n<pre><code>var C = <a href=\"#!/api/Luc.define\" rel=\"Luc.define\" class=\"docClass\">Luc.define</a>({\n    a: 1,\n    doLog: true,\n    logA: function() {\n        if (this.doLog) {\n            console.log(this.a);\n        }\n    }\n});\nvar c = new C();\nc.logA();\n&gt;1\nc.a = 45;\nc.logA();\n&gt;45\nc.doLog = false;\nc.logA();\n\nnew C().logA()\n&gt;1\n</code></pre>\n\n<p>Check out the following configs to add functionality to a class without messing\nup the inheritance chain.  All the configs have examples and documentation on\nhow to use them.</p>\n\n<p><a href=\"#!/api/Luc.define-property-S-super\" rel=\"Luc.define-property-S-super\" class=\"docClass\">super</a> <br>\n<a href=\"#!/api/Luc.define-cfg-S-compositions\" rel=\"Luc.define-cfg-S-compositions\" class=\"docClass\">compositions</a> <br>\n<a href=\"#!/api/Luc.define-cfg-S-mixins\" rel=\"Luc.define-cfg-S-mixins\" class=\"docClass\">mixins</a> <br>\n<a href=\"#!/api/Luc.define-cfg-S-statics\" rel=\"Luc.define-cfg-S-statics\" class=\"docClass\">statics</a> <br></p>\n</div><div class='members'><div class='members-section'><div class='definedBy'>Defined By</div><h3 class='members-title icon-cfg'>Config options</h3><div class='subsection'><div id='cfg-S-compositions' class='member first-child not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Luc.define'>Luc.define</span><br/><a href='source/definer.html#Luc-define-cfg-S-compositions' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Luc.define-cfg-S-compositions' class='name expandable'>$compositions</a><span> : <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a>/<a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a>[]</span></div><div class='description'><div class='short'>(optional) config objects for\nLuc.Composition. ...</div><div class='long'><p>(optional) config objects for\n<a href=\"#!/api/Luc.Composition\" rel=\"Luc.Composition\" class=\"docClass\">Luc.Composition</a>.  Compositions are a great way to add behavior to a class\nwithout extending it.  A $mixin can offer similar functionality but should\nbe stateless.  A Constructor and a name are needed for the config object\nThe filterKeys property is optional here but it is saying take all of\n<a href=\"#!/api/Luc.EventEmitter\" rel=\"Luc.EventEmitter\" class=\"docClass\">Luc.EventEmitter</a>'s instance methods and make them instance methods for C.\nYou can check out all of the config options by looking at <a href=\"#!/api/Luc.Composition\" rel=\"Luc.Composition\" class=\"docClass\">Luc.Composition</a>.</p>\n\n<pre><code>    var C = <a href=\"#!/api/Luc.define\" rel=\"Luc.define\" class=\"docClass\">Luc.define</a>({\n        $compositions: {\n            Constructor: <a href=\"#!/api/Luc.EventEmitter\" rel=\"Luc.EventEmitter\" class=\"docClass\">Luc.EventEmitter</a>,\n            name: 'emitter',\n            filterKeys: 'allMethods'\n        }\n    });\n\n    var c = new C();\n\n    c.on('hey', function() {\n        console.log(arguments);\n    });\n\n    c.emit('hey', 1,2,3, 'a');\n    &gt;[1, 2, 3, \"a\"]\n    c instanceof <a href=\"#!/api/Luc.EventEmitter\" rel=\"Luc.EventEmitter\" class=\"docClass\">Luc.EventEmitter</a>\n    &gt;false\n    c._events\n    &gt;undefined\n</code></pre>\n\n<p><a href=\"#!/api/Luc.EventEmitter\" rel=\"Luc.EventEmitter\" class=\"docClass\">Luc.EventEmitter</a> is preferred as a composition over a mixin because\nit adds a state \"_events\" to the this instance when on is called.\nIt is not terrible practice by any means but it is not good to have an object\nthat knows that it may be mixin.  Even worse than that would be a mixin that needs\nto be inited by the defining class.  Encapsulating logic in a class\nand using it anywhere seamlessly is where compositions shine. Luc comes with two common\nenums that we expect will be used often.</p>\n\n<p><br>\nHere is an example of a composition that doesn't\ncome with Luc:</p>\n\n<pre><code>     function Counter() {\n        this.count = 0;\n     };\n\n     Counter.prototype = {\n        getCount: function() {\n            return this.count;\n        },\n        increaseCount: function() {\n            this.count++;\n        }\n     }\n\n     var C = <a href=\"#!/api/Luc.define\" rel=\"Luc.define\" class=\"docClass\">Luc.define</a>({\n            $compositions: {\n                name: 'counter',\n                Constructor: Counter,\n                filterKeys: 'allMethods'\n            }\n    });\n\n    var c = new C()\n\n    c.increaseCount();\n    c.increaseCount();\n    c.increaseCount();\n    c.getCount();\n    &gt;3\n    c.count\n</code></pre>\n\n<p>Here is the plugin manager enum in action keep in mind that this\nfunctionality can be added to any class, not just ones defined with\n<a href=\"#!/api/Luc.define\" rel=\"Luc.define\" class=\"docClass\">Luc.define</a>.</p>\n\n<pre><code>function MyPlugin() {\n    this.myCoolName = 'coo';\n\n    this.init = function() {\n        console.log('im getting initted');\n    }\n    this.destroy = function() {\n        console.log('MyPlugin instance being destroyed')\n    }\n}\n\nvar C = <a href=\"#!/api/Luc.define\" rel=\"Luc.define\" class=\"docClass\">Luc.define</a>({\n    $compositions: <a href=\"#!/api/Luc.compositionEnumns-property-PluginManager\" rel=\"Luc.compositionEnumns-property-PluginManager\" class=\"docClass\">Luc.compositionEnumns.PluginManager</a>\n});\n\nvar c = new C({\n    //inheriting from <a href=\"#!/api/Luc.Base\" rel=\"Luc.Base\" class=\"docClass\">Luc.Base</a> is not needed\n    super: null,\n    plugins: [{Constructor: MyPlugin, myCoolName: 'coo'}]\n});\n&gt;im getting initted\n\nc.getPlugin({myCoolName: 'coo'}) instanceof MyPlugin\n&gt; true\n\n\nc.a = 1;\n//This will be the default Luc.Plugin\nc.addPlugin({\n    init: function(owner) {\n        console.log(owner.a)\n    },\n    destroy: function() {\n        console.log('Im getting destroyed')\n    }\n});\n\n&gt;1\n\nc.destroyAllPlugins();\n&gt;MyPlugin instance being destroyed\n&gt;I'm getting destroyed.\n\nc.getPlugin({myCoolName: 'coo'})\n&gt;false\n</code></pre>\n\n<p>You can see that it can add plugin like behavior to any defining\nclass with Luc.PluginManger which is less than 75 SLOC.</p>\n</div></div></div><div id='cfg-S-mixins' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Luc.define'>Luc.define</span><br/><a href='source/definer.html#Luc-define-cfg-S-mixins' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Luc.define-cfg-S-mixins' class='name expandable'>$mixins</a><span> : Object/Constructor/Object[]/Constructor[]</span></div><div class='description'><div class='short'>(optional)  Mixins are a way to add functionality\nto a class that should not add state. ...</div><div class='long'><p>(optional)  Mixins are a way to add functionality\nto a class that should not add state.  $mixins can be either objects or Constructors.</p>\n\n<pre><code>function Logger() {}\nLogger.prototype.log = function() {\n    console.log(arguments)\n}\n\nvar C = <a href=\"#!/api/Luc.define\" rel=\"Luc.define\" class=\"docClass\">Luc.define</a>({\n    $mixins: [Logger, {\n        warn: function() {\n            console.warn(arguments)\n        }\n    }]\n});\n\nvar c = new C();\n\nc.log(1,2)\n&gt;[1,2]\n\nc.warn(3,4)\n&gt;[3,4]\n</code></pre>\n</div></div></div><div id='cfg-S-statics' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Luc.define'>Luc.define</span><br/><a href='source/definer.html#Luc-define-cfg-S-statics' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Luc.define-cfg-S-statics' class='name expandable'>$statics</a><span> : <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a></span></div><div class='description'><div class='short'>(optional) Add static properties or methods\nto the class. ...</div><div class='long'><p>(optional) Add static properties or methods\nto the class.  These properties/methods will not be able to be\ndirectly modified by the instance so they are good for defining default\nconfigs.</p>\n\n<pre><code>var C = <a href=\"#!/api/Luc.define\" rel=\"Luc.define\" class=\"docClass\">Luc.define</a>({\n    $statics: {\n        number: 1\n    }\n});\n\nvar c = new C();\nc.number\n&gt;undefined\nC.number\n&gt;1\n</code></pre>\n\n<p>Bad things can happen if non primitives are placed on the\nprototype and instance sharing is not wanted.  Using statics\nprevent subclasses and instances from unknowingly modifying\nall instances.</p>\n\n<pre><code>var C = <a href=\"#!/api/Luc.define\" rel=\"Luc.define\" class=\"docClass\">Luc.define</a>({\n    cfg: {\n        a: 1\n    }\n});\n\nvar c = new C();\nc.cfg.a\n&gt;1\nc.cfg.a = 5\nnew C().cfg.a\n&gt;5\n</code></pre>\n</div></div></div><div id='cfg-S-super' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Luc.define'>Luc.define</span><br/><a href='source/definer.html#Luc-define-cfg-S-super' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Luc.define-cfg-S-super' class='name expandable'>$super</a><span> : Constructor</span></div><div class='description'><div class='short'>(optional)  super for the defining class. ...</div><div class='long'><p>(optional)  super for the defining class.  By <a href=\"#!/api/Luc.Base\" rel=\"Luc.Base\" class=\"docClass\">Luc.Base</a>\nis the default if super is not passed in.  To define a class without a superclass\nyou can pass in false or null.</p>\n\n<pre><code> function Counter() {\n    this.count = 0;\n };\n\n Counter.prototype = {\n    getCount: function() {\n        return this.count;\n    },\n    increaseCount: function() {\n        this.count++;\n    }\n }\n\n var C = <a href=\"#!/api/Luc.define\" rel=\"Luc.define\" class=\"docClass\">Luc.define</a>({\n    $super:Counter\n});\n\nvar c = new C()\n\nc instanceof Counter\n&gt;true\nc.increaseCount();\nc.getCount();\n&gt;1\nc.count\n&gt;1\n</code></pre>\n\n<p>Check out <a href=\"#!/api/Luc.Base\" rel=\"Luc.Base\" class=\"docClass\">Luc.Base</a> to see why we have it as the default.</p>\n\n<pre><code>var B = <a href=\"#!/api/Luc.define\" rel=\"Luc.define\" class=\"docClass\">Luc.define</a>({\n    amIALucBase: function() {\n        return this instanceof <a href=\"#!/api/Luc.Base\" rel=\"Luc.Base\" class=\"docClass\">Luc.Base</a>\n    }\n})\nvar b = new B();\nb.amIALucBase();\n&gt;true\n</code></pre>\n</div></div></div></div></div><div class='members-section'><div class='definedBy'>Defined By</div><h3 class='members-title icon-property'>Properties</h3><div class='subsection'><div id='property-S-class' class='member first-child not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Luc.define'>Luc.define</span><br/><a href='source/definer.html#Luc-define-property-S-class' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Luc.define-property-S-class' class='name expandable'>$class</a><span> : <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a></span></div><div class='description'><div class='short'>reference to the instances own constructor. ...</div><div class='long'><p>reference to the instances own constructor.  This\nwill get added to any class that is defined with <a href=\"#!/api/Luc.define\" rel=\"Luc.define\" class=\"docClass\">Luc.define</a>.</p>\n\n<pre><code>var C = <a href=\"#!/api/Luc.define\" rel=\"Luc.define\" class=\"docClass\">Luc.define</a>()\nvar c = new C()\nc.$class === C\n&gt;true\n</code></pre>\n\n<p>There are some really good use cases to have a reference to it's\nown constructor.  <br> Add functionality to an instance in a simple\nand generic way.</p>\n\n<pre><code>var C = <a href=\"#!/api/Luc.define\" rel=\"Luc.define\" class=\"docClass\">Luc.define</a>({\n    add: function(a,b) {\n        return a + b;\n    }\n});\n\n//<a href=\"#!/api/Luc.Base\" rel=\"Luc.Base\" class=\"docClass\">Luc.Base</a> applies first \n//arg to the instance\n\nvar c = new C({\n    add: function(a,b,c) {\n        return this.$class.prototype.add.call(this, a,b) + c;\n    }\n});\n\nc.add(1,2,3)\n&gt;6\nnew C().add(1,2,3)\n&gt;3\n</code></pre>\n\n<p>Or have a simple generic clone method :</p>\n\n<pre><code>var C = <a href=\"#!/api/Luc.define\" rel=\"Luc.define\" class=\"docClass\">Luc.define</a>({\n    clone: function() {\n        var myOwnProps = {};\n        <a href=\"#!/api/Luc.Object-method-each\" rel=\"Luc.Object-method-each\" class=\"docClass\">Luc.Object.each</a>(this, function(key, value) {\n            myOwnProps[key] = value;\n        });\n\n        return new this.$class(myOwnProps);\n    }\n});\n\nvar c = new C({a:1,b:2,c:3});\nc.d = 4;\nvar clone = c.clone();\n\nclone === c\n&gt;false\n\nclone.a\n&gt;1\nclone.b\n&gt;2\nclone.c\n&gt;3\nclone.d\n&gt;4\n</code></pre>\n</div></div></div><div id='property-S-super' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Luc.define'>Luc.define</span><br/><a href='source/definer.html#Luc-define-property-S-super' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Luc.define-property-S-super' class='name expandable'>$super</a><span> : <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a></span></div><div class='description'><div class='short'>If $super is not false or null\nthe $super property will be added to every instance of the defined class,\n$super is th...</div><div class='long'><p>If $super is not false or null\nthe $super property will be added to every instance of the defined class,\n$super is the Constructor passed in with the $super config or the <a href=\"#!/api/Luc.ClassDefiner-cfg-defaultType\" rel=\"Luc.ClassDefiner-cfg-defaultType\" class=\"docClass\">default</a></p>\n\n<pre><code>var C = <a href=\"#!/api/Luc.define\" rel=\"Luc.define\" class=\"docClass\">Luc.define</a>()\nvar c = new C()\n//<a href=\"#!/api/Luc.Base\" rel=\"Luc.Base\" class=\"docClass\">Luc.Base</a> is the default \nc.$super === <a href=\"#!/api/Luc.Base\" rel=\"Luc.Base\" class=\"docClass\">Luc.Base</a>\n&gt;true\n</code></pre>\n</div></div></div><div id='property-S-superclass' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Luc.define'>Luc.define</span><br/><a href='source/definer.html#Luc-define-property-S-superclass' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Luc.define-property-S-superclass' class='name expandable'>$superclass</a><span> : <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a></span></div><div class='description'><div class='short'>If $super is defined it\nwill the prototype of $super. ...</div><div class='long'><p>If $super is defined it\nwill the prototype of $super.  It can be used to call parent's\nmethod</p>\n\n<pre><code>function MyCoolClass() {}\nMyCoolClass.prototype.addNums = function(a,b) {\n    return a + b;\n}\n\nvar MyOtherCoolClass = <a href=\"#!/api/Luc.define\" rel=\"Luc.define\" class=\"docClass\">Luc.define</a>({\n    $super: MyCoolClass,\n    addNums: function(a, b, c) {\n        return this.$superclass.addNums.call(this, a, b) + c;\n    }\n})\n\nvar m = new MyOtherCoolClass();\nm.addNums(1,2,3);\n&gt;6\n</code></pre>\n</div></div></div><div id='property-getComposition' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Luc.define'>Luc.define</span><br/><a href='source/definer.html#Luc-define-property-getComposition' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Luc.define-property-getComposition' class='name not-expandable'>getComposition</a><span> : <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a></span></div><div class='description'><div class='short'><p>this method will be\nto instances that use the $compositions config</p>\n</div><div class='long'><p>this method will be\nto instances that use the $compositions config</p>\n</div></div></div><div id='property-getStaticValue' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Luc.define'>Luc.define</span><br/><a href='source/definer.html#Luc-define-property-getStaticValue' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Luc.define-property-getStaticValue' class='name expandable'>getStaticValue</a><span> : <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a></span></div><div class='description'><div class='short'>this method\nwill be added to instances that use the $statics\nconfig. ...</div><div class='long'><p>this method\nwill be added to instances that use the $statics\nconfig.</p>\n\n<p>This should be used over this.$class.staticName to\nget the value over a static.  If the class gets inherited\nfrom this.$class will not be the same.  getStatic value\ndeals with this issue.</p>\n\n<pre><code>var A = <a href=\"#!/api/Luc.define\" rel=\"Luc.define\" class=\"docClass\">Luc.define</a>({\n$statics: {\na: 1\n},\ngetABetter: function() {\nreturn this.getStaticValue('a');\n},\ngetA: function() {\nreturn this.$class.a;\n}\n});\n\nvar B = <a href=\"#!/api/Luc.define\" rel=\"Luc.define\" class=\"docClass\">Luc.define</a>({\n$super: A,\n$statics: {\nb: 2,\nc: 3\n}\n});\n\n\nvar b = new B();\nb.getA();\n&gt;undefined\nb.getABetter();\n&gt;1\n</code></pre>\n</div></div></div></div></div><div class='members-section'><div class='definedBy'>Defined By</div><h3 class='members-title icon-method'>Methods</h3><div class='subsection'><div id='method-define' class='member first-child not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Luc.define'>Luc.define</span><br/><a href='source/definer.html#Luc-define-method-define' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Luc.define-method-define' class='name expandable'>define</a>( <span class='pre'>config</span> ) : <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a></div><div class='description'><div class='short'> ...</div><div class='long'>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>config</span> : <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a><div class='sub-desc'><p>config object used when creating the class.  Any property that\nis not apart of the special configs will be applied to the prototype.  Check out\n<a href=\"#!/api/Luc.define\" rel=\"Luc.define\" class=\"docClass\">Luc.define</a> for all the config options.   No configs are needed to define a class.</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'><a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a></span><div class='sub-desc'><p>the defined class</p>\n\n<pre><code>var C = <a href=\"#!/api/Luc.define\" rel=\"Luc.define\" class=\"docClass\">Luc.define</a>({\n    logA: function() {\n        console.log(this.a)\n    },\n    a: 1\n});\nvar c = new C();\nc.logA();\n&gt;1\n\nc.a = 4;\nc.logA();\n&gt;4\n</code></pre>\n</div></li></ul></div></div></div></div></div></div></div>"});