;(function(e,t,n){function i(n,s){if(!t[n]){if(!e[n]){var o=typeof require=="function"&&require;if(!s&&o)return o(n,!0);if(r)return r(n,!0);throw new Error("Cannot find module '"+n+"'")}var u=t[n]={exports:{}};e[n][0].call(u.exports,function(t){var r=e[n][1][t];return i(r?r:t)},u,u.exports)}return t[n].exports}var r=typeof require=="function"&&require;for(var s=0;s<n.length;s++)i(n[s]);return i})({1:[function(require,module,exports){
require('../array');
require('../object');
require('../nodet');
require('../class');
require('../is');
require('../function');
require('../compare');
},{"../array":2,"../object":3,"../nodet":4,"../class":5,"../is":6,"../compare":7,"../function":8}],9:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            if (ev.source === window && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],10:[function(require,module,exports){
(function(process){ module.exports = process.env.COVERAGE 
   ? require('../lib-cov/luc')
   : require('../lib/luc-es5-shim');
})(require("__browserify_process"))
},{"../lib-cov/luc":11,"../lib/luc-es5-shim":12,"__browserify_process":9}],2:[function(require,module,exports){
var Luc = require('./lucTestLib'),
    expect = require('expect.js');

describe('Luc Array functions', function() {
    it('each', function() {
        var arr = ['a', 'b', 'z'], obj = {str :'' };

        Luc.Array.each(arr, function(value, index, a) {
            this.str += value + index + a.length;
        }, obj);
        expect(obj.str).to.eql('a03b13z23');
    });

    it('toArray', function() {
        expect(Luc.Array.toArray(undefined)).to.eql([]);
        expect(Luc.Array.toArray(null)).to.eql([]);
        expect(Luc.Array.toArray([])).to.eql([]);
        expect(Luc.Array.toArray('')).to.eql(['']);
        expect(Luc.Array.toArray([1])).to.eql([1]);
    });

    it('insert append', function() {
        var arr1 = [1, 2, 3],
            arr2 = [4, 5, 6];
        expect(Luc.Array.insert(arr1, arr2, true)).to.be.eql([1, 2, 3, 4, 5, 6]);
        expect(Luc.Array.insert(arr2, arr1, true)).to.be.eql([4, 5, 6, 1, 2, 3]);
    });

    it('insert from indexes', function() {
        var arr1 = [1, 2, 3],
            arr2 = [4, 5, 6];

            expect(Luc.Array.insert(arr1, arr2, 3)).to.be.eql([1,2,3,4,5,6]);
            expect(Luc.Array.insert(arr1, arr2, 2)).to.be.eql([1,2,4,5,6,3]);
            expect(Luc.Array.insert(arr1, arr2, 1)).to.be.eql([1,4,5,6,2,3]);
            expect(Luc.Array.insert(arr1, arr2, 0)).to.be.eql([4,5,6, 1,2,3]);

            expect(Luc.Array.insert(arr2, arr1, 3)).to.be.eql([4,5,6,1,2,3]);
            expect(Luc.Array.insert(arr2, arr1, 2)).to.be.eql([4,5,1,2,3,6]);
            expect(Luc.Array.insert(arr2, arr1, 1)).to.be.eql([4,1,2,3,5,6]);
            expect(Luc.Array.insert(arr2, arr1, 0)).to.be.eql([1,2,3,4,5,6]);

    });


    it('insert arrays are not modified', function() {
        var arr1 = [1, 2, 3],
            arr2 = [4, 5, 6];
        Luc.Array.insert(arr1, arr2, 1);
        Luc.Array.insert(arr2, arr1, 1);
        //test no modify
        expect(arr1).to.be.eql([1, 2, 3]);
        expect(arr2).to.be.eql([4, 5, 6]);
    });

    it('removeAll with single falsy', function() {
        var arr = [false, false, 0, ''];
        var ret = Luc.Array.removeAll(arr, '');

        expect(arr).to.be.eql([false, false, 0]);
        expect(ret).to.be.eql(['']);
    });

    it('removeAll all values', function() {
        var arr = [false, false, false];
        var ret = Luc.Array.removeAll(arr, false);

        expect(arr).to.be.eql([]);
        expect(ret).to.be.eql([false, false, false]);
        expect(Luc.Array.removeAll(arr, false)).to.be.eql([]);
    });

    it('removeAll loose comparison', function() {
        var arr = [{}, {a:1}, {a:1, b:2}];
        var ret = Luc.Array.removeAll(arr, {a: 1});

        expect(ret).to.be.eql([{a:1}, {a:1, b:2}]);
        expect(arr).to.be.eql([{}]);
    });

    it('removeAll deep comparison', function() {
        var arr = [{}, {a:1}, {a:1, b:2}];
        var ret = Luc.Array.removeAll(arr, {a: 1}, {type: 'deep'});

        expect(ret).to.be.eql([{a:1}]);
        expect(arr).to.be.eql([{},{a:1, b:2}]);
    });

    it('removeAllNot single falsy', function() {
        var arr = [false, false, 0, ''],
            ret = Luc.Array.removeAllNot(arr, '');

        expect(arr).to.be.eql(['']);
        expect(ret).to.be.eql([false, false, 0]);
    });

    it('removeAllNot no matches', function() {
        var arr = [false, false, false];
        var ret = Luc.Array.removeAllNot(arr, false);

        expect(arr).to.be.eql([false, false, false]);
        expect(ret).to.be.eql([]);

    });

    it('removeAllNot single loose compare', function() {
        var arr = [{}, {a:1}, {a:1, b:2}];
        var ret = Luc.Array.removeAllNot(arr, {a: 1});

        expect(arr).to.be.eql([{a:1}, {a:1, b:2}]);
        expect(ret).to.be.eql([{}]);
    });

    it('removeFirst first multi array match', function() {
        var arr = [[],[1,2], [1,2]];
        var ret = Luc.Array.removeFirst(arr, [1,2]);

        expect(arr).to.be.eql([[],[1,2]]);
        expect(ret).to.be.eql([1,2]);
        expect(Luc.Array.removeFirst(arr, [1,2])).to.be.eql([1,2]);
    });

    it('removeFirst empty array strict', function() {
        var arr = [[], [], []];
        var ret = Luc.Array.removeFirst(arr, [], {type: 'strict'});
        expect(arr).to.be.eql([[],[],[]]);
        expect(ret).to.be.eql(false);
    });

    it('removeFirst empty array shallow', function() {
        var arr = [[], [], []];
        var ret = Luc.Array.removeFirst(arr, [], {type: 'shallow'});
        expect(arr).to.be.eql([[],[]]);
        expect(ret).to.be.eql([]);
    });

    it('removeFirstNot multi array match', function() {
        var arr = [[],[1,2], [1,2]];
        var ret = Luc.Array.removeFirstNot(arr, []);

        expect(arr).to.be.eql([[],[1,2]]);
        expect(ret).to.be.eql([1,2]);
        expect(Luc.Array.removeFirstNot(arr, [1,2])).to.be.eql([]);
        expect(Luc.Array.removeFirstNot(arr, [1,2])).to.be(false);
    });

    it('removeFirstNot not matches', function() {
        var arr = [{a:1}, {a:1, b:2}, {a:1}];
        var ret = Luc.Array.removeFirstNot(arr, {a: 1});

        expect(arr).to.be.eql([{a:1}, {a:1, b:2}, {a:1}]);
        expect(ret).to.be.eql(false);
    });

    it('removeFirstNot not strict compare', function() {
        var a = {a: 1};
        var arr = [{a:1}, {a:1, b:2}, a];

        var ret = Luc.Array.removeFirstNot(arr, {a:1}, {type: 'strict'});
        expect(arr).to.be.eql([{a:1, b:2}, {a:1}]);
        expect(ret).to.be.eql({a:1});
        Luc.Array.removeFirstNot(arr, a, {type: 'strict'});
        Luc.Array.removeFirstNot(arr, a, {type: 'strict'});
        ret = Luc.Array.removeFirstNot(arr, a, {type: 'strict'});
        expect(arr).to.be.eql([{a:1}]);
        expect(ret).to.be(false);
    });

    it('findFirst handle loose compare', function() {
         var arr = [{a:1}, {a:1}, {a:1}, {a:1, b:2}];
         expect(Luc.Array.findFirst(arr, {a:1, b:2})).to.be.eql({a:1, b:2});
    });

    it('findFirst strict compare', function() {
        var arr = [{a:1}, {a:1}, {a:1}, {a:1, b:2}];
         expect(Luc.Array.findFirst(arr, {a:1, b:2}, {type: 'strict'})).to.be.eql(false);
    });

    it('findFirst match all props', function() {
        var arr = [{a:1}, {a:1}, {a:1}, {a:1, b:2}];
        expect(Luc.Array.findFirst(arr, {a:1, b:2, c:3})).to.be.eql(false);
    });

    it('findFirst all falsys', function() {
        var arr = [false, 0, undefined, null, ''];
        //shim/IE bug
        if(0 in [undefined]) {
        expect(Luc.Array.findFirst(arr, null)).to.be.eql(null);
        expect(Luc.Array.findFirst(arr, false)).to.be.eql(false);
        expect(Luc.Array.findFirst(arr, undefined)).to.be.eql(undefined);
        expect(Luc.Array.findFirst(arr, 0)).to.be.eql(0);
        }
    });

    it('findFirst dates', function() {
         var arr = [new Date(1000), new Date(1000), new Date(1001)];
         expect(Luc.Array.findFirst(arr, new Date(1001))).to.be.eql(new Date(1001));
         expect(Luc.Array.findFirst(arr, new Date(1002))).to.be(false);
    });

    it('findFirst strict and shallow dates', function() {
         var d = new Date();
         var arr = [new Date(1000), new Date(1000), d];
         expect(Luc.Array.findFirst(arr, d, {type: 'strict'})).to.be(d);
         expect(Luc.Array.findFirst(arr, d, {type: 'shallow'})).to.be(d);
    });

    it('findFirstNot matching first key value', function() {

        var arr = [{a:1}, {a:1}, {a:1}, {a:1, b:2}];
        expect(Luc.Array.findFirstNot(arr, {a:1, b:2})).to.be.eql({a:1});
    })

    it('findFirstNot falsys', function() {
        var arr = ['', '', '', null];
        expect(Luc.Array.findFirstNot(arr, null)).to.be.eql('');
        expect(Luc.Array.findFirstNot(arr, '')).to.be.eql(null);
        arr = ['', '', ''];
        expect(Luc.Array.findFirstNot(arr, '')).to.be.eql(false);
    });

    it('findFirstNot primitives and non-primitives', function(){
         expect(Luc.Array.findFirstNot([1,2,3,{}], {})).to.be(1);
    });

    it('findAll find exact object keys', function() {
        var arr = [{a:1}, {a:1}, {a:1}, {a:1, b:2}, {b:2}];
        expect(Luc.Array.findAll(arr, {a:1, b:2})).to.be.eql([{a:1, b:2}]);
        expect(Luc.Array.findAll(arr, {a:1})).to.be.eql([{a:1},{a:1},{a:1},{a:1, b:2}]);
        expect(Luc.Array.findAll(arr, {a:1, b:2}, {type: 'strict'})).to.be.eql([]);
        expect(Luc.Array.findAll(arr, {a:1, b:2, c:3})).to.be.eql([]);
    });

    it('findAll find exact array values', function() {
        var arr = [[],[1,2], [1,2]];
        expect(Luc.Array.findAll(arr, [1,2])).to.be.eql([[1,2], [1,2]]);
        expect(Luc.Array.findAll(arr, [1])).to.eql([]);
        expect(Luc.Array.findAll(arr, [2,2])).to.eql([]);
    });

    it('findAll falsy values', function() {
        var arr = [false, 0, undefined, null, ''];
        expect(Luc.Array.findAll(arr, null)).to.be.eql([null]);
        expect(Luc.Array.findAll(arr, false)).to.be.eql([false]);
        expect(Luc.Array.findAll(arr, undefined)).to.be.eql([undefined]);
        expect(Luc.Array.findAll(arr, 0)).to.be.eql([0]);
    });

    it('findAll date values', function() {
        var arr = [new Date(1000), new Date(1000), new Date(1001), false];
        expect(Luc.Array.findAll(arr, new Date(1001))).to.be.eql([new Date(1001)]);
    });

    it('findAllNot match all keys', function() {
        var arr = [{a:1}, {a:1}, {a:1}, {a:1, b:2}];
        expect(Luc.Array.findAllNot(arr, {a:1, b:2})).to.be.eql([{a:1},{a:1},{a:1}]);
    });

    it('findAllNot falsy values', function() {
        arr = ['', '', '', null];
        expect(Luc.Array.findAllNot(arr, null)).to.be.eql(['','','']);
        expect(Luc.Array.findAllNot(arr, '')).to.be.eql([null]);
        arr = ['', '', ''];
        expect(Luc.Array.findAllNot(arr, '')).to.be.eql([]);
    });

    it('dynamic findFirstNot', function() {
        expect(Luc.Array.findFirstNotFalse([false, 1])).to.be(1);
        expect(Luc.Array.findFirstNotTrue([true, 1])).to.be(1);
        expect(Luc.Array.findFirstNotNull([null, 1])).to.be(1);
        expect(Luc.Array.findFirstNotUndefined([undefined, 1])).to.be(1);
    });

    it('dynamic findAllNot', function() {
        expect(Luc.Array.findAllNotFalse([false, 1])).to.be.eql([1]);
        expect(Luc.Array.findAllNotTrue([true, 1])).to.be.eql([1]);
        expect(Luc.Array.findAllNotNull([null, 1])).to.be.eql([1]);
        expect(Luc.Array.findAllNotUndefined([undefined, 1])).to.be.eql([1]);
    });

    it('dynamic removeFirstNot', function() {
        expect(Luc.Array.removeFirstNotFalse([false, 1])).to.be(1);
        expect(Luc.Array.removeFirstNotTrue([true, 1])).to.be(1);
        expect(Luc.Array.removeFirstNotNull([null, 1])).to.be(1);
        expect(Luc.Array.removeFirstNotUndefined([undefined, 1])).to.be(1);
    });

    it('dynamic removeAllNot', function() {
        expect(Luc.Array.removeAllNotFalse([false, 1])).to.be.eql([1]);
        expect(Luc.Array.removeAllNotTrue([true, 1])).to.be.eql([1]);
        expect(Luc.Array.removeAllNotNull([null, 1])).to.be.eql([1]);
        expect(Luc.Array.removeAllNotUndefined([undefined, 1])).to.be.eql([1]);
    });

    it('dynamic removeFirst', function() {
        expect(Luc.Array.removeFirstFalse([false, 1])).to.be(false);
        expect(Luc.Array.removeFirstTrue([true, 1])).to.be(true);
        expect(Luc.Array.removeFirstNull([null, 1])).to.be(null);
        //shim/IE bug
        if(0 in [undefined]) {
            expect(Luc.Array.removeFirstUndefined([undefined, 1])).to.be(undefined);
        }
    });

    it('dynamic removeAll', function() {
        expect(Luc.Array.removeAllFalse([false, 1])).to.be.eql([false]);
        expect(Luc.Array.removeAllTrue([true, 1])).to.be.eql([true]);
        expect(Luc.Array.removeAllNull([null, 1])).to.be.eql([null]);
        expect(Luc.Array.removeAllUndefined([undefined, 1])).to.be.eql([undefined]);
    });

    it('dynamic removeLastNot', function() {
        expect(Luc.Array.removeLastNotFalse([false, 1])).to.be(1);
        expect(Luc.Array.removeLastNotTrue([true, 1])).to.be(1);
        expect(Luc.Array.removeLastNotNull([null, 1])).to.be(1);
        expect(Luc.Array.removeLastNotUndefined([undefined, 1])).to.be(1);
    });

    it('dynamic removeLast', function() {
        expect(Luc.Array.removeLastFalse([false, 1])).to.be(false);
        expect(Luc.Array.removeLastTrue([true, 1])).to.be(true);
        expect(Luc.Array.removeLastNull([null, 1])).to.be(null);
        //shim/IE bug
        if(0 in [undefined]) {
            expect(Luc.Array.removeLastUndefined([undefined, 1])).to.be(undefined);
        }
    });

    it('dynamic findLastNot', function() {
        expect(Luc.Array.findLastNotFalse([false, 1])).to.be.eql(1);
        expect(Luc.Array.findLastNotTrue([true, 1])).to.be.eql(1);
        expect(Luc.Array.findLastNotNull([null, 1])).to.be.eql(1);
        expect(Luc.Array.findLastNotUndefined([undefined, 1])).to.be.eql(1);

    });

    it('remove/find with iterator and thisArg', function() {
        var arr = [{a:1}, {a:1}, {a:1}, {a:1, b:2}];

        expect(Luc.Array.findAll(arr, function(value) {
            return this.num === value.a
        }, {
            num: 1
        })).to.be.eql([{
                a: 1
            }, {
                a: 1
            }, {
                a: 1
            }, {
                a: 1,
                b: 2
            }
        ]);

       expect(Luc.Array.findAllNot(arr, function(value) {
            return this.num === value.a
        }, {
            num: 1
        })).to.be.eql([]);
   });

     it('direct function comparison', function() {
        expect(Luc.Array.findAllNot(arr, function(){}, {type:'strict'})).to.be.eql(arr);
    });

    it('Not remove/find with iterator and thisArg', function() {
        expect(Luc.Array.findAllNot(arr, function(){
            return true
        })).to.be.eql([]);
    });

    it('find in', function() {
        expect(Luc.Array.findAllIn([1,2,3, {a:1,b:2}, {b:1}], [2,{a:1}])).to.be.eql([2,{a:1,b:2}]);
        expect(Luc.Array.findAllIn([1,2,3, {a:1,b:2}, {b:1}], [2,{a:1}], {type: 'deep'})).to.be.eql([2]);
        expect(Luc.Array.findAllIn([1,2,3, {a:1,b:2}, {b:1}], [2,{a:1}], {type: 'loose'})).to.be.eql([2,{a:1,b:2}]);
        expect(Luc.Array.findAllIn([1,2,3, {a:1,b:2}, {b:1}], [2,{a:1}], {type: 'strict'})).to.be.eql([2]);
        expect(Luc.Array.findAllIn([1,2,3], [2,3])).to.be.eql([2,3]);
        expect(Luc.Array.findFirstIn([1,2,3], [2,3])).to.be.eql(2);
        expect(Luc.Array.findLastIn([1,2,3], [2,3])).to.be.eql(3);
        expect(Luc.Array.findLastIn([1,2,3], [false, 2,3, false])).to.be.eql(3);
        expect(Luc.Array.findAllIn([1,2,3, false], [false, 2,3, false])).to.be.eql([2,3,false]);
    });

    it('last', function() {
        expect(Luc.Array.last([1,2,3])).to.be(3);
        (function(){
            expect(Luc.Array.last(arguments)).to.be(3);
        })(1,2,3)
    });

    it('from index', function() {
        expect(Luc.Array.fromIndex([1,2,3], 1)).to.be.eql([2,3]);
        (function(){
            expect(Luc.Array.fromIndex(arguments, 1)).to.be.eql([2,3]);
            expect(Luc.Array.fromIndex(arguments, 0)).to.be.eql([1,2,3]);
            expect(Luc.Array.fromIndex(arguments, 2)).to.be.eql([3]);
        })(1,2,3)
    });

    it('pluck', function() {
        expect(Luc.Array.pluck([{a:'1', b:2}, {b:3}, {b:4}], 'b')).to.be.eql([2,3,4]);
    });
});
},{"./lucTestLib":10,"expect.js":13}],3:[function(require,module,exports){
var Luc = require('./lucTestLib'),
    expect = require('expect.js');
describe('Luc Object functions', function() {
    it('each', function() {
        var t = {
            a: 'a',
            b: 'b',
            z: 'z'
        }, obj = {str : ''};

        Luc.Object.each(t, function(key, value) {
            this.str += key + value;
        }, obj);
        expect(obj.str).to.eql('aabbzz');
    });

    it('apply', function() {
        var a = {b: 3};
        Luc.apply(a, {a: 1, b:2});
        expect(a).to.eql({a: 1, b:2});
        a = {b: 3};
        Luc.apply(a, {a: 1});
        expect(a).to.eql({a: 1, b: 3});
        expect(Luc.apply({}, undefined)).to.eql({});
        expect(Luc.apply(undefined, {})).to.eql({});
    });

    it('mix', function() {
        var a = {b: 3};
        Luc.mix(a, {a: 1, b:2});
        expect(a).to.eql({a: 1, b:3});
    });

    it('toObject', function() {
        var a = {},
            b = [],
            toObjectArgs,
            toObjectArray;

        toObjectArray = Luc.Object.toObject(['name1', 'name2'], [a,b]);
        expect(toObjectArray.name1).to.eql(a);
        expect(toObjectArray.name2).to.eql(b);

        (function(c,d){
            toObjectArgs = Luc.Object.toObject(['name1', 'name2'], arguments);
            expect(toObjectArgs.name1).to.eql(a);
            expect(toObjectArgs.name2).to.eql(b);
        }(a,b));
    });

    it('filter non ownProperties', function() {
        var obj = Object.create({a: 1, b:2}),
            filtered;

        filtered = Luc.Object.filter(obj, function(key, value) {
            return key === 'a';
        }, undefined, {
            ownProperties: false
        });

        expect(filtered).to.eql([{key: 'a', value: 1}]);
    });

    it('filter ownProperties', function() {
        var obj = Object.create({a: 1, b:2}),
            filtered;

        obj.c = 3;

        filtered = Luc.Object.filter(obj, function(key, value) {
            return key === 'a';
        }, undefined, {
            ownProperties: true
        });

        expect(filtered).to.eql([]);

        filtered = Luc.Object.filter(obj, function(key, value) {
            return key === 'c';
        }, undefined, {
            ownProperties: true
        });

        expect(filtered).to.eql([{key: 'c', value: 3}]);
    });
});
},{"./lucTestLib":10,"expect.js":13}],4:[function(require,module,exports){
var Luc = require('./lucTestLib'),
    expect = require('expect.js');
var emitterTest = require('./common').testEmitter;
//Sanity check to make sure node components work on the browser.
describe('Luc Node functions', function() {

    it('Emitter', function() {
        emitterTest(new Luc.EventEmitter());
    });
})
},{"./lucTestLib":10,"./common":14,"expect.js":13}],5:[function(require,module,exports){
var emitterTest = require('./common').testEmitter;
var Luc = require('./lucTestLib'),
    expect = require('expect.js');


function defineClassWithAllOptions() {
    function Adder() {}

    Adder.prototype.add = function(a, b) {
        return a + b;
    };
    return Luc.define({
        $super: Adder,
        $statics: {
            total: 0
        },
        $mixins: {
            makeString: function(value) {
                return value + '';
            }
        },
        $compositions: {
            Constructor: Luc.EventEmitter,
            name: 'emitter',
            methods: 'allMethods'
        },
        add: function(a, b, c) {
            var two = this.$superclass.add.call(this, a, b),
                ret = two + c;

            this.emit('toString', this.makeString(ret));

            this.$class.total += ret;

            return ret;
        }
    });
}

describe('Luc Class', function() {
    it('Base', function() {
        var b = new Luc.Base({
            a: 1,
            init: function() {
                this.a++;
            }
        });
        expect(b.a).to.be(2);
    });

    it('simple define', function() {
        var C = Luc.define({
            b: '2'
        });
        var b = new C({
            a: 1
        });
        expect(b.a).to.eql(1);
        expect(b.b).to.eql('2');
    });

    it('single mixin', function() {
        var C = Luc.define({
            $mixins: Luc.EventEmitter
        });

        var b = new C({
            a: 1
        });

        emitterTest(b);
    });

    it('multiple mixins', function() {
        var mixinObj = {
            a: function() {

            },
            prop: {}
        }, C = Luc.define({
            $mixins: [Luc.EventEmitter, mixinObj]
        }),
        c = new C();

        expect(c.a).to.be(mixinObj.a);
        expect(c.prop).to.be(mixinObj.prop);
        expect(c.emit).to.be(Luc.EventEmitter.prototype.emit);
    });

    it('statics', function() {
        var C = Luc.define({
            $statics: {
                b: 1
            }
        });

        var c = new C();

        expect(C.b).to.be(1);
        expect(c.$class.b).to.be(1);
    });

    it('test get static value', function() {
        var A = Luc.define({
            $statics: {
                a: 1
            }
        });

        var B = Luc.define({
            $super: A,
            $statics: {
                b: 2,
                c:3
            }
        });

        var C = Luc.define({
            $super: B,
            $statics: {
                a: 5
            }
        });

        var a = new A(), b = new B(), c = new C();

        expect(a.getStaticValue('a')).to.be(1);
        expect(a.getStaticValue('b')).to.be(undefined);

        expect(b.getStaticValue('a')).to.be(1);
        expect(b.getStaticValue('b')).to.be(2);
        expect(b.getStaticValue('c')).to.be(3);
        expect(b.getStaticValue('d')).to.be(undefined);

        expect(c.getStaticValue('a')).to.be(5);
        expect(c.getStaticValue('b')).to.be(2);
        expect(c.getStaticValue('c')).to.be(3);
        expect(c.getStaticValue('d')).to.be(undefined);
    });

    it('$class', function() {
        var C = Luc.define({}),
            c = new C();

        expect(c.$class).to.be(C);
    });

    it('super', function() {
        var i;
        var C = Luc.define({
            $super: Luc.EventEmitter,
            emit: function() {
                i = 0;
                this.$superclass.emit.apply(this, arguments);
            }
        });


        var c = new C({});
        emitterTest(c);
        expect(i).to.be(0);
        expect(c instanceof Luc.EventEmitter).to.be(true);
    });

    it('composition', function() {
        var EmitterParent =  Luc.define({
            $super: Luc.EventEmitter
        });

        var BaseEmitter = Luc.define({
            $compositions: [{Constructor: EmitterParent, name: 'emitter', methods: 'allMethods'}]
        });


        var base = new BaseEmitter({});
        emitterTest(base);
        expect(base instanceof Luc.EventEmitter).to.be(false);
        expect(base.events).to.be(undefined);
    });

    it('all class options together', function() {
        var AdderEmitter = defineClassWithAllOptions(),
            stringValue, result,
            adderEmit = new AdderEmitter();

        adderEmit.on('toString', function(value) {
            stringValue = value;
        });

        result = adderEmit.add(1, 2, 3);

        expect(result).to.be(6);
        expect(stringValue).to.be('6');

        adderEmit.add(3, 3, 3);

        expect(stringValue).to.be('9');

        expect(AdderEmitter.total).to.be(15);
    });

    it('class options do not get applied to the instance', function() {
        var AdderEmitter = defineClassWithAllOptions(),
            allOptions = Luc.ClassDefiner.processorKeys,
            ignoreKeys = ['$super'];

        Object.keys(allOptions).forEach(function(option) {
            if(ignoreKeys.indexOf(option) === -1) {
                expect(AdderEmitter.prototype[option]).to.be(undefined);
            }
        });
    });

    it('get composition', function() {
        function A() {}
        function B(){}
        function C(){}
        var Comps = Luc.define({
            $compositions: [{
                    Constructor: A,
                    name: 'a'
                }, {
                    Constructor: B,
                    name: 'b'
                }, {
                    Constructor: C,
                    name: 'c'
                }
            ]
        });

        var c = new Comps();

        expect(c.getComposition('a')).to.be.a(A);
        expect(c.getComposition('b')).to.be.a(B);
        expect(c.getComposition('c')).to.be.a(C);
    });

    it('initComposition before and after', function() {
        var hasABeenInited = false,
            hasBBeenInited = false,
            hasCBeenInited = false;
        function A() {
            hasABeenInited = true;
        }
        function B(){
            hasBBeenInited = true;
        }
        function C(){
            hasCBeenInited = true;
            expect(hasABeenInited).to.be(false);
            expect(hasBBeenInited).to.be(true);
        }
        var Comps = Luc.define({
            $compositions: [{
                    Constructor: A,
                    name: 'a',
                    initAfter: true
                }, {
                    Constructor: B,
                    name: 'b',
                    initAfter: false
                }, {
                    Constructor: C,
                    name: 'c'
                }
            ]
        });

        var c = new Comps();
        expect(hasCBeenInited).to.be(true);
    });

    it('test no superclass', function() {
        var NoSuper = Luc.define({
            $super: false,
            $statics: {
                total: 0
            },
            $mixins: {
                makeString: function(value) {
                    return value + '';
                }
            },
            $compositions: {
                defaults : Luc.compositionEnums.EventEmitter
            }
        });

        var NoSuperNoComp = Luc.define({
            $super: false,
            $statics: {
                total: 0
            },
            $mixins: {
                makeString: function(value) {
                    return value + '';
                }
            }
        });

        var noSuper = new NoSuper();
        expect(new  NoSuperNoComp().makeString(noSuper.$class.total)).to.be('0');
        expect(noSuper.makeString(noSuper.$class.total)).to.be('0');
        emitterTest(noSuper);
        expect(noSuper).to.not.be.a(Luc.Base);
        expect(noSuper.$superclass).to.be(undefined);
    });

    it('test composition validation', function() {
        function defineNoName() {
            Luc.define({
                $compositions: {
                    Constructor: Luc.EventEmitter
                }
            });
        }
        function defineNoConstructor() {
            Luc.define({
                $compositions: {
                    name: 'a'
                }
            });
        }
        expect(defineNoName).to.throwException();

        expect(defineNoConstructor).to.throwException();
    });

    it('test default plugin composition', function() {
        var testIntance,
        ClassWithPlugins = Luc.define({
            $compositions: {
                defaults: Luc.compositionEnums.PluginManager
            }
        });

        var c = new ClassWithPlugins({
            plugins: [{
                    init: function(instance) {
                        testInstance = instance;
                    },
                    destroy: function(){

                    },
                    name: 'myPlugin'
                }
            ]
        });

        expect(testInstance).to.be(c);
        expect(c.getPlugin(Luc.Plugin)).to.be.a(Luc.Plugin);
        expect(c.getPlugin({name: 'myPlugin'})).to.be.a(Luc.Plugin);
        c.destroyPlugin({name: 'myPlugin'});
        expect(c.getPlugin(Luc.Plugin)).to.be(false);
        var ret = c.addPlugin({name: 'myPlugin'});
        expect(ret).to.be.a(Luc.Plugin);

        function A(){

        }
        ret = c.addPlugin({Constructor: A, name: 'myPlugin'});
        expect(ret).to.be.a(A);
    });

    it('test configured plugin constructors', function() {
        var testIntance,
            ConfiguredPlugin = function(config) {
                this.myOwner = config.owner;
            },
            ClassWithPlugins = Luc.define({
                $compositions: {
                    defaults: Luc.compositionEnums.PluginManager
                }
            });

        var c = new ClassWithPlugins({
            plugins: [{}, {
                    Constructor: ConfiguredPlugin
                }
            ]
        });

        expect(c.getComposition('plugins').plugins[0]).to.be.a(Luc.Plugin);
        var configedPlugin = c.getComposition('plugins').plugins[1];
        expect(configedPlugin).to.be.a(ConfiguredPlugin);
        expect(configedPlugin.myOwner).to.be(c);
    });

    it('test default plugin destroy', function() {
        var testValue = false,
        ClassWithPlugins = Luc.define({
            $compositions: {
                defaults: Luc.compositionEnums.PluginManager
            }
        });

        var c = new ClassWithPlugins({
            plugins: [{
                    destroy: function() {
                        testValue = true;
                    }
                }, {}
            ]
        });

        expect(testValue).to.be(false);
        c.destroyAllPlugins();
        expect(testValue).to.be(true);
    });
});





},{"./common":14,"./lucTestLib":10,"expect.js":13}],6:[function(require,module,exports){
var Luc = require('./lucTestLib'),
    expect = require('expect.js');

describe('Luc is', function() {

    it('isArray', function() {
        expect(Luc.isArray({})).to.be(false);
        expect(Luc.isArray([])).to.be(true);
    });

    it('isRegExp', function() {
        expect(Luc.isRegExp({})).to.be(false);
        expect(Luc.isRegExp(new RegExp())).to.be(true);
    });

    it('isDate', function() {
        expect(Luc.isDate({})).to.be(false);
        expect(Luc.isDate(new Date())).to.be(true);
    });

    it('isString', function() {
        expect(Luc.isString({})).to.be(false);
        expect(Luc.isString(new String())).to.be(true);
        expect(Luc.isString('')).to.be(true);
    });

    it('isObject', function() {
        expect(Luc.isObject({})).to.be(true);
        expect(Luc.isObject([])).to.be(false);
    });

    it('isNumber', function() {
        expect(Luc.isNumber({})).to.be(false);
        expect(Luc.isNumber(0)).to.be(true);
    });

    it('isFunction', function() {
        expect(Luc.isFunction({})).to.be(false);
        expect(Luc.isFunction(new Function())).to.be(true);
        expect(Luc.isFunction(function(){})).to.be(true);
    });

    it('isFalsy', function() {
        expect(Luc.isFalsy(0)).to.be(false);
        expect(Luc.isFalsy('')).to.be(true);
        expect(Luc.isFalsy(undefined)).to.be(true);
        expect(Luc.isFalsy(null)).to.be(true);
        expect(Luc.isFalsy(false)).to.be(true);
        expect(Luc.isFalsy(NaN)).to.be(true);
        expect(Luc.isFalsy({})).to.be(false);
    });

    it('isEmpty', function() {
        expect(Luc.isEmpty(0)).to.be(false);
        expect(Luc.isEmpty('')).to.be(true);
        expect(Luc.isEmpty(undefined)).to.be(true);
        expect(Luc.isEmpty(null)).to.be(true);
        expect(Luc.isEmpty(false)).to.be(true);

        expect(Luc.isEmpty([])).to.be(true);
        expect(Luc.isEmpty({})).to.be(true);

        expect(Luc.isEmpty([0])).to.be(false);
        expect(Luc.isEmpty({0:0})).to.be(false);
    });

    it('isArguments', function() {
        expect(Luc.isArguments({})).to.be(false);
        expect(Luc.isArguments([])).to.be(false);
        (function(){
            expect(Luc.isArguments(arguments)).to.be(true);
        }());
        
    });
});
},{"./lucTestLib":10,"expect.js":13}],7:[function(require,module,exports){
var Luc = require('./lucTestLib'),
    expect = require('expect.js');

describe('Luc compare fn', function() {

    it('compare empty objects', function() {
        expect(Luc.compare({}, {})).to.be(true);
        expect(Luc.compare([], [])).to.be(true);
        expect(Luc.compare(new Date(1000), new Date(1000))).to.be(true);
        expect(Luc.compare(new Date(1000), new Date(1001))).to.be(false);
    });

    it('compare values', function() {
        expect(Luc.compare({}, {
            a: 1
        })).to.be(false);

        expect(Luc.compare({
            a: 1
        }, {
            a: 1
        })).to.be(true);

        expect(Luc.compare({
            a: 1,
            b: 1
        }, {
            a: 1
        })).to.be(false);
    });


    it('compare different object types', function() {
        expect(Luc.compare(new Date(10000), {})).to.be(false);
        expect(Luc.compare(new Date(10000), undefined)).to.be(false);
        expect(Luc.compare(new Date(10000), [])).to.be(false);

    });

    it('compare falsys', function() {
        expect(Luc.compare(false, false)).to.be(true);
        expect(Luc.compare(0, false)).to.be(false);
        expect(Luc.compare('', false)).to.be(false);
        expect(Luc.compare(null, false)).to.be(false);
        expect(Luc.compare(undefined, false)).to.be(false);
        expect(Luc.compare(NaN, false)).to.be(false);
        expect(Luc.compare([], [1], {type: 'deep'})).to.be(false);
    });

    it('deep compare', function() { 
        var deepTrue = Luc.compare({
            a: {
                a: 1
            },
            b: [1, 'a', new Date(1000), {
                    a: {
                        a: {
                            a: true,
                            b: undefined
                        }
                    }
                }
            ]
        }, {
            a: {
                a: 1
            },
            b: [1, 'a', new Date(1000), {
                    a: {
                        a: {
                            a: true,
                            b: undefined
                        }
                    }
                }
            ]
        }, {
            type: 'deep'
        });

        var deepFalse = Luc.compare({
            a: {
                a: 1
            },
            b: [1, 'a', new Date(1000), {
                    a: {
                        a: {
                            a: true,
                            b: undefined
                        }
                    }
                }
            ]
        }, {
            a: {
                a: 1
            },
            b: [1, 'a', new Date(1000), {
                    a: {
                        a: {
                            a: true,
                            b: undefined,
                            c: undefined
                        }
                    }
                }
            ]
        }, {
            type: 'deep'
        });

        expect(deepTrue).to.be(true);
        expect(deepFalse).to.be(false);
        })

    it('simple deep and shallow compare', function() {
        expect(Luc.compare({a:1}, {a:1}, {type: 'shallow'})).to.be(true);
        expect(Luc.compare({a:1, b: {}}, {a:1, b: {}}, {type: 'shallow'})).to.be(false);
        expect(Luc.compare({a:1}, {a:1}, {type: 'deep'})).to.be(true);
        expect(Luc.compare({a:1, b: {}}, {a:1, b: {}}, {type: 'deep'})).to.be(true);
        expect(Luc.compare({a:1}, {a:1}, {type: 'strict'})).to.be(false);

    });

    it('invalid type throws an exception', function() {
        var invalidType = function(){
            Luc.compare(true, true, {type: 'deeeeep'});
        };
        expect(invalidType).to.throwException();
    });

    it('loose compare', function() {
        expect(Luc.compare(new Date(10000), {}), {type: 'loose'}).to.be(false);
        expect(Luc.compare({}, new Date(10000)), {type: 'loose'}).to.be(false);

        expect(Luc.compare({a:1}, {a:1, b:2}, {type: 'loose'})).to.be(true);
        expect(Luc.compare({a:1}, {a:2}, {type: 'loose'})).to.be(false);

        expect(Luc.compare(1, {a:2}, {type: 'loose'})).to.be(false);
        expect(Luc.compare({a:1}, 1, {type: 'loose'})).to.be(false);

        expect(Luc.compare([{a:1}], [{a:1, b:2}], {type: 'loose'})).to.be(true);
        expect(Luc.compare([{a:1}, 1], [{a:1, b:2}], {type: 'loose'})).to.be(false);
        expect(Luc.compare([{a:1}, 1], [{a:1, b:2}, 1], {type: 'loose'})).to.be(true);
        expect(Luc.compare([{a:1}, 1], [{a:1, b:2}, 2], {type: 'loose'})).to.be(false);
    })
});
},{"./lucTestLib":10,"expect.js":13}],8:[function(require,module,exports){
var Luc = require('./lucTestLib'),
    expect = require('expect.js'),
    arraySlice = Array.prototype.slice;

describe('Luc Function utilities', function() {

    
        function testFn() {
            var arr = arraySlice.call(arguments);
            return this.str + arr.join('');
        }

    it('create augmentor append and this', function() {

        var appendAndThis = Luc.Function.createAugmenter(testFn, {
            thisArg: {
                str: '1'
            },
            args: [4, 5],
            index: true
        });

        expect(appendAndThis(2, 3)).to.be('12345');
    });

    it('create augmentor thisArg with append after', function() {
        var appendAndThisArgumentsAfter = Luc.Function.createAugmenter(testFn, {
            thisArg: {
                str: '1'
            },
            args: [4, 5],
            index: true,
            argumentsFirst: false
        });

        expect(appendAndThisArgumentsAfter(2,3)).to.be('14523');
    });

    it('create augmentor thisArg index and args after', function() {
        var argumentsAfter = Luc.Function.createAugmenter(testFn, {
            thisArg: {
                str: '1'
            },
            args: [4, 5],
            index: 1,
            argumentsFirst: false
        });

        expect(argumentsAfter(2,3)).to.be('14235');
    });

    it('create augmentor this arg and default insert args', function() {
        var argumentsInsert = Luc.Function.createAugmenter(testFn, {
            thisArg: {
                str: '1'
            },
            args: [4, 5],
            index: 1
        });

        expect(argumentsInsert(2,3)).to.be('12453');
    });

    it('create augmentor default insert args', function() {
        var noThisArg = Luc.Function.createAugmenter(testFn, {
            args: [4, 5],
            index: 1
        });

        expect(noThisArg.apply({str: '2'},[2,3])).to.be('22453');
    });

    it('create augmentor just arguments', function() {
        var justArgs = Luc.Function.createAugmenter(testFn, {
            args: [4, 5]
        });

        expect(justArgs.apply({str: '2'},[2,3])).to.be('245');
    });

    it('create sequence', function() {
        var hasRun1, hasRun2, hasRun3;

        var sequenced = Luc.Function.createSequence([
            function() {
                hasRun1 = true;
            },
            function() {
                hasRun2 = true;
            },
            function() {
                hasRun3 = true;
                return true;
            }
        ]);

        var ret = sequenced();

        expect(hasRun1).to.be(true);
        expect(hasRun2).to.be(true);
        expect(hasRun3).to.be(true);
        expect(ret).to.be(true);
    });

    it('create sequence augmentor config', function() {
        var hasRun1, hasRun2, hasRun3;

        var sequenced = Luc.Function.createSequence([
            function(a,b) {
                expect(a).to.be(1);
                expect(b).to.be(2);
                hasRun1 = true;
            },
            function() {
                hasRun2 = true;
            },
            function() {
                hasRun3 = true;
                return this;
            }
        ],{
            thisArg: {
                a: 1
            }
        });

        var ret = sequenced(1,2);

        expect(hasRun1).to.be(true);
        expect(hasRun2).to.be(true);
        expect(hasRun3).to.be(true);
        expect(ret).to.eql({a:1});
    });

    it('create sequenceIf', function() {
        var hasRun1, hasRun2, hasRun3;

        var sequenced = Luc.Function.createSequenceIf([
            function(a,b) {
                expect(a).to.be(1);
                 expect(b).to.be(2);
                hasRun1 = true;
            },
            function() {
                hasRun2 = true;
                return false;
            },
            function() {
                hasRun3 = true;
                return this;
            }
        ],{
            thisArg: {
                a: 1
            }
        });

        var ret = sequenced(1,2);

        expect(hasRun1).to.be(true);
        expect(hasRun2).to.be(true);
        expect(hasRun3).to.be(undefined);
        expect(ret).to.be(false);
    });

    it('create relayer', function() {
        var sequenced = Luc.Function.createRelayer([
            function(a,b,c) {
                return a + b + c;
            },
            //acb, b
            function(a,b) {
                return a + a + b + b;
            },
            //acbacbbb, b
            function(a,b) {
                return b + a;
            }
        ],{
            args: ['b'],
            index: true
        });

        var ret = sequenced('a', 'c');

        expect(ret).to.be('bacbacbbb');
    });

    it('create deferred', function(done) {
        var hasDefered = false;
        var deferred = Luc.Function.createDeferred(function(a,b){
            hasDefered = true;
            expect(a).to.be(1);
            expect(b).to.be(2);
            done();

        }, 1, {
            args: [2],
            index: true
        });

        deferred(1);

        expect(hasDefered).to.be(false);
    });

    it('create deferred no millis', function(done) {
        var hasDefered = false;
        var deferred = Luc.Function.createDeferred(function(a,b){
            hasDefered = true;
            expect(a).to.be(1);
            expect(b).to.be(undefined);
            done();
        }, 0);

        deferred(1);

        expect(hasDefered).to.be(true);
    });

    it('create throtteled no millis', function(done) {
        var hasDefered = false;
        var deferred = Luc.Function.createThrottled(function(a,b){
            hasDefered = true;
            expect(a).to.be(1);
            expect(b).to.be(undefined);
            done();
        }, 0);

        deferred(1);

        expect(hasDefered).to.be(true);
    });

    it('create throtteled', function(done) {
        var callCount = 0;
        var throttled = Luc.Function.createThrottled(function(a,b,c){
            callCount++;
            expect(a).to.be(1);
            expect(b).to.be(3);
            expect(c).to.be(2);
            expect(callCount).to.be(1);
            done();

        }, 1, {
            args: [3],
            index: 1
        });

        for(var i = 0; i < 200; ++i) {
            throttled(1);
        }

        throttled(1,2);

        expect(callCount).to.be(0);
    });


});
},{"./lucTestLib":10,"expect.js":13}],15:[function(require,module,exports){
require=(function(e,t,n,r){function i(r){if(!n[r]){if(!t[r]){if(e)return e(r);throw new Error("Cannot find module '"+r+"'")}var s=n[r]={exports:{}};t[r][0](function(e){var n=t[r][1][e];return i(n?n:e)},s,s.exports)}return n[r].exports}for(var s=0;s<r.length;s++)i(r[s]);return i})(typeof require!=="undefined"&&require,{1:[function(require,module,exports){
// UTILITY
var util = require('util');
var Buffer = require("buffer").Buffer;
var pSlice = Array.prototype.slice;

function objectKeys(object) {
  if (Object.keys) return Object.keys(object);
  var result = [];
  for (var name in object) {
    if (Object.prototype.hasOwnProperty.call(object, name)) {
      result.push(name);
    }
  }
  return result;
}

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.message = options.message;
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  var stackStartFunction = options.stackStartFunction || fail;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  }
};
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (value === undefined) {
    return '' + value;
  }
  if (typeof value === 'number' && (isNaN(value) || !isFinite(value))) {
    return value.toString();
  }
  if (typeof value === 'function' || value instanceof RegExp) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (typeof s == 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

assert.AssertionError.prototype.toString = function() {
  if (this.message) {
    return [this.name + ':', this.message].join(' ');
  } else {
    return [
      this.name + ':',
      truncate(JSON.stringify(this.actual, replacer), 128),
      this.operator,
      truncate(JSON.stringify(this.expected, replacer), 128)
    ].join(' ');
  }
};

// assert.AssertionError instanceof Error

assert.AssertionError.__proto__ = Error.prototype;

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!!!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (Buffer.isBuffer(actual) && Buffer.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

  // 7.3. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (typeof actual != 'object' && typeof expected != 'object') {
    return actual == expected;

  // 7.4. For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b),
        key, i;
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (expected instanceof RegExp) {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail('Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail('Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};

},{"util":2,"buffer":3}],2:[function(require,module,exports){
var events = require('events');

exports.isArray = isArray;
exports.isDate = function(obj){return Object.prototype.toString.call(obj) === '[object Date]'};
exports.isRegExp = function(obj){return Object.prototype.toString.call(obj) === '[object RegExp]'};


exports.print = function () {};
exports.puts = function () {};
exports.debug = function() {};

exports.inspect = function(obj, showHidden, depth, colors) {
  var seen = [];

  var stylize = function(str, styleType) {
    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
    var styles =
        { 'bold' : [1, 22],
          'italic' : [3, 23],
          'underline' : [4, 24],
          'inverse' : [7, 27],
          'white' : [37, 39],
          'grey' : [90, 39],
          'black' : [30, 39],
          'blue' : [34, 39],
          'cyan' : [36, 39],
          'green' : [32, 39],
          'magenta' : [35, 39],
          'red' : [31, 39],
          'yellow' : [33, 39] };

    var style =
        { 'special': 'cyan',
          'number': 'blue',
          'boolean': 'yellow',
          'undefined': 'grey',
          'null': 'bold',
          'string': 'green',
          'date': 'magenta',
          // "name": intentionally not styling
          'regexp': 'red' }[styleType];

    if (style) {
      return '\033[' + styles[style][0] + 'm' + str +
             '\033[' + styles[style][1] + 'm';
    } else {
      return str;
    }
  };
  if (! colors) {
    stylize = function(str, styleType) { return str; };
  }

  function format(value, recurseTimes) {
    // Provide a hook for user-specified inspect functions.
    // Check that value is an object with an inspect function on it
    if (value && typeof value.inspect === 'function' &&
        // Filter out the util module, it's inspect function is special
        value !== exports &&
        // Also filter out any prototype objects using the circular check.
        !(value.constructor && value.constructor.prototype === value)) {
      return value.inspect(recurseTimes);
    }

    // Primitive types cannot have properties
    switch (typeof value) {
      case 'undefined':
        return stylize('undefined', 'undefined');

      case 'string':
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                                 .replace(/'/g, "\\'")
                                                 .replace(/\\"/g, '"') + '\'';
        return stylize(simple, 'string');

      case 'number':
        return stylize('' + value, 'number');

      case 'boolean':
        return stylize('' + value, 'boolean');
    }
    // For some reason typeof null is "object", so special case here.
    if (value === null) {
      return stylize('null', 'null');
    }

    // Look up the keys of the object.
    var visible_keys = Object_keys(value);
    var keys = showHidden ? Object_getOwnPropertyNames(value) : visible_keys;

    // Functions without properties can be shortcutted.
    if (typeof value === 'function' && keys.length === 0) {
      if (isRegExp(value)) {
        return stylize('' + value, 'regexp');
      } else {
        var name = value.name ? ': ' + value.name : '';
        return stylize('[Function' + name + ']', 'special');
      }
    }

    // Dates without properties can be shortcutted
    if (isDate(value) && keys.length === 0) {
      return stylize(value.toUTCString(), 'date');
    }

    var base, type, braces;
    // Determine the object type
    if (isArray(value)) {
      type = 'Array';
      braces = ['[', ']'];
    } else {
      type = 'Object';
      braces = ['{', '}'];
    }

    // Make functions say that they are functions
    if (typeof value === 'function') {
      var n = value.name ? ': ' + value.name : '';
      base = (isRegExp(value)) ? ' ' + value : ' [Function' + n + ']';
    } else {
      base = '';
    }

    // Make dates with properties first say the date
    if (isDate(value)) {
      base = ' ' + value.toUTCString();
    }

    if (keys.length === 0) {
      return braces[0] + base + braces[1];
    }

    if (recurseTimes < 0) {
      if (isRegExp(value)) {
        return stylize('' + value, 'regexp');
      } else {
        return stylize('[Object]', 'special');
      }
    }

    seen.push(value);

    var output = keys.map(function(key) {
      var name, str;
      if (value.__lookupGetter__) {
        if (value.__lookupGetter__(key)) {
          if (value.__lookupSetter__(key)) {
            str = stylize('[Getter/Setter]', 'special');
          } else {
            str = stylize('[Getter]', 'special');
          }
        } else {
          if (value.__lookupSetter__(key)) {
            str = stylize('[Setter]', 'special');
          }
        }
      }
      if (visible_keys.indexOf(key) < 0) {
        name = '[' + key + ']';
      }
      if (!str) {
        if (seen.indexOf(value[key]) < 0) {
          if (recurseTimes === null) {
            str = format(value[key]);
          } else {
            str = format(value[key], recurseTimes - 1);
          }
          if (str.indexOf('\n') > -1) {
            if (isArray(value)) {
              str = str.split('\n').map(function(line) {
                return '  ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function(line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = stylize('[Circular]', 'special');
        }
      }
      if (typeof name === 'undefined') {
        if (type === 'Array' && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify('' + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'")
                     .replace(/\\"/g, '"')
                     .replace(/(^"|"$)/g, "'");
          name = stylize(name, 'string');
        }
      }

      return name + ': ' + str;
    });

    seen.pop();

    var numLinesEst = 0;
    var length = output.reduce(function(prev, cur) {
      numLinesEst++;
      if (cur.indexOf('\n') >= 0) numLinesEst++;
      return prev + cur.length + 1;
    }, 0);

    if (length > 50) {
      output = braces[0] +
               (base === '' ? '' : base + '\n ') +
               ' ' +
               output.join(',\n  ') +
               ' ' +
               braces[1];

    } else {
      output = braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }

    return output;
  }
  return format(obj, (typeof depth === 'undefined' ? 2 : depth));
};


function isArray(ar) {
  return ar instanceof Array ||
         Array.isArray(ar) ||
         (ar && ar !== Object.prototype && isArray(ar.__proto__));
}


function isRegExp(re) {
  return re instanceof RegExp ||
    (typeof re === 'object' && Object.prototype.toString.call(re) === '[object RegExp]');
}


function isDate(d) {
  if (d instanceof Date) return true;
  if (typeof d !== 'object') return false;
  var properties = Date.prototype && Object_getOwnPropertyNames(Date.prototype);
  var proto = d.__proto__ && Object_getOwnPropertyNames(d.__proto__);
  return JSON.stringify(proto) === JSON.stringify(properties);
}

function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}

var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}

exports.log = function (msg) {};

exports.pump = null;

var Object_keys = Object.keys || function (obj) {
    var res = [];
    for (var key in obj) res.push(key);
    return res;
};

var Object_getOwnPropertyNames = Object.getOwnPropertyNames || function (obj) {
    var res = [];
    for (var key in obj) {
        if (Object.hasOwnProperty.call(obj, key)) res.push(key);
    }
    return res;
};

var Object_create = Object.create || function (prototype, properties) {
    // from es5-shim
    var object;
    if (prototype === null) {
        object = { '__proto__' : null };
    }
    else {
        if (typeof prototype !== 'object') {
            throw new TypeError(
                'typeof prototype[' + (typeof prototype) + '] != \'object\''
            );
        }
        var Type = function () {};
        Type.prototype = prototype;
        object = new Type();
        object.__proto__ = prototype;
    }
    if (typeof properties !== 'undefined' && Object.defineProperties) {
        Object.defineProperties(object, properties);
    }
    return object;
};

exports.inherits = function(ctor, superCtor) {
  ctor.super_ = superCtor;
  ctor.prototype = Object_create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
};

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (typeof f !== 'string') {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(exports.inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j': return JSON.stringify(args[i++]);
      default:
        return x;
    }
  });
  for(var x = args[i]; i < len; x = args[++i]){
    if (x === null || typeof x !== 'object') {
      str += ' ' + x;
    } else {
      str += ' ' + exports.inspect(x);
    }
  }
  return str;
};

},{"events":4}],5:[function(require,module,exports){
exports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isBE ? 0 : (nBytes - 1),
      d = isBE ? 1 : -1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isBE ? (nBytes - 1) : 0,
      d = isBE ? -1 : 1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],6:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            if (ev.source === window && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],4:[function(require,module,exports){
(function(process){if (!process.EventEmitter) process.EventEmitter = function () {};

var EventEmitter = exports.EventEmitter = process.EventEmitter;
var isArray = typeof Array.isArray === 'function'
    ? Array.isArray
    : function (xs) {
        return Object.prototype.toString.call(xs) === '[object Array]'
    }
;
function indexOf (xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for (var i = 0; i < xs.length; i++) {
        if (x === xs[i]) return i;
    }
    return -1;
}

// By default EventEmitters will print a warning if more than
// 10 listeners are added to it. This is a useful default which
// helps finding memory leaks.
//
// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
var defaultMaxListeners = 10;
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!this._events) this._events = {};
  this._events.maxListeners = n;
};


EventEmitter.prototype.emit = function(type) {
  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events || !this._events.error ||
        (isArray(this._events.error) && !this._events.error.length))
    {
      if (arguments[1] instanceof Error) {
        throw arguments[1]; // Unhandled 'error' event
      } else {
        throw new Error("Uncaught, unspecified 'error' event.");
      }
      return false;
    }
  }

  if (!this._events) return false;
  var handler = this._events[type];
  if (!handler) return false;

  if (typeof handler == 'function') {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        var args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
    return true;

  } else if (isArray(handler)) {
    var args = Array.prototype.slice.call(arguments, 1);

    var listeners = handler.slice();
    for (var i = 0, l = listeners.length; i < l; i++) {
      listeners[i].apply(this, args);
    }
    return true;

  } else {
    return false;
  }
};

// EventEmitter is defined in src/node_events.cc
// EventEmitter.prototype.emit() is also defined there.
EventEmitter.prototype.addListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('addListener only takes instances of Function');
  }

  if (!this._events) this._events = {};

  // To avoid recursion in the case that type == "newListeners"! Before
  // adding it to the listeners, first emit "newListeners".
  this.emit('newListener', type, listener);

  if (!this._events[type]) {
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  } else if (isArray(this._events[type])) {

    // Check for listener leak
    if (!this._events[type].warned) {
      var m;
      if (this._events.maxListeners !== undefined) {
        m = this._events.maxListeners;
      } else {
        m = defaultMaxListeners;
      }

      if (m && m > 0 && this._events[type].length > m) {
        this._events[type].warned = true;
        console.error('(node) warning: possible EventEmitter memory ' +
                      'leak detected. %d listeners added. ' +
                      'Use emitter.setMaxListeners() to increase limit.',
                      this._events[type].length);
        console.trace();
      }
    }

    // If we've already got an array, just append.
    this._events[type].push(listener);
  } else {
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  var self = this;
  self.on(type, function g() {
    self.removeListener(type, g);
    listener.apply(this, arguments);
  });

  return this;
};

EventEmitter.prototype.removeListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('removeListener only takes instances of Function');
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (!this._events || !this._events[type]) return this;

  var list = this._events[type];

  if (isArray(list)) {
    var i = indexOf(list, listener);
    if (i < 0) return this;
    list.splice(i, 1);
    if (list.length == 0)
      delete this._events[type];
  } else if (this._events[type] === listener) {
    delete this._events[type];
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  if (arguments.length === 0) {
    this._events = {};
    return this;
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (type && this._events && this._events[type]) this._events[type] = null;
  return this;
};

EventEmitter.prototype.listeners = function(type) {
  if (!this._events) this._events = {};
  if (!this._events[type]) this._events[type] = [];
  if (!isArray(this._events[type])) {
    this._events[type] = [this._events[type]];
  }
  return this._events[type];
};

})(require("__browserify_process"))
},{"__browserify_process":6}],"buffer-browserify":[function(require,module,exports){
module.exports=require('q9TxCC');
},{}],"q9TxCC":[function(require,module,exports){
function SlowBuffer (size) {
    this.length = size;
};

var assert = require('assert');

exports.INSPECT_MAX_BYTES = 50;


function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; i++)
    if (str.charCodeAt(i) <= 0x7F)
      byteArray.push(str.charCodeAt(i));
    else {
      var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16));
    }

  return byteArray;
}

function asciiToBytes(str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++ )
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push( str.charCodeAt(i) & 0xFF );

  return byteArray;
}

function base64ToBytes(str) {
  return require("base64-js").toByteArray(str);
}

SlowBuffer.byteLength = function (str, encoding) {
  switch (encoding || "utf8") {
    case 'hex':
      return str.length / 2;

    case 'utf8':
    case 'utf-8':
      return utf8ToBytes(str).length;

    case 'ascii':
    case 'binary':
      return str.length;

    case 'base64':
      return base64ToBytes(str).length;

    default:
      throw new Error('Unknown encoding');
  }
};

function blitBuffer(src, dst, offset, length) {
  var pos, i = 0;
  while (i < length) {
    if ((i+offset >= dst.length) || (i >= src.length))
      break;

    dst[i + offset] = src[i];
    i++;
  }
  return i;
}

SlowBuffer.prototype.utf8Write = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);
};

SlowBuffer.prototype.asciiWrite = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);
};

SlowBuffer.prototype.binaryWrite = SlowBuffer.prototype.asciiWrite;

SlowBuffer.prototype.base64Write = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);
};

SlowBuffer.prototype.base64Slice = function (start, end) {
  var bytes = Array.prototype.slice.apply(this, arguments)
  return require("base64-js").fromByteArray(bytes);
}

function decodeUtf8Char(str) {
  try {
    return decodeURIComponent(str);
  } catch (err) {
    return String.fromCharCode(0xFFFD); // UTF 8 invalid char
  }
}

SlowBuffer.prototype.utf8Slice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var res = "";
  var tmp = "";
  var i = 0;
  while (i < bytes.length) {
    if (bytes[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);
      tmp = "";
    } else
      tmp += "%" + bytes[i].toString(16);

    i++;
  }

  return res + decodeUtf8Char(tmp);
}

SlowBuffer.prototype.asciiSlice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var ret = "";
  for (var i = 0; i < bytes.length; i++)
    ret += String.fromCharCode(bytes[i]);
  return ret;
}

SlowBuffer.prototype.binarySlice = SlowBuffer.prototype.asciiSlice;

SlowBuffer.prototype.inspect = function() {
  var out = [],
      len = this.length;
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }
  return '<SlowBuffer ' + out.join(' ') + '>';
};


SlowBuffer.prototype.hexSlice = function(start, end) {
  var len = this.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; i++) {
    out += toHex(this[i]);
  }
  return out;
};


SlowBuffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();
  start = +start || 0;
  if (typeof end == 'undefined') end = this.length;

  // Fastpath empty strings
  if (+end == start) {
    return '';
  }

  switch (encoding) {
    case 'hex':
      return this.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.utf8Slice(start, end);

    case 'ascii':
      return this.asciiSlice(start, end);

    case 'binary':
      return this.binarySlice(start, end);

    case 'base64':
      return this.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


SlowBuffer.prototype.hexWrite = function(string, offset, length) {
  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2) {
    throw new Error('Invalid hex string');
  }
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(byte)) throw new Error('Invalid hex string');
    this[offset + i] = byte;
  }
  SlowBuffer._charsWritten = i * 2;
  return i;
};


SlowBuffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  switch (encoding) {
    case 'hex':
      return this.hexWrite(string, offset, length);

    case 'utf8':
    case 'utf-8':
      return this.utf8Write(string, offset, length);

    case 'ascii':
      return this.asciiWrite(string, offset, length);

    case 'binary':
      return this.binaryWrite(string, offset, length);

    case 'base64':
      return this.base64Write(string, offset, length);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Write(string, offset, length);

    default:
      throw new Error('Unknown encoding');
  }
};


// slice(start, end)
SlowBuffer.prototype.slice = function(start, end) {
  if (end === undefined) end = this.length;

  if (end > this.length) {
    throw new Error('oob');
  }
  if (start > end) {
    throw new Error('oob');
  }

  return new Buffer(this, end - start, +start);
};

SlowBuffer.prototype.copy = function(target, targetstart, sourcestart, sourceend) {
  var temp = [];
  for (var i=sourcestart; i<sourceend; i++) {
    assert.ok(typeof this[i] !== 'undefined', "copying undefined buffer bytes!");
    temp.push(this[i]);
  }

  for (var i=targetstart; i<targetstart+temp.length; i++) {
    target[i] = temp[i-targetstart];
  }
};

SlowBuffer.prototype.fill = function(value, start, end) {
  if (end > this.length) {
    throw new Error('oob');
  }
  if (start > end) {
    throw new Error('oob');
  }

  for (var i = start; i < end; i++) {
    this[i] = value;
  }
}

function coerce(length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length);
  return length < 0 ? 0 : length;
}


// Buffer

function Buffer(subject, encoding, offset) {
  if (!(this instanceof Buffer)) {
    return new Buffer(subject, encoding, offset);
  }

  var type;

  // Are we slicing?
  if (typeof offset === 'number') {
    this.length = coerce(encoding);
    this.parent = subject;
    this.offset = offset;
  } else {
    // Find the length
    switch (type = typeof subject) {
      case 'number':
        this.length = coerce(subject);
        break;

      case 'string':
        this.length = Buffer.byteLength(subject, encoding);
        break;

      case 'object': // Assume object is an array
        this.length = coerce(subject.length);
        break;

      default:
        throw new Error('First argument needs to be a number, ' +
                        'array or string.');
    }

    if (this.length > Buffer.poolSize) {
      // Big buffer, just alloc one.
      this.parent = new SlowBuffer(this.length);
      this.offset = 0;

    } else {
      // Small buffer.
      if (!pool || pool.length - pool.used < this.length) allocPool();
      this.parent = pool;
      this.offset = pool.used;
      pool.used += this.length;
    }

    // Treat array-ish objects as a byte array.
    if (isArrayIsh(subject)) {
      for (var i = 0; i < this.length; i++) {
        if (subject instanceof Buffer) {
          this.parent[i + this.offset] = subject.readUInt8(i);
        }
        else {
          this.parent[i + this.offset] = subject[i];
        }
      }
    } else if (type == 'string') {
      // We are a string
      this.length = this.write(subject, 0, encoding);
    }
  }

}

function isArrayIsh(subject) {
  return Array.isArray(subject) || Buffer.isBuffer(subject) ||
         subject && typeof subject === 'object' &&
         typeof subject.length === 'number';
}

exports.SlowBuffer = SlowBuffer;
exports.Buffer = Buffer;

Buffer.poolSize = 8 * 1024;
var pool;

function allocPool() {
  pool = new SlowBuffer(Buffer.poolSize);
  pool.used = 0;
}


// Static methods
Buffer.isBuffer = function isBuffer(b) {
  return b instanceof Buffer || b instanceof SlowBuffer;
};

Buffer.concat = function (list, totalLength) {
  if (!Array.isArray(list)) {
    throw new Error("Usage: Buffer.concat(list, [totalLength])\n \
      list should be an Array.");
  }

  if (list.length === 0) {
    return new Buffer(0);
  } else if (list.length === 1) {
    return list[0];
  }

  if (typeof totalLength !== 'number') {
    totalLength = 0;
    for (var i = 0; i < list.length; i++) {
      var buf = list[i];
      totalLength += buf.length;
    }
  }

  var buffer = new Buffer(totalLength);
  var pos = 0;
  for (var i = 0; i < list.length; i++) {
    var buf = list[i];
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

// Inspect
Buffer.prototype.inspect = function inspect() {
  var out = [],
      len = this.length;

  for (var i = 0; i < len; i++) {
    out[i] = toHex(this.parent[i + this.offset]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }

  return '<Buffer ' + out.join(' ') + '>';
};


Buffer.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this.parent[this.offset + i];
};


Buffer.prototype.set = function set(i, v) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this.parent[this.offset + i] = v;
};


// write(string, offset = 0, length = buffer.length-offset, encoding = 'utf8')
Buffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  var ret;
  switch (encoding) {
    case 'hex':
      ret = this.parent.hexWrite(string, this.offset + offset, length);
      break;

    case 'utf8':
    case 'utf-8':
      ret = this.parent.utf8Write(string, this.offset + offset, length);
      break;

    case 'ascii':
      ret = this.parent.asciiWrite(string, this.offset + offset, length);
      break;

    case 'binary':
      ret = this.parent.binaryWrite(string, this.offset + offset, length);
      break;

    case 'base64':
      // Warning: maxLength not taken into account in base64Write
      ret = this.parent.base64Write(string, this.offset + offset, length);
      break;

    case 'ucs2':
    case 'ucs-2':
      ret = this.parent.ucs2Write(string, this.offset + offset, length);
      break;

    default:
      throw new Error('Unknown encoding');
  }

  Buffer._charsWritten = SlowBuffer._charsWritten;

  return ret;
};


// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();

  if (typeof start == 'undefined' || start < 0) {
    start = 0;
  } else if (start > this.length) {
    start = this.length;
  }

  if (typeof end == 'undefined' || end > this.length) {
    end = this.length;
  } else if (end < 0) {
    end = 0;
  }

  start = start + this.offset;
  end = end + this.offset;

  switch (encoding) {
    case 'hex':
      return this.parent.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.parent.utf8Slice(start, end);

    case 'ascii':
      return this.parent.asciiSlice(start, end);

    case 'binary':
      return this.parent.binarySlice(start, end);

    case 'base64':
      return this.parent.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.parent.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


// byteLength
Buffer.byteLength = SlowBuffer.byteLength;


// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill(value, start, end) {
  value || (value = 0);
  start || (start = 0);
  end || (end = this.length);

  if (typeof value === 'string') {
    value = value.charCodeAt(0);
  }
  if (!(typeof value === 'number') || isNaN(value)) {
    throw new Error('value is not a number');
  }

  if (end < start) throw new Error('end < start');

  // Fill 0 bytes; we're done
  if (end === start) return 0;
  if (this.length == 0) return 0;

  if (start < 0 || start >= this.length) {
    throw new Error('start out of bounds');
  }

  if (end < 0 || end > this.length) {
    throw new Error('end out of bounds');
  }

  return this.parent.fill(value,
                          start + this.offset,
                          end + this.offset);
};


// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function(target, target_start, start, end) {
  var source = this;
  start || (start = 0);
  end || (end = this.length);
  target_start || (target_start = 0);

  if (end < start) throw new Error('sourceEnd < sourceStart');

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length == 0 || source.length == 0) return 0;

  if (target_start < 0 || target_start >= target.length) {
    throw new Error('targetStart out of bounds');
  }

  if (start < 0 || start >= source.length) {
    throw new Error('sourceStart out of bounds');
  }

  if (end < 0 || end > source.length) {
    throw new Error('sourceEnd out of bounds');
  }

  // Are we oob?
  if (end > this.length) {
    end = this.length;
  }

  if (target.length - target_start < end - start) {
    end = target.length - target_start + start;
  }

  return this.parent.copy(target.parent,
                          target_start + target.offset,
                          start + this.offset,
                          end + this.offset);
};


// slice(start, end)
Buffer.prototype.slice = function(start, end) {
  if (end === undefined) end = this.length;
  if (end > this.length) throw new Error('oob');
  if (start > end) throw new Error('oob');

  return new Buffer(this.parent, end - start, +start + this.offset);
};


// Legacy methods for backwards compatibility.

Buffer.prototype.utf8Slice = function(start, end) {
  return this.toString('utf8', start, end);
};

Buffer.prototype.binarySlice = function(start, end) {
  return this.toString('binary', start, end);
};

Buffer.prototype.asciiSlice = function(start, end) {
  return this.toString('ascii', start, end);
};

Buffer.prototype.utf8Write = function(string, offset) {
  return this.write(string, offset, 'utf8');
};

Buffer.prototype.binaryWrite = function(string, offset) {
  return this.write(string, offset, 'binary');
};

Buffer.prototype.asciiWrite = function(string, offset) {
  return this.write(string, offset, 'ascii');
};

Buffer.prototype.readUInt8 = function(offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  return buffer.parent[buffer.offset + offset];
};

function readUInt16(buffer, offset, isBigEndian, noAssert) {
  var val = 0;


  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    val = buffer.parent[buffer.offset + offset] << 8;
    if (offset + 1 < buffer.length) {
      val |= buffer.parent[buffer.offset + offset + 1];
    }
  } else {
    val = buffer.parent[buffer.offset + offset];
    if (offset + 1 < buffer.length) {
      val |= buffer.parent[buffer.offset + offset + 1] << 8;
    }
  }

  return val;
}

Buffer.prototype.readUInt16LE = function(offset, noAssert) {
  return readUInt16(this, offset, false, noAssert);
};

Buffer.prototype.readUInt16BE = function(offset, noAssert) {
  return readUInt16(this, offset, true, noAssert);
};

function readUInt32(buffer, offset, isBigEndian, noAssert) {
  var val = 0;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    if (offset + 1 < buffer.length)
      val = buffer.parent[buffer.offset + offset + 1] << 16;
    if (offset + 2 < buffer.length)
      val |= buffer.parent[buffer.offset + offset + 2] << 8;
    if (offset + 3 < buffer.length)
      val |= buffer.parent[buffer.offset + offset + 3];
    val = val + (buffer.parent[buffer.offset + offset] << 24 >>> 0);
  } else {
    if (offset + 2 < buffer.length)
      val = buffer.parent[buffer.offset + offset + 2] << 16;
    if (offset + 1 < buffer.length)
      val |= buffer.parent[buffer.offset + offset + 1] << 8;
    val |= buffer.parent[buffer.offset + offset];
    if (offset + 3 < buffer.length)
      val = val + (buffer.parent[buffer.offset + offset + 3] << 24 >>> 0);
  }

  return val;
}

Buffer.prototype.readUInt32LE = function(offset, noAssert) {
  return readUInt32(this, offset, false, noAssert);
};

Buffer.prototype.readUInt32BE = function(offset, noAssert) {
  return readUInt32(this, offset, true, noAssert);
};


/*
 * Signed integer types, yay team! A reminder on how two's complement actually
 * works. The first bit is the signed bit, i.e. tells us whether or not the
 * number should be positive or negative. If the two's complement value is
 * positive, then we're done, as it's equivalent to the unsigned representation.
 *
 * Now if the number is positive, you're pretty much done, you can just leverage
 * the unsigned translations and return those. Unfortunately, negative numbers
 * aren't quite that straightforward.
 *
 * At first glance, one might be inclined to use the traditional formula to
 * translate binary numbers between the positive and negative values in two's
 * complement. (Though it doesn't quite work for the most negative value)
 * Mainly:
 *  - invert all the bits
 *  - add one to the result
 *
 * Of course, this doesn't quite work in Javascript. Take for example the value
 * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of
 * course, Javascript will do the following:
 *
 * > ~0xff80
 * -65409
 *
 * Whoh there, Javascript, that's not quite right. But wait, according to
 * Javascript that's perfectly correct. When Javascript ends up seeing the
 * constant 0xff80, it has no notion that it is actually a signed number. It
 * assumes that we've input the unsigned value 0xff80. Thus, when it does the
 * binary negation, it casts it into a signed value, (positive 0xff80). Then
 * when you perform binary negation on that, it turns it into a negative number.
 *
 * Instead, we're going to have to use the following general formula, that works
 * in a rather Javascript friendly way. I'm glad we don't support this kind of
 * weird numbering scheme in the kernel.
 *
 * (BIT-MAX - (unsigned)val + 1) * -1
 *
 * The astute observer, may think that this doesn't make sense for 8-bit numbers
 * (really it isn't necessary for them). However, when you get 16-bit numbers,
 * you do. Let's go back to our prior example and see how this will look:
 *
 * (0xffff - 0xff80 + 1) * -1
 * (0x007f + 1) * -1
 * (0x0080) * -1
 */
Buffer.prototype.readInt8 = function(offset, noAssert) {
  var buffer = this;
  var neg;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  neg = buffer.parent[buffer.offset + offset] & 0x80;
  if (!neg) {
    return (buffer.parent[buffer.offset + offset]);
  }

  return ((0xff - buffer.parent[buffer.offset + offset] + 1) * -1);
};

function readInt16(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt16(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x8000;
  if (!neg) {
    return val;
  }

  return (0xffff - val + 1) * -1;
}

Buffer.prototype.readInt16LE = function(offset, noAssert) {
  return readInt16(this, offset, false, noAssert);
};

Buffer.prototype.readInt16BE = function(offset, noAssert) {
  return readInt16(this, offset, true, noAssert);
};

function readInt32(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt32(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x80000000;
  if (!neg) {
    return (val);
  }

  return (0xffffffff - val + 1) * -1;
}

Buffer.prototype.readInt32LE = function(offset, noAssert) {
  return readInt32(this, offset, false, noAssert);
};

Buffer.prototype.readInt32BE = function(offset, noAssert) {
  return readInt32(this, offset, true, noAssert);
};

function readFloat(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.readFloatLE = function(offset, noAssert) {
  return readFloat(this, offset, false, noAssert);
};

Buffer.prototype.readFloatBE = function(offset, noAssert) {
  return readFloat(this, offset, true, noAssert);
};

function readDouble(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 7 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.readDoubleLE = function(offset, noAssert) {
  return readDouble(this, offset, false, noAssert);
};

Buffer.prototype.readDoubleBE = function(offset, noAssert) {
  return readDouble(this, offset, true, noAssert);
};


/*
 * We have to make sure that the value is a valid integer. This means that it is
 * non-negative. It has no fractional component and that it does not exceed the
 * maximum allowed value.
 *
 *      value           The number to check for validity
 *
 *      max             The maximum value
 */
function verifuint(value, max) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value >= 0,
      'specified a negative value for writing an unsigned value');

  assert.ok(value <= max, 'value is larger than maximum value for type');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xff);
  }

  if (offset < buffer.length) {
    buffer.parent[buffer.offset + offset] = value;
  }
};

function writeUInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 2); i++) {
    buffer.parent[buffer.offset + offset + i] =
        (value & (0xff << (8 * (isBigEndian ? 1 - i : i)))) >>>
            (isBigEndian ? 1 - i : i) * 8;
  }

}

Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, true, noAssert);
};

function writeUInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffffffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 4); i++) {
    buffer.parent[buffer.offset + offset + i] =
        (value >>> (isBigEndian ? 3 - i : i) * 8) & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, true, noAssert);
};


/*
 * We now move onto our friends in the signed number category. Unlike unsigned
 * numbers, we're going to have to worry a bit more about how we put values into
 * arrays. Since we are only worrying about signed 32-bit values, we're in
 * slightly better shape. Unfortunately, we really can't do our favorite binary
 * & in this system. It really seems to do the wrong thing. For example:
 *
 * > -32 & 0xff
 * 224
 *
 * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of
 * this aren't treated as a signed number. Ultimately a bad thing.
 *
 * What we're going to want to do is basically create the unsigned equivalent of
 * our representation and pass that off to the wuint* functions. To do that
 * we're going to do the following:
 *
 *  - if the value is positive
 *      we can pass it directly off to the equivalent wuint
 *  - if the value is negative
 *      we do the following computation:
 *         mb + val + 1, where
 *         mb   is the maximum unsigned value in that byte size
 *         val  is the Javascript negative integer
 *
 *
 * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If
 * you do out the computations:
 *
 * 0xffff - 128 + 1
 * 0xffff - 127
 * 0xff80
 *
 * You can then encode this value as the signed version. This is really rather
 * hacky, but it should work and get the job done which is our goal here.
 */

/*
 * A series of checks to make sure we actually have a signed 32-bit number
 */
function verifsint(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

function verifIEEE754(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');
}

Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7f, -0x80);
  }

  if (value >= 0) {
    buffer.writeUInt8(value, offset, noAssert);
  } else {
    buffer.writeUInt8(0xff + value + 1, offset, noAssert);
  }
};

function writeInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fff, -0x8000);
  }

  if (value >= 0) {
    writeUInt16(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, true, noAssert);
};

function writeInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fffffff, -0x80000000);
  }

  if (value >= 0) {
    writeUInt32(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, true, noAssert);
};

function writeFloat(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, false, noAssert);
};

Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, true, noAssert);
};

function writeDouble(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 7 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, false, noAssert);
};

Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, true, noAssert);
};

SlowBuffer.prototype.readUInt8 = Buffer.prototype.readUInt8;
SlowBuffer.prototype.readUInt16LE = Buffer.prototype.readUInt16LE;
SlowBuffer.prototype.readUInt16BE = Buffer.prototype.readUInt16BE;
SlowBuffer.prototype.readUInt32LE = Buffer.prototype.readUInt32LE;
SlowBuffer.prototype.readUInt32BE = Buffer.prototype.readUInt32BE;
SlowBuffer.prototype.readInt8 = Buffer.prototype.readInt8;
SlowBuffer.prototype.readInt16LE = Buffer.prototype.readInt16LE;
SlowBuffer.prototype.readInt16BE = Buffer.prototype.readInt16BE;
SlowBuffer.prototype.readInt32LE = Buffer.prototype.readInt32LE;
SlowBuffer.prototype.readInt32BE = Buffer.prototype.readInt32BE;
SlowBuffer.prototype.readFloatLE = Buffer.prototype.readFloatLE;
SlowBuffer.prototype.readFloatBE = Buffer.prototype.readFloatBE;
SlowBuffer.prototype.readDoubleLE = Buffer.prototype.readDoubleLE;
SlowBuffer.prototype.readDoubleBE = Buffer.prototype.readDoubleBE;
SlowBuffer.prototype.writeUInt8 = Buffer.prototype.writeUInt8;
SlowBuffer.prototype.writeUInt16LE = Buffer.prototype.writeUInt16LE;
SlowBuffer.prototype.writeUInt16BE = Buffer.prototype.writeUInt16BE;
SlowBuffer.prototype.writeUInt32LE = Buffer.prototype.writeUInt32LE;
SlowBuffer.prototype.writeUInt32BE = Buffer.prototype.writeUInt32BE;
SlowBuffer.prototype.writeInt8 = Buffer.prototype.writeInt8;
SlowBuffer.prototype.writeInt16LE = Buffer.prototype.writeInt16LE;
SlowBuffer.prototype.writeInt16BE = Buffer.prototype.writeInt16BE;
SlowBuffer.prototype.writeInt32LE = Buffer.prototype.writeInt32LE;
SlowBuffer.prototype.writeInt32BE = Buffer.prototype.writeInt32BE;
SlowBuffer.prototype.writeFloatLE = Buffer.prototype.writeFloatLE;
SlowBuffer.prototype.writeFloatBE = Buffer.prototype.writeFloatBE;
SlowBuffer.prototype.writeDoubleLE = Buffer.prototype.writeDoubleLE;
SlowBuffer.prototype.writeDoubleBE = Buffer.prototype.writeDoubleBE;

},{"assert":1,"./buffer_ieee754":5,"base64-js":7}],7:[function(require,module,exports){
(function (exports) {
	'use strict';

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	function b64ToByteArray(b64) {
		var i, j, l, tmp, placeHolders, arr;
	
		if (b64.length % 4 > 0) {
			throw 'Invalid string. Length must be a multiple of 4';
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		placeHolders = b64.indexOf('=');
		placeHolders = placeHolders > 0 ? b64.length - placeHolders : 0;

		// base64 is 4/3 + up to two characters of the original data
		arr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length;

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);
			arr.push((tmp & 0xFF0000) >> 16);
			arr.push((tmp & 0xFF00) >> 8);
			arr.push(tmp & 0xFF);
		}

		if (placeHolders === 2) {
			tmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);
			arr.push(tmp & 0xFF);
		} else if (placeHolders === 1) {
			tmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);
			arr.push((tmp >> 8) & 0xFF);
			arr.push(tmp & 0xFF);
		}

		return arr;
	}

	function uint8ToBase64(uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length;

		function tripletToBase64 (num) {
			return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
		};

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
			output += tripletToBase64(temp);
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1];
				output += lookup[temp >> 2];
				output += lookup[(temp << 4) & 0x3F];
				output += '==';
				break;
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
				output += lookup[temp >> 10];
				output += lookup[(temp >> 4) & 0x3F];
				output += lookup[(temp << 2) & 0x3F];
				output += '=';
				break;
		}

		return output;
	}

	module.exports.toByteArray = b64ToByteArray;
	module.exports.fromByteArray = uint8ToBase64;
}());

},{}],8:[function(require,module,exports){
exports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isBE ? 0 : (nBytes - 1),
      d = isBE ? 1 : -1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isBE ? (nBytes - 1) : 0,
      d = isBE ? -1 : 1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],3:[function(require,module,exports){
function SlowBuffer (size) {
    this.length = size;
};

var assert = require('assert');

exports.INSPECT_MAX_BYTES = 50;


function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; i++)
    if (str.charCodeAt(i) <= 0x7F)
      byteArray.push(str.charCodeAt(i));
    else {
      var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16));
    }

  return byteArray;
}

function asciiToBytes(str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++ )
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push( str.charCodeAt(i) & 0xFF );

  return byteArray;
}

function base64ToBytes(str) {
  return require("base64-js").toByteArray(str);
}

SlowBuffer.byteLength = function (str, encoding) {
  switch (encoding || "utf8") {
    case 'hex':
      return str.length / 2;

    case 'utf8':
    case 'utf-8':
      return utf8ToBytes(str).length;

    case 'ascii':
      return str.length;

    case 'base64':
      return base64ToBytes(str).length;

    default:
      throw new Error('Unknown encoding');
  }
};

function blitBuffer(src, dst, offset, length) {
  var pos, i = 0;
  while (i < length) {
    if ((i+offset >= dst.length) || (i >= src.length))
      break;

    dst[i + offset] = src[i];
    i++;
  }
  return i;
}

SlowBuffer.prototype.utf8Write = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);
};

SlowBuffer.prototype.asciiWrite = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);
};

SlowBuffer.prototype.base64Write = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);
};

SlowBuffer.prototype.base64Slice = function (start, end) {
  var bytes = Array.prototype.slice.apply(this, arguments)
  return require("base64-js").fromByteArray(bytes);
}

function decodeUtf8Char(str) {
  try {
    return decodeURIComponent(str);
  } catch (err) {
    return String.fromCharCode(0xFFFD); // UTF 8 invalid char
  }
}

SlowBuffer.prototype.utf8Slice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var res = "";
  var tmp = "";
  var i = 0;
  while (i < bytes.length) {
    if (bytes[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);
      tmp = "";
    } else
      tmp += "%" + bytes[i].toString(16);

    i++;
  }

  return res + decodeUtf8Char(tmp);
}

SlowBuffer.prototype.asciiSlice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var ret = "";
  for (var i = 0; i < bytes.length; i++)
    ret += String.fromCharCode(bytes[i]);
  return ret;
}

SlowBuffer.prototype.inspect = function() {
  var out = [],
      len = this.length;
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }
  return '<SlowBuffer ' + out.join(' ') + '>';
};


SlowBuffer.prototype.hexSlice = function(start, end) {
  var len = this.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; i++) {
    out += toHex(this[i]);
  }
  return out;
};


SlowBuffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();
  start = +start || 0;
  if (typeof end == 'undefined') end = this.length;

  // Fastpath empty strings
  if (+end == start) {
    return '';
  }

  switch (encoding) {
    case 'hex':
      return this.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.utf8Slice(start, end);

    case 'ascii':
      return this.asciiSlice(start, end);

    case 'binary':
      return this.binarySlice(start, end);

    case 'base64':
      return this.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


SlowBuffer.prototype.hexWrite = function(string, offset, length) {
  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2) {
    throw new Error('Invalid hex string');
  }
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(byte)) throw new Error('Invalid hex string');
    this[offset + i] = byte;
  }
  SlowBuffer._charsWritten = i * 2;
  return i;
};


SlowBuffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  switch (encoding) {
    case 'hex':
      return this.hexWrite(string, offset, length);

    case 'utf8':
    case 'utf-8':
      return this.utf8Write(string, offset, length);

    case 'ascii':
      return this.asciiWrite(string, offset, length);

    case 'binary':
      return this.binaryWrite(string, offset, length);

    case 'base64':
      return this.base64Write(string, offset, length);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Write(string, offset, length);

    default:
      throw new Error('Unknown encoding');
  }
};


// slice(start, end)
SlowBuffer.prototype.slice = function(start, end) {
  if (end === undefined) end = this.length;

  if (end > this.length) {
    throw new Error('oob');
  }
  if (start > end) {
    throw new Error('oob');
  }

  return new Buffer(this, end - start, +start);
};

SlowBuffer.prototype.copy = function(target, targetstart, sourcestart, sourceend) {
  var temp = [];
  for (var i=sourcestart; i<sourceend; i++) {
    assert.ok(typeof this[i] !== 'undefined', "copying undefined buffer bytes!");
    temp.push(this[i]);
  }

  for (var i=targetstart; i<targetstart+temp.length; i++) {
    target[i] = temp[i-targetstart];
  }
};

function coerce(length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length);
  return length < 0 ? 0 : length;
}


// Buffer

function Buffer(subject, encoding, offset) {
  if (!(this instanceof Buffer)) {
    return new Buffer(subject, encoding, offset);
  }

  var type;

  // Are we slicing?
  if (typeof offset === 'number') {
    this.length = coerce(encoding);
    this.parent = subject;
    this.offset = offset;
  } else {
    // Find the length
    switch (type = typeof subject) {
      case 'number':
        this.length = coerce(subject);
        break;

      case 'string':
        this.length = Buffer.byteLength(subject, encoding);
        break;

      case 'object': // Assume object is an array
        this.length = coerce(subject.length);
        break;

      default:
        throw new Error('First argument needs to be a number, ' +
                        'array or string.');
    }

    if (this.length > Buffer.poolSize) {
      // Big buffer, just alloc one.
      this.parent = new SlowBuffer(this.length);
      this.offset = 0;

    } else {
      // Small buffer.
      if (!pool || pool.length - pool.used < this.length) allocPool();
      this.parent = pool;
      this.offset = pool.used;
      pool.used += this.length;
    }

    // Treat array-ish objects as a byte array.
    if (isArrayIsh(subject)) {
      for (var i = 0; i < this.length; i++) {
        this.parent[i + this.offset] = subject[i];
      }
    } else if (type == 'string') {
      // We are a string
      this.length = this.write(subject, 0, encoding);
    }
  }

}

function isArrayIsh(subject) {
  return Array.isArray(subject) || Buffer.isBuffer(subject) ||
         subject && typeof subject === 'object' &&
         typeof subject.length === 'number';
}

exports.SlowBuffer = SlowBuffer;
exports.Buffer = Buffer;

Buffer.poolSize = 8 * 1024;
var pool;

function allocPool() {
  pool = new SlowBuffer(Buffer.poolSize);
  pool.used = 0;
}


// Static methods
Buffer.isBuffer = function isBuffer(b) {
  return b instanceof Buffer || b instanceof SlowBuffer;
};

Buffer.concat = function (list, totalLength) {
  if (!Array.isArray(list)) {
    throw new Error("Usage: Buffer.concat(list, [totalLength])\n \
      list should be an Array.");
  }

  if (list.length === 0) {
    return new Buffer(0);
  } else if (list.length === 1) {
    return list[0];
  }

  if (typeof totalLength !== 'number') {
    totalLength = 0;
    for (var i = 0; i < list.length; i++) {
      var buf = list[i];
      totalLength += buf.length;
    }
  }

  var buffer = new Buffer(totalLength);
  var pos = 0;
  for (var i = 0; i < list.length; i++) {
    var buf = list[i];
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

// Inspect
Buffer.prototype.inspect = function inspect() {
  var out = [],
      len = this.length;

  for (var i = 0; i < len; i++) {
    out[i] = toHex(this.parent[i + this.offset]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }

  return '<Buffer ' + out.join(' ') + '>';
};


Buffer.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this.parent[this.offset + i];
};


Buffer.prototype.set = function set(i, v) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this.parent[this.offset + i] = v;
};


// write(string, offset = 0, length = buffer.length-offset, encoding = 'utf8')
Buffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  var ret;
  switch (encoding) {
    case 'hex':
      ret = this.parent.hexWrite(string, this.offset + offset, length);
      break;

    case 'utf8':
    case 'utf-8':
      ret = this.parent.utf8Write(string, this.offset + offset, length);
      break;

    case 'ascii':
      ret = this.parent.asciiWrite(string, this.offset + offset, length);
      break;

    case 'binary':
      ret = this.parent.binaryWrite(string, this.offset + offset, length);
      break;

    case 'base64':
      // Warning: maxLength not taken into account in base64Write
      ret = this.parent.base64Write(string, this.offset + offset, length);
      break;

    case 'ucs2':
    case 'ucs-2':
      ret = this.parent.ucs2Write(string, this.offset + offset, length);
      break;

    default:
      throw new Error('Unknown encoding');
  }

  Buffer._charsWritten = SlowBuffer._charsWritten;

  return ret;
};


// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();

  if (typeof start == 'undefined' || start < 0) {
    start = 0;
  } else if (start > this.length) {
    start = this.length;
  }

  if (typeof end == 'undefined' || end > this.length) {
    end = this.length;
  } else if (end < 0) {
    end = 0;
  }

  start = start + this.offset;
  end = end + this.offset;

  switch (encoding) {
    case 'hex':
      return this.parent.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.parent.utf8Slice(start, end);

    case 'ascii':
      return this.parent.asciiSlice(start, end);

    case 'binary':
      return this.parent.binarySlice(start, end);

    case 'base64':
      return this.parent.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.parent.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


// byteLength
Buffer.byteLength = SlowBuffer.byteLength;


// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill(value, start, end) {
  value || (value = 0);
  start || (start = 0);
  end || (end = this.length);

  if (typeof value === 'string') {
    value = value.charCodeAt(0);
  }
  if (!(typeof value === 'number') || isNaN(value)) {
    throw new Error('value is not a number');
  }

  if (end < start) throw new Error('end < start');

  // Fill 0 bytes; we're done
  if (end === start) return 0;
  if (this.length == 0) return 0;

  if (start < 0 || start >= this.length) {
    throw new Error('start out of bounds');
  }

  if (end < 0 || end > this.length) {
    throw new Error('end out of bounds');
  }

  return this.parent.fill(value,
                          start + this.offset,
                          end + this.offset);
};


// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function(target, target_start, start, end) {
  var source = this;
  start || (start = 0);
  end || (end = this.length);
  target_start || (target_start = 0);

  if (end < start) throw new Error('sourceEnd < sourceStart');

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length == 0 || source.length == 0) return 0;

  if (target_start < 0 || target_start >= target.length) {
    throw new Error('targetStart out of bounds');
  }

  if (start < 0 || start >= source.length) {
    throw new Error('sourceStart out of bounds');
  }

  if (end < 0 || end > source.length) {
    throw new Error('sourceEnd out of bounds');
  }

  // Are we oob?
  if (end > this.length) {
    end = this.length;
  }

  if (target.length - target_start < end - start) {
    end = target.length - target_start + start;
  }

  return this.parent.copy(target.parent,
                          target_start + target.offset,
                          start + this.offset,
                          end + this.offset);
};


// slice(start, end)
Buffer.prototype.slice = function(start, end) {
  if (end === undefined) end = this.length;
  if (end > this.length) throw new Error('oob');
  if (start > end) throw new Error('oob');

  return new Buffer(this.parent, end - start, +start + this.offset);
};


// Legacy methods for backwards compatibility.

Buffer.prototype.utf8Slice = function(start, end) {
  return this.toString('utf8', start, end);
};

Buffer.prototype.binarySlice = function(start, end) {
  return this.toString('binary', start, end);
};

Buffer.prototype.asciiSlice = function(start, end) {
  return this.toString('ascii', start, end);
};

Buffer.prototype.utf8Write = function(string, offset) {
  return this.write(string, offset, 'utf8');
};

Buffer.prototype.binaryWrite = function(string, offset) {
  return this.write(string, offset, 'binary');
};

Buffer.prototype.asciiWrite = function(string, offset) {
  return this.write(string, offset, 'ascii');
};

Buffer.prototype.readUInt8 = function(offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  return buffer.parent[buffer.offset + offset];
};

function readUInt16(buffer, offset, isBigEndian, noAssert) {
  var val = 0;


  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (isBigEndian) {
    val = buffer.parent[buffer.offset + offset] << 8;
    val |= buffer.parent[buffer.offset + offset + 1];
  } else {
    val = buffer.parent[buffer.offset + offset];
    val |= buffer.parent[buffer.offset + offset + 1] << 8;
  }

  return val;
}

Buffer.prototype.readUInt16LE = function(offset, noAssert) {
  return readUInt16(this, offset, false, noAssert);
};

Buffer.prototype.readUInt16BE = function(offset, noAssert) {
  return readUInt16(this, offset, true, noAssert);
};

function readUInt32(buffer, offset, isBigEndian, noAssert) {
  var val = 0;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (isBigEndian) {
    val = buffer.parent[buffer.offset + offset + 1] << 16;
    val |= buffer.parent[buffer.offset + offset + 2] << 8;
    val |= buffer.parent[buffer.offset + offset + 3];
    val = val + (buffer.parent[buffer.offset + offset] << 24 >>> 0);
  } else {
    val = buffer.parent[buffer.offset + offset + 2] << 16;
    val |= buffer.parent[buffer.offset + offset + 1] << 8;
    val |= buffer.parent[buffer.offset + offset];
    val = val + (buffer.parent[buffer.offset + offset + 3] << 24 >>> 0);
  }

  return val;
}

Buffer.prototype.readUInt32LE = function(offset, noAssert) {
  return readUInt32(this, offset, false, noAssert);
};

Buffer.prototype.readUInt32BE = function(offset, noAssert) {
  return readUInt32(this, offset, true, noAssert);
};


/*
 * Signed integer types, yay team! A reminder on how two's complement actually
 * works. The first bit is the signed bit, i.e. tells us whether or not the
 * number should be positive or negative. If the two's complement value is
 * positive, then we're done, as it's equivalent to the unsigned representation.
 *
 * Now if the number is positive, you're pretty much done, you can just leverage
 * the unsigned translations and return those. Unfortunately, negative numbers
 * aren't quite that straightforward.
 *
 * At first glance, one might be inclined to use the traditional formula to
 * translate binary numbers between the positive and negative values in two's
 * complement. (Though it doesn't quite work for the most negative value)
 * Mainly:
 *  - invert all the bits
 *  - add one to the result
 *
 * Of course, this doesn't quite work in Javascript. Take for example the value
 * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of
 * course, Javascript will do the following:
 *
 * > ~0xff80
 * -65409
 *
 * Whoh there, Javascript, that's not quite right. But wait, according to
 * Javascript that's perfectly correct. When Javascript ends up seeing the
 * constant 0xff80, it has no notion that it is actually a signed number. It
 * assumes that we've input the unsigned value 0xff80. Thus, when it does the
 * binary negation, it casts it into a signed value, (positive 0xff80). Then
 * when you perform binary negation on that, it turns it into a negative number.
 *
 * Instead, we're going to have to use the following general formula, that works
 * in a rather Javascript friendly way. I'm glad we don't support this kind of
 * weird numbering scheme in the kernel.
 *
 * (BIT-MAX - (unsigned)val + 1) * -1
 *
 * The astute observer, may think that this doesn't make sense for 8-bit numbers
 * (really it isn't necessary for them). However, when you get 16-bit numbers,
 * you do. Let's go back to our prior example and see how this will look:
 *
 * (0xffff - 0xff80 + 1) * -1
 * (0x007f + 1) * -1
 * (0x0080) * -1
 */
Buffer.prototype.readInt8 = function(offset, noAssert) {
  var buffer = this;
  var neg;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  neg = buffer.parent[buffer.offset + offset] & 0x80;
  if (!neg) {
    return (buffer.parent[buffer.offset + offset]);
  }

  return ((0xff - buffer.parent[buffer.offset + offset] + 1) * -1);
};

function readInt16(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt16(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x8000;
  if (!neg) {
    return val;
  }

  return (0xffff - val + 1) * -1;
}

Buffer.prototype.readInt16LE = function(offset, noAssert) {
  return readInt16(this, offset, false, noAssert);
};

Buffer.prototype.readInt16BE = function(offset, noAssert) {
  return readInt16(this, offset, true, noAssert);
};

function readInt32(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt32(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x80000000;
  if (!neg) {
    return (val);
  }

  return (0xffffffff - val + 1) * -1;
}

Buffer.prototype.readInt32LE = function(offset, noAssert) {
  return readInt32(this, offset, false, noAssert);
};

Buffer.prototype.readInt32BE = function(offset, noAssert) {
  return readInt32(this, offset, true, noAssert);
};

function readFloat(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.readFloatLE = function(offset, noAssert) {
  return readFloat(this, offset, false, noAssert);
};

Buffer.prototype.readFloatBE = function(offset, noAssert) {
  return readFloat(this, offset, true, noAssert);
};

function readDouble(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 7 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.readDoubleLE = function(offset, noAssert) {
  return readDouble(this, offset, false, noAssert);
};

Buffer.prototype.readDoubleBE = function(offset, noAssert) {
  return readDouble(this, offset, true, noAssert);
};


/*
 * We have to make sure that the value is a valid integer. This means that it is
 * non-negative. It has no fractional component and that it does not exceed the
 * maximum allowed value.
 *
 *      value           The number to check for validity
 *
 *      max             The maximum value
 */
function verifuint(value, max) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value >= 0,
      'specified a negative value for writing an unsigned value');

  assert.ok(value <= max, 'value is larger than maximum value for type');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xff);
  }

  buffer.parent[buffer.offset + offset] = value;
};

function writeUInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffff);
  }

  if (isBigEndian) {
    buffer.parent[buffer.offset + offset] = (value & 0xff00) >>> 8;
    buffer.parent[buffer.offset + offset + 1] = value & 0x00ff;
  } else {
    buffer.parent[buffer.offset + offset + 1] = (value & 0xff00) >>> 8;
    buffer.parent[buffer.offset + offset] = value & 0x00ff;
  }
}

Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, true, noAssert);
};

function writeUInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffffffff);
  }

  if (isBigEndian) {
    buffer.parent[buffer.offset + offset] = (value >>> 24) & 0xff;
    buffer.parent[buffer.offset + offset + 1] = (value >>> 16) & 0xff;
    buffer.parent[buffer.offset + offset + 2] = (value >>> 8) & 0xff;
    buffer.parent[buffer.offset + offset + 3] = value & 0xff;
  } else {
    buffer.parent[buffer.offset + offset + 3] = (value >>> 24) & 0xff;
    buffer.parent[buffer.offset + offset + 2] = (value >>> 16) & 0xff;
    buffer.parent[buffer.offset + offset + 1] = (value >>> 8) & 0xff;
    buffer.parent[buffer.offset + offset] = value & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, true, noAssert);
};


/*
 * We now move onto our friends in the signed number category. Unlike unsigned
 * numbers, we're going to have to worry a bit more about how we put values into
 * arrays. Since we are only worrying about signed 32-bit values, we're in
 * slightly better shape. Unfortunately, we really can't do our favorite binary
 * & in this system. It really seems to do the wrong thing. For example:
 *
 * > -32 & 0xff
 * 224
 *
 * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of
 * this aren't treated as a signed number. Ultimately a bad thing.
 *
 * What we're going to want to do is basically create the unsigned equivalent of
 * our representation and pass that off to the wuint* functions. To do that
 * we're going to do the following:
 *
 *  - if the value is positive
 *      we can pass it directly off to the equivalent wuint
 *  - if the value is negative
 *      we do the following computation:
 *         mb + val + 1, where
 *         mb   is the maximum unsigned value in that byte size
 *         val  is the Javascript negative integer
 *
 *
 * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If
 * you do out the computations:
 *
 * 0xffff - 128 + 1
 * 0xffff - 127
 * 0xff80
 *
 * You can then encode this value as the signed version. This is really rather
 * hacky, but it should work and get the job done which is our goal here.
 */

/*
 * A series of checks to make sure we actually have a signed 32-bit number
 */
function verifsint(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

function verifIEEE754(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');
}

Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7f, -0x80);
  }

  if (value >= 0) {
    buffer.writeUInt8(value, offset, noAssert);
  } else {
    buffer.writeUInt8(0xff + value + 1, offset, noAssert);
  }
};

function writeInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fff, -0x8000);
  }

  if (value >= 0) {
    writeUInt16(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, true, noAssert);
};

function writeInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fffffff, -0x80000000);
  }

  if (value >= 0) {
    writeUInt32(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, true, noAssert);
};

function writeFloat(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, false, noAssert);
};

Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, true, noAssert);
};

function writeDouble(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 7 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, false, noAssert);
};

Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, true, noAssert);
};

SlowBuffer.prototype.readUInt8 = Buffer.prototype.readUInt8;
SlowBuffer.prototype.readUInt16LE = Buffer.prototype.readUInt16LE;
SlowBuffer.prototype.readUInt16BE = Buffer.prototype.readUInt16BE;
SlowBuffer.prototype.readUInt32LE = Buffer.prototype.readUInt32LE;
SlowBuffer.prototype.readUInt32BE = Buffer.prototype.readUInt32BE;
SlowBuffer.prototype.readInt8 = Buffer.prototype.readInt8;
SlowBuffer.prototype.readInt16LE = Buffer.prototype.readInt16LE;
SlowBuffer.prototype.readInt16BE = Buffer.prototype.readInt16BE;
SlowBuffer.prototype.readInt32LE = Buffer.prototype.readInt32LE;
SlowBuffer.prototype.readInt32BE = Buffer.prototype.readInt32BE;
SlowBuffer.prototype.readFloatLE = Buffer.prototype.readFloatLE;
SlowBuffer.prototype.readFloatBE = Buffer.prototype.readFloatBE;
SlowBuffer.prototype.readDoubleLE = Buffer.prototype.readDoubleLE;
SlowBuffer.prototype.readDoubleBE = Buffer.prototype.readDoubleBE;
SlowBuffer.prototype.writeUInt8 = Buffer.prototype.writeUInt8;
SlowBuffer.prototype.writeUInt16LE = Buffer.prototype.writeUInt16LE;
SlowBuffer.prototype.writeUInt16BE = Buffer.prototype.writeUInt16BE;
SlowBuffer.prototype.writeUInt32LE = Buffer.prototype.writeUInt32LE;
SlowBuffer.prototype.writeUInt32BE = Buffer.prototype.writeUInt32BE;
SlowBuffer.prototype.writeInt8 = Buffer.prototype.writeInt8;
SlowBuffer.prototype.writeInt16LE = Buffer.prototype.writeInt16LE;
SlowBuffer.prototype.writeInt16BE = Buffer.prototype.writeInt16BE;
SlowBuffer.prototype.writeInt32LE = Buffer.prototype.writeInt32LE;
SlowBuffer.prototype.writeInt32BE = Buffer.prototype.writeInt32BE;
SlowBuffer.prototype.writeFloatLE = Buffer.prototype.writeFloatLE;
SlowBuffer.prototype.writeFloatBE = Buffer.prototype.writeFloatBE;
SlowBuffer.prototype.writeDoubleLE = Buffer.prototype.writeDoubleLE;
SlowBuffer.prototype.writeDoubleBE = Buffer.prototype.writeDoubleBE;

},{"assert":1,"./buffer_ieee754":8,"base64-js":9}],9:[function(require,module,exports){
(function (exports) {
	'use strict';

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	function b64ToByteArray(b64) {
		var i, j, l, tmp, placeHolders, arr;
	
		if (b64.length % 4 > 0) {
			throw 'Invalid string. Length must be a multiple of 4';
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		placeHolders = b64.indexOf('=');
		placeHolders = placeHolders > 0 ? b64.length - placeHolders : 0;

		// base64 is 4/3 + up to two characters of the original data
		arr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length;

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);
			arr.push((tmp & 0xFF0000) >> 16);
			arr.push((tmp & 0xFF00) >> 8);
			arr.push(tmp & 0xFF);
		}

		if (placeHolders === 2) {
			tmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);
			arr.push(tmp & 0xFF);
		} else if (placeHolders === 1) {
			tmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);
			arr.push((tmp >> 8) & 0xFF);
			arr.push(tmp & 0xFF);
		}

		return arr;
	}

	function uint8ToBase64(uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length;

		function tripletToBase64 (num) {
			return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
		};

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
			output += tripletToBase64(temp);
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1];
				output += lookup[temp >> 2];
				output += lookup[(temp << 4) & 0x3F];
				output += '==';
				break;
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
				output += lookup[temp >> 10];
				output += lookup[(temp >> 4) & 0x3F];
				output += lookup[(temp << 2) & 0x3F];
				output += '=';
				break;
		}

		return output;
	}

	module.exports.toByteArray = b64ToByteArray;
	module.exports.fromByteArray = uint8ToBase64;
}());

},{}]},{},[])
;;module.exports=require("buffer-browserify")

},{}],13:[function(require,module,exports){
(function(Buffer){
(function (global, module) {

  if ('undefined' == typeof module) {
    var module = { exports: {} }
      , exports = module.exports
  }

  /**
   * Exports.
   */

  module.exports = expect;
  expect.Assertion = Assertion;

  /**
   * Exports version.
   */

  expect.version = '0.1.2';

  /**
   * Possible assertion flags.
   */

  var flags = {
      not: ['to', 'be', 'have', 'include', 'only']
    , to: ['be', 'have', 'include', 'only', 'not']
    , only: ['have']
    , have: ['own']
    , be: ['an']
  };

  function expect (obj) {
    return new Assertion(obj);
  }

  /**
   * Constructor
   *
   * @api private
   */

  function Assertion (obj, flag, parent) {
    this.obj = obj;
    this.flags = {};

    if (undefined != parent) {
      this.flags[flag] = true;

      for (var i in parent.flags) {
        if (parent.flags.hasOwnProperty(i)) {
          this.flags[i] = true;
        }
      }
    }

    var $flags = flag ? flags[flag] : keys(flags)
      , self = this

    if ($flags) {
      for (var i = 0, l = $flags.length; i < l; i++) {
        // avoid recursion
        if (this.flags[$flags[i]]) continue;

        var name = $flags[i]
          , assertion = new Assertion(this.obj, name, this)

        if ('function' == typeof Assertion.prototype[name]) {
          // clone the function, make sure we dont touch the prot reference
          var old = this[name];
          this[name] = function () {
            return old.apply(self, arguments);
          }

          for (var fn in Assertion.prototype) {
            if (Assertion.prototype.hasOwnProperty(fn) && fn != name) {
              this[name][fn] = bind(assertion[fn], assertion);
            }
          }
        } else {
          this[name] = assertion;
        }
      }
    }
  };

  /**
   * Performs an assertion
   *
   * @api private
   */

  Assertion.prototype.assert = function (truth, msg, error) {
    var msg = this.flags.not ? error : msg
      , ok = this.flags.not ? !truth : truth;

    if (!ok) {
      throw new Error(msg.call(this));
    }

    this.and = new Assertion(this.obj);
  };

  /**
   * Check if the value is truthy
   *
   * @api public
   */

  Assertion.prototype.ok = function () {
    this.assert(
        !!this.obj
      , function(){ return 'expected ' + i(this.obj) + ' to be truthy' }
      , function(){ return 'expected ' + i(this.obj) + ' to be falsy' });
  };

  /**
   * Assert that the function throws.
   *
   * @param {Function|RegExp} callback, or regexp to match error string against
   * @api public
   */

  Assertion.prototype.throwError =
  Assertion.prototype.throwException = function (fn) {
    expect(this.obj).to.be.a('function');

    var thrown = false
      , not = this.flags.not

    try {
      this.obj();
    } catch (e) {
      if ('function' == typeof fn) {
        fn(e);
      } else if ('object' == typeof fn) {
        var subject = 'string' == typeof e ? e : e.message;
        if (not) {
          expect(subject).to.not.match(fn);
        } else {
          expect(subject).to.match(fn);
        }
      }
      thrown = true;
    }

    if ('object' == typeof fn && not) {
      // in the presence of a matcher, ensure the `not` only applies to
      // the matching.
      this.flags.not = false;
    }

    var name = this.obj.name || 'fn';
    this.assert(
        thrown
      , function(){ return 'expected ' + name + ' to throw an exception' }
      , function(){ return 'expected ' + name + ' not to throw an exception' });
  };

  /**
   * Checks if the array is empty.
   *
   * @api public
   */

  Assertion.prototype.empty = function () {
    var expectation;

    if ('object' == typeof this.obj && null !== this.obj && !isArray(this.obj)) {
      if ('number' == typeof this.obj.length) {
        expectation = !this.obj.length;
      } else {
        expectation = !keys(this.obj).length;
      }
    } else {
      if ('string' != typeof this.obj) {
        expect(this.obj).to.be.an('object');
      }

      expect(this.obj).to.have.property('length');
      expectation = !this.obj.length;
    }

    this.assert(
        expectation
      , function(){ return 'expected ' + i(this.obj) + ' to be empty' }
      , function(){ return 'expected ' + i(this.obj) + ' to not be empty' });
    return this;
  };

  /**
   * Checks if the obj exactly equals another.
   *
   * @api public
   */

  Assertion.prototype.be =
  Assertion.prototype.equal = function (obj) {
    this.assert(
        obj === this.obj
      , function(){ return 'expected ' + i(this.obj) + ' to equal ' + i(obj) }
      , function(){ return 'expected ' + i(this.obj) + ' to not equal ' + i(obj) });
    return this;
  };

  /**
   * Checks if the obj sortof equals another.
   *
   * @api public
   */

  Assertion.prototype.eql = function (obj) {
    this.assert(
        expect.eql(obj, this.obj)
      , function(){ return 'expected ' + i(this.obj) + ' to sort of equal ' + i(obj) }
      , function(){ return 'expected ' + i(this.obj) + ' to sort of not equal ' + i(obj) });
    return this;
  };

  /**
   * Assert within start to finish (inclusive).
   *
   * @param {Number} start
   * @param {Number} finish
   * @api public
   */

  Assertion.prototype.within = function (start, finish) {
    var range = start + '..' + finish;
    this.assert(
        this.obj >= start && this.obj <= finish
      , function(){ return 'expected ' + i(this.obj) + ' to be within ' + range }
      , function(){ return 'expected ' + i(this.obj) + ' to not be within ' + range });
    return this;
  };

  /**
   * Assert typeof / instance of
   *
   * @api public
   */

  Assertion.prototype.a =
  Assertion.prototype.an = function (type) {
    if ('string' == typeof type) {
      // proper english in error msg
      var n = /^[aeiou]/.test(type) ? 'n' : '';

      // typeof with support for 'array'
      this.assert(
          'array' == type ? isArray(this.obj) :
            'object' == type
              ? 'object' == typeof this.obj && null !== this.obj
              : type == typeof this.obj
        , function(){ return 'expected ' + i(this.obj) + ' to be a' + n + ' ' + type }
        , function(){ return 'expected ' + i(this.obj) + ' not to be a' + n + ' ' + type });
    } else {
      // instanceof
      var name = type.name || 'supplied constructor';
      this.assert(
          this.obj instanceof type
        , function(){ return 'expected ' + i(this.obj) + ' to be an instance of ' + name }
        , function(){ return 'expected ' + i(this.obj) + ' not to be an instance of ' + name });
    }

    return this;
  };

  /**
   * Assert numeric value above _n_.
   *
   * @param {Number} n
   * @api public
   */

  Assertion.prototype.greaterThan =
  Assertion.prototype.above = function (n) {
    this.assert(
        this.obj > n
      , function(){ return 'expected ' + i(this.obj) + ' to be above ' + n }
      , function(){ return 'expected ' + i(this.obj) + ' to be below ' + n });
    return this;
  };

  /**
   * Assert numeric value below _n_.
   *
   * @param {Number} n
   * @api public
   */

  Assertion.prototype.lessThan =
  Assertion.prototype.below = function (n) {
    this.assert(
        this.obj < n
      , function(){ return 'expected ' + i(this.obj) + ' to be below ' + n }
      , function(){ return 'expected ' + i(this.obj) + ' to be above ' + n });
    return this;
  };

  /**
   * Assert string value matches _regexp_.
   *
   * @param {RegExp} regexp
   * @api public
   */

  Assertion.prototype.match = function (regexp) {
    this.assert(
        regexp.exec(this.obj)
      , function(){ return 'expected ' + i(this.obj) + ' to match ' + regexp }
      , function(){ return 'expected ' + i(this.obj) + ' not to match ' + regexp });
    return this;
  };

  /**
   * Assert property "length" exists and has value of _n_.
   *
   * @param {Number} n
   * @api public
   */

  Assertion.prototype.length = function (n) {
    expect(this.obj).to.have.property('length');
    var len = this.obj.length;
    this.assert(
        n == len
      , function(){ return 'expected ' + i(this.obj) + ' to have a length of ' + n + ' but got ' + len }
      , function(){ return 'expected ' + i(this.obj) + ' to not have a length of ' + len });
    return this;
  };

  /**
   * Assert property _name_ exists, with optional _val_.
   *
   * @param {String} name
   * @param {Mixed} val
   * @api public
   */

  Assertion.prototype.property = function (name, val) {
    if (this.flags.own) {
      this.assert(
          Object.prototype.hasOwnProperty.call(this.obj, name)
        , function(){ return 'expected ' + i(this.obj) + ' to have own property ' + i(name) }
        , function(){ return 'expected ' + i(this.obj) + ' to not have own property ' + i(name) });
      return this;
    }

    if (this.flags.not && undefined !== val) {
      if (undefined === this.obj[name]) {
        throw new Error(i(this.obj) + ' has no property ' + i(name));
      }
    } else {
      var hasProp;
      try {
        hasProp = name in this.obj
      } catch (e) {
        hasProp = undefined !== this.obj[name]
      }

      this.assert(
          hasProp
        , function(){ return 'expected ' + i(this.obj) + ' to have a property ' + i(name) }
        , function(){ return 'expected ' + i(this.obj) + ' to not have a property ' + i(name) });
    }

    if (undefined !== val) {
      this.assert(
          val === this.obj[name]
        , function(){ return 'expected ' + i(this.obj) + ' to have a property ' + i(name)
          + ' of ' + i(val) + ', but got ' + i(this.obj[name]) }
        , function(){ return 'expected ' + i(this.obj) + ' to not have a property ' + i(name)
          + ' of ' + i(val) });
    }

    this.obj = this.obj[name];
    return this;
  };

  /**
   * Assert that the array contains _obj_ or string contains _obj_.
   *
   * @param {Mixed} obj|string
   * @api public
   */

  Assertion.prototype.string =
  Assertion.prototype.contain = function (obj) {
    if ('string' == typeof this.obj) {
      this.assert(
          ~this.obj.indexOf(obj)
        , function(){ return 'expected ' + i(this.obj) + ' to contain ' + i(obj) }
        , function(){ return 'expected ' + i(this.obj) + ' to not contain ' + i(obj) });
    } else {
      this.assert(
          ~indexOf(this.obj, obj)
        , function(){ return 'expected ' + i(this.obj) + ' to contain ' + i(obj) }
        , function(){ return 'expected ' + i(this.obj) + ' to not contain ' + i(obj) });
    }
    return this;
  };

  /**
   * Assert exact keys or inclusion of keys by using
   * the `.own` modifier.
   *
   * @param {Array|String ...} keys
   * @api public
   */

  Assertion.prototype.key =
  Assertion.prototype.keys = function ($keys) {
    var str
      , ok = true;

    $keys = isArray($keys)
      ? $keys
      : Array.prototype.slice.call(arguments);

    if (!$keys.length) throw new Error('keys required');

    var actual = keys(this.obj)
      , len = $keys.length;

    // Inclusion
    ok = every($keys, function (key) {
      return ~indexOf(actual, key);
    });

    // Strict
    if (!this.flags.not && this.flags.only) {
      ok = ok && $keys.length == actual.length;
    }

    // Key string
    if (len > 1) {
      $keys = map($keys, function (key) {
        return i(key);
      });
      var last = $keys.pop();
      str = $keys.join(', ') + ', and ' + last;
    } else {
      str = i($keys[0]);
    }

    // Form
    str = (len > 1 ? 'keys ' : 'key ') + str;

    // Have / include
    str = (!this.flags.only ? 'include ' : 'only have ') + str;

    // Assertion
    this.assert(
        ok
      , function(){ return 'expected ' + i(this.obj) + ' to ' + str }
      , function(){ return 'expected ' + i(this.obj) + ' to not ' + str });

    return this;
  };
  /**
   * Assert a failure.
   *
   * @param {String ...} custom message
   * @api public
   */
  Assertion.prototype.fail = function (msg) {
    msg = msg || "explicit failure";
    this.assert(false, msg, msg);
    return this;
  };

  /**
   * Function bind implementation.
   */

  function bind (fn, scope) {
    return function () {
      return fn.apply(scope, arguments);
    }
  }

  /**
   * Array every compatibility
   *
   * @see bit.ly/5Fq1N2
   * @api public
   */

  function every (arr, fn, thisObj) {
    var scope = thisObj || global;
    for (var i = 0, j = arr.length; i < j; ++i) {
      if (!fn.call(scope, arr[i], i, arr)) {
        return false;
      }
    }
    return true;
  };

  /**
   * Array indexOf compatibility.
   *
   * @see bit.ly/a5Dxa2
   * @api public
   */

  function indexOf (arr, o, i) {
    if (Array.prototype.indexOf) {
      return Array.prototype.indexOf.call(arr, o, i);
    }

    if (arr.length === undefined) {
      return -1;
    }

    for (var j = arr.length, i = i < 0 ? i + j < 0 ? 0 : i + j : i || 0
        ; i < j && arr[i] !== o; i++);

    return j <= i ? -1 : i;
  };

  // https://gist.github.com/1044128/
  var getOuterHTML = function(element) {
    if ('outerHTML' in element) return element.outerHTML;
    var ns = "http://www.w3.org/1999/xhtml";
    var container = document.createElementNS(ns, '_');
    var elemProto = (window.HTMLElement || window.Element).prototype;
    var xmlSerializer = new XMLSerializer();
    var html;
    if (document.xmlVersion) {
      return xmlSerializer.serializeToString(element);
    } else {
      container.appendChild(element.cloneNode(false));
      html = container.innerHTML.replace('><', '>' + element.innerHTML + '<');
      container.innerHTML = '';
      return html;
    }
  };

  // Returns true if object is a DOM element.
  var isDOMElement = function (object) {
    if (typeof HTMLElement === 'object') {
      return object instanceof HTMLElement;
    } else {
      return object &&
        typeof object === 'object' &&
        object.nodeType === 1 &&
        typeof object.nodeName === 'string';
    }
  };

  /**
   * Inspects an object.
   *
   * @see taken from node.js `util` module (copyright Joyent, MIT license)
   * @api private
   */

  function i (obj, showHidden, depth) {
    var seen = [];

    function stylize (str) {
      return str;
    };

    function format (value, recurseTimes) {
      // Provide a hook for user-specified inspect functions.
      // Check that value is an object with an inspect function on it
      if (value && typeof value.inspect === 'function' &&
          // Filter out the util module, it's inspect function is special
          value !== exports &&
          // Also filter out any prototype objects using the circular check.
          !(value.constructor && value.constructor.prototype === value)) {
        return value.inspect(recurseTimes);
      }

      // Primitive types cannot have properties
      switch (typeof value) {
        case 'undefined':
          return stylize('undefined', 'undefined');

        case 'string':
          var simple = '\'' + json.stringify(value).replace(/^"|"$/g, '')
                                                   .replace(/'/g, "\\'")
                                                   .replace(/\\"/g, '"') + '\'';
          return stylize(simple, 'string');

        case 'number':
          return stylize('' + value, 'number');

        case 'boolean':
          return stylize('' + value, 'boolean');
      }
      // For some reason typeof null is "object", so special case here.
      if (value === null) {
        return stylize('null', 'null');
      }

      if (isDOMElement(value)) {
        return getOuterHTML(value);
      }

      // Look up the keys of the object.
      var visible_keys = keys(value);
      var $keys = showHidden ? Object.getOwnPropertyNames(value) : visible_keys;

      // Functions without properties can be shortcutted.
      if (typeof value === 'function' && $keys.length === 0) {
        if (isRegExp(value)) {
          return stylize('' + value, 'regexp');
        } else {
          var name = value.name ? ': ' + value.name : '';
          return stylize('[Function' + name + ']', 'special');
        }
      }

      // Dates without properties can be shortcutted
      if (isDate(value) && $keys.length === 0) {
        return stylize(value.toUTCString(), 'date');
      }

      var base, type, braces;
      // Determine the object type
      if (isArray(value)) {
        type = 'Array';
        braces = ['[', ']'];
      } else {
        type = 'Object';
        braces = ['{', '}'];
      }

      // Make functions say that they are functions
      if (typeof value === 'function') {
        var n = value.name ? ': ' + value.name : '';
        base = (isRegExp(value)) ? ' ' + value : ' [Function' + n + ']';
      } else {
        base = '';
      }

      // Make dates with properties first say the date
      if (isDate(value)) {
        base = ' ' + value.toUTCString();
      }

      if ($keys.length === 0) {
        return braces[0] + base + braces[1];
      }

      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return stylize('' + value, 'regexp');
        } else {
          return stylize('[Object]', 'special');
        }
      }

      seen.push(value);

      var output = map($keys, function (key) {
        var name, str;
        if (value.__lookupGetter__) {
          if (value.__lookupGetter__(key)) {
            if (value.__lookupSetter__(key)) {
              str = stylize('[Getter/Setter]', 'special');
            } else {
              str = stylize('[Getter]', 'special');
            }
          } else {
            if (value.__lookupSetter__(key)) {
              str = stylize('[Setter]', 'special');
            }
          }
        }
        if (indexOf(visible_keys, key) < 0) {
          name = '[' + key + ']';
        }
        if (!str) {
          if (indexOf(seen, value[key]) < 0) {
            if (recurseTimes === null) {
              str = format(value[key]);
            } else {
              str = format(value[key], recurseTimes - 1);
            }
            if (str.indexOf('\n') > -1) {
              if (isArray(value)) {
                str = map(str.split('\n'), function (line) {
                  return '  ' + line;
                }).join('\n').substr(2);
              } else {
                str = '\n' + map(str.split('\n'), function (line) {
                  return '   ' + line;
                }).join('\n');
              }
            }
          } else {
            str = stylize('[Circular]', 'special');
          }
        }
        if (typeof name === 'undefined') {
          if (type === 'Array' && key.match(/^\d+$/)) {
            return str;
          }
          name = json.stringify('' + key);
          if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
            name = name.substr(1, name.length - 2);
            name = stylize(name, 'name');
          } else {
            name = name.replace(/'/g, "\\'")
                       .replace(/\\"/g, '"')
                       .replace(/(^"|"$)/g, "'");
            name = stylize(name, 'string');
          }
        }

        return name + ': ' + str;
      });

      seen.pop();

      var numLinesEst = 0;
      var length = reduce(output, function (prev, cur) {
        numLinesEst++;
        if (indexOf(cur, '\n') >= 0) numLinesEst++;
        return prev + cur.length + 1;
      }, 0);

      if (length > 50) {
        output = braces[0] +
                 (base === '' ? '' : base + '\n ') +
                 ' ' +
                 output.join(',\n  ') +
                 ' ' +
                 braces[1];

      } else {
        output = braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
      }

      return output;
    }
    return format(obj, (typeof depth === 'undefined' ? 2 : depth));
  };

  function isArray (ar) {
    return Object.prototype.toString.call(ar) == '[object Array]';
  };

  function isRegExp(re) {
    var s;
    try {
      s = '' + re;
    } catch (e) {
      return false;
    }

    return re instanceof RegExp || // easy case
           // duck-type for context-switching evalcx case
           typeof(re) === 'function' &&
           re.constructor.name === 'RegExp' &&
           re.compile &&
           re.test &&
           re.exec &&
           s.match(/^\/.*\/[gim]{0,3}$/);
  };

  function isDate(d) {
    if (d instanceof Date) return true;
    return false;
  };

  function keys (obj) {
    if (Object.keys) {
      return Object.keys(obj);
    }

    var keys = [];

    for (var i in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, i)) {
        keys.push(i);
      }
    }

    return keys;
  }

  function map (arr, mapper, that) {
    if (Array.prototype.map) {
      return Array.prototype.map.call(arr, mapper, that);
    }

    var other= new Array(arr.length);

    for (var i= 0, n = arr.length; i<n; i++)
      if (i in arr)
        other[i] = mapper.call(that, arr[i], i, arr);

    return other;
  };

  function reduce (arr, fun) {
    if (Array.prototype.reduce) {
      return Array.prototype.reduce.apply(
          arr
        , Array.prototype.slice.call(arguments, 1)
      );
    }

    var len = +this.length;

    if (typeof fun !== "function")
      throw new TypeError();

    // no value to return if no initial value and an empty array
    if (len === 0 && arguments.length === 1)
      throw new TypeError();

    var i = 0;
    if (arguments.length >= 2) {
      var rv = arguments[1];
    } else {
      do {
        if (i in this) {
          rv = this[i++];
          break;
        }

        // if array contains no values, no initial value to return
        if (++i >= len)
          throw new TypeError();
      } while (true);
    }

    for (; i < len; i++) {
      if (i in this)
        rv = fun.call(null, rv, this[i], i, this);
    }

    return rv;
  };

  /**
   * Asserts deep equality
   *
   * @see taken from node.js `assert` module (copyright Joyent, MIT license)
   * @api private
   */

  expect.eql = function eql (actual, expected) {
    // 7.1. All identical values are equivalent, as determined by ===.
    if (actual === expected) {
      return true;
    } else if ('undefined' != typeof Buffer
        && Buffer.isBuffer(actual) && Buffer.isBuffer(expected)) {
      if (actual.length != expected.length) return false;

      for (var i = 0; i < actual.length; i++) {
        if (actual[i] !== expected[i]) return false;
      }

      return true;

    // 7.2. If the expected value is a Date object, the actual value is
    // equivalent if it is also a Date object that refers to the same time.
    } else if (actual instanceof Date && expected instanceof Date) {
      return actual.getTime() === expected.getTime();

    // 7.3. Other pairs that do not both pass typeof value == "object",
    // equivalence is determined by ==.
    } else if (typeof actual != 'object' && typeof expected != 'object') {
      return actual == expected;

    // 7.4. For all other Object pairs, including Array objects, equivalence is
    // determined by having the same number of owned properties (as verified
    // with Object.prototype.hasOwnProperty.call), the same set of keys
    // (although not necessarily the same order), equivalent values for every
    // corresponding key, and an identical "prototype" property. Note: this
    // accounts for both named and indexed properties on Arrays.
    } else {
      return objEquiv(actual, expected);
    }
  }

  function isUndefinedOrNull (value) {
    return value === null || value === undefined;
  }

  function isArguments (object) {
    return Object.prototype.toString.call(object) == '[object Arguments]';
  }

  function objEquiv (a, b) {
    if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
      return false;
    // an identical "prototype" property.
    if (a.prototype !== b.prototype) return false;
    //~~~I've managed to break Object.keys through screwy arguments passing.
    //   Converting to array solves the problem.
    if (isArguments(a)) {
      if (!isArguments(b)) {
        return false;
      }
      a = pSlice.call(a);
      b = pSlice.call(b);
      return expect.eql(a, b);
    }
    try{
      var ka = keys(a),
        kb = keys(b),
        key, i;
    } catch (e) {//happens when one is a string literal and the other isn't
      return false;
    }
    // having the same number of owned properties (keys incorporates hasOwnProperty)
    if (ka.length != kb.length)
      return false;
    //the same set of keys (although not necessarily the same order),
    ka.sort();
    kb.sort();
    //~~~cheap key test
    for (i = ka.length - 1; i >= 0; i--) {
      if (ka[i] != kb[i])
        return false;
    }
    //equivalent values for every corresponding key, and
    //~~~possibly expensive deep test
    for (i = ka.length - 1; i >= 0; i--) {
      key = ka[i];
      if (!expect.eql(a[key], b[key]))
         return false;
    }
    return true;
  }

  var json = (function () {
    "use strict";

    if ('object' == typeof JSON && JSON.parse && JSON.stringify) {
      return {
          parse: nativeJSON.parse
        , stringify: nativeJSON.stringify
      }
    }

    var JSON = {};

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10 ? '0' + n : n;
    }

    function date(d, key) {
      return isFinite(d.valueOf()) ?
          d.getUTCFullYear()     + '-' +
          f(d.getUTCMonth() + 1) + '-' +
          f(d.getUTCDate())      + 'T' +
          f(d.getUTCHours())     + ':' +
          f(d.getUTCMinutes())   + ':' +
          f(d.getUTCSeconds())   + 'Z' : null;
    };

    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,
        indent,
        meta = {    // table of character substitutions
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '\\': '\\\\'
        },
        rep;


    function quote(string) {

  // If the string contains no control characters, no quote characters, and no
  // backslash characters, then we can safely slap some quotes around it.
  // Otherwise we must also replace the offending characters with safe escape
  // sequences.

        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
            var c = meta[a];
            return typeof c === 'string' ? c :
                '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }


    function str(key, holder) {

  // Produce a string from holder[key].

        var i,          // The loop counter.
            k,          // The member key.
            v,          // The member value.
            length,
            mind = gap,
            partial,
            value = holder[key];

  // If the value has a toJSON method, call it to obtain a replacement value.

        if (value instanceof Date) {
            value = date(key);
        }

  // If we were called with a replacer function, then call the replacer to
  // obtain a replacement value.

        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }

  // What happens next depends on the value's type.

        switch (typeof value) {
        case 'string':
            return quote(value);

        case 'number':

  // JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value) ? String(value) : 'null';

        case 'boolean':
        case 'null':

  // If the value is a boolean or null, convert it to a string. Note:
  // typeof null does not produce 'null'. The case is included here in
  // the remote chance that this gets fixed someday.

            return String(value);

  // If the type is 'object', we might be dealing with an object or an array or
  // null.

        case 'object':

  // Due to a specification blunder in ECMAScript, typeof null is 'object',
  // so watch out for that case.

            if (!value) {
                return 'null';
            }

  // Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

  // Is the value an array?

            if (Object.prototype.toString.apply(value) === '[object Array]') {

  // The value is an array. Stringify every element. Use null as a placeholder
  // for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }

  // Join all of the elements together, separated with commas, and wrap them in
  // brackets.

                v = partial.length === 0 ? '[]' : gap ?
                    '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
                    '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }

  // If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    if (typeof rep[i] === 'string') {
                        k = rep[i];
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            } else {

  // Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }

  // Join all of the member texts together, separated with commas,
  // and wrap them in braces.

            v = partial.length === 0 ? '{}' : gap ?
                '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
                '{' + partial.join(',') + '}';
            gap = mind;
            return v;
        }
    }

  // If the JSON object does not yet have a stringify method, give it one.

    JSON.stringify = function (value, replacer, space) {

  // The stringify method takes a value and an optional replacer, and an optional
  // space parameter, and returns a JSON text. The replacer can be a function
  // that can replace values, or an array of strings that will select the keys.
  // A default replacer method can be provided. Use of the space parameter can
  // produce text that is more easily readable.

        var i;
        gap = '';
        indent = '';

  // If the space parameter is a number, make an indent string containing that
  // many spaces.

        if (typeof space === 'number') {
            for (i = 0; i < space; i += 1) {
                indent += ' ';
            }

  // If the space parameter is a string, it will be used as the indent string.

        } else if (typeof space === 'string') {
            indent = space;
        }

  // If there is a replacer, it must be a function or an array.
  // Otherwise, throw an error.

        rep = replacer;
        if (replacer && typeof replacer !== 'function' &&
                (typeof replacer !== 'object' ||
                typeof replacer.length !== 'number')) {
            throw new Error('JSON.stringify');
        }

  // Make a fake root object containing our value under the key of ''.
  // Return the result of stringifying the value.

        return str('', {'': value});
    };

  // If the JSON object does not yet have a parse method, give it one.

    JSON.parse = function (text, reviver) {
    // The parse method takes a text and an optional reviver function, and returns
    // a JavaScript value if the text is a valid JSON text.

        var j;

        function walk(holder, key) {

    // The walk method is used to recursively walk the resulting structure so
    // that modifications can be made.

            var k, v, value = holder[key];
            if (value && typeof value === 'object') {
                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = walk(value, k);
                        if (v !== undefined) {
                            value[k] = v;
                        } else {
                            delete value[k];
                        }
                    }
                }
            }
            return reviver.call(holder, key, value);
        }


    // Parsing happens in four stages. In the first stage, we replace certain
    // Unicode characters with escape sequences. JavaScript handles many characters
    // incorrectly, either silently deleting them, or treating them as line endings.

        text = String(text);
        cx.lastIndex = 0;
        if (cx.test(text)) {
            text = text.replace(cx, function (a) {
                return '\\u' +
                    ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
            });
        }

    // In the second stage, we run the text against regular expressions that look
    // for non-JSON patterns. We are especially concerned with '()' and 'new'
    // because they can cause invocation, and '=' because it can cause mutation.
    // But just to be safe, we want to reject all unexpected forms.

    // We split the second stage into 4 regexp operations in order to work around
    // crippling inefficiencies in IE's and Safari's regexp engines. First we
    // replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
    // replace all simple value tokens with ']' characters. Third, we delete all
    // open brackets that follow a colon or comma or that begin the text. Finally,
    // we look to see that the remaining characters are only whitespace or ']' or
    // ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

        if (/^[\],:{}\s]*$/
                .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
                    .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
                    .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

    // In the third stage we use the eval function to compile the text into a
    // JavaScript structure. The '{' operator is subject to a syntactic ambiguity
    // in JavaScript: it can begin a block or an object literal. We wrap the text
    // in parens to eliminate the ambiguity.

            j = eval('(' + text + ')');

    // In the optional fourth stage, we recursively walk the new structure, passing
    // each name/value pair to a reviver function for possible transformation.

            return typeof reviver === 'function' ?
                walk({'': j}, '') : j;
        }

    // If the text is not JSON parseable, then a SyntaxError is thrown.

        throw new SyntaxError('JSON.parse');
    };

    return JSON;
  })();

  if ('undefined' != typeof window) {
    window.expect = module.exports;
  }

})(
    this
  , 'undefined' != typeof module ? module : {}
  , 'undefined' != typeof exports ? exports : {}
);

})(require("__browserify_Buffer").Buffer)
},{"__browserify_Buffer":15}],11:[function(require,module,exports){
/* automatically generated by JSCoverage - do not edit */
if (typeof _$jscoverage === 'undefined') _$jscoverage = {};
if (! _$jscoverage['luc.js']) {
  _$jscoverage['luc.js'] = [];
  _$jscoverage['luc.js'][1] = 0;
  _$jscoverage['luc.js'][7] = 0;
  _$jscoverage['luc.js'][9] = 0;
  _$jscoverage['luc.js'][10] = 0;
  _$jscoverage['luc.js'][16] = 0;
  _$jscoverage['luc.js'][24] = 0;
  _$jscoverage['luc.js'][31] = 0;
  _$jscoverage['luc.js'][34] = 0;
  _$jscoverage['luc.js'][35] = 0;
  _$jscoverage['luc.js'][42] = 0;
  _$jscoverage['luc.js'][49] = 0;
  _$jscoverage['luc.js'][56] = 0;
  _$jscoverage['luc.js'][58] = 0;
  _$jscoverage['luc.js'][59] = 0;
  _$jscoverage['luc.js'][66] = 0;
  _$jscoverage['luc.js'][68] = 0;
  _$jscoverage['luc.js'][70] = 0;
  _$jscoverage['luc.js'][72] = 0;
  _$jscoverage['luc.js'][74] = 0;
  _$jscoverage['luc.js'][76] = 0;
  _$jscoverage['luc.js'][78] = 0;
  _$jscoverage['luc.js'][80] = 0;
  _$jscoverage['luc.js'][82] = 0;
  _$jscoverage['luc.js'][89] = 0;
  _$jscoverage['luc.js'][91] = 0;
  _$jscoverage['luc.js'][93] = 0;
  _$jscoverage['luc.js'][95] = 0;
  _$jscoverage['luc.js'][99] = 0;
  _$jscoverage['luc.js'][101] = 0;
  _$jscoverage['luc.js'][104] = 0;
  _$jscoverage['luc.js'][105] = 0;
}
_$jscoverage['luc.js'][1]++;
var Luc = {};
_$jscoverage['luc.js'][7]++;
module.exports = Luc;
_$jscoverage['luc.js'][9]++;
var object = require("./object");
_$jscoverage['luc.js'][10]++;
Luc.Object = object;
_$jscoverage['luc.js'][16]++;
Luc.O = object;
_$jscoverage['luc.js'][24]++;
Luc.apply = Luc.Object.apply;
_$jscoverage['luc.js'][31]++;
Luc.mix = Luc.Object.mix;
_$jscoverage['luc.js'][34]++;
var fun = require("./function");
_$jscoverage['luc.js'][35]++;
Luc.Function = fun;
_$jscoverage['luc.js'][42]++;
Luc.F = fun;
_$jscoverage['luc.js'][49]++;
Luc.emptyFn = Luc.Function.emptyFn;
_$jscoverage['luc.js'][56]++;
Luc.abstractFn = Luc.Function.abstractFn;
_$jscoverage['luc.js'][58]++;
var array = require("./array");
_$jscoverage['luc.js'][59]++;
Luc.Array = array;
_$jscoverage['luc.js'][66]++;
Luc.A = array;
_$jscoverage['luc.js'][68]++;
Luc.ArrayFnGenerator = require("./arrayFnGenerator");
_$jscoverage['luc.js'][70]++;
Luc.apply(Luc, require("./is"));
_$jscoverage['luc.js'][72]++;
var EventEmitter = require("./events/eventEmitter");
_$jscoverage['luc.js'][74]++;
Luc.EventEmitter = EventEmitter;
_$jscoverage['luc.js'][76]++;
var Base = require("./class/base");
_$jscoverage['luc.js'][78]++;
Luc.Base = Base;
_$jscoverage['luc.js'][80]++;
var Definer = require("./class/definer");
_$jscoverage['luc.js'][82]++;
Luc.ClassDefiner = Definer;
_$jscoverage['luc.js'][89]++;
Luc.define = Definer.define;
_$jscoverage['luc.js'][91]++;
Luc.Plugin = require("./class/plugin");
_$jscoverage['luc.js'][93]++;
Luc.PluginManager = require("./class/pluginManager");
_$jscoverage['luc.js'][95]++;
Luc.apply(Luc, {compositionEnums: require("./class/compositionEnums")});
_$jscoverage['luc.js'][99]++;
Luc.compare = require("./compare").compare;
_$jscoverage['luc.js'][101]++;
Luc.id = require("./id");
_$jscoverage['luc.js'][104]++;
if (typeof window !== "undefined") {
  _$jscoverage['luc.js'][105]++;
  window.Luc = Luc;
}
_$jscoverage['luc.js'].source = ["var Luc = {};","/**"," * @class Luc"," * Aliases for common Luc methods and packages.  Check out Luc.define"," * to look at the class system Luc provides."," */","module.exports = Luc;","","var object = require('./object');","Luc.Object = object;","/**"," * @member Luc"," * @property O Luc.O"," * Alias for Luc.Object"," */","Luc.O = object;","","","/**"," * @member Luc"," * @method apply"," * @inheritdoc Luc.Object#apply"," */","Luc.apply = Luc.Object.apply;","","/**"," * @member Luc"," * @method mix"," * @inheritdoc Luc.Object#mix"," */","Luc.mix = Luc.Object.mix;","","","var fun = require('./function');","Luc.Function = fun;","","/**"," * @member Luc"," * @property F Luc.F"," * Alias for Luc.Function"," */","Luc.F = fun;","","/**"," * @member Luc"," * @method emptyFn"," * @inheritdoc Luc.Function#emptyFn"," */","Luc.emptyFn = Luc.Function.emptyFn;","","/**"," * @member Luc"," * @method abstractFn"," * @inheritdoc Luc.Function#abstractFn"," */","Luc.abstractFn = Luc.Function.abstractFn;","","var array = require('./array');","Luc.Array = array;","","/**"," * @member Luc"," * @property A Luc.A"," * Alias for Luc.Array"," */","Luc.A = array;","","Luc.ArrayFnGenerator = require('./arrayFnGenerator');","","Luc.apply(Luc, require('./is'));","","var EventEmitter = require('./events/eventEmitter');","","Luc.EventEmitter = EventEmitter;","","var Base = require('./class/base');","","Luc.Base = Base;","","var Definer = require('./class/definer');","","Luc.ClassDefiner = Definer;","","/**"," * @member Luc"," * @method define"," * @inheritdoc Luc.define#define"," */","Luc.define = Definer.define;","","Luc.Plugin = require('./class/plugin');","","Luc.PluginManager = require('./class/pluginManager');","","Luc.apply(Luc, {","    compositionEnums: require('./class/compositionEnums')","});","","Luc.compare = require('./compare').compare;","","Luc.id = require('./id');","","","if(typeof window !== 'undefined') {","    window.Luc = Luc;","}"];

},{"./function":16,"./object":17,"./array":18,"./is":19,"./arrayFnGenerator":20,"./events/eventEmitter":21,"./class/base":22,"./class/plugin":23,"./class/definer":24,"./class/pluginManager":25,"./class/compositionEnums":26,"./compare":27,"./id":28}],14:[function(require,module,exports){
var Luc = require('./lucTestLib'),
    expect = require('expect.js');

exports.testEmitter = function(emitter) {

    var i = '';
    emitter.on('aaa', function(v) {
        i += v;
    });
    emitter.emit('aaa', 'a');
    emitter.emit('aaa', 'b');
    emitter.emit('aaa', 'c');
    expect(i).to.be('abc');
    i = "";

    emitter.once('bbb', function(v) {
        i += v;
    });

    emitter.emit('bbb', 'a');
    emitter.emit('bbb', 'b');
    emitter.emit('bbb', 'c');
    expect(i).to.be('a');
}
},{"./lucTestLib":10,"expect.js":13}],17:[function(require,module,exports){
/* automatically generated by JSCoverage - do not edit */
if (typeof _$jscoverage === 'undefined') _$jscoverage = {};
if (! _$jscoverage['object.js']) {
  _$jscoverage['object.js'] = [];
  _$jscoverage['object.js'][36] = 0;
  _$jscoverage['object.js'][37] = 0;
  _$jscoverage['object.js'][41] = 0;
  _$jscoverage['object.js'][42] = 0;
  _$jscoverage['object.js'][43] = 0;
  _$jscoverage['object.js'][47] = 0;
  _$jscoverage['object.js'][70] = 0;
  _$jscoverage['object.js'][71] = 0;
  _$jscoverage['object.js'][75] = 0;
  _$jscoverage['object.js'][76] = 0;
  _$jscoverage['object.js'][77] = 0;
  _$jscoverage['object.js'][81] = 0;
  _$jscoverage['object.js'][106] = 0;
  _$jscoverage['object.js'][107] = 0;
  _$jscoverage['object.js'][110] = 0;
  _$jscoverage['object.js'][111] = 0;
  _$jscoverage['object.js'][112] = 0;
  _$jscoverage['object.js'][115] = 0;
  _$jscoverage['object.js'][116] = 0;
  _$jscoverage['object.js'][117] = 0;
  _$jscoverage['object.js'][158] = 0;
  _$jscoverage['object.js'][159] = 0;
  _$jscoverage['object.js'][162] = 0;
  _$jscoverage['object.js'][163] = 0;
  _$jscoverage['object.js'][166] = 0;
  _$jscoverage['object.js'][214] = 0;
  _$jscoverage['object.js'][215] = 0;
  _$jscoverage['object.js'][218] = 0;
  _$jscoverage['object.js'][219] = 0;
  _$jscoverage['object.js'][220] = 0;
  _$jscoverage['object.js'][221] = 0;
  _$jscoverage['object.js'][222] = 0;
  _$jscoverage['object.js'][223] = 0;
  _$jscoverage['object.js'][225] = 0;
  _$jscoverage['object.js'][233] = 0;
}
_$jscoverage['object.js'][36]++;
exports.apply = (function (toObject, fromObject) {
  _$jscoverage['object.js'][37]++;
  var to = toObject || {}, from = fromObject || {}, prop;
  _$jscoverage['object.js'][41]++;
  for (prop in from) {
    _$jscoverage['object.js'][42]++;
    if (from.hasOwnProperty(prop)) {
      _$jscoverage['object.js'][43]++;
      to[prop] = from[prop];
    }
}
  _$jscoverage['object.js'][47]++;
  return to;
});
_$jscoverage['object.js'][70]++;
exports.mix = (function (toObject, fromObject) {
  _$jscoverage['object.js'][71]++;
  var to = toObject || {}, from = fromObject || {}, prop;
  _$jscoverage['object.js'][75]++;
  for (prop in from) {
    _$jscoverage['object.js'][76]++;
    if (from.hasOwnProperty(prop) && to[prop] === undefined) {
      _$jscoverage['object.js'][77]++;
      to[prop] = from[prop];
    }
}
  _$jscoverage['object.js'][81]++;
  return to;
});
_$jscoverage['object.js'][106]++;
exports.each = (function (obj, fn, thisArg, config) {
  _$jscoverage['object.js'][107]++;
  var key, value, allProperties = config && config.ownProperties === false;
  _$jscoverage['object.js'][110]++;
  if (allProperties) {
    _$jscoverage['object.js'][111]++;
    for (key in obj) {
      _$jscoverage['object.js'][112]++;
      fn.call(thisArg, key, obj[key]);
}
  }
  else {
    _$jscoverage['object.js'][115]++;
    for (key in obj) {
      _$jscoverage['object.js'][116]++;
      if (obj.hasOwnProperty(key)) {
        _$jscoverage['object.js'][117]++;
        fn.call(thisArg, key, obj[key]);
      }
}
  }
});
_$jscoverage['object.js'][158]++;
exports.toObject = (function (strings, values) {
  _$jscoverage['object.js'][159]++;
  var obj = {}, i = 0, len = strings.length;
  _$jscoverage['object.js'][162]++;
  for (; i < len; ++i) {
    _$jscoverage['object.js'][163]++;
    obj[strings[i]] = values[i];
}
  _$jscoverage['object.js'][166]++;
  return obj;
});
_$jscoverage['object.js'][214]++;
exports.filter = (function (obj, filterFn, thisArg, c) {
  _$jscoverage['object.js'][215]++;
  var values = [], config = c || {};
  _$jscoverage['object.js'][218]++;
  exports.each(obj, (function (key, value) {
  _$jscoverage['object.js'][219]++;
  if (filterFn.call(thisArg, key, value)) {
    _$jscoverage['object.js'][220]++;
    if (config.keys === true) {
      _$jscoverage['object.js'][221]++;
      values.push(key);
    }
    else {
      _$jscoverage['object.js'][222]++;
      if (config.values === true) {
        _$jscoverage['object.js'][223]++;
        values.push(value);
      }
      else {
        _$jscoverage['object.js'][225]++;
        values.push({value: value, key: key});
      }
    }
  }
}), thisArg, config);
  _$jscoverage['object.js'][233]++;
  return values;
});
_$jscoverage['object.js'].source = ["/**"," * @class Luc.Object"," * Package for Object methods.  Luc.Object.apply and Luc.Object.each"," * are used very often.  mix and apply are aliased to Luc.apply and Luc.mix."," */","","/**"," * Apply the properties from fromObject to the toObject.  fromObject will"," * overwrite any shared keys.  It can also be used as a simple shallow clone."," * ","    var to = {a:1, c:1}, from = {a:2, b:2}","    Luc.Object.apply(to, from)","    &gt;Object {a: 2, c: 1, b: 2}","    to === to","    &gt;true","    var clone = Luc.Object.apply({}, from)","    &gt;undefined","    clone","    &gt;Object {a: 2, b: 2}","    clone === from","    &gt;false"," *"," * No null checks are needed.","    ","    Luc.apply(undefined, {a:1})","    &gt;{a:1}","    Luc.apply({a: 1})","    &gt;{a:1}",""," *"," * "," * @param  {Object} [toObject] Object to put the properties fromObject on."," * @param  {Object} [fromObject] Object to put the properties on the toObject"," * @return {Object} the toObject"," */","exports.apply = function(toObject, fromObject) {","    var to = toObject || {},","        from = fromObject || {},","        prop;","","    for (prop in from) {","        if (from.hasOwnProperty(prop)) {","            to[prop] = from[prop];","        }","    }","","    return to;","};","","/**"," * Similar to Luc.Object.apply except that the fromObject will "," * NOT overwrite the keys of the toObject if they are defined."," *","    Luc.mix({a:1,b:2}, {a:3,b:4,c:5})","    &gt;{a: 1, b: 2, c: 5}",""," * No null checks are needed.","    ","    Luc.mix(undefined, {a:1})","    &gt;{a:1}","    Luc.mix({a: 1})","    &gt;{a:1}","    "," *",""," * @param  {Object} [toObject] Object to put the properties fromObject on."," * @param  {Object} [fromObject] fromObject Object to put the properties on the toObject"," * @return {Object} the toObject"," */","exports.mix = function(toObject, fromObject) {","    var to = toObject || {},","        from = fromObject || {},","        prop;","","    for (prop in from) {","        if (from.hasOwnProperty(prop) &amp;&amp; to[prop] === undefined) {","            to[prop] = from[prop];","        }","    }","","    return to;","};","","/**"," * Iterate over an objects properties"," * as key value \"pairs\" with the passed in function."," * ","    var thisArg = {val:'c'};","    Luc.Object.each({","        u: 'L'","    }, function(key, value) {","        console.log(value + key + this.val)","    }, thisArg)","    ","    &gt;Luc "," "," * @param  {Object}   obj  the object to iterate over"," * @param  {Function} fn   the function to call"," * @param  {String} fn.key   the object key"," * @param  {Object} fn.value   the object value"," * @param  {Object}   [thisArg] "," * @param {Object}  [config]"," * @param {Boolean}  config.ownProperties set to false"," * to iterate over all of the objects enumerable properties."," */","exports.each = function(obj, fn, thisArg, config) {","    var key, value,","        allProperties = config &amp;&amp; config.ownProperties === false;","","    if (allProperties) {","        for (key in obj) {","            fn.call(thisArg, key, obj[key]);","        }","    } else {","        for (key in obj) {","            if (obj.hasOwnProperty(key)) {","                fn.call(thisArg, key, obj[key]);","            }","        }","    }","};","","/**"," * Take an array of strings and an array/arguments of"," * values and return an object of key value pairs"," * based off each arrays index.  It is useful for taking"," * a long list of arguments and creating an object that can"," * be passed to other methods."," * ","    function longArgs(a,b,c,d,e,f) {","        return Luc.Object.toObject(['a','b', 'c', 'd', 'e', 'f'], arguments)","    }","","    longArgs(1,2,3,4,5,6,7,8,9)","","    &gt;Object {a: 1, b: 2, c: 3, d: 4, e: 5&#226;&#128;&#166;}","    a: 1","    b: 2","    c: 3","    d: 4","    e: 5","    f: 6","","    longArgs(1,2,3)","","    &gt;Object {a: 1, b: 2, c: 3, d: undefined, e: undefined&#226;&#128;&#166;}","    a: 1","    b: 2","    c: 3","    d: undefined","    e: undefined","    f: undefined",""," * @param  {String[]} strings"," * @param  {Array/arguments} values"," * @return {Object}"," */","exports.toObject = function(strings, values) {","    var obj = {},","        i = 0,","        len = strings.length;","    for (; i &lt; len; ++i) {","        obj[strings[i]] = values[i];","    }","","    return obj;","};","","/**"," * Return key value pairs from the object if the"," * filterFn returns a truthy value."," *","    Luc.Object.filter({","        a: false,","        b: true,","        c: false","    }, function(key, value) {","        return key === 'a' || value","    })","    &gt;[{key: 'a', value: false}, {key: 'b', value: true}]","","    Luc.Object.filter({","        a: false,","        b: true,","        c: false","    }, function(key, value) {","        return key === 'a' || value","    }, undefined, {","        keys: true","    })","    &gt;['a', 'b']"," * "," * @param  {Object}   obj  the object to iterate over"," * @param  {Function} filterFn   the function to call, return a truthy value"," * to add the key value pair"," * @param  {String} filterFn.key   the object key"," * @param  {Object} filterFn.value   the object value"," * @param  {Object}   [thisArg] "," * @param {Object}  [config]"," * @param {Boolean}  config.ownProperties set to false"," * to iterate over all of the objects enumerable properties."," * "," * @param {Boolean}  config.keys set to true to return"," * just the keys."," *"," * @param {Boolean}  config.values set to true to return"," * just the values."," * "," * @return {Object[]/String[]} Array of key value pairs in the form"," * of {key: 'key', value: value}.  If keys or values is true on the config"," * just the keys or values are returned."," *"," */","exports.filter = function(obj, filterFn, thisArg, c) {","    var values = [],","        config = c || {};","","    exports.each(obj, function(key, value) {","        if (filterFn.call(thisArg, key, value)) {","            if (config.keys === true) {","                values.push(key);","            } else if (config.values === true) {","                values.push(value);","            } else {","                values.push({","                    value: value,","                    key: key","                });","            }","        }","    }, thisArg, config);","","    return values;","};"];

},{}],19:[function(require,module,exports){
/* automatically generated by JSCoverage - do not edit */
if (typeof _$jscoverage === 'undefined') _$jscoverage = {};
if (! _$jscoverage['is.js']) {
  _$jscoverage['is.js'] = [];
  _$jscoverage['is.js'][1] = 0;
  _$jscoverage['is.js'][11] = 0;
  _$jscoverage['is.js'][12] = 0;
  _$jscoverage['is.js'][22] = 0;
  _$jscoverage['is.js'][23] = 0;
  _$jscoverage['is.js'][33] = 0;
  _$jscoverage['is.js'][34] = 0;
  _$jscoverage['is.js'][44] = 0;
  _$jscoverage['is.js'][45] = 0;
  _$jscoverage['is.js'][55] = 0;
  _$jscoverage['is.js'][56] = 0;
  _$jscoverage['is.js'][66] = 0;
  _$jscoverage['is.js'][67] = 0;
  _$jscoverage['is.js'][77] = 0;
  _$jscoverage['is.js'][78] = 0;
  _$jscoverage['is.js'][89] = 0;
  _$jscoverage['is.js'][90] = 0;
  _$jscoverage['is.js'][101] = 0;
  _$jscoverage['is.js'][102] = 0;
  _$jscoverage['is.js'][113] = 0;
  _$jscoverage['is.js'][114] = 0;
  _$jscoverage['is.js'][116] = 0;
  _$jscoverage['is.js'][117] = 0;
  _$jscoverage['is.js'][118] = 0;
  _$jscoverage['is.js'][119] = 0;
  _$jscoverage['is.js'][120] = 0;
  _$jscoverage['is.js'][121] = 0;
  _$jscoverage['is.js'][124] = 0;
  _$jscoverage['is.js'][127] = 0;
}
_$jscoverage['is.js'][1]++;
var oToString = Object.prototype.toString;
_$jscoverage['is.js'][11]++;
function isArray(obj) {
  _$jscoverage['is.js'][12]++;
  return Array.isArray(obj);
}
_$jscoverage['is.js'][22]++;
function isObject(obj) {
  _$jscoverage['is.js'][23]++;
  return obj && oToString.call(obj) === "[object Object]";
}
_$jscoverage['is.js'][33]++;
function isFunction(obj) {
  _$jscoverage['is.js'][34]++;
  return oToString.call(obj) === "[object Function]";
}
_$jscoverage['is.js'][44]++;
function isDate(obj) {
  _$jscoverage['is.js'][45]++;
  return oToString.call(obj) === "[object Date]";
}
_$jscoverage['is.js'][55]++;
function isRegExp(obj) {
  _$jscoverage['is.js'][56]++;
  return oToString.call(obj) === "[object RegExp]";
}
_$jscoverage['is.js'][66]++;
function isNumber(obj) {
  _$jscoverage['is.js'][67]++;
  return oToString.call(obj) === "[object Number]";
}
_$jscoverage['is.js'][77]++;
function isString(obj) {
  _$jscoverage['is.js'][78]++;
  return oToString.call(obj) === "[object String]";
}
_$jscoverage['is.js'][89]++;
function isArguments(obj) {
  _$jscoverage['is.js'][90]++;
  return oToString.call(obj) === "[object Arguments]" || obj && ! ! obj.callee;
}
_$jscoverage['is.js'][101]++;
function isFalsy(obj) {
  _$jscoverage['is.js'][102]++;
  return (! obj && obj !== 0);
}
_$jscoverage['is.js'][113]++;
function isEmpty(obj) {
  _$jscoverage['is.js'][114]++;
  var empty = false;
  _$jscoverage['is.js'][116]++;
  if (isFalsy(obj)) {
    _$jscoverage['is.js'][117]++;
    empty = true;
  }
  else {
    _$jscoverage['is.js'][118]++;
    if (isArray(obj)) {
      _$jscoverage['is.js'][119]++;
      empty = obj.length === 0;
    }
    else {
      _$jscoverage['is.js'][120]++;
      if (isObject(obj)) {
        _$jscoverage['is.js'][121]++;
        empty = Object.keys(obj).length === 0;
      }
    }
  }
  _$jscoverage['is.js'][124]++;
  return empty;
}
_$jscoverage['is.js'][127]++;
module.exports = {isArray: isArray, isObject: isObject, isFunction: isFunction, isDate: isDate, isString: isString, isNumber: isNumber, isRegExp: isRegExp, isArguments: isArguments, isFalsy: isFalsy, isEmpty: isEmpty};
_$jscoverage['is.js'].source = ["var oToString = Object.prototype.toString;","","","/**"," * @member Luc"," * Return true if the passed in object is of"," * the type {@link Array Array}"," * @param  {Object}  obj "," * @return {Boolean}"," */","function isArray(obj) {","    return Array.isArray(obj);","}","","/**"," * @member Luc"," * Return true if the passed in object is of"," * the type {@link Object Object}"," * @param  {Object}  obj "," * @return {Boolean}"," */","function isObject(obj) {","    return obj &amp;&amp; oToString.call(obj) === '[object Object]';","}","","/**"," * @member Luc"," * Return true if the passed in object is of"," * the type {@link Function Function}"," * @param  {Object}  obj "," * @return {Boolean}"," */","function isFunction(obj) {","    return oToString.call(obj) === '[object Function]';","}","","/**"," * @member Luc"," * Return true if the passed in object is of"," * the type {@link Date Date}"," * @param  {Object}  obj "," * @return {Boolean}"," */","function isDate(obj) {","    return oToString.call(obj) === '[object Date]';","}","","/**"," * @member Luc"," * Return true if the passed in object is of"," * the type {@link RegExp RegExp}"," * @param  {Object}  obj "," * @return {Boolean}"," */","function isRegExp(obj) {","    return oToString.call(obj) === '[object RegExp]';","}","","/**"," * @member Luc"," * Return true if the passed in object is of"," * the type {@link Number Number}"," * @param  {Object}  obj "," * @return {Boolean}"," */","function isNumber(obj) {","    return oToString.call(obj) === '[object Number]';","}","","/**"," * @member Luc"," * Return true if the passed in object is of"," * the type {@link String String}"," * @param  {Object}  obj "," * @return {Boolean}"," */","function isString(obj) {","    return oToString.call(obj) === '[object String]';","}","","/**"," * @member Luc"," * Return true if the passed in object is of"," * the type arguments."," * "," * @param  {Object}  obj "," * @return {Boolean}"," */","function isArguments(obj) {","    return oToString.call(obj) === '[object Arguments]' || obj &amp;&amp; !!obj.callee;","}","","/**"," * @member Luc"," * Return true if the object is falsy but not zero.  If"," * you want falsy check that includes zero use a goram "," * if statement :)"," * @param  {Object}  obj"," * @return {Boolean}     "," */","function isFalsy(obj) {","    return (!obj &amp;&amp; obj !== 0);","}","","/**"," * @member Luc"," * Return true if the object is empty."," * {}, [], '',false, null, undefined, NaN "," * Are all treated as empty."," * @param  {Object}  obj"," * @return {Boolean}"," */","function isEmpty(obj) {","    var empty = false;","","    if (isFalsy(obj)) {","        empty = true;","    } else if (isArray(obj)) {","        empty = obj.length === 0;","    } else if (isObject(obj)) {","        empty = Object.keys(obj).length === 0;","    }","","    return empty;","}","","module.exports = {","    isArray: isArray,","    isObject: isObject,","    isFunction: isFunction,","    isDate: isDate,","    isString: isString,","    isNumber: isNumber,","    isRegExp: isRegExp,","    isArguments: isArguments,","    isFalsy: isFalsy,","    isEmpty: isEmpty","};"];

},{}],28:[function(require,module,exports){
/* automatically generated by JSCoverage - do not edit */
if (typeof _$jscoverage === 'undefined') _$jscoverage = {};
if (! _$jscoverage['id.js']) {
  _$jscoverage['id.js'] = [];
  _$jscoverage['id.js'][1] = 0;
  _$jscoverage['id.js'][22] = 0;
  _$jscoverage['id.js'][23] = 0;
  _$jscoverage['id.js'][25] = 0;
  _$jscoverage['id.js'][26] = 0;
  _$jscoverage['id.js'][29] = 0;
}
_$jscoverage['id.js'][1]++;
var ids = {};
_$jscoverage['id.js'][22]++;
module.exports = (function (p) {
  _$jscoverage['id.js'][23]++;
  var prefix = p === undefined? "luc-": p;
  _$jscoverage['id.js'][25]++;
  if (ids[prefix] === undefined) {
    _$jscoverage['id.js'][26]++;
    ids[prefix] = 0;
  }
  _$jscoverage['id.js'][29]++;
  return prefix + ids[prefix]++;
});
_$jscoverage['id.js'].source = ["var ids = {};","/**"," * @member Luc"," * @method id"," * "," * Return a unique id."," * @param {String} [prefix] Optional prefix to use"," *"," *","        Luc.id()","        &gt;\"luc-0\"","        Luc.id()","        &gt;\"luc-1\"","        Luc.id('my-prefix')","        &gt;\"my-prefix0\"","        Luc.id('')","        &gt;\"0\""," *"," * @return {String}"," *"," */","module.exports = function(p) {","    var prefix = p === undefined ? 'luc-' : p;","","    if(ids[prefix] === undefined) {","        ids[prefix] = 0;","    }","","    return prefix + ids[prefix]++;","};"];

},{}],21:[function(require,module,exports){
/* automatically generated by JSCoverage - do not edit */
if (typeof _$jscoverage === 'undefined') _$jscoverage = {};
if (! _$jscoverage['events/eventEmitter.js']) {
  _$jscoverage['events/eventEmitter.js'] = [];
  _$jscoverage['events/eventEmitter.js'][1] = 0;
  _$jscoverage['events/eventEmitter.js'][13] = 0;
  _$jscoverage['events/eventEmitter.js'][15] = 0;
  _$jscoverage['events/eventEmitter.js'][17] = 0;
  _$jscoverage['events/eventEmitter.js'][18] = 0;
  _$jscoverage['events/eventEmitter.js'][21] = 0;
  _$jscoverage['events/eventEmitter.js'][23] = 0;
  _$jscoverage['events/eventEmitter.js'][26] = 0;
}
_$jscoverage['events/eventEmitter.js'][1]++;
var EventEmitter = require("events").EventEmitter;
_$jscoverage['events/eventEmitter.js'][13]++;
EventEmitter.prototype.once = (function (type, listener) {
  _$jscoverage['events/eventEmitter.js'][15]++;
  var self = this, g = (function () {
  _$jscoverage['events/eventEmitter.js'][17]++;
  self.removeListener(type, g);
  _$jscoverage['events/eventEmitter.js'][18]++;
  listener.apply(this, arguments);
});
  _$jscoverage['events/eventEmitter.js'][21]++;
  self.on(type, g);
  _$jscoverage['events/eventEmitter.js'][23]++;
  return this;
});
_$jscoverage['events/eventEmitter.js'][26]++;
module.exports = EventEmitter;
_$jscoverage['events/eventEmitter.js'].source = ["var EventEmitter = require('events').EventEmitter;","/**"," * @license https://raw.github.com/joyent/node/v0.10.11/LICENSE"," * Node js license. EventEmitter will be in the client"," * only code."," */","/**"," * @class Luc.EventEmitter"," * The wonderful event emmiter that comes with node,"," * that works in the supported browsers."," * [http://nodejs.org/api/events.html](http://nodejs.org/api/events.html)"," */","EventEmitter.prototype.once = function(type, listener) {","    //put in fix for IE 9 and below","    var self = this,","        g = function() {","            self.removeListener(type, g);","            listener.apply(this, arguments);","        };","","    self.on(type, g);","","    return this;","};","","module.exports = EventEmitter;"];

},{"events":29}],12:[function(require,module,exports){
/**
 * @license https://raw.github.com/kriskowal/es5-shim/master/LICENSE
 * es5-shim license
 */

if(typeof window !== 'undefined') {
    require('es5-shim-sham');
}

module.exports = require('./luc');
},{"./luc":30,"es5-shim-sham":31}],30:[function(require,module,exports){
var Luc = {};
/**
 * @class Luc
 * Aliases for common Luc methods and packages.  Check out Luc.define
 * to look at the class system Luc provides.
 */
module.exports = Luc;

var object = require('./object');
Luc.Object = object;
/**
 * @member Luc
 * @property O Luc.O
 * Alias for Luc.Object
 */
Luc.O = object;


/**
 * @member Luc
 * @method apply
 * @inheritdoc Luc.Object#apply
 */
Luc.apply = Luc.Object.apply;

/**
 * @member Luc
 * @method mix
 * @inheritdoc Luc.Object#mix
 */
Luc.mix = Luc.Object.mix;


var fun = require('./function');
Luc.Function = fun;

/**
 * @member Luc
 * @property F Luc.F
 * Alias for Luc.Function
 */
Luc.F = fun;

/**
 * @member Luc
 * @method emptyFn
 * @inheritdoc Luc.Function#emptyFn
 */
Luc.emptyFn = Luc.Function.emptyFn;

/**
 * @member Luc
 * @method abstractFn
 * @inheritdoc Luc.Function#abstractFn
 */
Luc.abstractFn = Luc.Function.abstractFn;

var array = require('./array');
Luc.Array = array;

/**
 * @member Luc
 * @property A Luc.A
 * Alias for Luc.Array
 */
Luc.A = array;

Luc.ArrayFnGenerator = require('./arrayFnGenerator');

Luc.apply(Luc, require('./is'));

var EventEmitter = require('./events/eventEmitter');

Luc.EventEmitter = EventEmitter;

var Base = require('./class/base');

Luc.Base = Base;

var Definer = require('./class/definer');

Luc.ClassDefiner = Definer;

/**
 * @member Luc
 * @method define
 * @inheritdoc Luc.define#define
 */
Luc.define = Definer.define;

Luc.Plugin = require('./class/plugin');

Luc.PluginManager = require('./class/pluginManager');

Luc.apply(Luc, {
    compositionEnums: require('./class/compositionEnums')
});

Luc.compare = require('./compare').compare;

Luc.id = require('./id');


if(typeof window !== 'undefined') {
    window.Luc = Luc;
}
},{"./object":32,"./function":33,"./array":34,"./arrayFnGenerator":35,"./is":36,"./events/eventEmitter":37,"./class/base":38,"./class/definer":39,"./class/plugin":40,"./class/pluginManager":41,"./class/compositionEnums":42,"./compare":43,"./id":44}],16:[function(require,module,exports){
/* automatically generated by JSCoverage - do not edit */
if (typeof _$jscoverage === 'undefined') _$jscoverage = {};
if (! _$jscoverage['function.js']) {
  _$jscoverage['function.js'] = [];
  _$jscoverage['function.js'][1] = 0;
  _$jscoverage['function.js'][3] = 0;
  _$jscoverage['function.js'][12] = 0;
  _$jscoverage['function.js'][13] = 0;
  _$jscoverage['function.js'][17] = 0;
  _$jscoverage['function.js'][18] = 0;
  _$jscoverage['function.js'][21] = 0;
  _$jscoverage['function.js'][22] = 0;
  _$jscoverage['function.js'][23] = 0;
  _$jscoverage['function.js'][25] = 0;
  _$jscoverage['function.js'][28] = 0;
  _$jscoverage['function.js'][35] = 0;
  _$jscoverage['function.js'][42] = 0;
  _$jscoverage['function.js'][43] = 0;
  _$jscoverage['function.js'][108] = 0;
  _$jscoverage['function.js'][109] = 0;
  _$jscoverage['function.js'][111] = 0;
  _$jscoverage['function.js'][112] = 0;
  _$jscoverage['function.js'][116] = 0;
  _$jscoverage['function.js'][117] = 0;
  _$jscoverage['function.js'][118] = 0;
  _$jscoverage['function.js'][119] = 0;
  _$jscoverage['function.js'][121] = 0;
  _$jscoverage['function.js'][122] = 0;
  _$jscoverage['function.js'][125] = 0;
  _$jscoverage['function.js'][128] = 0;
  _$jscoverage['function.js'][161] = 0;
  _$jscoverage['function.js'][162] = 0;
  _$jscoverage['function.js'][164] = 0;
  _$jscoverage['function.js'][165] = 0;
  _$jscoverage['function.js'][168] = 0;
  _$jscoverage['function.js'][169] = 0;
  _$jscoverage['function.js'][172] = 0;
  _$jscoverage['function.js'][214] = 0;
  _$jscoverage['function.js'][215] = 0;
  _$jscoverage['function.js'][217] = 0;
  _$jscoverage['function.js'][218] = 0;
  _$jscoverage['function.js'][221] = 0;
  _$jscoverage['function.js'][222] = 0;
  _$jscoverage['function.js'][224] = 0;
  _$jscoverage['function.js'][227] = 0;
  _$jscoverage['function.js'][258] = 0;
  _$jscoverage['function.js'][259] = 0;
  _$jscoverage['function.js'][261] = 0;
  _$jscoverage['function.js'][262] = 0;
  _$jscoverage['function.js'][265] = 0;
  _$jscoverage['function.js'][266] = 0;
  _$jscoverage['function.js'][267] = 0;
  _$jscoverage['function.js'][269] = 0;
  _$jscoverage['function.js'][273] = 0;
  _$jscoverage['function.js'][311] = 0;
  _$jscoverage['function.js'][312] = 0;
  _$jscoverage['function.js'][315] = 0;
  _$jscoverage['function.js'][316] = 0;
  _$jscoverage['function.js'][319] = 0;
  _$jscoverage['function.js'][320] = 0;
  _$jscoverage['function.js'][322] = 0;
  _$jscoverage['function.js'][323] = 0;
  _$jscoverage['function.js'][326] = 0;
  _$jscoverage['function.js'][327] = 0;
  _$jscoverage['function.js'][328] = 0;
  _$jscoverage['function.js'][346] = 0;
  _$jscoverage['function.js'][347] = 0;
  _$jscoverage['function.js'][349] = 0;
  _$jscoverage['function.js'][350] = 0;
  _$jscoverage['function.js'][353] = 0;
  _$jscoverage['function.js'][354] = 0;
  _$jscoverage['function.js'][356] = 0;
  _$jscoverage['function.js'][357] = 0;
}
_$jscoverage['function.js'][1]++;
var is = require("./is"), aInsert = require("./array").insert;
_$jscoverage['function.js'][3]++;
aEach = require("./array").each;
_$jscoverage['function.js'][12]++;
function _augmentArgs(config, callArgs) {
  _$jscoverage['function.js'][13]++;
  var configArgs = config.args, index = config.index, argsArray;
  _$jscoverage['function.js'][17]++;
  if (! configArgs) {
    _$jscoverage['function.js'][18]++;
    return callArgs;
  }
  _$jscoverage['function.js'][21]++;
  if (index === true || is.isNumber(index)) {
    _$jscoverage['function.js'][22]++;
    if (config.argumentsFirst === false) {
      _$jscoverage['function.js'][23]++;
      return aInsert(configArgs, callArgs, index);
    }
    _$jscoverage['function.js'][25]++;
    return aInsert(callArgs, configArgs, index);
  }
  _$jscoverage['function.js'][28]++;
  return configArgs;
}
_$jscoverage['function.js'][35]++;
exports.emptyFn = (function () {
});
_$jscoverage['function.js'][42]++;
exports.abstractFn = (function () {
  _$jscoverage['function.js'][43]++;
  throw new Error("abstractFn must be implemented");
});
_$jscoverage['function.js'][108]++;
exports.createAugmenter = (function (fn, config) {
  _$jscoverage['function.js'][109]++;
  var thisArg = config.thisArg;
  _$jscoverage['function.js'][111]++;
  return (function () {
  _$jscoverage['function.js'][112]++;
  return fn.apply(thisArg || this, _augmentArgs(config, arguments));
});
});
_$jscoverage['function.js'][116]++;
function _initSequenceFunctions(fns, config) {
  _$jscoverage['function.js'][117]++;
  var toRun = [];
  _$jscoverage['function.js'][118]++;
  aEach(fns, (function (f) {
  _$jscoverage['function.js'][119]++;
  var fn = f;
  _$jscoverage['function.js'][121]++;
  if (config) {
    _$jscoverage['function.js'][122]++;
    fn = exports.createAugmenter(f, config);
  }
  _$jscoverage['function.js'][125]++;
  toRun.push(fn);
}));
  _$jscoverage['function.js'][128]++;
  return toRun;
}
_$jscoverage['function.js'][161]++;
exports.createSequence = (function (fns, config) {
  _$jscoverage['function.js'][162]++;
  var functions = _initSequenceFunctions(fns, config);
  _$jscoverage['function.js'][164]++;
  return (function () {
  _$jscoverage['function.js'][165]++;
  var i = 0, len = functions.length;
  _$jscoverage['function.js'][168]++;
  for (; i < len - 1; ++i) {
    _$jscoverage['function.js'][169]++;
    functions[i].apply(this, arguments);
}
  _$jscoverage['function.js'][172]++;
  return functions[len - 1].apply(this, arguments);
});
});
_$jscoverage['function.js'][214]++;
exports.createSequenceIf = (function (fns, config) {
  _$jscoverage['function.js'][215]++;
  var functions = _initSequenceFunctions(fns, config);
  _$jscoverage['function.js'][217]++;
  return (function () {
  _$jscoverage['function.js'][218]++;
  var value, args = arguments;
  _$jscoverage['function.js'][221]++;
  functions.some((function (fn) {
  _$jscoverage['function.js'][222]++;
  value = fn.apply(this, args);
  _$jscoverage['function.js'][224]++;
  return value === false;
}), this);
  _$jscoverage['function.js'][227]++;
  return value;
});
});
_$jscoverage['function.js'][258]++;
exports.createRelayer = (function (fns, config) {
  _$jscoverage['function.js'][259]++;
  var functions = _initSequenceFunctions(fns, config);
  _$jscoverage['function.js'][261]++;
  return (function () {
  _$jscoverage['function.js'][262]++;
  var value, args = arguments;
  _$jscoverage['function.js'][265]++;
  functions.forEach((function (fn, index) {
  _$jscoverage['function.js'][266]++;
  if (index === 0) {
    _$jscoverage['function.js'][267]++;
    value = fn.apply(this, args);
  }
  else {
    _$jscoverage['function.js'][269]++;
    value = fn.apply(this, [value]);
  }
}), this);
  _$jscoverage['function.js'][273]++;
  return value;
});
});
_$jscoverage['function.js'][311]++;
exports.createThrottled = (function (f, millis, config) {
  _$jscoverage['function.js'][312]++;
  var fn = config? exports.createAugmenter(f, config): f, timeOutId = false;
  _$jscoverage['function.js'][315]++;
  if (! millis) {
    _$jscoverage['function.js'][316]++;
    return fn;
  }
  _$jscoverage['function.js'][319]++;
  return (function () {
  _$jscoverage['function.js'][320]++;
  var args = arguments;
  _$jscoverage['function.js'][322]++;
  if (timeOutId) {
    _$jscoverage['function.js'][323]++;
    clearTimeout(timeOutId);
  }
  _$jscoverage['function.js'][326]++;
  timeOutId = setTimeout((function () {
  _$jscoverage['function.js'][327]++;
  timeOutId = false;
  _$jscoverage['function.js'][328]++;
  fn.apply(this, args);
}), millis);
});
});
_$jscoverage['function.js'][346]++;
exports.createDeferred = (function (f, millis, config) {
  _$jscoverage['function.js'][347]++;
  var fn = config? exports.createAugmenter(f, config): f;
  _$jscoverage['function.js'][349]++;
  if (! millis) {
    _$jscoverage['function.js'][350]++;
    return fn;
  }
  _$jscoverage['function.js'][353]++;
  return (function () {
  _$jscoverage['function.js'][354]++;
  var args = arguments;
  _$jscoverage['function.js'][356]++;
  setTimeout((function () {
  _$jscoverage['function.js'][357]++;
  fn.apply(this, args);
}), millis);
});
});
_$jscoverage['function.js'].source = ["var is = require('./is'),","    aInsert = require('./array').insert;","    aEach = require('./array').each;","","/**"," * @class Luc.Function"," * Package for function methods.  Most of them follow the same api:"," * function or function[], relevant args ... with an optional config"," * to Luc.Function.createAutmenter as the last argument."," */","","function _augmentArgs(config, callArgs) {","    var configArgs = config.args,","        index = config.index,","        argsArray;","","    if (!configArgs) {","        return callArgs;","    }","","    if(index === true || is.isNumber(index)) {","        if(config.argumentsFirst === false) {","            return aInsert(configArgs, callArgs, index);","        }","        return aInsert(callArgs, configArgs, index);","    }","","    return configArgs;","}","","/**"," * A reusable empty function"," * @return {Function}"," */","exports.emptyFn = function() {};","","/**"," * A function that throws an error when called."," * Useful when defining abstract like classes"," * @return {Function}"," */","exports.abstractFn = function() {","    throw new Error('abstractFn must be implemented');","};","","/**"," * Augment the passed in function's thisArg and or arguments object "," * based on the passed in config."," * "," * @param  {Function} fn the function to call"," * @param  {Object} config"," * "," * @param {Object} [config.thisArg] the thisArg for the function being executed."," * If this is the only property on your config object the preferred way would"," * be just to use Function.bind"," * "," * @param {Array} [config.args] the arguments used for the function being executed."," * This will replace the functions call args if index is not a number or "," * true."," * "," * @param {Number/True} [config.index] By default the the configured arguments"," * will be inserted into the functions passed in call arguments.  If index is true"," * append the args together if it is a number insert it at the passed in index."," * "," * @param {Array} [config.argumentsFirst] pass in false to "," * augment the configured args first with Luc.Array.insert.  Defaults"," * to true","     ","     function fn() {","        console.log(this)","        console.log(arguments)","    }","    ","    //Luc.Array.insert([4], [1,2,3], 0)","    Luc.Function.createAugmenter(fn, {","        thisArg: {configedThisArg: true},","        args: [1,2,3],","        index:0","    })(4)","","    &gt;Object {configedThisArg: true}","    &gt;[1, 2, 3, 4]","","    //Luc.Array.insert([1,2,3], [4], 0)","    Luc.Function.createAugmenter(fn, {","        thisArg: {configedThisArg: true},","        args: [1,2,3],","        index:0,","        argumentsFirst:false","    })(4)","","    &gt;Object {configedThisArg: true}","    &gt;[4, 1, 2, 3]","","    Luc.Array.insert([4], [1,2,3],  true)","    var f = Luc.Function.createAugmenter(fn, {","        args: [1,2,3],","        index: true","    });","","    f.apply({config: false}, [4])","","    &gt;Object {config: false}","    &gt;[4, 1, 2, 3]",""," * @return {Function} the augmented function."," */","exports.createAugmenter = function(fn, config) {","    var thisArg = config.thisArg;","","    return function() {","        return fn.apply(thisArg || this, _augmentArgs(config, arguments));","    };","};","","function _initSequenceFunctions(fns, config) {","    var toRun = [];","    aEach(fns, function(f) {","        var fn = f;","","        if (config) {","            fn = exports.createAugmenter(f, config);","        }","","        toRun.push(fn);","    });","","    return toRun;","}","","/**"," * Return a function that runs the passed in functions"," * and returns the result of the last function called."," * "," * @param  {Function[]} fns "," * @param  {Object} [config] Config object"," * for Luc.Function.createAugmenter.  If defined all of the functions"," * will get created with the passed in config;"," *","    Luc.Function.createSequence([","        function() {","            console.log(1)","        },","        function() {","            console.log(2)","        },","        function() {","            console.log(3)","            console.log('finished logging')","            return 4;","        }","    ])()","    &gt;1","    &gt;2","    &gt;3","    &gt;finished logging","    &gt;4"," * "," * @return {Function}"," */","exports.createSequence = function(fns, config) {","    var functions = _initSequenceFunctions(fns, config);","","    return function() {","        var i = 0,","            len = functions.length;","","        for(;i &lt; len -1; ++i) {","            functions[i].apply(this, arguments);","        }","","        return functions[len -1 ].apply(this, arguments);","    };","};","","/**"," * Return a function that runs the passed in functions"," * if one of the functions results false the rest of the "," * functions won't run and false will be returned."," *"," * If no false is returned the value of the last function return will be returned"," * ","    Luc.Function.createSequenceIf([","        function() {","            console.log(1)","        },","        function() {","            console.log(2)","        },","        function() {","            console.log(3)","            console.log('finished logging')","            return 4;","        }, function() {","            return false;","        }, function() {","            console.log('i cant log')","        }","    ])()","","    &gt;1","    &gt;2","    &gt;3","    &gt;finished logging","    &gt;false"," *"," * "," * @param  {Function[]} fns "," * @param  {Object} [config] Config object"," * for Luc.Function.createAugmenter.  If defined all of the functions"," * will get created with the passed in config;"," * @return {Function}"," */","exports.createSequenceIf = function(fns, config) {","    var functions = _initSequenceFunctions(fns, config);","","    return function() {","        var value,","            args = arguments;","","        functions.some(function(fn){","            value = fn.apply(this, args);","","            return value === false;","        }, this);","","        return value;","    };","};","","/**"," * Return a functions that runs the passed in functions"," * the result of each function will be the the call args "," * for the next function.  The value of the last function "," * return will be returned."," * ","     ","     Luc.Function.createRelayer([","        function(str) {","            return str + 'b'","        },","        function(str) {","            return str + 'c'","        },","        function(str) {","            return str + 'd'","        }","    ])('a')","","    &gt;\"abcd\"",""," * @param  {Function[]} fns "," * @param  {Object} [config] Config object"," * for Luc.Function.createAugmenter.  If defined all of the functions"," * will get created with the passed in config;"," * @return {Function}"," */","exports.createRelayer = function(fns, config) {","    var functions = _initSequenceFunctions(fns, config);","","    return function() {","        var value,","            args = arguments;","","        functions.forEach(function(fn, index) {","            if (index === 0) {","                value = fn.apply(this, args);","            } else {","                value = fn.apply(this, [value]);","            }","        }, this);","","        return value;","    };","};","","/**"," * Create a throttled function from the passed in function"," * that will only get called once the passed number of miliseconds"," * have been exceeded."," * ","    var logArgs  = function() {","        console.log(arguments)","    };","","    var a = Luc.Function.createThrottled(logArgs, 1);","","    for(var i = 0; i &lt; 100; ++i) {","        a(1,2,3);","    }","","    setTimeout(function() {","        a(1)","    }, 100)","    setTimeout(function() {","        a(2)","    }, 400)","","    &gt;[1, 2, 3]","    &gt;[1]","    &gt;[2]"," * "," * @param  {Function} fn"," * @param  {Number} millis Number of milliseconds to"," * throttle the function."," * @param  {Object} [config] Config object"," * for Luc.Function.createAugmenter.  If defined all of the functions"," * will get created with the passed in config;"," * @return {Function}"," */","exports.createThrottled = function(f, millis, config) {","    var fn = config ? exports.createAugmenter(f, config) : f,","        timeOutId = false;","","    if(!millis) {","        return fn;","    }","","    return function() {","        var args = arguments;","","        if(timeOutId) {","            clearTimeout(timeOutId);","        }","","        timeOutId = setTimeout(function() {","            timeOutId = false;","            fn.apply(this, args);","        }, millis);","    };","};","","/**"," * Defer a function's execution for the passed in"," * milliseconds."," * "," * @param  {Function} fn"," * @param  {Number} millis Number of milliseconds to"," * defer"," * @param  {Object} [config] Config object"," * for Luc.Function.createAugmenter.  If defined all of the functions"," * will get created with the passed in config;"," * "," * @return {Function}"," */","exports.createDeferred = function(f, millis, config) {","    var fn = config ? exports.createAugmenter(f, config) : f;","","    if(!millis) {","        return fn;","    }","","    return function() {","        var args = arguments;","","        setTimeout(function() {","            fn.apply(this, args);","        }, millis);","    };","};"];

},{"./is":19,"./array":18}],18:[function(require,module,exports){
/* automatically generated by JSCoverage - do not edit */
if (typeof _$jscoverage === 'undefined') _$jscoverage = {};
if (! _$jscoverage['array.js']) {
  _$jscoverage['array.js'] = [];
  _$jscoverage['array.js'][1] = 0;
  _$jscoverage['array.js'][6] = 0;
  _$jscoverage['array.js'][7] = 0;
  _$jscoverage['array.js'][9] = 0;
  _$jscoverage['array.js'][10] = 0;
  _$jscoverage['array.js'][13] = 0;
  _$jscoverage['array.js'][14] = 0;
  _$jscoverage['array.js'][17] = 0;
  _$jscoverage['array.js'][18] = 0;
  _$jscoverage['array.js'][22] = 0;
  _$jscoverage['array.js'][23] = 0;
  _$jscoverage['array.js'][25] = 0;
  _$jscoverage['array.js'][26] = 0;
  _$jscoverage['array.js'][113] = 0;
  _$jscoverage['array.js'][114] = 0;
  _$jscoverage['array.js'][115] = 0;
  _$jscoverage['array.js'][117] = 0;
  _$jscoverage['array.js'][132] = 0;
  _$jscoverage['array.js'][133] = 0;
  _$jscoverage['array.js'][146] = 0;
  _$jscoverage['array.js'][147] = 0;
  _$jscoverage['array.js'][148] = 0;
  _$jscoverage['array.js'][164] = 0;
  _$jscoverage['array.js'][165] = 0;
  _$jscoverage['array.js'][166] = 0;
  _$jscoverage['array.js'][193] = 0;
  _$jscoverage['array.js'][194] = 0;
  _$jscoverage['array.js'][195] = 0;
  _$jscoverage['array.js'][218] = 0;
  _$jscoverage['array.js'][219] = 0;
  _$jscoverage['array.js'][223] = 0;
  _$jscoverage['array.js'][224] = 0;
  _$jscoverage['array.js'][227] = 0;
  _$jscoverage['array.js'][228] = 0;
  _$jscoverage['array.js'][229] = 0;
  _$jscoverage['array.js'][246] = 0;
  _$jscoverage['array.js'][247] = 0;
  _$jscoverage['array.js'][248] = 0;
  _$jscoverage['array.js'][249] = 0;
  _$jscoverage['array.js'][252] = 0;
  _$jscoverage['array.js'][253] = 0;
  _$jscoverage['array.js'][255] = 0;
  _$jscoverage['array.js'][256] = 0;
  _$jscoverage['array.js'][257] = 0;
  _$jscoverage['array.js'][258] = 0;
  _$jscoverage['array.js'][262] = 0;
  _$jscoverage['array.js'][274] = 0;
  _$jscoverage['array.js'][275] = 0;
  _$jscoverage['array.js'][276] = 0;
  _$jscoverage['array.js'][288] = 0;
  _$jscoverage['array.js'][289] = 0;
  _$jscoverage['array.js'][290] = 0;
  _$jscoverage['array.js'][294] = 0;
  _$jscoverage['array.js'][295] = 0;
  _$jscoverage['array.js'][298] = 0;
  _$jscoverage['array.js'][299] = 0;
  _$jscoverage['array.js'][300] = 0;
  _$jscoverage['array.js'][301] = 0;
  _$jscoverage['array.js'][305] = 0;
  _$jscoverage['array.js'][306] = 0;
  _$jscoverage['array.js'][309] = 0;
  _$jscoverage['array.js'][321] = 0;
  _$jscoverage['array.js'][322] = 0;
  _$jscoverage['array.js'][323] = 0;
  _$jscoverage['array.js'][335] = 0;
  _$jscoverage['array.js'][336] = 0;
  _$jscoverage['array.js'][337] = 0;
  _$jscoverage['array.js'][340] = 0;
  _$jscoverage['array.js'][341] = 0;
  _$jscoverage['array.js'][342] = 0;
  _$jscoverage['array.js'][343] = 0;
  _$jscoverage['array.js'][344] = 0;
  _$jscoverage['array.js'][345] = 0;
  _$jscoverage['array.js'][349] = 0;
  _$jscoverage['array.js'][361] = 0;
  _$jscoverage['array.js'][362] = 0;
  _$jscoverage['array.js'][363] = 0;
  _$jscoverage['array.js'][375] = 0;
  _$jscoverage['array.js'][376] = 0;
  _$jscoverage['array.js'][377] = 0;
  _$jscoverage['array.js'][380] = 0;
  _$jscoverage['array.js'][381] = 0;
  _$jscoverage['array.js'][382] = 0;
  _$jscoverage['array.js'][394] = 0;
  _$jscoverage['array.js'][395] = 0;
  _$jscoverage['array.js'][396] = 0;
  _$jscoverage['array.js'][408] = 0;
  _$jscoverage['array.js'][409] = 0;
  _$jscoverage['array.js'][410] = 0;
  _$jscoverage['array.js'][414] = 0;
  _$jscoverage['array.js'][415] = 0;
  _$jscoverage['array.js'][416] = 0;
  _$jscoverage['array.js'][417] = 0;
  _$jscoverage['array.js'][418] = 0;
  _$jscoverage['array.js'][419] = 0;
  _$jscoverage['array.js'][421] = 0;
  _$jscoverage['array.js'][422] = 0;
  _$jscoverage['array.js'][423] = 0;
  _$jscoverage['array.js'][424] = 0;
  _$jscoverage['array.js'][425] = 0;
  _$jscoverage['array.js'][427] = 0;
  _$jscoverage['array.js'][428] = 0;
  _$jscoverage['array.js'][429] = 0;
  _$jscoverage['array.js'][430] = 0;
  _$jscoverage['array.js'][432] = 0;
  _$jscoverage['array.js'][433] = 0;
  _$jscoverage['array.js'][434] = 0;
  _$jscoverage['array.js'][436] = 0;
  _$jscoverage['array.js'][437] = 0;
  _$jscoverage['array.js'][439] = 0;
  _$jscoverage['array.js'][440] = 0;
  _$jscoverage['array.js'][441] = 0;
  _$jscoverage['array.js'][443] = 0;
  _$jscoverage['array.js'][448] = 0;
  _$jscoverage['array.js'][449] = 0;
}
_$jscoverage['array.js'][1]++;
var arraySlice = Array.prototype.slice, compare = require("./compare"), is = require("./is"), compare = compare.compare;
_$jscoverage['array.js'][6]++;
function _createIteratorFn(fn, c) {
  _$jscoverage['array.js'][7]++;
  var config = c || {};
  _$jscoverage['array.js'][9]++;
  if (is.isFunction(fn) && (config.type !== "strict")) {
    _$jscoverage['array.js'][10]++;
    return c? fn.bind(c): fn;
  }
  _$jscoverage['array.js'][13]++;
  if (config.type === undefined) {
    _$jscoverage['array.js'][14]++;
    config.type = "loose";
  }
  _$jscoverage['array.js'][17]++;
  return (function (value) {
  _$jscoverage['array.js'][18]++;
  return compare(fn, value, config);
});
}
_$jscoverage['array.js'][22]++;
function _createIteratorNotFn(fn, config) {
  _$jscoverage['array.js'][23]++;
  var functionToNot = _createIteratorFn(fn, config);
  _$jscoverage['array.js'][25]++;
  return (function () {
  _$jscoverage['array.js'][26]++;
  return ! functionToNot.apply(this, arguments);
});
}
_$jscoverage['array.js'][113]++;
function toArray(item) {
  _$jscoverage['array.js'][114]++;
  if (Array.isArray(item)) {
    _$jscoverage['array.js'][115]++;
    return item;
  }
  _$jscoverage['array.js'][117]++;
  return (item === null || item === undefined)? []: [item];
}
_$jscoverage['array.js'][132]++;
function last(arr) {
  _$jscoverage['array.js'][133]++;
  return arr[arr.length - 1];
}
_$jscoverage['array.js'][146]++;
function pluck(arr, key) {
  _$jscoverage['array.js'][147]++;
  return arr.map((function (value) {
  _$jscoverage['array.js'][148]++;
  return value && value[key];
}));
}
_$jscoverage['array.js'][164]++;
function fromIndex(a, index) {
  _$jscoverage['array.js'][165]++;
  var arr = is.isArguments(a)? arraySlice.call(a): a;
  _$jscoverage['array.js'][166]++;
  return arraySlice.call(arr, index, arr.length);
}
_$jscoverage['array.js'][193]++;
function each(item, fn, thisArg) {
  _$jscoverage['array.js'][194]++;
  var arr = toArray(item);
  _$jscoverage['array.js'][195]++;
  return arr.forEach.call(arr, fn, thisArg);
}
_$jscoverage['array.js'][218]++;
function insert(firstArrayOrArgs, secondArrayOrArgs, indexOrAppend) {
  _$jscoverage['array.js'][219]++;
  var firstArray = arraySlice.call(firstArrayOrArgs), secondArray = arraySlice.call(secondArrayOrArgs), spliceArgs;
  _$jscoverage['array.js'][223]++;
  if (indexOrAppend === true) {
    _$jscoverage['array.js'][224]++;
    return firstArray.concat(secondArray);
  }
  _$jscoverage['array.js'][227]++;
  spliceArgs = [indexOrAppend, 0].concat(secondArray);
  _$jscoverage['array.js'][228]++;
  firstArray.splice.apply(firstArray, spliceArgs);
  _$jscoverage['array.js'][229]++;
  return firstArray;
}
_$jscoverage['array.js'][246]++;
function removeAtIndex(arr, index) {
  _$jscoverage['array.js'][247]++;
  var item = arr[index];
  _$jscoverage['array.js'][248]++;
  arr.splice(index, 1);
  _$jscoverage['array.js'][249]++;
  return item;
}
_$jscoverage['array.js'][252]++;
function _removeFirst(arr, fn) {
  _$jscoverage['array.js'][253]++;
  var removed = false;
  _$jscoverage['array.js'][255]++;
  arr.some((function (value, index) {
  _$jscoverage['array.js'][256]++;
  if (fn.apply(this, arguments)) {
    _$jscoverage['array.js'][257]++;
    removed = removeAtIndex(arr, index);
    _$jscoverage['array.js'][258]++;
    return true;
  }
}));
  _$jscoverage['array.js'][262]++;
  return removed;
}
_$jscoverage['array.js'][274]++;
function removeFirst(arr, obj, config) {
  _$jscoverage['array.js'][275]++;
  var fn = _createIteratorFn(obj, config);
  _$jscoverage['array.js'][276]++;
  return _removeFirst(arr, fn);
}
_$jscoverage['array.js'][288]++;
function removeFirstNot(arr, obj, config) {
  _$jscoverage['array.js'][289]++;
  var fn = _createIteratorNotFn(obj, config);
  _$jscoverage['array.js'][290]++;
  return _removeFirst(arr, fn);
}
_$jscoverage['array.js'][294]++;
function _removeAll(arr, fn) {
  _$jscoverage['array.js'][295]++;
  var indexsToRemove = [], removed = [];
  _$jscoverage['array.js'][298]++;
  arr.forEach((function (value, index) {
  _$jscoverage['array.js'][299]++;
  if (fn.apply(this, arguments)) {
    _$jscoverage['array.js'][300]++;
    indexsToRemove.unshift(index);
    _$jscoverage['array.js'][301]++;
    removed.push(value);
  }
}));
  _$jscoverage['array.js'][305]++;
  indexsToRemove.forEach((function (index) {
  _$jscoverage['array.js'][306]++;
  removeAtIndex(arr, index);
}));
  _$jscoverage['array.js'][309]++;
  return removed;
}
_$jscoverage['array.js'][321]++;
function removeAllNot(arr, obj, config) {
  _$jscoverage['array.js'][322]++;
  var fn = _createIteratorNotFn(obj, config);
  _$jscoverage['array.js'][323]++;
  return _removeAll(arr, fn);
}
_$jscoverage['array.js'][335]++;
function removeAll(arr, obj, config) {
  _$jscoverage['array.js'][336]++;
  var fn = _createIteratorFn(obj, config);
  _$jscoverage['array.js'][337]++;
  return _removeAll(arr, fn);
}
_$jscoverage['array.js'][340]++;
function _findFirst(arr, fn) {
  _$jscoverage['array.js'][341]++;
  var item = false;
  _$jscoverage['array.js'][342]++;
  arr.some((function (value, index) {
  _$jscoverage['array.js'][343]++;
  if (fn.apply(this, arguments)) {
    _$jscoverage['array.js'][344]++;
    item = arr[index];
    _$jscoverage['array.js'][345]++;
    return true;
  }
}));
  _$jscoverage['array.js'][349]++;
  return item;
}
_$jscoverage['array.js'][361]++;
function findFirst(arr, obj, config) {
  _$jscoverage['array.js'][362]++;
  var fn = _createIteratorFn(obj, config);
  _$jscoverage['array.js'][363]++;
  return _findFirst(arr, fn);
}
_$jscoverage['array.js'][375]++;
function findFirstNot(arr, obj, config) {
  _$jscoverage['array.js'][376]++;
  var fn = _createIteratorNotFn(obj, config);
  _$jscoverage['array.js'][377]++;
  return _findFirst(arr, fn);
}
_$jscoverage['array.js'][380]++;
function _findAll(arr, fn) {
  _$jscoverage['array.js'][381]++;
  var found = arr.filter(fn);
  _$jscoverage['array.js'][382]++;
  return found;
}
_$jscoverage['array.js'][394]++;
function findAll(arr, obj, config) {
  _$jscoverage['array.js'][395]++;
  var fn = _createIteratorFn(obj, config);
  _$jscoverage['array.js'][396]++;
  return _findAll(arr, fn);
}
_$jscoverage['array.js'][408]++;
function findAllNot(arr, obj, config) {
  _$jscoverage['array.js'][409]++;
  var fn = _createIteratorNotFn(obj, config);
  _$jscoverage['array.js'][410]++;
  return _findAll(arr, fn);
}
_$jscoverage['array.js'][414]++;
exports.toArray = toArray;
_$jscoverage['array.js'][415]++;
exports.each = each;
_$jscoverage['array.js'][416]++;
exports.insert = insert;
_$jscoverage['array.js'][417]++;
exports.fromIndex = fromIndex;
_$jscoverage['array.js'][418]++;
exports.last = last;
_$jscoverage['array.js'][419]++;
exports.pluck = pluck;
_$jscoverage['array.js'][421]++;
exports.removeAtIndex = removeAtIndex;
_$jscoverage['array.js'][422]++;
exports.findFirstNot = findFirstNot;
_$jscoverage['array.js'][423]++;
exports.findAllNot = findAllNot;
_$jscoverage['array.js'][424]++;
exports.findFirst = findFirst;
_$jscoverage['array.js'][425]++;
exports.findAll = findAll;
_$jscoverage['array.js'][427]++;
exports.removeFirstNot = removeFirstNot;
_$jscoverage['array.js'][428]++;
exports.removeAllNot = removeAllNot;
_$jscoverage['array.js'][429]++;
exports.removeFirst = removeFirst;
_$jscoverage['array.js'][430]++;
exports.removeAll = removeAll;
_$jscoverage['array.js'][432]++;
(function () {
  _$jscoverage['array.js'][433]++;
  var _createLastFn = (function (fnName) {
  _$jscoverage['array.js'][434]++;
  var lastName = fnName.replace("First", "Last");
  _$jscoverage['array.js'][436]++;
  exports[lastName] = (function (arr, obj, config) {
  _$jscoverage['array.js'][437]++;
  var ret;
  _$jscoverage['array.js'][439]++;
  arr.reverse();
  _$jscoverage['array.js'][440]++;
  ret = exports[fnName](arr, obj, config);
  _$jscoverage['array.js'][441]++;
  arr.reverse();
  _$jscoverage['array.js'][443]++;
  return ret;
});
}), namesToAddLast = ["findFirstNot", "findFirst", "removeFirstNot", "removeFirst"];
  _$jscoverage['array.js'][448]++;
  namesToAddLast.forEach((function (fnName) {
  _$jscoverage['array.js'][449]++;
  _createLastFn(fnName);
}));
})();
_$jscoverage['array.js'].source = ["var arraySlice = Array.prototype.slice,","    compare = require('./compare'),","    is = require('./is'),","    compare = compare.compare;","","function _createIteratorFn(fn, c) {","    var config = c || {};","","    if(is.isFunction(fn) &amp;&amp; (config.type !== 'strict')) {","        return c ? fn.bind(c) : fn;","    }","","    if(config.type === undefined) {","        config.type = 'loose';","    }","","    return function(value) {","        return compare(fn, value, config);","    };","}","","function _createIteratorNotFn(fn, config) {","    var functionToNot = _createIteratorFn(fn, config);","        ","    return function() {","        return !functionToNot.apply(this, arguments);","    };","}","","","/**"," * @class Luc.Array "," * Package for Array methods. &lt;br&gt;"," * "," * Keep in mind that Luc is optionally packaged with es5 shim so you can write es5 code in non es5 browsers."," * It comes with your favorite {@link Array Array} methods such as Array.forEach, Array.filter, Array.some, Array.every Array.reduceRight .."," *"," * Also don't forget about Luc.Array.each and Luc.Array.toArray, they are great utility methods"," * that are used all over the framework."," * "," * All remove\\* / find\\* methods follow the same api.  \\*All functions will return an array of removed or found"," * items.  The items will be added to the array in the order they are"," * found.  \\*First functions will return the first item and stop iterating after that, if none"," *  is found false is returned.  remove\\* functions will directly change the passed in array."," *  \\*Not functions only do the following actions if the comparison is not true."," *  All remove\\* / find\\* take the following api: array, objectToCompareOrIterator, compareConfigOrThisArg for example:"," *","    //most common use case","    Luc.Array.findFirst([1,2,3, {}], {});","    &gt;Object {}","","    //pass in option config for a strict === comparison","    Luc.Array.findFirst([1,2,3,{}], {}, {type: 'strict'});","    &gt;false","","    //pass in an iterator and thisArg","    Luc.Array.findFirst([1,2,3,{}], function(val, index, array){","        return val === 3 || this.num === val;","    }, {num: 1});","    &gt;1","    ","    //you can see remove modifies the passed in array.","    var arr = [1,2,{a:1},1, {a:1}];","    Luc.Array.removeFirst(arr, {a:1})","    &gt;{a:1}","    arr;","    &gt;[1, 2, 1, {a:1}]","    Luc.Array.removeLast(arr, 1)","    &gt;1","    arr;","    &gt;[1,2, {a:1}]","    ","    ","    Luc.Array.findAll([1,2,3, {a:1,b:2}], function() {return true;})","    &gt; [1,2,3, {a:1,b:2}]","    //show how not works with an iterator","    Luc.Array.findAllNot([1,2,3, {a:1,b:2}], function() {return true;})","    &gt;[]"," *"," * For commonly used find/remove functions check out Luc.ArrayFns for example a"," * \"compact\" like function"," * ","    Luc.Array.findAllNotFalsy([false, '', undefined, 0, {}, []])","    &gt;[0, {}, []]"," *"," * Or remove all empty items"," * ","    var arr = ['', 0 , [], {a:1}, true, {}, [1]]","    Luc.Array.removeAllEmpty(arr)","    &gt;['', [], {}]","    arr","    &gt;[0, {a:1}, true, [1]]"," */","","/**"," * Turn the passed in item into an array if it"," * isn't one already, if the item is an array just return it.  "," * It returns an empty array if item is null or undefined."," * If it is just a single item return an array containing the item."," * ","    Luc.Array.toArray()","    &gt;[]","    Luc.Array.toArray(null)","    &gt;[]","    Luc.Array.toArray(1)","    &gt;[1]","    Luc.Array.toArray([1,2])","    &gt;[1, 2]"," *"," * @param  {Object} item item to turn into an array."," * @return the array"," */","function toArray(item) {","    if (Array.isArray(item)) {","        return item;","    }","    return (item === null || item === undefined) ? [] : [item];","}","","/**"," * Return the last item of the array"," * @param  {Array} arr"," * @return {Object} the item","    ","    var myLongArrayNameForThingsThatIWantToKeepTrackOf = [1,2,3]","    ","    Luc.Array.last(myLongArrayNameForThingsThatIWantToKeepTrackOf);","    vs.","    myLongArrayNameForThingsThatIWantToKeepTrackOf[myLongArrayNameForThingsThatIWantToKeepTrackOf.length -1]"," *"," */","function last(arr) {","    return arr[arr.length -1];","}","","/**"," * Flatten out an array of objects based of their value for the passed in key."," * This also takes acccount for null/undefined values."," *","    Luc.Array.pluck([undefined, {a:'1', b:2}, {b:3}, {b:4}], 'b')","    &gt;[undefined, 2, 3, 4]"," * @param  {Object[]} arr "," * @param  {String} key "," * @return {Array}     "," */","function pluck(arr, key) {","    return arr.map(function(value) {","        return value &amp;&amp; value[key];","    });","}","","/**"," * Return the items inbetween the passed in index"," * and the end of the array."," *","    Luc.Array.fromIndex([1,2,3,4,5], 1)","    &gt;[2, 3, 4, 5]",""," * @param  {Array/arguments} arr "," * @param  {Number} index "," * @return {Array} the new array."," * "," */","function fromIndex(a, index) {","    var arr = is.isArguments(a) ? arraySlice.call(a) : a;","    return arraySlice.call(arr, index, arr.length);","}","","/**"," * Runs an Array.forEach after calling Luc.Array.toArray on the item.","  It is very useful for setting up flexible api's that can handle none one or many.","","    Luc.Array.each(this.items, function(item) {","        this._addItem(item);","    });","","    vs.","","    if(Array.isArray(this.items)){","        this.items.forEach(function(item) {","            this._addItem(item);","        })","    }","    else if(this.items !== undefined) {","        this._addItem(this.items);","    }",""," * @param  {Object}   item"," * @param  {Function} callback"," * @param  {Object}   thisArg   "," *"," */","function each(item, fn, thisArg) {","    var arr = toArray(item);","    return arr.forEach.call(arr, fn, thisArg);","}","","/**"," * Insert or append the second array/arguments into the"," * first array/arguments.  This method does not alter"," * the passed in array/arguments."," * "," * @param  {Array/arguments} firstArrayOrArgs"," * @param  {Array/arguments} secondArrayOrArgs"," * @param  {Number/true} indexOrAppend true to append "," * the second array to the end of the first one.  If it is a number"," * insert the secondArray into the first one at the passed in index."," * @return {Array} the newly created array."," *","    Luc.Array.insert([0,4], [1,2,3], 1);","    &gt;[0, 1, 2, 3, 4]","    Luc.Array.insert([0,4], [1,2,3], true);","    &gt;[0, 4, 1, 2, 3]","    Luc.Array.insert([0,4], [1,2,3], 0);","    &gt;[1, 2, 3, 0, 4]"," *"," */","function insert(firstArrayOrArgs, secondArrayOrArgs, indexOrAppend) {","    var firstArray = arraySlice.call(firstArrayOrArgs),","        secondArray = arraySlice.call(secondArrayOrArgs),","        spliceArgs;","","    if(indexOrAppend === true) {","        return firstArray.concat(secondArray);","    }","","    spliceArgs = [indexOrAppend, 0].concat(secondArray);","    firstArray.splice.apply(firstArray, spliceArgs);","    return firstArray;","}","","/**"," * Remove an item from an the passed in arr"," * from the index."," * @param  {Array} arr"," * @param  {Number} index"," * @return {Object} the item removed."," *","    var arr = [1,2,3];","    Luc.Array.removeAtIndex(arr, 1);","    &gt;2","    arr;","    &gt;[1,3]",""," */","function removeAtIndex(arr, index) {","    var item = arr[index];","    arr.splice(index, 1);","    return item;","}","","function _removeFirst(arr, fn) {","    var removed = false;","","    arr.some(function(value, index) {","        if (fn.apply(this, arguments)) {","            removed = removeAtIndex(arr, index);","            return true;","        }","    });","","    return removed;","}","","/**"," * Remove the first item from the passed in array"," * that {@link Luc#compare matches} the passed in object.  Instead of "," * comparing an object an iterator function can be"," * used."," * ","{copyDoc#arrParams}","{copyDoc#arrRemoveSingle}"," */","function removeFirst(arr, obj, config) {","    var fn = _createIteratorFn(obj, config);","    return _removeFirst(arr, fn);","}","","/**"," * Remove the first item from the passed in array"," * that does not {@link Luc#compare match} the passed in object.  Instead of "," * comparing an object an iterator function can be"," * used."," * ","{copyDoc#arrParams}","{copyDoc#arrRemoveSingle}"," */","function removeFirstNot(arr, obj, config) {","    var fn = _createIteratorNotFn(obj, config);","    return _removeFirst(arr, fn);","}","","","function _removeAll(arr, fn) {","    var indexsToRemove = [],","        removed = [];","","    arr.forEach(function(value, index) {","        if (fn.apply(this, arguments)) {","            indexsToRemove.unshift(index);","            removed.push(value);","        }","    });","","    indexsToRemove.forEach(function(index){","        removeAtIndex(arr, index);","    });","","    return removed;","}","","/**"," * Remove the all the items from the passed in array"," * that do not {@link Luc#compare match} the passed in object.  Instead of "," * comparing an object an iterator function can be"," * used."," * ","{copyDoc#arrParams}","{copyDoc#arrRemoveAll}"," */","function removeAllNot(arr, obj, config) {","    var fn = _createIteratorNotFn(obj, config);","    return _removeAll(arr, fn);","}","","/**"," * Remove the all the items from the passed in array"," * that {@link Luc#compare matches} the passed in object.  Instead of "," * comparing an object an iterator function can be"," * used."," * ","{copyDoc#arrParams}","{copyDoc#arrRemoveAll}"," */","function removeAll(arr, obj, config) {","    var fn = _createIteratorFn(obj, config);","    return _removeAll(arr, fn);","}","","function _findFirst(arr, fn) {","    var item = false;","    arr.some(function(value, index) {","        if (fn.apply(this, arguments)) {","            item = arr[index];","            return true;","        }","    });","","    return item;","}","","/**"," * Find the first item from the passed in array"," * that does {@link Luc#compare matches} the passed in object.  Instead of "," * comparing an object an iterator function can be"," * used."," * ","{copyDoc#arrParams}","{copyDoc#arrFindSingle}"," */","function findFirst(arr, obj, config) {","    var fn = _createIteratorFn(obj, config);","    return _findFirst(arr, fn);","}","","/**"," * Find the first item from the passed in array"," * that does not {@link Luc#compare match} the passed in object.  Instead of "," * comparing an object an iterator function can be"," * used."," * ","{copyDoc#arrParams}","{copyDoc#arrFindSingle}"," */","function findFirstNot(arr, obj, config) {","    var fn = _createIteratorNotFn(obj, config);","    return _findFirst(arr, fn);","}","","function _findAll(arr, fn) {","    var found = arr.filter(fn);","    return found;","}","","/**"," * Find all of the the items from the passed in array"," * that {@link Luc#compare matches} the passed in object.  Instead of "," * comparing an object an iterator function can be"," * used."," * ","{copyDoc#arrParams}","{copyDoc#arrFindAll}"," */","function findAll(arr, obj, config) {","    var fn = _createIteratorFn(obj, config);","    return _findAll(arr, fn);","}","","/**"," * Find all of the the items from the passed in array"," * that do not {@link Luc#compare match} the passed in object.  Instead of "," * comparing an object an iterator function can be"," * used."," * ","{copyDoc#arrParams}","{copyDoc#arrFindAll}"," */","function findAllNot(arr, obj, config) {","    var fn = _createIteratorNotFn(obj, config);","    return _findAll(arr, fn);","}","","","exports.toArray = toArray;","exports.each = each;","exports.insert = insert;","exports.fromIndex = fromIndex;","exports.last = last;","exports.pluck = pluck;","","exports.removeAtIndex = removeAtIndex;","exports.findFirstNot = findFirstNot;","exports.findAllNot = findAllNot;","exports.findFirst = findFirst;","exports.findAll = findAll;","","exports.removeFirstNot = removeFirstNot;","exports.removeAllNot = removeAllNot;","exports.removeFirst = removeFirst;","exports.removeAll = removeAll;","","(function(){","    var _createLastFn = function(fnName) {","        var lastName = fnName.replace('First', 'Last');","","        exports[lastName] = function(arr, obj, config) {","            var ret;","","            arr.reverse();","            ret = exports[fnName](arr, obj, config);","            arr.reverse();","","            return ret;","        };","","    }, namesToAddLast = ['findFirstNot', 'findFirst', 'removeFirstNot', 'removeFirst'];","","    namesToAddLast.forEach(function(fnName) {","        _createLastFn(fnName);","    });","","}());","","/**"," * @member Luc.Array "," * @method findLastNot "," * Same as Luc.Array.findFirstNot except start at the end."," */","","/**"," * @member Luc.Array "," * @method findLast"," * Same as Luc.Array.findFirst except start at the end."," */","","/**"," * @member Luc.Array "," * @method removeLastNot "," * Same as Luc.Array.removeFirstNot except start at the end."," */","","/**"," * @member Luc.Array "," * @method removeLast "," * Same as Luc.Array.removeFirst except start at the end."," */"];

},{"./compare":27,"./is":19}],20:[function(require,module,exports){
/* automatically generated by JSCoverage - do not edit */
if (typeof _$jscoverage === 'undefined') _$jscoverage = {};
if (! _$jscoverage['arrayFnGenerator.js']) {
  _$jscoverage['arrayFnGenerator.js'] = [];
  _$jscoverage['arrayFnGenerator.js'][1] = 0;
  _$jscoverage['arrayFnGenerator.js'][5] = 0;
  _$jscoverage['arrayFnGenerator.js'][12] = 0;
  _$jscoverage['arrayFnGenerator.js'][13] = 0;
  _$jscoverage['arrayFnGenerator.js'][18] = 0;
  _$jscoverage['arrayFnGenerator.js'][19] = 0;
  _$jscoverage['arrayFnGenerator.js'][20] = 0;
  _$jscoverage['arrayFnGenerator.js'][25] = 0;
  _$jscoverage['arrayFnGenerator.js'][83] = 0;
  _$jscoverage['arrayFnGenerator.js'][84] = 0;
  _$jscoverage['arrayFnGenerator.js'][86] = 0;
  _$jscoverage['arrayFnGenerator.js'][87] = 0;
  _$jscoverage['arrayFnGenerator.js'][88] = 0;
  _$jscoverage['arrayFnGenerator.js'][89] = 0;
  _$jscoverage['arrayFnGenerator.js'][90] = 0;
  _$jscoverage['arrayFnGenerator.js'][96] = 0;
  _$jscoverage['arrayFnGenerator.js'][97] = 0;
  _$jscoverage['arrayFnGenerator.js'][100] = 0;
  _$jscoverage['arrayFnGenerator.js'][102] = 0;
  _$jscoverage['arrayFnGenerator.js'][105] = 0;
  _$jscoverage['arrayFnGenerator.js'][108] = 0;
  _$jscoverage['arrayFnGenerator.js'][111] = 0;
  _$jscoverage['arrayFnGenerator.js'][115] = 0;
  _$jscoverage['arrayFnGenerator.js'][116] = 0;
  _$jscoverage['arrayFnGenerator.js'][117] = 0;
  _$jscoverage['arrayFnGenerator.js'][122] = 0;
  _$jscoverage['arrayFnGenerator.js'][123] = 0;
  _$jscoverage['arrayFnGenerator.js'][125] = 0;
  _$jscoverage['arrayFnGenerator.js'][126] = 0;
  _$jscoverage['arrayFnGenerator.js'][129] = 0;
  _$jscoverage['arrayFnGenerator.js'][130] = 0;
  _$jscoverage['arrayFnGenerator.js'][131] = 0;
  _$jscoverage['arrayFnGenerator.js'][132] = 0;
  _$jscoverage['arrayFnGenerator.js'][135] = 0;
  _$jscoverage['arrayFnGenerator.js'][138] = 0;
  _$jscoverage['arrayFnGenerator.js'][143] = 0;
  _$jscoverage['arrayFnGenerator.js'][144] = 0;
  _$jscoverage['arrayFnGenerator.js'][145] = 0;
}
_$jscoverage['arrayFnGenerator.js'][1]++;
var array = require("./array"), is = require("./is"), Generator;
_$jscoverage['arrayFnGenerator.js'][5]++;
Generator = {arrayFnNames: ["findFirstNot", "findAllNot", "findFirst", "findAll", "removeFirstNot", "removeAllNot", "removeFirst", "removeAll", "removeLastNot", "removeLast", "findLast", "findLastNot"], createFn: (function (arrayFnName, fn) {
  _$jscoverage['arrayFnGenerator.js'][12]++;
  return (function (arr) {
  _$jscoverage['arrayFnGenerator.js'][13]++;
  return array[arrayFnName](arr, fn);
});
}), createBoundFn: (function (arrayFnName, fnToBind) {
  _$jscoverage['arrayFnGenerator.js'][18]++;
  return (function (arr, value) {
  _$jscoverage['arrayFnGenerator.js'][19]++;
  var fn = fnToBind.apply(this, array.fromIndex(arguments, 1));
  _$jscoverage['arrayFnGenerator.js'][20]++;
  return array[arrayFnName](arr, fn);
});
})};
_$jscoverage['arrayFnGenerator.js'][25]++;
module.exports = Generator;
_$jscoverage['arrayFnGenerator.js'][83]++;
(function _createIsFns() {
  _$jscoverage['arrayFnGenerator.js'][84]++;
  var isToIgnore = ["isRegExp", "isArguments"];
  _$jscoverage['arrayFnGenerator.js'][86]++;
  Object.keys(is).forEach((function (key) {
  _$jscoverage['arrayFnGenerator.js'][87]++;
  var name = key.split("is")[1];
  _$jscoverage['arrayFnGenerator.js'][88]++;
  Generator.arrayFnNames.forEach((function (fnName) {
  _$jscoverage['arrayFnGenerator.js'][89]++;
  if (isToIgnore.indexOf(key) === -1) {
    _$jscoverage['arrayFnGenerator.js'][90]++;
    array[fnName + name] = Generator.createFn(fnName, is[key]);
  }
}));
}));
})();
_$jscoverage['arrayFnGenerator.js'][96]++;
(function _createFalsyFns() {
  _$jscoverage['arrayFnGenerator.js'][97]++;
  var usefullFalsyFns = ["findFirstNot", "findAllNot", "removeFirstNot", "removeAllNot", "removeFirst", "removeAll", "removeLastNot", "removeLast", "findLastNot"];
  _$jscoverage['arrayFnGenerator.js'][100]++;
  var fns = {"False": (function (val) {
  _$jscoverage['arrayFnGenerator.js'][102]++;
  return val === false;
}), "True": (function (val) {
  _$jscoverage['arrayFnGenerator.js'][105]++;
  return val === true;
}), "Null": (function (val) {
  _$jscoverage['arrayFnGenerator.js'][108]++;
  return val === null;
}), "Undefined": (function (val) {
  _$jscoverage['arrayFnGenerator.js'][111]++;
  return val === undefined;
})};
  _$jscoverage['arrayFnGenerator.js'][115]++;
  Object.keys(fns).forEach((function (key) {
  _$jscoverage['arrayFnGenerator.js'][116]++;
  usefullFalsyFns.forEach((function (fnName) {
  _$jscoverage['arrayFnGenerator.js'][117]++;
  array[fnName + key] = Generator.createFn(fnName, fns[key]);
}));
}));
})();
_$jscoverage['arrayFnGenerator.js'][122]++;
(function _createBoundFns() {
  _$jscoverage['arrayFnGenerator.js'][123]++;
  var fns = {"InstanceOf": (function (Constructor) {
  _$jscoverage['arrayFnGenerator.js'][125]++;
  return (function (value) {
  _$jscoverage['arrayFnGenerator.js'][126]++;
  return (value instanceof Constructor);
});
}), "In": (function (arr, c) {
  _$jscoverage['arrayFnGenerator.js'][129]++;
  var defaultC = {type: "looseRight"};
  _$jscoverage['arrayFnGenerator.js'][130]++;
  return (function (value) {
  _$jscoverage['arrayFnGenerator.js'][131]++;
  if (value !== false) {
    _$jscoverage['arrayFnGenerator.js'][132]++;
    var cfg = c || defaultC;
    _$jscoverage['arrayFnGenerator.js'][135]++;
    return array.findFirst(arr, value, cfg.type === "loose"? defaultC: cfg) !== false;
  }
  _$jscoverage['arrayFnGenerator.js'][138]++;
  return arr.indexOf(false) > -1;
});
})};
  _$jscoverage['arrayFnGenerator.js'][143]++;
  Object.keys(fns).forEach((function (key) {
  _$jscoverage['arrayFnGenerator.js'][144]++;
  Generator.arrayFnNames.forEach((function (fnName) {
  _$jscoverage['arrayFnGenerator.js'][145]++;
  array[fnName + key] = Generator.createBoundFn(fnName, fns[key]);
}));
}));
})();
_$jscoverage['arrayFnGenerator.js'].source = ["var array = require('./array'),","    is = require('./is'),","    Generator;","","Generator = {","    arrayFnNames: ['findFirstNot', 'findAllNot', 'findFirst', 'findAll',","            'removeFirstNot', 'removeAllNot', 'removeFirst', 'removeAll',","            'removeLastNot', 'removeLast', 'findLast', 'findLastNot'","    ],","","    createFn: function(arrayFnName, fn) {","        return function(arr) {","            return array[arrayFnName](arr, fn);","        };","    },","","    createBoundFn: function(arrayFnName, fnToBind) {","        return function(arr, value) {","            var fn = fnToBind.apply(this, array.fromIndex(arguments, 1));","            return array[arrayFnName](arr, fn);","        };","    }","};","","module.exports = Generator;","","/**"," * @class Luc.ArrayFns"," * This is documented as a separate package but it actually exists under the "," * Luc.Array namespace.  Check out the \"Filter class members\" input box"," * just to the right when searching for functions."," *&lt;br&gt;"," * "," * There are a lot of functions in this package but all of them "," * follow the same api.  \\*All functions will return an array of removed or found"," * items.  The items will be added to the array in the order they are"," * found.  \\*First functions will return the first item and stop iterating after that, if none"," *  is found false is returned.  remove\\* functions will directly change the passed in array."," *  \\*Not functions only do the following actions if the comparison is not true."," *  \\*Last functions do the same as their \\*First counterparts except that the iterating"," *  starts at the end of the array. Almost every public method of Luc.is is available it"," *  uses the following grammar Luc.Array[\"methodName\"\"isMethodName\"]"," *","      Luc.Array.findAllNotEmpty([false, true, null, undefined, 0, '', [], [1]])","      &gt; [true, 0, [1]]","","      Luc.Array.findAllNotFalsy([false, true, null, undefined, 0, '', [], [1]])","      &gt; [true, 0, [], [1]]","     ","      Luc.Array.findFirstNotString([1,2,3,'5'])","      &gt;1","      var arr = [1,2,3,'5'];","      Luc.Array.removeAllNotString(arr);","      &gt;[1,2,3]","      arr","      &gt;[\"5\"]"," *"," * As of right now there are two function sets which differ from the is"," * api."," *"," * InstanceOf"," * ","    Luc.Array.findAllInstanceOf([1,2, new Date(), {}, []], Object)","    &gt;[date, {}, []]","    &gt;Luc.Array.findAllNotInstanceOf([1,2, new Date(), {}, []], Object)","    [1, 2]"," *"," * In"," * ","    Luc.Array.findAllIn([1,2,3], [1,2])","    &gt;[1, 2]","    Luc.Array.findFirstIn([1,2,3], [1,2])","    &gt;1","","    //defaults to loose comparison","    Luc.Array.findAllIn([1,2,3, {a:1, b:2}], [1,{a:1}])","    &gt; [1, {a:1,b:2}]","","    Luc.Array.findAllIn([1,2,3, {a:1, b:2}], [1,{a:1}], {type: 'deep'})","    &gt;[1]"," */","","(function _createIsFns() {","    var isToIgnore = ['isRegExp', 'isArguments'];","","    Object.keys(is).forEach(function(key) {","        var name = key.split('is')[1];","        Generator.arrayFnNames.forEach(function(fnName) {","            if(isToIgnore.indexOf(key) === -1) {","                array[fnName + name] = Generator.createFn(fnName, is[key]);","            }","        });","    });","}());","","(function _createFalsyFns() {","    var usefullFalsyFns = ['findFirstNot', 'findAllNot', 'removeFirstNot', 'removeAllNot',","                            'removeFirst', 'removeAll', 'removeLastNot', 'removeLast',  'findLastNot'];","","    var fns = {","        'False': function(val) {","            return val === false;","        },","        'True': function(val) {","            return val === true;","        },","        'Null': function(val) {","            return val === null;","        },","        'Undefined': function(val) {","            return val === undefined;","        }","    };","","    Object.keys(fns).forEach(function(key) {","        usefullFalsyFns.forEach(function(fnName) {","            array[fnName + key] = Generator.createFn(fnName, fns[key]);","        });","    });","}());","","(function _createBoundFns() {","    var fns = {","        'InstanceOf': function(Constructor) {","            return function(value) {","                return (value instanceof Constructor);","            };","        },'In': function(arr, c) {","            var defaultC = {type:'looseRight'};","            return function(value) {","                if(value !== false) {","                    var cfg = c || defaultC;","                    //this is a right to left comparison ","                    //expected loose behavior should be looseRight","                    return array.findFirst(arr, value, cfg.type === 'loose' ? defaultC : cfg) !== false;","                }","                ","                return arr.indexOf(false) &gt; -1;","            };","        }","    };","","    Object.keys(fns).forEach(function(key) {","        Generator.arrayFnNames.forEach(function(fnName) {","            array[fnName + key] = Generator.createBoundFn(fnName, fns[key]);","        });","    });","}());"];

},{"./array":18,"./is":19}],27:[function(require,module,exports){
/* automatically generated by JSCoverage - do not edit */
if (typeof _$jscoverage === 'undefined') _$jscoverage = {};
if (! _$jscoverage['compare.js']) {
  _$jscoverage['compare.js'] = [];
  _$jscoverage['compare.js'][1] = 0;
  _$jscoverage['compare.js'][3] = 0;
  _$jscoverage['compare.js'][4] = 0;
  _$jscoverage['compare.js'][7] = 0;
  _$jscoverage['compare.js'][8] = 0;
  _$jscoverage['compare.js'][11] = 0;
  _$jscoverage['compare.js'][12] = 0;
  _$jscoverage['compare.js'][15] = 0;
  _$jscoverage['compare.js'][16] = 0;
  _$jscoverage['compare.js'][19] = 0;
  _$jscoverage['compare.js'][20] = 0;
  _$jscoverage['compare.js'][21] = 0;
  _$jscoverage['compare.js'][25] = 0;
  _$jscoverage['compare.js'][28] = 0;
  _$jscoverage['compare.js'][29] = 0;
  _$jscoverage['compare.js'][32] = 0;
  _$jscoverage['compare.js'][33] = 0;
  _$jscoverage['compare.js'][36] = 0;
  _$jscoverage['compare.js'][37] = 0;
  _$jscoverage['compare.js'][38] = 0;
  _$jscoverage['compare.js'][42] = 0;
  _$jscoverage['compare.js'][45] = 0;
  _$jscoverage['compare.js'][46] = 0;
  _$jscoverage['compare.js'][49] = 0;
  _$jscoverage['compare.js'][50] = 0;
  _$jscoverage['compare.js'][52] = 0;
  _$jscoverage['compare.js'][53] = 0;
  _$jscoverage['compare.js'][56] = 0;
  _$jscoverage['compare.js'][57] = 0;
  _$jscoverage['compare.js'][58] = 0;
  _$jscoverage['compare.js'][59] = 0;
  _$jscoverage['compare.js'][60] = 0;
  _$jscoverage['compare.js'][65] = 0;
  _$jscoverage['compare.js'][68] = 0;
  _$jscoverage['compare.js'][69] = 0;
  _$jscoverage['compare.js'][71] = 0;
  _$jscoverage['compare.js'][72] = 0;
  _$jscoverage['compare.js'][75] = 0;
  _$jscoverage['compare.js'][76] = 0;
  _$jscoverage['compare.js'][77] = 0;
  _$jscoverage['compare.js'][78] = 0;
  _$jscoverage['compare.js'][79] = 0;
  _$jscoverage['compare.js'][84] = 0;
  _$jscoverage['compare.js'][88] = 0;
  _$jscoverage['compare.js'][89] = 0;
  _$jscoverage['compare.js'][91] = 0;
  _$jscoverage['compare.js'][92] = 0;
  _$jscoverage['compare.js'][95] = 0;
  _$jscoverage['compare.js'][96] = 0;
  _$jscoverage['compare.js'][97] = 0;
  _$jscoverage['compare.js'][98] = 0;
  _$jscoverage['compare.js'][99] = 0;
  _$jscoverage['compare.js'][100] = 0;
  _$jscoverage['compare.js'][106] = 0;
  _$jscoverage['compare.js'][107] = 0;
  _$jscoverage['compare.js'][108] = 0;
  _$jscoverage['compare.js'][109] = 0;
  _$jscoverage['compare.js'][110] = 0;
  _$jscoverage['compare.js'][117] = 0;
  _$jscoverage['compare.js'][121] = 0;
  _$jscoverage['compare.js'][122] = 0;
  _$jscoverage['compare.js'][123] = 0;
  _$jscoverage['compare.js'][126] = 0;
  _$jscoverage['compare.js'][129] = 0;
  _$jscoverage['compare.js'][130] = 0;
  _$jscoverage['compare.js'][131] = 0;
  _$jscoverage['compare.js'][135] = 0;
  _$jscoverage['compare.js'][136] = 0;
  _$jscoverage['compare.js'][140] = 0;
  _$jscoverage['compare.js'][141] = 0;
  _$jscoverage['compare.js'][142] = 0;
  _$jscoverage['compare.js'][143] = 0;
  _$jscoverage['compare.js'][144] = 0;
  _$jscoverage['compare.js'][145] = 0;
  _$jscoverage['compare.js'][146] = 0;
  _$jscoverage['compare.js'][148] = 0;
  _$jscoverage['compare.js'][149] = 0;
  _$jscoverage['compare.js'][150] = 0;
  _$jscoverage['compare.js'][151] = 0;
  _$jscoverage['compare.js'][152] = 0;
  _$jscoverage['compare.js'][153] = 0;
  _$jscoverage['compare.js'][154] = 0;
  _$jscoverage['compare.js'][156] = 0;
  _$jscoverage['compare.js'][159] = 0;
  _$jscoverage['compare.js'][162] = 0;
  _$jscoverage['compare.js'][212] = 0;
  _$jscoverage['compare.js'][213] = 0;
  _$jscoverage['compare.js'][217] = 0;
  _$jscoverage['compare.js'][218] = 0;
  _$jscoverage['compare.js'][220] = 0;
  _$jscoverage['compare.js'][223] = 0;
  _$jscoverage['compare.js'][224] = 0;
}
_$jscoverage['compare.js'][1]++;
var is = require("./is");
_$jscoverage['compare.js'][3]++;
function _strict(val1, val2) {
  _$jscoverage['compare.js'][4]++;
  return val1 === val2;
}
_$jscoverage['compare.js'][7]++;
function _compareArrayLength(val1, val2) {
  _$jscoverage['compare.js'][8]++;
  return (is.isArray(val1) && is.isArray(val2) && val1.length === val2.length);
}
_$jscoverage['compare.js'][11]++;
function _shallowArray(val1, val2) {
  _$jscoverage['compare.js'][12]++;
  var i = 0, len;
  _$jscoverage['compare.js'][15]++;
  if (! _compareArrayLength(val1, val2)) {
    _$jscoverage['compare.js'][16]++;
    return false;
  }
  _$jscoverage['compare.js'][19]++;
  for (len = val1.length; i < len; ++i) {
    _$jscoverage['compare.js'][20]++;
    if (val1[i] !== val2[i]) {
      _$jscoverage['compare.js'][21]++;
      return false;
    }
}
  _$jscoverage['compare.js'][25]++;
  return true;
}
_$jscoverage['compare.js'][28]++;
function _deepArray(val1, val2, config) {
  _$jscoverage['compare.js'][29]++;
  var i = 0, len;
  _$jscoverage['compare.js'][32]++;
  if (! _compareArrayLength(val1, val2)) {
    _$jscoverage['compare.js'][33]++;
    return false;
  }
  _$jscoverage['compare.js'][36]++;
  for (len = val1.length; i < len; ++i) {
    _$jscoverage['compare.js'][37]++;
    if (! compare(val1[i], val2[i], config)) {
      _$jscoverage['compare.js'][38]++;
      return false;
    }
}
  _$jscoverage['compare.js'][42]++;
  return true;
}
_$jscoverage['compare.js'][45]++;
function _compareObjectKeysLength(val1, val2) {
  _$jscoverage['compare.js'][46]++;
  return (is.isObject(val1) && is.isObject(val2) && Object.keys(val1).length === Object.keys(val2).length);
}
_$jscoverage['compare.js'][49]++;
function _shallowObject(val1, val2) {
  _$jscoverage['compare.js'][50]++;
  var key, val;
  _$jscoverage['compare.js'][52]++;
  if (! _compareObjectKeysLength(val1, val2)) {
    _$jscoverage['compare.js'][53]++;
    return false;
  }
  _$jscoverage['compare.js'][56]++;
  for (key in val1) {
    _$jscoverage['compare.js'][57]++;
    if (val1.hasOwnProperty(key)) {
      _$jscoverage['compare.js'][58]++;
      value = val1[key];
      _$jscoverage['compare.js'][59]++;
      if (! val2.hasOwnProperty(key) || val2[key] !== value) {
        _$jscoverage['compare.js'][60]++;
        return false;
      }
    }
}
  _$jscoverage['compare.js'][65]++;
  return true;
}
_$jscoverage['compare.js'][68]++;
function _deepObject(val1, val2, config) {
  _$jscoverage['compare.js'][69]++;
  var key, val;
  _$jscoverage['compare.js'][71]++;
  if (! _compareObjectKeysLength(val1, val2)) {
    _$jscoverage['compare.js'][72]++;
    return false;
  }
  _$jscoverage['compare.js'][75]++;
  for (key in val1) {
    _$jscoverage['compare.js'][76]++;
    if (val1.hasOwnProperty(key)) {
      _$jscoverage['compare.js'][77]++;
      value = val1[key];
      _$jscoverage['compare.js'][78]++;
      if (! val2.hasOwnProperty(key) || compare(value, val2[key], config) !== true) {
        _$jscoverage['compare.js'][79]++;
        return false;
      }
    }
}
  _$jscoverage['compare.js'][84]++;
  return true;
}
_$jscoverage['compare.js'][88]++;
function _looseObject(val1, val2, config) {
  _$jscoverage['compare.js'][89]++;
  var key, val;
  _$jscoverage['compare.js'][91]++;
  if (! (is.isObject(val1) && is.isObject(val2))) {
    _$jscoverage['compare.js'][92]++;
    return false;
  }
  _$jscoverage['compare.js'][95]++;
  if (config.type === "looseRight") {
    _$jscoverage['compare.js'][96]++;
    for (key in val2) {
      _$jscoverage['compare.js'][97]++;
      if (val2.hasOwnProperty(key)) {
        _$jscoverage['compare.js'][98]++;
        value = val2[key];
        _$jscoverage['compare.js'][99]++;
        if (compare(value, val1[key], config) !== true) {
          _$jscoverage['compare.js'][100]++;
          return false;
        }
      }
}
  }
  else {
    _$jscoverage['compare.js'][106]++;
    for (key in val1) {
      _$jscoverage['compare.js'][107]++;
      if (val1.hasOwnProperty(key)) {
        _$jscoverage['compare.js'][108]++;
        value = val1[key];
        _$jscoverage['compare.js'][109]++;
        if (compare(value, val2[key], config) !== true) {
          _$jscoverage['compare.js'][110]++;
          return false;
        }
      }
}
  }
  _$jscoverage['compare.js'][117]++;
  return true;
}
_$jscoverage['compare.js'][121]++;
function _date(val1, val2) {
  _$jscoverage['compare.js'][122]++;
  if (is.isDate(val1) && is.isDate(val2)) {
    _$jscoverage['compare.js'][123]++;
    return val1.getTime() === val2.getTime();
  }
  _$jscoverage['compare.js'][126]++;
  return false;
}
_$jscoverage['compare.js'][129]++;
function _createBoundCompare(object, fn) {
  _$jscoverage['compare.js'][130]++;
  return (function (value) {
  _$jscoverage['compare.js'][131]++;
  return fn(object, value);
});
}
_$jscoverage['compare.js'][135]++;
function getCompareFn(object, c) {
  _$jscoverage['compare.js'][136]++;
  var compareFn = _strict, config = c || {}, type = config.type;
  _$jscoverage['compare.js'][140]++;
  if (type === "deep" || type === "loose" || type === "looseRight" || type === undefined) {
    _$jscoverage['compare.js'][141]++;
    if (is.isObject(object)) {
      _$jscoverage['compare.js'][142]++;
      compareFn = type === "loose" || type === "looseRight"? _looseObject: _deepObject;
    }
    else {
      _$jscoverage['compare.js'][143]++;
      if (is.isArray(object)) {
        _$jscoverage['compare.js'][144]++;
        compareFn = _deepArray;
      }
      else {
        _$jscoverage['compare.js'][145]++;
        if (is.isDate(object)) {
          _$jscoverage['compare.js'][146]++;
          compareFn = _date;
        }
      }
    }
  }
  else {
    _$jscoverage['compare.js'][148]++;
    if (type === "shallow") {
      _$jscoverage['compare.js'][149]++;
      if (is.isObject(object)) {
        _$jscoverage['compare.js'][150]++;
        compareFn = _shallowObject;
      }
      else {
        _$jscoverage['compare.js'][151]++;
        if (is.isArray(object)) {
          _$jscoverage['compare.js'][152]++;
          compareFn = _shallowArray;
        }
        else {
          _$jscoverage['compare.js'][153]++;
          if (is.isDate(object)) {
            _$jscoverage['compare.js'][154]++;
            compareFn = _date;
          }
        }
      }
    }
    else {
      _$jscoverage['compare.js'][156]++;
      if (type !== "strict") {
        _$jscoverage['compare.js'][159]++;
        throw new Error("You passed in an invalid comparison type");
      }
    }
  }
  _$jscoverage['compare.js'][162]++;
  return compareFn;
}
_$jscoverage['compare.js'][212]++;
function compare(val1, val2, config) {
  _$jscoverage['compare.js'][213]++;
  return getCompareFn(val1, config)(val1, val2, config);
}
_$jscoverage['compare.js'][217]++;
function createBoundCompareFn(object, c) {
  _$jscoverage['compare.js'][218]++;
  var compareFn = getCompareFn(object, c);
  _$jscoverage['compare.js'][220]++;
  return _createBoundCompare(object, compareFn);
}
_$jscoverage['compare.js'][223]++;
exports.compare = compare;
_$jscoverage['compare.js'][224]++;
exports.createBoundCompareFn = createBoundCompareFn;
_$jscoverage['compare.js'].source = ["var is = require('./is');","","function _strict(val1, val2){","    return val1 === val2;","}","","function _compareArrayLength(val1, val2) {","    return(is.isArray(val1) &amp;&amp; is.isArray(val2)  &amp;&amp; val1.length === val2.length);","}","","function _shallowArray(val1, val2) {","    var i = 0,","        len;","    ","    if(!_compareArrayLength(val1, val2)) {","        return false;","    }","","    for(len = val1.length; i &lt; len; ++i) {","        if(val1[i] !== val2[i]) {","            return false;","        }","    }","","    return true;","}","","function _deepArray(val1, val2, config) {","    var i = 0,","        len;","    ","    if(!_compareArrayLength(val1, val2)) {","        return false;","    }","","    for(len = val1.length; i &lt; len; ++i) {","        if(!compare(val1[i],val2[i], config)) {","            return false;","        }","    }","","    return true;","}","","function _compareObjectKeysLength(val1, val2) {","    return (is.isObject(val1) &amp;&amp; is.isObject(val2) &amp;&amp; Object.keys(val1).length === Object.keys(val2).length);","}","","function _shallowObject(val1, val2) {","    var key, val;","","    if (!_compareObjectKeysLength(val1, val2)) {","        return false;","    }","","    for (key in val1) {","        if (val1.hasOwnProperty(key)) {","            value = val1[key];","            if (!val2.hasOwnProperty(key) || val2[key] !== value) {","                return false;","            }","        }","    }","","    return true;","}","","function _deepObject(val1, val2, config) {","    var key, val;","","    if (!_compareObjectKeysLength(val1, val2)) {","        return false;","    }","","    for (key in val1) {","        if (val1.hasOwnProperty(key)) {","            value = val1[key];","            if (!val2.hasOwnProperty(key) || compare(value, val2[key], config) !== true) {","                return false;","            }","        }","    }","","    return true;","","}","","function _looseObject(val1, val2, config) {","    var key, val;","","    if(!(is.isObject(val1) &amp;&amp; is.isObject(val2))) {","        return false;","    }","","    if(config.type === 'looseRight') {","        for (key in val2) {","            if (val2.hasOwnProperty(key)) {","                value = val2[key];","                if (compare(value, val1[key], config) !== true) {","                    return false;","                }","            }","        }","    }","    else {","        for (key in val1) {","            if (val1.hasOwnProperty(key)) {","                value = val1[key];","                if (compare(value, val2[key], config) !== true) {","                    return false;","                }","            }","        }","    }","","","    return true;","","}","","function _date(val1, val2) {","    if(is.isDate(val1) &amp;&amp; is.isDate(val2)) {","        return val1.getTime() === val2.getTime();","    }","","    return false;","}","","function _createBoundCompare(object, fn) {","    return function(value) {","        return fn(object, value);","    };","}","","function getCompareFn(object, c) {","    var compareFn = _strict,","        config = c || {},","        type = config.type;","","    if (type === 'deep' || type === 'loose' || type === 'looseRight' || type === undefined) {","        if (is.isObject(object)) {","            compareFn = type === 'loose' || type === 'looseRight' ? _looseObject : _deepObject;","        } else if (is.isArray(object)) {","            compareFn = _deepArray;","        } else if (is.isDate(object)) {","            compareFn = _date;","        }","    } else if (type === 'shallow') {","        if (is.isObject(object)) {","            compareFn = _shallowObject;","        } else if (is.isArray(object)) {","            compareFn = _shallowArray;","        } else if (is.isDate(object)) {","            compareFn = _date;","        }","    } else if (type !== 'strict') {","        //we would be doing a strict comparison on a type-o","        //I think an error is good here.","        throw new Error('You passed in an invalid comparison type');","    }","","    return compareFn;","}","","/**"," * @member Luc"," * @method compare"," * "," * Return true if the values are equal to each"," * other.  By default a deep comparison is "," * done on arrays, dates and objects and a strict comparison"," * is done on other types."," * "," * @param  {Any} val1  "," * @param  {Any} val2   "," * @param  {Object} [config]"," * @param {String} config.type pass in 'shallow' for a shallow"," * comparison, 'deep' (default) for a deep comparison"," * 'strict' for a strict === comparison for all objects or "," * 'loose' for a loose comparison on objects.  A loose comparison"," *  will compare the keys and values of val1 to val2 and does not"," *  check if keys from val2 do not exist in val1."," *"," *","    Luc.compare('1', 1)","    &gt;false","    Luc.compare({a: 1}, {a: 1})","    &gt;true","    Luc.compare({a: 1, b: {}}, {a: 1, b: {} }, {type:'shallow'})","    &gt;false","    Luc.compare({a: 1, b: {}}, {a: 1, b: {} }, {type: 'deep'})","    &gt;true","    Luc.compare({a: 1, b: {}}, {a: 1, b: {} }, {type: 'strict'})","    &gt;false","    Luc.compare({a: 1}, {a:1,b:1})","    &gt;false","    Luc.compare({a: 1}, {a:1,b:1}, {type: 'loose'})","    &gt;true","    Luc.compare({a: 1}, {a:1,b:1}, {type: 'loose'})","    &gt;true","    Luc.compare([{a: 1}], [{a:1,b:1}], {type: 'loose'})","    &gt;true","    Luc.compare([{a: 1}, {}], [{a:1,b:1}], {type: 'loose'})","    &gt;false","    Luc.compare([{a: 1}, {}], [{a:1,b:1}, {}], {type: 'loose'})","    &gt;true","    Luc.compare([{a:1,b:1}], [{a: 1}], {type: 'loose'})","    &gt;false",""," * @return {Boolean}"," */","function compare(val1, val2, config) {","    return getCompareFn(val1, config)(val1, val2, config);","}","","","function createBoundCompareFn(object, c) {","    var compareFn = getCompareFn(object, c);","","    return _createBoundCompare(object, compareFn);","}","","exports.compare = compare;","exports.createBoundCompareFn = createBoundCompareFn;"];

},{"./is":19}],22:[function(require,module,exports){
/* automatically generated by JSCoverage - do not edit */
if (typeof _$jscoverage === 'undefined') _$jscoverage = {};
if (! _$jscoverage['class/base.js']) {
  _$jscoverage['class/base.js'] = [];
  _$jscoverage['class/base.js'][1] = 0;
  _$jscoverage['class/base.js'][61] = 0;
  _$jscoverage['class/base.js'][62] = 0;
  _$jscoverage['class/base.js'][63] = 0;
  _$jscoverage['class/base.js'][66] = 0;
  _$jscoverage['class/base.js'][72] = 0;
  _$jscoverage['class/base.js'][82] = 0;
}
_$jscoverage['class/base.js'][1]++;
var emptyFn = require("../function").emptyFn, apply = require("../object").apply;
_$jscoverage['class/base.js'][61]++;
function Base() {
  _$jscoverage['class/base.js'][62]++;
  this.beforeInit.apply(this, arguments);
  _$jscoverage['class/base.js'][63]++;
  this.init();
}
_$jscoverage['class/base.js'][66]++;
Base.prototype = {beforeInit: (function (config) {
  _$jscoverage['class/base.js'][72]++;
  apply(this, config);
}), init: emptyFn};
_$jscoverage['class/base.js'][82]++;
module.exports = Base;
_$jscoverage['class/base.js'].source = ["var emptyFn = require('../function').emptyFn,","    apply = require('../object').apply;","","/**"," * @class Luc.Base"," * Simple class that by default {@link Luc#apply applies} the "," * first argument to the instance and then calls"," * Luc.Base.init."," *","    var b = new Luc.Base({","        a: 1,","        init: function() {","            console.log('hey')","        }","    })","    b.a","    &gt;hey","    &gt;1"," *"," * We found that most of our classes do this so we made"," * it the default.  Having a config object as the first and only "," * param keeps a clean api as well."," *","    var C = Luc.define({","        init: function() {","            Luc.Array.each(this.items, this.logItems)","        },","","        logItems: function(item) {","            console.log(item);","        }","    });","","    var c = new C({items: [1,2,3]});","    &gt;1","    &gt;2","    &gt;3","    var d = new C({items: 'A'});","    &gt;'A'","    var e = new C();"," *"," * If you don't like the applying of the config to the instance it "," * can always be \"disabled\""," *","    var NoApply = Luc.define({","        beforeInit: function() {","","        },","        init: function() {","            Luc.Array.each(this.items, this.logItems)","        },","","        logItems: function(item) {","            console.log(item);","        }","    });","","    var c = new NoApply({items: [1,2,3]});"," * "," */","function Base() {","    this.beforeInit.apply(this, arguments);","    this.init();","}","","Base.prototype = {","    /**","     * By default apply the config to the ","     * instance.","     */","    beforeInit: function(config) {","        apply(this, config);","    },","    /**","     * @method","     * Simple hook to initialize","     * the class.  Defaults to Luc.emptyFn","     */","    init: emptyFn","};","","module.exports = Base;"];

},{"../function":16,"../object":17}],23:[function(require,module,exports){
/* automatically generated by JSCoverage - do not edit */
if (typeof _$jscoverage === 'undefined') _$jscoverage = {};
if (! _$jscoverage['class/plugin.js']) {
  _$jscoverage['class/plugin.js'] = [];
  _$jscoverage['class/plugin.js'][1] = 0;
  _$jscoverage['class/plugin.js'][10] = 0;
  _$jscoverage['class/plugin.js'][11] = 0;
  _$jscoverage['class/plugin.js'][14] = 0;
  _$jscoverage['class/plugin.js'][29] = 0;
}
_$jscoverage['class/plugin.js'][1]++;
var aEach = require("../array").each, obj = require("../object"), emptyFn = require("../function").emptyFn, apply = obj.apply;
_$jscoverage['class/plugin.js'][10]++;
function Plugin(config) {
  _$jscoverage['class/plugin.js'][11]++;
  apply(this, config);
}
_$jscoverage['class/plugin.js'][14]++;
Plugin.prototype = {init: emptyFn, destroy: emptyFn};
_$jscoverage['class/plugin.js'][29]++;
module.exports = Plugin;
_$jscoverage['class/plugin.js'].source = ["var aEach = require('../array').each,","    obj = require('../object'),","    emptyFn = require('../function').emptyFn,","    apply = obj.apply;","","/**"," * @class Luc.Plugin"," * Simple class that is the default plugin type for Luc.PluginManager"," */","function Plugin(config) {","    apply(this, config);","}","","Plugin.prototype = {","    /**","     * @method","     * @param {Object} owner the owner instance","     * Simple hook to initialize the plugin","     * Defaults to Luc.emptyFn.","     */","    init: emptyFn,","    /**","     * @method Defaults to Luc.emptyFn.","     * Called when the plugin is being {@link Luc.PluginManager#destroyPlugin destroyed}.","     */","    destroy: emptyFn","};","","module.exports = Plugin;"];

},{"../array":18,"../object":17,"../function":16}],24:[function(require,module,exports){
/* automatically generated by JSCoverage - do not edit */
if (typeof _$jscoverage === 'undefined') _$jscoverage = {};
if (! _$jscoverage['class/definer.js']) {
  _$jscoverage['class/definer.js'] = [];
  _$jscoverage['class/definer.js'][1] = 0;
  _$jscoverage['class/definer.js'][36] = 0;
  _$jscoverage['class/definer.js'][50] = 0;
  _$jscoverage['class/definer.js'][55] = 0;
  _$jscoverage['class/definer.js'][57] = 0;
  _$jscoverage['class/definer.js'][59] = 0;
  _$jscoverage['class/definer.js'][61] = 0;
  _$jscoverage['class/definer.js'][65] = 0;
  _$jscoverage['class/definer.js'][68] = 0;
  _$jscoverage['class/definer.js'][69] = 0;
  _$jscoverage['class/definer.js'][72] = 0;
  _$jscoverage['class/definer.js'][76] = 0;
  _$jscoverage['class/definer.js'][79] = 0;
  _$jscoverage['class/definer.js'][80] = 0;
  _$jscoverage['class/definer.js'][82] = 0;
  _$jscoverage['class/definer.js'][83] = 0;
  _$jscoverage['class/definer.js'][86] = 0;
  _$jscoverage['class/definer.js'][87] = 0;
  _$jscoverage['class/definer.js'][91] = 0;
  _$jscoverage['class/definer.js'][95] = 0;
  _$jscoverage['class/definer.js'][99] = 0;
  _$jscoverage['class/definer.js'][105] = 0;
  _$jscoverage['class/definer.js'][106] = 0;
  _$jscoverage['class/definer.js'][110] = 0;
  _$jscoverage['class/definer.js'][111] = 0;
  _$jscoverage['class/definer.js'][112] = 0;
  _$jscoverage['class/definer.js'][116] = 0;
  _$jscoverage['class/definer.js'][120] = 0;
  _$jscoverage['class/definer.js'][124] = 0;
  _$jscoverage['class/definer.js'][125] = 0;
  _$jscoverage['class/definer.js'][127] = 0;
  _$jscoverage['class/definer.js'][128] = 0;
  _$jscoverage['class/definer.js'][129] = 0;
  _$jscoverage['class/definer.js'][134] = 0;
  _$jscoverage['class/definer.js'][137] = 0;
  _$jscoverage['class/definer.js'][138] = 0;
  _$jscoverage['class/definer.js'][141] = 0;
  _$jscoverage['class/definer.js'][142] = 0;
  _$jscoverage['class/definer.js'][147] = 0;
  _$jscoverage['class/definer.js'][150] = 0;
  _$jscoverage['class/definer.js'][151] = 0;
  _$jscoverage['class/definer.js'][154] = 0;
  _$jscoverage['class/definer.js'][155] = 0;
  _$jscoverage['class/definer.js'][156] = 0;
  _$jscoverage['class/definer.js'][160] = 0;
  _$jscoverage['class/definer.js'][164] = 0;
  _$jscoverage['class/definer.js'][165] = 0;
  _$jscoverage['class/definer.js'][169] = 0;
  _$jscoverage['class/definer.js'][176] = 0;
  _$jscoverage['class/definer.js'][177] = 0;
  _$jscoverage['class/definer.js'][178] = 0;
  _$jscoverage['class/definer.js'][184] = 0;
  _$jscoverage['class/definer.js'][188] = 0;
  _$jscoverage['class/definer.js'][189] = 0;
  _$jscoverage['class/definer.js'][191] = 0;
  _$jscoverage['class/definer.js'][192] = 0;
  _$jscoverage['class/definer.js'][198] = 0;
  _$jscoverage['class/definer.js'][199] = 0;
  _$jscoverage['class/definer.js'][201] = 0;
  _$jscoverage['class/definer.js'][202] = 0;
  _$jscoverage['class/definer.js'][207] = 0;
  _$jscoverage['class/definer.js'][209] = 0;
  _$jscoverage['class/definer.js'][211] = 0;
  _$jscoverage['class/definer.js'][212] = 0;
  _$jscoverage['class/definer.js'][217] = 0;
  _$jscoverage['class/definer.js'][220] = 0;
  _$jscoverage['class/definer.js'][221] = 0;
  _$jscoverage['class/definer.js'][225] = 0;
  _$jscoverage['class/definer.js'][227] = 0;
  _$jscoverage['class/definer.js'][229] = 0;
  _$jscoverage['class/definer.js'][230] = 0;
  _$jscoverage['class/definer.js'][231] = 0;
  _$jscoverage['class/definer.js'][235] = 0;
  _$jscoverage['class/definer.js'][236] = 0;
  _$jscoverage['class/definer.js'][243] = 0;
  _$jscoverage['class/definer.js'][245] = 0;
  _$jscoverage['class/definer.js'][246] = 0;
  _$jscoverage['class/definer.js'][247] = 0;
  _$jscoverage['class/definer.js'][248] = 0;
  _$jscoverage['class/definer.js'][253] = 0;
  _$jscoverage['class/definer.js'][254] = 0;
  _$jscoverage['class/definer.js'][255] = 0;
  _$jscoverage['class/definer.js'][267] = 0;
  _$jscoverage['class/definer.js'][268] = 0;
  _$jscoverage['class/definer.js'][271] = 0;
  _$jscoverage['class/definer.js'][272] = 0;
  _$jscoverage['class/definer.js'][278] = 0;
  _$jscoverage['class/definer.js'][280] = 0;
  _$jscoverage['class/definer.js'][288] = 0;
  _$jscoverage['class/definer.js'][292] = 0;
  _$jscoverage['class/definer.js'][296] = 0;
  _$jscoverage['class/definer.js'][298] = 0;
  _$jscoverage['class/definer.js'][299] = 0;
  _$jscoverage['class/definer.js'][300] = 0;
  _$jscoverage['class/definer.js'][301] = 0;
  _$jscoverage['class/definer.js'][305] = 0;
  _$jscoverage['class/definer.js'][310] = 0;
  _$jscoverage['class/definer.js'][312] = 0;
}
_$jscoverage['class/definer.js'][1]++;
var Base = require("./base"), Composition = require("./composition"), obj = require("../object"), arrayFns = require("../array"), emptyFn = require("../function").emptyFn, is = require("../is"), aEach = arrayFns.each, apply = obj.apply, oEach = obj.each, oFilter = obj.filter, mix = obj.mix, arraySlice = Array.prototype.slice, ClassDefiner;
_$jscoverage['class/definer.js'][36]++;
ClassDefiner = {COMPOSITIONS_NAME: "$compositions", defaultType: Base, processorKeys: {$mixins: "_applyMixins", $statics: "_applyStatics", $compositions: "_applyComposerMethods", $super: "_applySuper"}, define: (function (opts) {
  _$jscoverage['class/definer.js'][50]++;
  var options = opts || {}, Super = options.$super || (options.$super === undefined? this.defaultType: false), Constructor;
  _$jscoverage['class/definer.js'][55]++;
  options.$super = Super;
  _$jscoverage['class/definer.js'][57]++;
  Constructor = this._createConstructor(options);
  _$jscoverage['class/definer.js'][59]++;
  this._processAfterCreate(Constructor, options);
  _$jscoverage['class/definer.js'][61]++;
  return Constructor;
}), _createConstructor: (function (options) {
  _$jscoverage['class/definer.js'][65]++;
  var superclass = options.$super, Constructor = this._createConstructorFn(options);
  _$jscoverage['class/definer.js'][68]++;
  if (superclass) {
    _$jscoverage['class/definer.js'][69]++;
    Constructor.prototype = Object.create(superclass.prototype);
  }
  _$jscoverage['class/definer.js'][72]++;
  return Constructor;
}), _createConstructorFn: (function (options) {
  _$jscoverage['class/definer.js'][76]++;
  var superclass = options.$super, Constructor;
  _$jscoverage['class/definer.js'][79]++;
  if (this._hasConstructorModifyingOptions(options)) {
    _$jscoverage['class/definer.js'][80]++;
    Constructor = this._createConstructorFromOptions(options);
  }
  else {
    _$jscoverage['class/definer.js'][82]++;
    if (! superclass) {
      _$jscoverage['class/definer.js'][83]++;
      Constructor = (function () {
});
    }
    else {
      _$jscoverage['class/definer.js'][86]++;
      Constructor = (function () {
  _$jscoverage['class/definer.js'][87]++;
  superclass.apply(this, arguments);
});
    }
  }
  _$jscoverage['class/definer.js'][91]++;
  return Constructor;
}), _hasConstructorModifyingOptions: (function (options) {
  _$jscoverage['class/definer.js'][95]++;
  return options.$compositions;
}), _createConstructorFromOptions: (function (options) {
  _$jscoverage['class/definer.js'][99]++;
  var superclass = options.$super, me = this, initBeforeSuperclass, initAfterSuperclass, init;
  _$jscoverage['class/definer.js'][105]++;
  if (! superclass) {
    _$jscoverage['class/definer.js'][106]++;
    init = this._createInitClassFn(options, {all: true});
    _$jscoverage['class/definer.js'][110]++;
    return (function () {
  _$jscoverage['class/definer.js'][111]++;
  var args = arraySlice.call(arguments);
  _$jscoverage['class/definer.js'][112]++;
  init.call(this, options, args);
});
  }
  _$jscoverage['class/definer.js'][116]++;
  initBeforeSuperclass = this._createInitClassFn(options, {before: true});
  _$jscoverage['class/definer.js'][120]++;
  initAfterSuperclass = this._createInitClassFn(options, {before: false});
  _$jscoverage['class/definer.js'][124]++;
  return (function () {
  _$jscoverage['class/definer.js'][125]++;
  var args = arraySlice.call(arguments);
  _$jscoverage['class/definer.js'][127]++;
  initBeforeSuperclass.call(this, options, args);
  _$jscoverage['class/definer.js'][128]++;
  superclass.apply(this, arguments);
  _$jscoverage['class/definer.js'][129]++;
  initAfterSuperclass.call(this, options, args);
});
}), _createInitClassFn: (function (options, config) {
  _$jscoverage['class/definer.js'][134]++;
  var me = this, compositions = this._filterCompositions(config, options.$compositions);
  _$jscoverage['class/definer.js'][137]++;
  if (compositions.length === 0) {
    _$jscoverage['class/definer.js'][138]++;
    return emptyFn;
  }
  _$jscoverage['class/definer.js'][141]++;
  return (function (options, instanceArgs) {
  _$jscoverage['class/definer.js'][142]++;
  me._initCompositions.call(this, compositions, instanceArgs);
});
}), _filterCompositions: (function (config, compositions) {
  _$jscoverage['class/definer.js'][147]++;
  var before = config.before, filtered = [];
  _$jscoverage['class/definer.js'][150]++;
  if (config.all) {
    _$jscoverage['class/definer.js'][151]++;
    return compositions;
  }
  _$jscoverage['class/definer.js'][154]++;
  aEach(compositions, (function (composition) {
  _$jscoverage['class/definer.js'][155]++;
  if (before && composition.initAfter !== true || (! before && composition.initAfter === true)) {
    _$jscoverage['class/definer.js'][156]++;
    filtered.push(composition);
  }
}));
  _$jscoverage['class/definer.js'][160]++;
  return filtered;
}), _processAfterCreate: (function ($class, options) {
  _$jscoverage['class/definer.js'][164]++;
  this._applyValuesToProto($class, options);
  _$jscoverage['class/definer.js'][165]++;
  this._handlePostProcessors($class, options);
}), _applyValuesToProto: (function ($class, options) {
  _$jscoverage['class/definer.js'][169]++;
  var proto = $class.prototype, values = apply({$class: $class}, options);
  _$jscoverage['class/definer.js'][176]++;
  oEach(values, (function (key, value) {
  _$jscoverage['class/definer.js'][177]++;
  if (! this._getProcessorKey(key)) {
    _$jscoverage['class/definer.js'][178]++;
    proto[key] = value;
  }
}), this);
}), _getProcessorKey: (function (key) {
  _$jscoverage['class/definer.js'][184]++;
  return this.processorKeys[key];
}), _handlePostProcessors: (function ($class, options) {
  _$jscoverage['class/definer.js'][188]++;
  oEach(options, (function (key, value) {
  _$jscoverage['class/definer.js'][189]++;
  var method = this._getProcessorKey(key);
  _$jscoverage['class/definer.js'][191]++;
  if (is.isFunction(this[method])) {
    _$jscoverage['class/definer.js'][192]++;
    this[method].call(this, $class, options[key]);
  }
}), this);
}), _applyMixins: (function ($class, mixins) {
  _$jscoverage['class/definer.js'][198]++;
  var proto = $class.prototype;
  _$jscoverage['class/definer.js'][199]++;
  aEach(mixins, (function (mixin) {
  _$jscoverage['class/definer.js'][201]++;
  var toMix = mixin.prototype || mixin;
  _$jscoverage['class/definer.js'][202]++;
  mix(proto, toMix);
}));
}), _applyStatics: (function ($class, statics) {
  _$jscoverage['class/definer.js'][207]++;
  var prototype = $class.prototype;
  _$jscoverage['class/definer.js'][209]++;
  apply($class, statics);
  _$jscoverage['class/definer.js'][211]++;
  if (prototype.getStaticValue === undefined) {
    _$jscoverage['class/definer.js'][212]++;
    prototype.getStaticValue = this.getStaticValue;
  }
}), _applyComposerMethods: (function ($class, compositions) {
  _$jscoverage['class/definer.js'][217]++;
  var prototype = $class.prototype, methodsToCompose;
  _$jscoverage['class/definer.js'][220]++;
  aEach(compositions, (function (compositionConfig) {
  _$jscoverage['class/definer.js'][221]++;
  var composition = new Composition(compositionConfig), name = composition.name, Constructor = composition.Constructor;
  _$jscoverage['class/definer.js'][225]++;
  composition.validate();
  _$jscoverage['class/definer.js'][227]++;
  methodsToCompose = composition.getMethodsToCompose();
  _$jscoverage['class/definer.js'][229]++;
  methodsToCompose.forEach((function (key) {
  _$jscoverage['class/definer.js'][230]++;
  if (prototype[key] === undefined) {
    _$jscoverage['class/definer.js'][231]++;
    prototype[key] = this._createComposerProtoFn(key, name);
  }
}), this);
  _$jscoverage['class/definer.js'][235]++;
  if (prototype.getComposition === undefined) {
    _$jscoverage['class/definer.js'][236]++;
    prototype.getComposition = this.getComposition;
  }
}), this);
}), _applySuper: (function ($class, $super) {
  _$jscoverage['class/definer.js'][243]++;
  var proto;
  _$jscoverage['class/definer.js'][245]++;
  if ($super) {
    _$jscoverage['class/definer.js'][246]++;
    proto = $class.prototype;
    _$jscoverage['class/definer.js'][247]++;
    proto.$super = $super;
    _$jscoverage['class/definer.js'][248]++;
    proto.$superclass = $super.prototype;
  }
}), _createComposerProtoFn: (function (methodName, compositionName) {
  _$jscoverage['class/definer.js'][253]++;
  return (function () {
  _$jscoverage['class/definer.js'][254]++;
  var comp = this[ClassDefiner.COMPOSITIONS_NAME][compositionName];
  _$jscoverage['class/definer.js'][255]++;
  return comp[methodName].apply(comp, arguments);
});
}), _initCompositions: (function (compositions, instanceArgs) {
  _$jscoverage['class/definer.js'][267]++;
  if (! this[ClassDefiner.COMPOSITIONS_NAME]) {
    _$jscoverage['class/definer.js'][268]++;
    this[ClassDefiner.COMPOSITIONS_NAME] = {};
  }
  _$jscoverage['class/definer.js'][271]++;
  aEach(compositions, (function (compositionConfig) {
  _$jscoverage['class/definer.js'][272]++;
  var config = apply({instance: this, instanceArgs: instanceArgs}, compositionConfig), composition;
  _$jscoverage['class/definer.js'][278]++;
  composition = new Composition(config);
  _$jscoverage['class/definer.js'][280]++;
  this[ClassDefiner.COMPOSITIONS_NAME][composition.name] = composition.getInstance();
}), this);
}), getComposition: (function (key) {
  _$jscoverage['class/definer.js'][288]++;
  return this[ClassDefiner.COMPOSITIONS_NAME][key];
}), getStaticValue: (function (key, $class) {
  _$jscoverage['class/definer.js'][292]++;
  var classToFindValue = $class || this.$class, $super, value;
  _$jscoverage['class/definer.js'][296]++;
  value = classToFindValue[key];
  _$jscoverage['class/definer.js'][298]++;
  if (value === undefined) {
    _$jscoverage['class/definer.js'][299]++;
    $super = classToFindValue.prototype.$super;
    _$jscoverage['class/definer.js'][300]++;
    if ($super) {
      _$jscoverage['class/definer.js'][301]++;
      return this.getStaticValue(key, $super);
    }
  }
  _$jscoverage['class/definer.js'][305]++;
  return value;
})};
_$jscoverage['class/definer.js'][310]++;
ClassDefiner.define = ClassDefiner.define.bind(ClassDefiner);
_$jscoverage['class/definer.js'][312]++;
module.exports = ClassDefiner;
_$jscoverage['class/definer.js'].source = ["var Base = require('./base'),","    Composition = require('./composition'),","    obj = require('../object'),","    arrayFns = require('../array'),","    emptyFn = require('../function').emptyFn,","    is = require('../is'),","    aEach = arrayFns.each,","    apply = obj.apply,","    oEach = obj.each,","    oFilter = obj.filter,","    mix = obj.mix,","    arraySlice = Array.prototype.slice,","    ClassDefiner;","","/**"," * @class Luc.ClassDefiner"," * @singleton"," *"," * Singleton that {@link Luc.define#define Luc.define} uses to define classes.  The defualt type can"," * be changed to any Constructor"," *","    function MyClass(){};","    Luc.ClassDefiner.defaultType = MyClass;","    var C = Luc.define();","    new C() instanceof Luc.Base","    &gt;false","    new C() instanceof MyClass","    &gt;true"," */","","/**"," * @cfg {Function} defaultType this can be changed to any Constructor.  Defaults"," * to Luc.Base."," */","","ClassDefiner = {","","    COMPOSITIONS_NAME: '$compositions',","","    defaultType: Base,","","    processorKeys: {","        $mixins: '_applyMixins',","        $statics: '_applyStatics',","        $compositions: '_applyComposerMethods',","        $super: '_applySuper'","    },","","    define: function(opts) {","        var options = opts || {},","            //if super is a falsy value besides undefined that means no superclass","            Super = options.$super || (options.$super === undefined ? this.defaultType : false),","            Constructor;","","        options.$super = Super;","","        Constructor = this._createConstructor(options);","","        this._processAfterCreate(Constructor, options);","","        return Constructor;","    },","","    _createConstructor: function(options) {","        var superclass = options.$super,","            Constructor = this._createConstructorFn(options);","","        if(superclass) {","            Constructor.prototype = Object.create(superclass.prototype);","        }","        ","        return Constructor;","    },","","    _createConstructorFn: function(options) {","        var superclass = options.$super,","            Constructor;","","        if (this._hasConstructorModifyingOptions(options)) {","            Constructor = this._createConstructorFromOptions(options);","        }","        else if(!superclass) {","            Constructor = function() {};","        }","        else {","            Constructor = function() {","                superclass.apply(this, arguments);","            };","        }","","        return Constructor;","    },","","    _hasConstructorModifyingOptions: function(options) {","        return options.$compositions;","    },","","    _createConstructorFromOptions: function(options) {","        var superclass = options.$super,","            me = this,","            initBeforeSuperclass,","            initAfterSuperclass,","            init;","","        if (!superclass) {","            init = this._createInitClassFn(options, {","                all: true","            });","","            return function() {","                var args = arraySlice.call(arguments);","                init.call(this, options, args);","            };","        }","","        initBeforeSuperclass = this._createInitClassFn(options, {","            before: true","        });","","        initAfterSuperclass = this._createInitClassFn(options, {","            before: false","        });","","        return function() {","            var args = arraySlice.call(arguments);","","            initBeforeSuperclass.call(this, options, args);","            superclass.apply(this, arguments);","            initAfterSuperclass.call(this, options, args);","        };","    },","","    _createInitClassFn: function(options, config) {","        var me = this,","            compositions = this._filterCompositions(config, options.$compositions);","","        if(compositions.length === 0) {","            return emptyFn;","        }","        ","        return function(options, instanceArgs) {","            me._initCompositions.call(this, compositions, instanceArgs);","        };","    },","","    _filterCompositions: function(config, compositions) {","        var before = config.before, ","            filtered = [];","","        if(config.all) {","            return compositions;","        }","","        aEach(compositions, function(composition) {","            if(before &amp;&amp; composition.initAfter !== true || (!before &amp;&amp; composition.initAfter === true)) {","                    filtered.push(composition);","            }","        });","","        return filtered;","    },","","    _processAfterCreate: function($class, options) {","        this._applyValuesToProto($class, options);","        this._handlePostProcessors($class, options);","    },","","    _applyValuesToProto: function($class, options) {","        var proto = $class.prototype,","            values = apply({","                $class: $class","            }, options);","","        //Don't put the define specific properties","        //on the prototype","        oEach(values, function(key, value) {","            if (!this._getProcessorKey(key)) {","                proto[key] = value;","            }","        }, this);","    },","","    _getProcessorKey: function(key) {","        return this.processorKeys[key];","    },","","    _handlePostProcessors: function($class, options) {","        oEach(options, function(key, value) {","            var method = this._getProcessorKey(key);","","            if (is.isFunction(this[method])) {","                this[method].call(this, $class, options[key]);","            }","        }, this);","    },","","    _applyMixins: function($class, mixins) {","        var proto = $class.prototype;","        aEach(mixins, function(mixin) {","            //accept Constructors or Objects","            var toMix = mixin.prototype || mixin;","            mix(proto, toMix);","        });","    },","","    _applyStatics: function($class, statics) {","        var prototype = $class.prototype;","","        apply($class, statics);","","        if(prototype.getStaticValue === undefined) {","            prototype.getStaticValue = this.getStaticValue;","        }","    },","","    _applyComposerMethods: function($class, compositions) {","        var prototype = $class.prototype,","            methodsToCompose;","","        aEach(compositions, function(compositionConfig) {","            var composition = new Composition(compositionConfig),","                name = composition.name,","                Constructor = composition.Constructor;","","            composition.validate();","","            methodsToCompose = composition.getMethodsToCompose();","","            methodsToCompose.forEach(function(key) {","                if (prototype[key] === undefined) {","                    prototype[key] = this._createComposerProtoFn(key, name);","                }","            }, this);","","            if(prototype.getComposition === undefined) {","                prototype.getComposition = this.getComposition;","            }","","        }, this);","    },","","    _applySuper: function($class, $super) {","        var proto;","        //super can be falsy to signify no superclass","        if ($super) {","            proto = $class.prototype;","            proto.$super = $super;","            proto.$superclass = $super.prototype;","        }","    },","","    _createComposerProtoFn: function(methodName, compositionName) {","        return function() {","            var comp = this[ClassDefiner.COMPOSITIONS_NAME][compositionName];","            return comp[methodName].apply(comp, arguments);","        };","    },","","    /**","     * @private","     * @ignore","     * options {Object} the composition config object","     * instanceArgs {Array} the arguments passed to the instance's","     * constructor.","     */","    _initCompositions: function(compositions, instanceArgs) {","        if(!this[ClassDefiner.COMPOSITIONS_NAME]) {","            this[ClassDefiner.COMPOSITIONS_NAME] = {};","        }","","        aEach(compositions, function(compositionConfig) {","            var config = apply({","                instance: this,","                instanceArgs: instanceArgs","            }, compositionConfig), ","            composition;","","            composition = new Composition(config);","","            this[ClassDefiner.COMPOSITIONS_NAME][composition.name] = composition.getInstance();","        }, this);","    },","","    //Methods that can get added to the prototype","    //they will be called in the context of the instance.","    //","    getComposition: function(key) {","        return this[ClassDefiner.COMPOSITIONS_NAME][key];","    },","","    getStaticValue: function (key, $class) {","        var classToFindValue = $class || this.$class,","            $super,","            value;","","        value = classToFindValue[key];","","        if(value === undefined) {","            $super = classToFindValue.prototype.$super;","            if($super) {","                return this.getStaticValue(key, $super);","            }","        }","","        return value;","    }","","};","","ClassDefiner.define = ClassDefiner.define.bind(ClassDefiner);","","module.exports = ClassDefiner;","","/**"," * @class  Luc.define"," * This is actually a function but has a decent amount of important options"," * so we are documenting it like it is a class.  Properties are things that will get"," * applied to instances of classes defined with {@link Luc.define#define define}.  None"," * are needed for {@link Luc.define#define defining} a class.  {@link Luc.define#define define}"," * just takes the passed in config and puts the properties on the prototype and returns"," * a Constructor."," *","","    var C = Luc.define({","        a: 1,","        doLog: true,","        logA: function() {","            if (this.doLog) {","                console.log(this.a);","            }","        }","    });","    var c = new C();","    c.logA();","    &gt;1","    c.a = 45;","    c.logA();","    &gt;45","    c.doLog = false;","    c.logA();","","    new C().logA()","    &gt;1",""," *"," * Check out the following configs to add functionality to a class without messing"," * up the inheritance chain.  All the configs have examples and documentation on "," * how to use them."," *"," * {@link Luc.define#$super super} &lt;br&gt;"," * {@link Luc.define#$compositions compositions} &lt;br&gt;"," * {@link Luc.define#$mixins mixins} &lt;br&gt;"," * {@link Luc.define#$statics statics} &lt;br&gt;"," * "," * "," */","","/**"," * @method  define"," * @param {Object} config config object used when creating the class.  Any property that"," * is not apart of the special configs will be applied to the prototype.  Check out"," * Luc.define for all the config options.   No configs are needed to define a class."," * "," * @return {Function} the defined class"," *","    var C = Luc.define({","        logA: function() {","            console.log(this.a)","        },","        a: 1","    });","    var c = new C();","    c.logA();","    &gt;1","","    c.a = 4;","    c.logA();","    &gt;4"," *"," *"," */","","/**"," * @property {Function} $class reference to the instances own constructor.  This"," * will get added to any class that is defined with Luc.define."," * ","    var C = Luc.define()","    var c = new C()","    c.$class === C","    &gt;true"," *"," * There are some really good use cases to have a reference to it's"," * own constructor.  &lt;br&gt; Add functionality to an instance in a simple"," * and generic way."," *","    var C = Luc.define({","        add: function(a,b) {","            return a + b;","        }","    });","","    //Luc.Base applies first ","    //arg to the instance","","    var c = new C({","        add: function(a,b,c) {","            return this.$class.prototype.add.call(this, a,b) + c;","        }","    });","","    c.add(1,2,3)","    &gt;6","    new C().add(1,2,3)","    &gt;3"," *"," * Or have a simple generic clone method :"," *","    var C = Luc.define({","        clone: function() {","            var myOwnProps = {};","            Luc.Object.each(this, function(key, value) {","                myOwnProps[key] = value;","            });","","            return new this.$class(myOwnProps);","        }","    });","","    var c = new C({a:1,b:2,c:3});","    c.d = 4;","    var clone = c.clone();","","    clone === c","    &gt;false","","    clone.a","    &gt;1","    clone.b","    &gt;2","    clone.c","    &gt;3","    clone.d","    &gt;4"," */","","/**"," * @property {Function} [$super] If $super is not false or null "," * the $super property will be added to every instance of the defined class,"," * $super is the Constructor passed in with the $super config or the {@link Luc.ClassDefiner#defaultType default}"," * ","    var C = Luc.define()","    var c = new C()","    //Luc.Base is the default ","    c.$super === Luc.Base","    &gt;true"," */","","/**"," * @property {Function} [$superclass] If $super is defined it"," * will be the prototype of $super.  It can be used to call a parent's"," * method"," * ","    function MyCoolClass() {}","    MyCoolClass.prototype.addNums = function(a,b) {","        return a + b;","    }","","    var MyOtherCoolClass = Luc.define({","        $super: MyCoolClass,","        addNums: function(a, b, c) {","            return this.$superclass.addNums.call(this, a, b) + c;","        }","    })","","    var m = new MyOtherCoolClass();","    m.addNums(1,2,3);","    &gt;6"," */","","/**"," * @property {Function} getStaticValue this method"," * will be added to instances that use the $statics"," * config."," *"," * "," * This should be used over this.$class.staticName to"," * get the value of static.  If the class gets inherited"," * from, this.$class will not be the same.  getStatic value"," * deals with this issue."," * ","    var A = Luc.define({","        $statics: {","            a: 1","            },","        getABetter: function() {","            return this.getStaticValue('a');","        },","        getA: function() {","            return this.$class.a;","        }","    });","","    var B = Luc.define({","        $super: A,","        $statics: {","            b: 2,","            c: 3","        }","    });","","    ","    var b = new B();","    b.getA();","    &gt;undefined","    b.getABetter();","    &gt;1",""," * @return {Object} the static value of the key"," */","","    ","/**"," * @property {Function} getComposition this method will be"," * to instances that use the $compositions config"," *"," * @param  {String} name the game of the composition to"," * get."," */","","","/**"," * @cfg {Object} $statics (optional) Add static properties or methods"," * to the class.  These properties/methods will not be able to be"," * directly modified by the instance so they are good for defining default"," * configs.  "," *","    var C = Luc.define({","        $statics: {","            number: 1","        }","    });","","    var c = new C();","    c.number","    &gt;undefined","    C.number","    &gt;1","    "," *"," * Bad things can happen if non primitives are placed on the "," * prototype and instance sharing is not wanted.  Using statics"," * prevent subclasses and instances from unknowingly modifying"," * all instances."," * ","    var C = Luc.define({","        cfg: {","            a: 1","        }","    });","","    var c = new C();","    c.cfg.a","    &gt;1","    c.cfg.a = 5","    new C().cfg.a","    &gt;5"," *"," */","","/**"," * @property {Function} [$superclass] If $super is defined it"," * will the prototype of $super.  It can be used to call parent's"," * method"," * ","    function MyCoolClass() {}","    MyCoolClass.prototype.addNums = function(a,b) {","        return a + b;","    }","","    var MyOtherCoolClass = Luc.define({","        $super: MyCoolClass,","        addNums: function(a, b, c) {","            return this.$superclass.addNums.call(this, a, b) + c;","        }","    })","","    var m = new MyOtherCoolClass();","    m.addNums(1,2,3);","    &gt;6"," */","","/**"," * @cfg {Object/Constructor/Object[]/Constructor[]} $mixins (optional)  Mixins are a way to add functionality"," * to a class that should not add state to the instance unknowingly.  Mixins can be either objects or Constructors."," *","    function Logger() {}","    Logger.prototype.log = function() {","        console.log(arguments)","    }","","    var C = Luc.define({","        $mixins: [Logger, {","            warn: function() {","                console.warn(arguments)","            }","        }]","    });","","    var c = new C();","","    c.log(1,2)","    &gt;[1,2]","","    c.warn(3,4)","    &gt;[3,4]"," *"," */","/**"," * @cfg {Constructor} $super (optional)  super for the defining class.  By Luc.Base"," * is the default if super is not passed in.  To define a class without a superclass"," * you can pass in false or null."," *","     function Counter() {","        this.count = 0;","     };","","     Counter.prototype = {","        getCount: function() {","            return this.count;","        },","        increaseCount: function() {","            this.count++;","        }","     }","","     var C = Luc.define({","        $super:Counter","    });","","    var c = new C()","","    c instanceof Counter","    &gt;true","    c.increaseCount();","    c.getCount();","    &gt;1","    c.count","    &gt;1"," *"," * Check out Luc.Base to see why we have it as the default."," * ","    var B = Luc.define({","        amIALucBase: function() {","            return this instanceof Luc.Base","        }","    })","    var b = new B();","    b.amIALucBase();","    &gt;true"," *"," * "," */","","","","/**"," * @cfg {Object/Object[]} $compositions (optional) config objects for "," * Luc.Composition.  Compositions are a great way to add behavior to a class"," * without extending it.  A $mixin can offer similar functionality but should"," * be stateless.  A Constructor and a name are needed for the config object"," * The methods property is optional here but it is saying take all of "," * Luc.EventEmitter's instance methods and make them instance methods for C."," * You can check out all of the config options by looking at Luc.Composition."," * ","        var C = Luc.define({","            $compositions: {","                Constructor: Luc.EventEmitter,","                name: 'emitter',","                methods: 'allMethods'","            }","        });","","        var c = new C();","","        c.on('hey', function() {","            console.log(arguments);","        });","","        c.emit('hey', 1,2,3, 'a');","        &gt;[1, 2, 3, \"a\"]","        c instanceof Luc.EventEmitter","        &gt;false","        c._events","        &gt;undefined"," *"," * Luc.EventEmitter is preferred as a composition over a mixin because"," * it adds a state \"_events\" to the this instance when on is called.  It"," * also shouldn't have to know that it may be instantiated alone or mixed into classes"," * so the initing of state is not done in the constructor like it probably should."," * It is not terrible practice by any means but it is not good to have a standalone class"," * that knows that it may be mixin.  Even worse than that would be a mixin that needs"," * to be inited by the defining class.  Encapsulating logic in a class"," * and using it anywhere seamlessly is where compositions shine. Luc comes with two common "," * {@link Luc#compositionEnums enums} that we expect will be used often."," * "," * &lt;br&gt;"," * Here is an example of a simple composition see how the functionality "," * is added but we are not inheriting and this.count is"," * undefined."," *","         function Counter() {","            this.count = 0;","         };","","         Counter.prototype = {","            getCount: function() {","                return this.count;","            },","            increaseCount: function() {","                this.count++;","            }","         }","","         var C = Luc.define({","                $compositions: {","                    name: 'counter',","                    Constructor: Counter,","                    methods: 'allMethods'","                }","        });","","        var c = new C()","","        c.increaseCount();","        c.increaseCount();","        c.increaseCount();","        c.getCount();","        &gt;3","        c.count","        &gt;undefined"," *"," * Luc comes with two default composition objects Luc.compositionEnums.PluginManager"," * and Luc.compositionEnums.EventEmitter."," * "," * Here is the plugin manager enum, keep in mind that this"," * functionality can be added to any class, not just ones defined with "," * Luc.define.  Check out Luc.PluginManager to see all of the public "," * methods that gets added to the defined instance.","   ","    function MyClass() {};","","    function MyPlugin() {","        this.myCoolName = 'coo';","","        this.init = function() {","            console.log('im getting initted');","        }","        this.destroy = function() {","            console.log('MyPlugin instance being destroyed')","        }","    }","","    var C = Luc.define({","        $super: MyClass,","        $compositions: Luc.compositionEnums.PluginManager","    });","","    var c = new C({","        plugins: [{","                Constructor: MyPlugin,","                myCoolName: 'coo'","            }","        ]","    });","    &gt;im getting initted","    c instanceof MyClass","    &gt;true","","    c.getPlugin({myCoolName: 'coo'}) instanceof MyPlugin","    &gt; true","","","    c.a = 1;","    //This will be the default Luc.Plugin","    c.addPlugin({","        init: function(owner) {","            console.log(owner.a)","        },","        destroy: function() {","            console.log('Im getting destroyed')","        }","    });","","    &gt;1","","    c.destroyAllPlugins();","    &gt;MyPlugin instance being destroyed","    &gt;I'm getting destroyed.","","    c.getPlugin({myCoolName: 'coo'})","    &gt;false"," *"," * You can see that it can add plugin like behavior to any defining"," * class with Luc.PluginManger which is less than 75 SLOC."," */"];

},{"./base":22,"./composition":45,"../object":17,"../array":18,"../function":16,"../is":19}],25:[function(require,module,exports){
/* automatically generated by JSCoverage - do not edit */
if (typeof _$jscoverage === 'undefined') _$jscoverage = {};
if (! _$jscoverage['class/pluginManager.js']) {
  _$jscoverage['class/pluginManager.js'] = [];
  _$jscoverage['class/pluginManager.js'][1] = 0;
  _$jscoverage['class/pluginManager.js'][9] = 0;
  _$jscoverage['class/pluginManager.js'][10] = 0;
  _$jscoverage['class/pluginManager.js'][68] = 0;
  _$jscoverage['class/pluginManager.js'][78] = 0;
  _$jscoverage['class/pluginManager.js'][79] = 0;
  _$jscoverage['class/pluginManager.js'][80] = 0;
  _$jscoverage['class/pluginManager.js'][87] = 0;
  _$jscoverage['class/pluginManager.js'][88] = 0;
  _$jscoverage['class/pluginManager.js'][96] = 0;
  _$jscoverage['class/pluginManager.js'][97] = 0;
  _$jscoverage['class/pluginManager.js'][107] = 0;
  _$jscoverage['class/pluginManager.js'][109] = 0;
  _$jscoverage['class/pluginManager.js'][111] = 0;
  _$jscoverage['class/pluginManager.js'][113] = 0;
  _$jscoverage['class/pluginManager.js'][120] = 0;
  _$jscoverage['class/pluginManager.js'][122] = 0;
  _$jscoverage['class/pluginManager.js'][129] = 0;
  _$jscoverage['class/pluginManager.js'][134] = 0;
  _$jscoverage['class/pluginManager.js'][141] = 0;
  _$jscoverage['class/pluginManager.js'][142] = 0;
  _$jscoverage['class/pluginManager.js'][151] = 0;
  _$jscoverage['class/pluginManager.js'][152] = 0;
  _$jscoverage['class/pluginManager.js'][155] = 0;
  _$jscoverage['class/pluginManager.js'][159] = 0;
  _$jscoverage['class/pluginManager.js'][160] = 0;
  _$jscoverage['class/pluginManager.js'][171] = 0;
  _$jscoverage['class/pluginManager.js'][173] = 0;
  _$jscoverage['class/pluginManager.js'][174] = 0;
  _$jscoverage['class/pluginManager.js'][175] = 0;
  _$jscoverage['class/pluginManager.js'][178] = 0;
  _$jscoverage['class/pluginManager.js'][193] = 0;
  _$jscoverage['class/pluginManager.js'][194] = 0;
  _$jscoverage['class/pluginManager.js'][196] = 0;
  _$jscoverage['class/pluginManager.js'][200] = 0;
}
_$jscoverage['class/pluginManager.js'][1]++;
var Plugin = require("./plugin"), is = require("../is"), obj = require("../object"), arr = require("../array"), aEach = arr.each, mix = obj.mix, apply = obj.apply;
_$jscoverage['class/pluginManager.js'][9]++;
function PluginManager(config) {
  _$jscoverage['class/pluginManager.js'][10]++;
  this._init(config);
}
_$jscoverage['class/pluginManager.js'][68]++;
PluginManager.prototype = {defaultPlugin: Plugin, _init: (function (instanceValues) {
  _$jscoverage['class/pluginManager.js'][78]++;
  apply(this, instanceValues);
  _$jscoverage['class/pluginManager.js'][79]++;
  this.plugins = [];
  _$jscoverage['class/pluginManager.js'][80]++;
  this._createPlugins();
}), _createPlugins: (function () {
  _$jscoverage['class/pluginManager.js'][87]++;
  aEach(this._getPluginConfigFromInstance(), (function (pluginConfig) {
  _$jscoverage['class/pluginManager.js'][88]++;
  this.addPlugin(pluginConfig);
}), this);
}), _getPluginConfigFromInstance: (function () {
  _$jscoverage['class/pluginManager.js'][96]++;
  var config = this.instanceArgs[0] || {};
  _$jscoverage['class/pluginManager.js'][97]++;
  return config.plugins;
}), addPlugin: (function (pluginConfig) {
  _$jscoverage['class/pluginManager.js'][107]++;
  var pluginInstance = this._createPlugin(pluginConfig);
  _$jscoverage['class/pluginManager.js'][109]++;
  this._initPlugin(pluginInstance);
  _$jscoverage['class/pluginManager.js'][111]++;
  this.plugins.push(pluginInstance);
  _$jscoverage['class/pluginManager.js'][113]++;
  return pluginInstance;
}), _createPlugin: (function (config) {
  _$jscoverage['class/pluginManager.js'][120]++;
  config.owner = this.instance;
  _$jscoverage['class/pluginManager.js'][122]++;
  if (config.Constructor) {
    _$jscoverage['class/pluginManager.js'][129]++;
    return new config.Constructor(apply(config, {Constructor: undefined}));
  }
  _$jscoverage['class/pluginManager.js'][134]++;
  return new this.defaultPlugin(config);
}), _initPlugin: (function (plugin) {
  _$jscoverage['class/pluginManager.js'][141]++;
  if (is.isFunction(plugin.init)) {
    _$jscoverage['class/pluginManager.js'][142]++;
    plugin.init(this.instance);
  }
}), destroyAllPlugins: (function () {
  _$jscoverage['class/pluginManager.js'][151]++;
  this.plugins.forEach((function (plugin) {
  _$jscoverage['class/pluginManager.js'][152]++;
  this._destroyPlugin(plugin);
}), this);
  _$jscoverage['class/pluginManager.js'][155]++;
  this.plugins = [];
}), _destroyPlugin: (function (plugin) {
  _$jscoverage['class/pluginManager.js'][159]++;
  if (is.isFunction(plugin.destroy)) {
    _$jscoverage['class/pluginManager.js'][160]++;
    plugin.destroy(this.instance);
  }
}), destroyPlugin: (function (obj) {
  _$jscoverage['class/pluginManager.js'][171]++;
  var plugin = this.getPlugin(obj);
  _$jscoverage['class/pluginManager.js'][173]++;
  if (plugin) {
    _$jscoverage['class/pluginManager.js'][174]++;
    this._destroyPlugin(plugin);
    _$jscoverage['class/pluginManager.js'][175]++;
    arr.removeFirst(this.plugins, plugin, {type: "strict"});
  }
  _$jscoverage['class/pluginManager.js'][178]++;
  return plugin;
}), getPlugin: (function (obj) {
  _$jscoverage['class/pluginManager.js'][193]++;
  if (is.isFunction(obj)) {
    _$jscoverage['class/pluginManager.js'][194]++;
    return arr.findFirstInstanceOf(this.plugins, obj);
  }
  _$jscoverage['class/pluginManager.js'][196]++;
  return arr.findFirst(this.plugins, obj, {type: "loose"});
})};
_$jscoverage['class/pluginManager.js'][200]++;
module.exports = PluginManager;
_$jscoverage['class/pluginManager.js'].source = ["var Plugin = require('./plugin'),","    is = require('../is'),","    obj = require('../object'),","    arr = require('../array'),","    aEach = arr.each,","    mix = obj.mix,","    apply = obj.apply;","","function PluginManager(config) {","    this._init(config);","}","","/**"," * @protected"," * @class Luc.PluginManager"," * This class is used by Luc.compositionEnums#PluginManager to add its functionality "," * to any class.   By {@link Luc.compositionEnums#PluginManager default} it adds"," * all of these public methods to the instance.This class is designed to work as a composition, "," * it is exposed as not private so it can be extended if needed.   Check \"protected\" which"," * is a part of the Show v dropdown on the right to see the protected methods."," *","    function MyPlugin() {","        this.myCoolName = 'coo';","","        this.init = function() {","            console.log('im getting initted');","        }","        this.destroy = function() {","            console.log('MyPlugin instance being destroyed')","        }","    }","","    var C = Luc.define({","        $compositions: Luc.compositionEnums.PluginManager","    });","","    var c = new C({","        plugins: [{","                Constructor: MyPlugin,","                myCoolName: 'coo'","            }","        ]","    });","","    &gt;im getting initted","","    var plugInstance = c.addPlugin({","        destroy: function() {","            console.log('Im getting destroyed')","        }","    });","","    c.getPlugin(Luc.Plugin)","    &gt; Plugin {destroy: function, owner: MyClass, init: function, destroy: function}","","    c.getPlugin(MyPlugin)","    &gt; MyPlugin {myCoolName: \"coo\", init: function, destroy: function}","","    c.destroyAllPlugins()","","    &gt;MyPlugin instance being destroyed","    &gt;Im getting destroyed","","    c.getPlugin(MyPlugin)","    &gt;false",""," */","PluginManager.prototype = {","   /**","    * @cfg {Constructor} defaultPlugin","    */","    defaultPlugin: Plugin,","","    /**","     * @protected","     */","    _init: function(instanceValues) {","        apply(this, instanceValues);","        this.plugins = [];","        this._createPlugins();","    },","","    /**","     * @protected","     */","    _createPlugins: function() {","        aEach(this._getPluginConfigFromInstance(), function(pluginConfig) {","            this.addPlugin(pluginConfig);","        }, this);","    },","","    /**","     * @protected","     */","    _getPluginConfigFromInstance: function() {","        var config = this.instanceArgs[0] || {};","        return config.plugins;","    },","","    /**","     * Add a plugin to the instance and init the ","     * plugin.","     * @param  {Object} pluginConfig","     * @return {Object} the created plugin instance","     */","    addPlugin: function(pluginConfig) {","        var pluginInstance = this._createPlugin(pluginConfig);","","        this._initPlugin(pluginInstance);","","        this.plugins.push(pluginInstance);","","        return pluginInstance;","    },","","    /**","     * @protected","     */","    _createPlugin: function(config) {","        config.owner = this.instance;","","        if (config.Constructor) {","            //call the configed Constructor with the ","            //passed in config but take off the Constructor","            //config.","             ","            //The plugin Constructor ","            //should not need to know about itself","            return new config.Constructor(apply(config, {","                Constructor: undefined","            }));","        }","","        return new this.defaultPlugin(config);","    },","","    /**","     * @protected","     */","    _initPlugin: function(plugin) {","        if (is.isFunction(plugin.init)) {","            plugin.init(this.instance);","        }","    },","","    /**","     * Call destroy on all of the plugins","     * and remove them.","     */","    destroyAllPlugins: function() {","        this.plugins.forEach(function(plugin) {","            this._destroyPlugin(plugin);","        }, this);","","        this.plugins = [];","    },","","    _destroyPlugin: function(plugin) {","        if (is.isFunction(plugin.destroy)) {","            plugin.destroy(this.instance);","        }","    },","","    /**","     * Remove the plugin and if found destroy it.","     * @param  {Object/Constructor} object to use to match ","     * the plugin to remove.","     * @return {Object} the destroyed plugin.","     */","    destroyPlugin: function(obj) {","        var plugin = this.getPlugin(obj);","","        if(plugin) {","            this._destroyPlugin(plugin);","            arr.removeFirst(this.plugins, plugin, {type: 'strict'});","        }","","        return plugin;","    },","","    /**","     * Get a plugin instance.  A Constructor or an object can be used","     * to find a plugin.","     *","          c.addPlugin({a:1})","          c.getPlugin({a:1})","          &gt;Luc.Plugin({a:1})","","     * @param  {Object} obj ","     * @return {Object} the plugin instance if found.","     */","    getPlugin: function(obj) {","        if (is.isFunction(obj)) {","            return arr.findFirstInstanceOf(this.plugins, obj);","        }","        return arr.findFirst(this.plugins, obj, {type: 'loose'});","    }","};","","module.exports = PluginManager;"];

},{"./plugin":23,"../is":19,"../object":17,"../array":18}],26:[function(require,module,exports){
/* automatically generated by JSCoverage - do not edit */
if (typeof _$jscoverage === 'undefined') _$jscoverage = {};
if (! _$jscoverage['class/compositionEnums.js']) {
  _$jscoverage['class/compositionEnums.js'] = [];
  _$jscoverage['class/compositionEnums.js'][1] = 0;
  _$jscoverage['class/compositionEnums.js'][29] = 0;
  _$jscoverage['class/compositionEnums.js'][39] = 0;
  _$jscoverage['class/compositionEnums.js'][44] = 0;
  _$jscoverage['class/compositionEnums.js'][49] = 0;
}
_$jscoverage['class/compositionEnums.js'][1]++;
var EventEmitter = require("../events/eventEmitter"), PluginManager = require("./pluginManager");
_$jscoverage['class/compositionEnums.js'][29]++;
module.exports.EventEmitter = {Constructor: EventEmitter, name: "emitter", methods: "allMethods"};
_$jscoverage['class/compositionEnums.js'][39]++;
module.exports.PluginManager = {name: "plugins", initAfter: true, Constructor: PluginManager, create: (function () {
  _$jscoverage['class/compositionEnums.js'][44]++;
  var manager = new this.Constructor({instance: this.instance, instanceArgs: this.instanceArgs});
  _$jscoverage['class/compositionEnums.js'][49]++;
  return manager;
}), ignoreMethods: "defaultPlugin", methods: "publicMethods"};
_$jscoverage['class/compositionEnums.js'].source = ["var EventEmitter = require('../events/eventEmitter'),","    PluginManager = require('./pluginManager');","","/**"," * @class Luc.compositionEnums"," * Composition enums are just common config objects for Luc.Composition."," * Here is an example of a composition that uses EventEmitter but only"," * puts the emit method on the prototype."," *","    var C = Luc.define({","        $compositions: {","            defaults: Luc.compositionEnums.EventEmitter,","            methods: ['emit']","        }","    });","","    var c = new C();","","    typeof c.emit","    &gt;\"function\"","    typeof c.on","    \"undefined\""," * "," */","","/**"," * @property {Object} EventEmitter"," */","module.exports.EventEmitter = {","    Constructor: EventEmitter,","    name: 'emitter',","    methods: 'allMethods'","};","","","/**"," * @property {Object} PluginManager"," */","module.exports.PluginManager = {","    name: 'plugins',","    initAfter: true,","    Constructor: PluginManager,","    create: function() {","        var manager = new this.Constructor({","            instance: this.instance,","            instanceArgs: this.instanceArgs","        });","","        return manager;","    },","    ignoreMethods: 'defaultPlugin',","    methods: 'publicMethods'","};"];

},{"../events/eventEmitter":21,"./pluginManager":25}],29:[function(require,module,exports){
(function(process){if (!process.EventEmitter) process.EventEmitter = function () {};

var EventEmitter = exports.EventEmitter = process.EventEmitter;
var isArray = typeof Array.isArray === 'function'
    ? Array.isArray
    : function (xs) {
        return Object.prototype.toString.call(xs) === '[object Array]'
    }
;
function indexOf (xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for (var i = 0; i < xs.length; i++) {
        if (x === xs[i]) return i;
    }
    return -1;
}

// By default EventEmitters will print a warning if more than
// 10 listeners are added to it. This is a useful default which
// helps finding memory leaks.
//
// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
var defaultMaxListeners = 10;
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!this._events) this._events = {};
  this._events.maxListeners = n;
};


EventEmitter.prototype.emit = function(type) {
  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events || !this._events.error ||
        (isArray(this._events.error) && !this._events.error.length))
    {
      if (arguments[1] instanceof Error) {
        throw arguments[1]; // Unhandled 'error' event
      } else {
        throw new Error("Uncaught, unspecified 'error' event.");
      }
      return false;
    }
  }

  if (!this._events) return false;
  var handler = this._events[type];
  if (!handler) return false;

  if (typeof handler == 'function') {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        var args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
    return true;

  } else if (isArray(handler)) {
    var args = Array.prototype.slice.call(arguments, 1);

    var listeners = handler.slice();
    for (var i = 0, l = listeners.length; i < l; i++) {
      listeners[i].apply(this, args);
    }
    return true;

  } else {
    return false;
  }
};

// EventEmitter is defined in src/node_events.cc
// EventEmitter.prototype.emit() is also defined there.
EventEmitter.prototype.addListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('addListener only takes instances of Function');
  }

  if (!this._events) this._events = {};

  // To avoid recursion in the case that type == "newListeners"! Before
  // adding it to the listeners, first emit "newListeners".
  this.emit('newListener', type, listener);

  if (!this._events[type]) {
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  } else if (isArray(this._events[type])) {

    // Check for listener leak
    if (!this._events[type].warned) {
      var m;
      if (this._events.maxListeners !== undefined) {
        m = this._events.maxListeners;
      } else {
        m = defaultMaxListeners;
      }

      if (m && m > 0 && this._events[type].length > m) {
        this._events[type].warned = true;
        console.error('(node) warning: possible EventEmitter memory ' +
                      'leak detected. %d listeners added. ' +
                      'Use emitter.setMaxListeners() to increase limit.',
                      this._events[type].length);
        console.trace();
      }
    }

    // If we've already got an array, just append.
    this._events[type].push(listener);
  } else {
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  var self = this;
  self.on(type, function g() {
    self.removeListener(type, g);
    listener.apply(this, arguments);
  });

  return this;
};

EventEmitter.prototype.removeListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('removeListener only takes instances of Function');
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (!this._events || !this._events[type]) return this;

  var list = this._events[type];

  if (isArray(list)) {
    var i = indexOf(list, listener);
    if (i < 0) return this;
    list.splice(i, 1);
    if (list.length == 0)
      delete this._events[type];
  } else if (this._events[type] === listener) {
    delete this._events[type];
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  if (arguments.length === 0) {
    this._events = {};
    return this;
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (type && this._events && this._events[type]) this._events[type] = null;
  return this;
};

EventEmitter.prototype.listeners = function(type) {
  if (!this._events) this._events = {};
  if (!this._events[type]) this._events[type] = [];
  if (!isArray(this._events[type])) {
    this._events[type] = [this._events[type]];
  }
  return this._events[type];
};

})(require("__browserify_process"))
},{"__browserify_process":9}],32:[function(require,module,exports){
/**
 * @class Luc.Object
 * Package for Object methods.  Luc.Object.apply and Luc.Object.each
 * are used very often.  mix and apply are aliased to Luc.apply and Luc.mix.
 */

/**
 * Apply the properties from fromObject to the toObject.  fromObject will
 * overwrite any shared keys.  It can also be used as a simple shallow clone.
 * 
    var to = {a:1, c:1}, from = {a:2, b:2}
    Luc.Object.apply(to, from)
    >Object {a: 2, c: 1, b: 2}
    to === to
    >true
    var clone = Luc.Object.apply({}, from)
    >undefined
    clone
    >Object {a: 2, b: 2}
    clone === from
    >false
 *
 * No null checks are needed.
    
    Luc.apply(undefined, {a:1})
    >{a:1}
    Luc.apply({a: 1})
    >{a:1}

 *
 * 
 * @param  {Object} [toObject] Object to put the properties fromObject on.
 * @param  {Object} [fromObject] Object to put the properties on the toObject
 * @return {Object} the toObject
 */
exports.apply = function(toObject, fromObject) {
    var to = toObject || {},
        from = fromObject || {},
        prop;

    for (prop in from) {
        if (from.hasOwnProperty(prop)) {
            to[prop] = from[prop];
        }
    }

    return to;
};

/**
 * Similar to Luc.Object.apply except that the fromObject will 
 * NOT overwrite the keys of the toObject if they are defined.
 *
    Luc.mix({a:1,b:2}, {a:3,b:4,c:5})
    >{a: 1, b: 2, c: 5}

 * No null checks are needed.
    
    Luc.mix(undefined, {a:1})
    >{a:1}
    Luc.mix({a: 1})
    >{a:1}
    
 *

 * @param  {Object} [toObject] Object to put the properties fromObject on.
 * @param  {Object} [fromObject] fromObject Object to put the properties on the toObject
 * @return {Object} the toObject
 */
exports.mix = function(toObject, fromObject) {
    var to = toObject || {},
        from = fromObject || {},
        prop;

    for (prop in from) {
        if (from.hasOwnProperty(prop) && to[prop] === undefined) {
            to[prop] = from[prop];
        }
    }

    return to;
};

/**
 * Iterate over an objects properties
 * as key value "pairs" with the passed in function.
 * 
    var thisArg = {val:'c'};
    Luc.Object.each({
        u: 'L'
    }, function(key, value) {
        console.log(value + key + this.val)
    }, thisArg)
    
    >Luc 
 
 * @param  {Object}   obj  the object to iterate over
 * @param  {Function} fn   the function to call
 * @param  {String} fn.key   the object key
 * @param  {Object} fn.value   the object value
 * @param  {Object}   [thisArg] 
 * @param {Object}  [config]
 * @param {Boolean}  config.ownProperties set to false
 * to iterate over all of the objects enumerable properties.
 */
exports.each = function(obj, fn, thisArg, config) {
    var key, value,
        allProperties = config && config.ownProperties === false;

    if (allProperties) {
        for (key in obj) {
            fn.call(thisArg, key, obj[key]);
        }
    } else {
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                fn.call(thisArg, key, obj[key]);
            }
        }
    }
};

/**
 * Take an array of strings and an array/arguments of
 * values and return an object of key value pairs
 * based off each arrays index.  It is useful for taking
 * a long list of arguments and creating an object that can
 * be passed to other methods.
 * 
    function longArgs(a,b,c,d,e,f) {
        return Luc.Object.toObject(['a','b', 'c', 'd', 'e', 'f'], arguments)
    }

    longArgs(1,2,3,4,5,6,7,8,9)

    >Object {a: 1, b: 2, c: 3, d: 4, e: 5…}
    a: 1
    b: 2
    c: 3
    d: 4
    e: 5
    f: 6

    longArgs(1,2,3)

    >Object {a: 1, b: 2, c: 3, d: undefined, e: undefined…}
    a: 1
    b: 2
    c: 3
    d: undefined
    e: undefined
    f: undefined

 * @param  {String[]} strings
 * @param  {Array/arguments} values
 * @return {Object}
 */
exports.toObject = function(strings, values) {
    var obj = {},
        i = 0,
        len = strings.length;
    for (; i < len; ++i) {
        obj[strings[i]] = values[i];
    }

    return obj;
};

/**
 * Return key value pairs from the object if the
 * filterFn returns a truthy value.
 *
    Luc.Object.filter({
        a: false,
        b: true,
        c: false
    }, function(key, value) {
        return key === 'a' || value
    })
    >[{key: 'a', value: false}, {key: 'b', value: true}]

    Luc.Object.filter({
        a: false,
        b: true,
        c: false
    }, function(key, value) {
        return key === 'a' || value
    }, undefined, {
        keys: true
    })
    >['a', 'b']
 * 
 * @param  {Object}   obj  the object to iterate over
 * @param  {Function} filterFn   the function to call, return a truthy value
 * to add the key value pair
 * @param  {String} filterFn.key   the object key
 * @param  {Object} filterFn.value   the object value
 * @param  {Object}   [thisArg] 
 * @param {Object}  [config]
 * @param {Boolean}  config.ownProperties set to false
 * to iterate over all of the objects enumerable properties.
 * 
 * @param {Boolean}  config.keys set to true to return
 * just the keys.
 *
 * @param {Boolean}  config.values set to true to return
 * just the values.
 * 
 * @return {Object[]/String[]} Array of key value pairs in the form
 * of {key: 'key', value: value}.  If keys or values is true on the config
 * just the keys or values are returned.
 *
 */
exports.filter = function(obj, filterFn, thisArg, c) {
    var values = [],
        config = c || {};

    exports.each(obj, function(key, value) {
        if (filterFn.call(thisArg, key, value)) {
            if (config.keys === true) {
                values.push(key);
            } else if (config.values === true) {
                values.push(value);
            } else {
                values.push({
                    value: value,
                    key: key
                });
            }
        }
    }, thisArg, config);

    return values;
};
},{}],36:[function(require,module,exports){
var oToString = Object.prototype.toString;


/**
 * @member Luc
 * Return true if the passed in object is of
 * the type {@link Array Array}
 * @param  {Object}  obj 
 * @return {Boolean}
 */
function isArray(obj) {
    return Array.isArray(obj);
}

/**
 * @member Luc
 * Return true if the passed in object is of
 * the type {@link Object Object}
 * @param  {Object}  obj 
 * @return {Boolean}
 */
function isObject(obj) {
    return obj && oToString.call(obj) === '[object Object]';
}

/**
 * @member Luc
 * Return true if the passed in object is of
 * the type {@link Function Function}
 * @param  {Object}  obj 
 * @return {Boolean}
 */
function isFunction(obj) {
    return oToString.call(obj) === '[object Function]';
}

/**
 * @member Luc
 * Return true if the passed in object is of
 * the type {@link Date Date}
 * @param  {Object}  obj 
 * @return {Boolean}
 */
function isDate(obj) {
    return oToString.call(obj) === '[object Date]';
}

/**
 * @member Luc
 * Return true if the passed in object is of
 * the type {@link RegExp RegExp}
 * @param  {Object}  obj 
 * @return {Boolean}
 */
function isRegExp(obj) {
    return oToString.call(obj) === '[object RegExp]';
}

/**
 * @member Luc
 * Return true if the passed in object is of
 * the type {@link Number Number}
 * @param  {Object}  obj 
 * @return {Boolean}
 */
function isNumber(obj) {
    return oToString.call(obj) === '[object Number]';
}

/**
 * @member Luc
 * Return true if the passed in object is of
 * the type {@link String String}
 * @param  {Object}  obj 
 * @return {Boolean}
 */
function isString(obj) {
    return oToString.call(obj) === '[object String]';
}

/**
 * @member Luc
 * Return true if the passed in object is of
 * the type arguments.
 * 
 * @param  {Object}  obj 
 * @return {Boolean}
 */
function isArguments(obj) {
    return oToString.call(obj) === '[object Arguments]' || obj && !!obj.callee;
}

/**
 * @member Luc
 * Return true if the object is falsy but not zero.  If
 * you want falsy check that includes zero use a goram 
 * if statement :)
 * @param  {Object}  obj
 * @return {Boolean}     
 */
function isFalsy(obj) {
    return (!obj && obj !== 0);
}

/**
 * @member Luc
 * Return true if the object is empty.
 * {}, [], '',false, null, undefined, NaN 
 * Are all treated as empty.
 * @param  {Object}  obj
 * @return {Boolean}
 */
function isEmpty(obj) {
    var empty = false;

    if (isFalsy(obj)) {
        empty = true;
    } else if (isArray(obj)) {
        empty = obj.length === 0;
    } else if (isObject(obj)) {
        empty = Object.keys(obj).length === 0;
    }

    return empty;
}

module.exports = {
    isArray: isArray,
    isObject: isObject,
    isFunction: isFunction,
    isDate: isDate,
    isString: isString,
    isNumber: isNumber,
    isRegExp: isRegExp,
    isArguments: isArguments,
    isFalsy: isFalsy,
    isEmpty: isEmpty
};
},{}],44:[function(require,module,exports){
var ids = {};
/**
 * @member Luc
 * @method id
 * 
 * Return a unique id.
 * @param {String} [prefix] Optional prefix to use
 *
 *
        Luc.id()
        >"luc-0"
        Luc.id()
        >"luc-1"
        Luc.id('my-prefix')
        >"my-prefix0"
        Luc.id('')
        >"0"
 *
 * @return {String}
 *
 */
module.exports = function(p) {
    var prefix = p === undefined ? 'luc-' : p;

    if(ids[prefix] === undefined) {
        ids[prefix] = 0;
    }

    return prefix + ids[prefix]++;
};
},{}],37:[function(require,module,exports){
var EventEmitter = require('events').EventEmitter;
/**
 * @license https://raw.github.com/joyent/node/v0.10.11/LICENSE
 * Node js license. EventEmitter will be in the client
 * only code.
 */
/**
 * @class Luc.EventEmitter
 * The wonderful event emmiter that comes with node,
 * that works in the supported browsers.
 * [http://nodejs.org/api/events.html](http://nodejs.org/api/events.html)
 */
EventEmitter.prototype.once = function(type, listener) {
    //put in fix for IE 9 and below
    var self = this,
        g = function() {
            self.removeListener(type, g);
            listener.apply(this, arguments);
        };

    self.on(type, g);

    return this;
};

module.exports = EventEmitter;
},{"events":29}],31:[function(require,module,exports){
require('./node_modules/es5-shim/es5-shim');
require('./node_modules/es5-shim/es5-sham');
},{"./node_modules/es5-shim/es5-shim":46,"./node_modules/es5-shim/es5-sham":47}],34:[function(require,module,exports){
var arraySlice = Array.prototype.slice,
    compare = require('./compare'),
    is = require('./is'),
    compare = compare.compare;

function _createIteratorFn(fn, c) {
    var config = c || {};

    if(is.isFunction(fn) && (config.type !== 'strict')) {
        return c ? fn.bind(c) : fn;
    }

    if(config.type === undefined) {
        config.type = 'loose';
    }

    return function(value) {
        return compare(fn, value, config);
    };
}

function _createIteratorNotFn(fn, config) {
    var functionToNot = _createIteratorFn(fn, config);
        
    return function() {
        return !functionToNot.apply(this, arguments);
    };
}


/**
 * @class Luc.Array 
 * Package for Array methods. <br>
 * 
 * Keep in mind that Luc is optionally packaged with es5 shim so you can write es5 code in non es5 browsers.
 * It comes with your favorite {@link Array Array} methods such as Array.forEach, Array.filter, Array.some, Array.every Array.reduceRight ..
 *
 * Also don't forget about Luc.Array.each and Luc.Array.toArray, they are great utility methods
 * that are used all over the framework.
 * 
 * All remove\* / find\* methods follow the same api.  \*All functions will return an array of removed or found
 * items.  The items will be added to the array in the order they are
 * found.  \*First functions will return the first item and stop iterating after that, if none
 *  is found false is returned.  remove\* functions will directly change the passed in array.
 *  \*Not functions only do the following actions if the comparison is not true.
 *  All remove\* / find\* take the following api: array, objectToCompareOrIterator, compareConfigOrThisArg for example:
 *
    //most common use case
    Luc.Array.findFirst([1,2,3, {}], {});
    >Object {}

    //pass in option config for a strict === comparison
    Luc.Array.findFirst([1,2,3,{}], {}, {type: 'strict'});
    >false

    //pass in an iterator and thisArg
    Luc.Array.findFirst([1,2,3,{}], function(val, index, array){
        return val === 3 || this.num === val;
    }, {num: 1});
    >1
    
    //you can see remove modifies the passed in array.
    var arr = [1,2,{a:1},1, {a:1}];
    Luc.Array.removeFirst(arr, {a:1})
    >{a:1}
    arr;
    >[1, 2, 1, {a:1}]
    Luc.Array.removeLast(arr, 1)
    >1
    arr;
    >[1,2, {a:1}]
    
    
    Luc.Array.findAll([1,2,3, {a:1,b:2}], function() {return true;})
    > [1,2,3, {a:1,b:2}]
    //show how not works with an iterator
    Luc.Array.findAllNot([1,2,3, {a:1,b:2}], function() {return true;})
    >[]
 *
 * For commonly used find/remove functions check out Luc.ArrayFns for example a
 * "compact" like function
 * 
    Luc.Array.findAllNotFalsy([false, '', undefined, 0, {}, []])
    >[0, {}, []]
 *
 * Or remove all empty items
 * 
    var arr = ['', 0 , [], {a:1}, true, {}, [1]]
    Luc.Array.removeAllEmpty(arr)
    >['', [], {}]
    arr
    >[0, {a:1}, true, [1]]
 */

/**
 * Turn the passed in item into an array if it
 * isn't one already, if the item is an array just return it.  
 * It returns an empty array if item is null or undefined.
 * If it is just a single item return an array containing the item.
 * 
    Luc.Array.toArray()
    >[]
    Luc.Array.toArray(null)
    >[]
    Luc.Array.toArray(1)
    >[1]
    Luc.Array.toArray([1,2])
    >[1, 2]
 *
 * @param  {Object} item item to turn into an array.
 * @return the array
 */
function toArray(item) {
    if (Array.isArray(item)) {
        return item;
    }
    return (item === null || item === undefined) ? [] : [item];
}

/**
 * Return the last item of the array
 * @param  {Array} arr
 * @return {Object} the item
    
    var myLongArrayNameForThingsThatIWantToKeepTrackOf = [1,2,3]
    
    Luc.Array.last(myLongArrayNameForThingsThatIWantToKeepTrackOf);
    vs.
    myLongArrayNameForThingsThatIWantToKeepTrackOf[myLongArrayNameForThingsThatIWantToKeepTrackOf.length -1]
 *
 */
function last(arr) {
    return arr[arr.length -1];
}

/**
 * Flatten out an array of objects based of their value for the passed in key.
 * This also takes acccount for null/undefined values.
 *
    Luc.Array.pluck([undefined, {a:'1', b:2}, {b:3}, {b:4}], 'b')
    >[undefined, 2, 3, 4]
 * @param  {Object[]} arr 
 * @param  {String} key 
 * @return {Array}     
 */
function pluck(arr, key) {
    return arr.map(function(value) {
        return value && value[key];
    });
}

/**
 * Return the items inbetween the passed in index
 * and the end of the array.
 *
    Luc.Array.fromIndex([1,2,3,4,5], 1)
    >[2, 3, 4, 5]

 * @param  {Array/arguments} arr 
 * @param  {Number} index 
 * @return {Array} the new array.
 * 
 */
function fromIndex(a, index) {
    var arr = is.isArguments(a) ? arraySlice.call(a) : a;
    return arraySlice.call(arr, index, arr.length);
}

/**
 * Runs an Array.forEach after calling Luc.Array.toArray on the item.
  It is very useful for setting up flexible api's that can handle none one or many.

    Luc.Array.each(this.items, function(item) {
        this._addItem(item);
    });

    vs.

    if(Array.isArray(this.items)){
        this.items.forEach(function(item) {
            this._addItem(item);
        })
    }
    else if(this.items !== undefined) {
        this._addItem(this.items);
    }

 * @param  {Object}   item
 * @param  {Function} callback
 * @param  {Object}   thisArg   
 *
 */
function each(item, fn, thisArg) {
    var arr = toArray(item);
    return arr.forEach.call(arr, fn, thisArg);
}

/**
 * Insert or append the second array/arguments into the
 * first array/arguments.  This method does not alter
 * the passed in array/arguments.
 * 
 * @param  {Array/arguments} firstArrayOrArgs
 * @param  {Array/arguments} secondArrayOrArgs
 * @param  {Number/true} indexOrAppend true to append 
 * the second array to the end of the first one.  If it is a number
 * insert the secondArray into the first one at the passed in index.
 * @return {Array} the newly created array.
 *
    Luc.Array.insert([0,4], [1,2,3], 1);
    >[0, 1, 2, 3, 4]
    Luc.Array.insert([0,4], [1,2,3], true);
    >[0, 4, 1, 2, 3]
    Luc.Array.insert([0,4], [1,2,3], 0);
    >[1, 2, 3, 0, 4]
 *
 */
function insert(firstArrayOrArgs, secondArrayOrArgs, indexOrAppend) {
    var firstArray = arraySlice.call(firstArrayOrArgs),
        secondArray = arraySlice.call(secondArrayOrArgs),
        spliceArgs;

    if(indexOrAppend === true) {
        return firstArray.concat(secondArray);
    }

    spliceArgs = [indexOrAppend, 0].concat(secondArray);
    firstArray.splice.apply(firstArray, spliceArgs);
    return firstArray;
}

/**
 * Remove an item from an the passed in arr
 * from the index.
 * @param  {Array} arr
 * @param  {Number} index
 * @return {Object} the item removed.
 *
    var arr = [1,2,3];
    Luc.Array.removeAtIndex(arr, 1);
    >2
    arr;
    >[1,3]

 */
function removeAtIndex(arr, index) {
    var item = arr[index];
    arr.splice(index, 1);
    return item;
}

function _removeFirst(arr, fn) {
    var removed = false;

    arr.some(function(value, index) {
        if (fn.apply(this, arguments)) {
            removed = removeAtIndex(arr, index);
            return true;
        }
    });

    return removed;
}

/**
 * Remove the first item from the passed in array
 * that {@link Luc#compare matches} the passed in object.  Instead of 
 * comparing an object an iterator function can be
 * used.
 * 
{copyDoc#arrParams}
{copyDoc#arrRemoveSingle}
 */
function removeFirst(arr, obj, config) {
    var fn = _createIteratorFn(obj, config);
    return _removeFirst(arr, fn);
}

/**
 * Remove the first item from the passed in array
 * that does not {@link Luc#compare match} the passed in object.  Instead of 
 * comparing an object an iterator function can be
 * used.
 * 
{copyDoc#arrParams}
{copyDoc#arrRemoveSingle}
 */
function removeFirstNot(arr, obj, config) {
    var fn = _createIteratorNotFn(obj, config);
    return _removeFirst(arr, fn);
}


function _removeAll(arr, fn) {
    var indexsToRemove = [],
        removed = [];

    arr.forEach(function(value, index) {
        if (fn.apply(this, arguments)) {
            indexsToRemove.unshift(index);
            removed.push(value);
        }
    });

    indexsToRemove.forEach(function(index){
        removeAtIndex(arr, index);
    });

    return removed;
}

/**
 * Remove the all the items from the passed in array
 * that do not {@link Luc#compare match} the passed in object.  Instead of 
 * comparing an object an iterator function can be
 * used.
 * 
{copyDoc#arrParams}
{copyDoc#arrRemoveAll}
 */
function removeAllNot(arr, obj, config) {
    var fn = _createIteratorNotFn(obj, config);
    return _removeAll(arr, fn);
}

/**
 * Remove the all the items from the passed in array
 * that {@link Luc#compare matches} the passed in object.  Instead of 
 * comparing an object an iterator function can be
 * used.
 * 
{copyDoc#arrParams}
{copyDoc#arrRemoveAll}
 */
function removeAll(arr, obj, config) {
    var fn = _createIteratorFn(obj, config);
    return _removeAll(arr, fn);
}

function _findFirst(arr, fn) {
    var item = false;
    arr.some(function(value, index) {
        if (fn.apply(this, arguments)) {
            item = arr[index];
            return true;
        }
    });

    return item;
}

/**
 * Find the first item from the passed in array
 * that does {@link Luc#compare matches} the passed in object.  Instead of 
 * comparing an object an iterator function can be
 * used.
 * 
{copyDoc#arrParams}
{copyDoc#arrFindSingle}
 */
function findFirst(arr, obj, config) {
    var fn = _createIteratorFn(obj, config);
    return _findFirst(arr, fn);
}

/**
 * Find the first item from the passed in array
 * that does not {@link Luc#compare match} the passed in object.  Instead of 
 * comparing an object an iterator function can be
 * used.
 * 
{copyDoc#arrParams}
{copyDoc#arrFindSingle}
 */
function findFirstNot(arr, obj, config) {
    var fn = _createIteratorNotFn(obj, config);
    return _findFirst(arr, fn);
}

function _findAll(arr, fn) {
    var found = arr.filter(fn);
    return found;
}

/**
 * Find all of the the items from the passed in array
 * that {@link Luc#compare matches} the passed in object.  Instead of 
 * comparing an object an iterator function can be
 * used.
 * 
{copyDoc#arrParams}
{copyDoc#arrFindAll}
 */
function findAll(arr, obj, config) {
    var fn = _createIteratorFn(obj, config);
    return _findAll(arr, fn);
}

/**
 * Find all of the the items from the passed in array
 * that do not {@link Luc#compare match} the passed in object.  Instead of 
 * comparing an object an iterator function can be
 * used.
 * 
{copyDoc#arrParams}
{copyDoc#arrFindAll}
 */
function findAllNot(arr, obj, config) {
    var fn = _createIteratorNotFn(obj, config);
    return _findAll(arr, fn);
}


exports.toArray = toArray;
exports.each = each;
exports.insert = insert;
exports.fromIndex = fromIndex;
exports.last = last;
exports.pluck = pluck;

exports.removeAtIndex = removeAtIndex;
exports.findFirstNot = findFirstNot;
exports.findAllNot = findAllNot;
exports.findFirst = findFirst;
exports.findAll = findAll;

exports.removeFirstNot = removeFirstNot;
exports.removeAllNot = removeAllNot;
exports.removeFirst = removeFirst;
exports.removeAll = removeAll;

(function(){
    var _createLastFn = function(fnName) {
        var lastName = fnName.replace('First', 'Last');

        exports[lastName] = function(arr, obj, config) {
            var ret;

            arr.reverse();
            ret = exports[fnName](arr, obj, config);
            arr.reverse();

            return ret;
        };

    }, namesToAddLast = ['findFirstNot', 'findFirst', 'removeFirstNot', 'removeFirst'];

    namesToAddLast.forEach(function(fnName) {
        _createLastFn(fnName);
    });

}());

/**
 * @member Luc.Array 
 * @method findLastNot 
 * Same as Luc.Array.findFirstNot except start at the end.
 */

/**
 * @member Luc.Array 
 * @method findLast
 * Same as Luc.Array.findFirst except start at the end.
 */

/**
 * @member Luc.Array 
 * @method removeLastNot 
 * Same as Luc.Array.removeFirstNot except start at the end.
 */

/**
 * @member Luc.Array 
 * @method removeLast 
 * Same as Luc.Array.removeFirst except start at the end.
 */

},{"./compare":43,"./is":36}],33:[function(require,module,exports){
var is = require('./is'),
    aInsert = require('./array').insert;
    aEach = require('./array').each;

/**
 * @class Luc.Function
 * Package for function methods.  Most of them follow the same api:
 * function or function[], relevant args ... with an optional config
 * to Luc.Function.createAutmenter as the last argument.
 */

function _augmentArgs(config, callArgs) {
    var configArgs = config.args,
        index = config.index,
        argsArray;

    if (!configArgs) {
        return callArgs;
    }

    if(index === true || is.isNumber(index)) {
        if(config.argumentsFirst === false) {
            return aInsert(configArgs, callArgs, index);
        }
        return aInsert(callArgs, configArgs, index);
    }

    return configArgs;
}

/**
 * A reusable empty function
 * @return {Function}
 */
exports.emptyFn = function() {};

/**
 * A function that throws an error when called.
 * Useful when defining abstract like classes
 * @return {Function}
 */
exports.abstractFn = function() {
    throw new Error('abstractFn must be implemented');
};

/**
 * Augment the passed in function's thisArg and or arguments object 
 * based on the passed in config.
 * 
 * @param  {Function} fn the function to call
 * @param  {Object} config
 * 
 * @param {Object} [config.thisArg] the thisArg for the function being executed.
 * If this is the only property on your config object the preferred way would
 * be just to use Function.bind
 * 
 * @param {Array} [config.args] the arguments used for the function being executed.
 * This will replace the functions call args if index is not a number or 
 * true.
 * 
 * @param {Number/True} [config.index] By default the the configured arguments
 * will be inserted into the functions passed in call arguments.  If index is true
 * append the args together if it is a number insert it at the passed in index.
 * 
 * @param {Array} [config.argumentsFirst] pass in false to 
 * augment the configured args first with Luc.Array.insert.  Defaults
 * to true
     
     function fn() {
        console.log(this)
        console.log(arguments)
    }
    
    //Luc.Array.insert([4], [1,2,3], 0)
    Luc.Function.createAugmenter(fn, {
        thisArg: {configedThisArg: true},
        args: [1,2,3],
        index:0
    })(4)

    >Object {configedThisArg: true}
    >[1, 2, 3, 4]

    //Luc.Array.insert([1,2,3], [4], 0)
    Luc.Function.createAugmenter(fn, {
        thisArg: {configedThisArg: true},
        args: [1,2,3],
        index:0,
        argumentsFirst:false
    })(4)

    >Object {configedThisArg: true}
    >[4, 1, 2, 3]

    Luc.Array.insert([4], [1,2,3],  true)
    var f = Luc.Function.createAugmenter(fn, {
        args: [1,2,3],
        index: true
    });

    f.apply({config: false}, [4])

    >Object {config: false}
    >[4, 1, 2, 3]

 * @return {Function} the augmented function.
 */
exports.createAugmenter = function(fn, config) {
    var thisArg = config.thisArg;

    return function() {
        return fn.apply(thisArg || this, _augmentArgs(config, arguments));
    };
};

function _initSequenceFunctions(fns, config) {
    var toRun = [];
    aEach(fns, function(f) {
        var fn = f;

        if (config) {
            fn = exports.createAugmenter(f, config);
        }

        toRun.push(fn);
    });

    return toRun;
}

/**
 * Return a function that runs the passed in functions
 * and returns the result of the last function called.
 * 
 * @param  {Function[]} fns 
 * @param  {Object} [config] Config object
 * for Luc.Function.createAugmenter.  If defined all of the functions
 * will get created with the passed in config;
 *
    Luc.Function.createSequence([
        function() {
            console.log(1)
        },
        function() {
            console.log(2)
        },
        function() {
            console.log(3)
            console.log('finished logging')
            return 4;
        }
    ])()
    >1
    >2
    >3
    >finished logging
    >4
 * 
 * @return {Function}
 */
exports.createSequence = function(fns, config) {
    var functions = _initSequenceFunctions(fns, config);

    return function() {
        var i = 0,
            len = functions.length;

        for(;i < len -1; ++i) {
            functions[i].apply(this, arguments);
        }

        return functions[len -1 ].apply(this, arguments);
    };
};

/**
 * Return a function that runs the passed in functions
 * if one of the functions results false the rest of the 
 * functions won't run and false will be returned.
 *
 * If no false is returned the value of the last function return will be returned
 * 
    Luc.Function.createSequenceIf([
        function() {
            console.log(1)
        },
        function() {
            console.log(2)
        },
        function() {
            console.log(3)
            console.log('finished logging')
            return 4;
        }, function() {
            return false;
        }, function() {
            console.log('i cant log')
        }
    ])()

    >1
    >2
    >3
    >finished logging
    >false
 *
 * 
 * @param  {Function[]} fns 
 * @param  {Object} [config] Config object
 * for Luc.Function.createAugmenter.  If defined all of the functions
 * will get created with the passed in config;
 * @return {Function}
 */
exports.createSequenceIf = function(fns, config) {
    var functions = _initSequenceFunctions(fns, config);

    return function() {
        var value,
            args = arguments;

        functions.some(function(fn){
            value = fn.apply(this, args);

            return value === false;
        }, this);

        return value;
    };
};

/**
 * Return a functions that runs the passed in functions
 * the result of each function will be the the call args 
 * for the next function.  The value of the last function 
 * return will be returned.
 * 
     
     Luc.Function.createRelayer([
        function(str) {
            return str + 'b'
        },
        function(str) {
            return str + 'c'
        },
        function(str) {
            return str + 'd'
        }
    ])('a')

    >"abcd"

 * @param  {Function[]} fns 
 * @param  {Object} [config] Config object
 * for Luc.Function.createAugmenter.  If defined all of the functions
 * will get created with the passed in config;
 * @return {Function}
 */
exports.createRelayer = function(fns, config) {
    var functions = _initSequenceFunctions(fns, config);

    return function() {
        var value,
            args = arguments;

        functions.forEach(function(fn, index) {
            if (index === 0) {
                value = fn.apply(this, args);
            } else {
                value = fn.apply(this, [value]);
            }
        }, this);

        return value;
    };
};

/**
 * Create a throttled function from the passed in function
 * that will only get called once the passed number of miliseconds
 * have been exceeded.
 * 
    var logArgs  = function() {
        console.log(arguments)
    };

    var a = Luc.Function.createThrottled(logArgs, 1);

    for(var i = 0; i < 100; ++i) {
        a(1,2,3);
    }

    setTimeout(function() {
        a(1)
    }, 100)
    setTimeout(function() {
        a(2)
    }, 400)

    >[1, 2, 3]
    >[1]
    >[2]
 * 
 * @param  {Function} fn
 * @param  {Number} millis Number of milliseconds to
 * throttle the function.
 * @param  {Object} [config] Config object
 * for Luc.Function.createAugmenter.  If defined all of the functions
 * will get created with the passed in config;
 * @return {Function}
 */
exports.createThrottled = function(f, millis, config) {
    var fn = config ? exports.createAugmenter(f, config) : f,
        timeOutId = false;

    if(!millis) {
        return fn;
    }

    return function() {
        var args = arguments;

        if(timeOutId) {
            clearTimeout(timeOutId);
        }

        timeOutId = setTimeout(function() {
            timeOutId = false;
            fn.apply(this, args);
        }, millis);
    };
};

/**
 * Defer a function's execution for the passed in
 * milliseconds.
 * 
 * @param  {Function} fn
 * @param  {Number} millis Number of milliseconds to
 * defer
 * @param  {Object} [config] Config object
 * for Luc.Function.createAugmenter.  If defined all of the functions
 * will get created with the passed in config;
 * 
 * @return {Function}
 */
exports.createDeferred = function(f, millis, config) {
    var fn = config ? exports.createAugmenter(f, config) : f;

    if(!millis) {
        return fn;
    }

    return function() {
        var args = arguments;

        setTimeout(function() {
            fn.apply(this, args);
        }, millis);
    };
};
},{"./is":36,"./array":34}],35:[function(require,module,exports){
var array = require('./array'),
    is = require('./is'),
    Generator;

Generator = {
    arrayFnNames: ['findFirstNot', 'findAllNot', 'findFirst', 'findAll',
            'removeFirstNot', 'removeAllNot', 'removeFirst', 'removeAll',
            'removeLastNot', 'removeLast', 'findLast', 'findLastNot'
    ],

    createFn: function(arrayFnName, fn) {
        return function(arr) {
            return array[arrayFnName](arr, fn);
        };
    },

    createBoundFn: function(arrayFnName, fnToBind) {
        return function(arr, value) {
            var fn = fnToBind.apply(this, array.fromIndex(arguments, 1));
            return array[arrayFnName](arr, fn);
        };
    }
};

module.exports = Generator;

/**
 * @class Luc.ArrayFns
 * This is documented as a separate package but it actually exists under the 
 * Luc.Array namespace.  Check out the "Filter class members" input box
 * just to the right when searching for functions.
 *<br>
 * 
 * There are a lot of functions in this package but all of them 
 * follow the same api.  \*All functions will return an array of removed or found
 * items.  The items will be added to the array in the order they are
 * found.  \*First functions will return the first item and stop iterating after that, if none
 *  is found false is returned.  remove\* functions will directly change the passed in array.
 *  \*Not functions only do the following actions if the comparison is not true.
 *  \*Last functions do the same as their \*First counterparts except that the iterating
 *  starts at the end of the array. Almost every public method of Luc.is is available it
 *  uses the following grammar Luc.Array["methodName""isMethodName"]
 *
      Luc.Array.findAllNotEmpty([false, true, null, undefined, 0, '', [], [1]])
      > [true, 0, [1]]

      Luc.Array.findAllNotFalsy([false, true, null, undefined, 0, '', [], [1]])
      > [true, 0, [], [1]]
     
      Luc.Array.findFirstNotString([1,2,3,'5'])
      >1
      var arr = [1,2,3,'5'];
      Luc.Array.removeAllNotString(arr);
      >[1,2,3]
      arr
      >["5"]
 *
 * As of right now there are two function sets which differ from the is
 * api.
 *
 * InstanceOf
 * 
    Luc.Array.findAllInstanceOf([1,2, new Date(), {}, []], Object)
    >[date, {}, []]
    >Luc.Array.findAllNotInstanceOf([1,2, new Date(), {}, []], Object)
    [1, 2]
 *
 * In
 * 
    Luc.Array.findAllIn([1,2,3], [1,2])
    >[1, 2]
    Luc.Array.findFirstIn([1,2,3], [1,2])
    >1

    //defaults to loose comparison
    Luc.Array.findAllIn([1,2,3, {a:1, b:2}], [1,{a:1}])
    > [1, {a:1,b:2}]

    Luc.Array.findAllIn([1,2,3, {a:1, b:2}], [1,{a:1}], {type: 'deep'})
    >[1]
 */

(function _createIsFns() {
    var isToIgnore = ['isRegExp', 'isArguments'];

    Object.keys(is).forEach(function(key) {
        var name = key.split('is')[1];
        Generator.arrayFnNames.forEach(function(fnName) {
            if(isToIgnore.indexOf(key) === -1) {
                array[fnName + name] = Generator.createFn(fnName, is[key]);
            }
        });
    });
}());

(function _createFalsyFns() {
    var usefullFalsyFns = ['findFirstNot', 'findAllNot', 'removeFirstNot', 'removeAllNot',
                            'removeFirst', 'removeAll', 'removeLastNot', 'removeLast',  'findLastNot'];

    var fns = {
        'False': function(val) {
            return val === false;
        },
        'True': function(val) {
            return val === true;
        },
        'Null': function(val) {
            return val === null;
        },
        'Undefined': function(val) {
            return val === undefined;
        }
    };

    Object.keys(fns).forEach(function(key) {
        usefullFalsyFns.forEach(function(fnName) {
            array[fnName + key] = Generator.createFn(fnName, fns[key]);
        });
    });
}());

(function _createBoundFns() {
    var fns = {
        'InstanceOf': function(Constructor) {
            return function(value) {
                return (value instanceof Constructor);
            };
        },'In': function(arr, c) {
            var defaultC = {type:'looseRight'};
            return function(value) {
                if(value !== false) {
                    var cfg = c || defaultC;
                    //this is a right to left comparison 
                    //expected loose behavior should be looseRight
                    return array.findFirst(arr, value, cfg.type === 'loose' ? defaultC : cfg) !== false;
                }
                
                return arr.indexOf(false) > -1;
            };
        }
    };

    Object.keys(fns).forEach(function(key) {
        Generator.arrayFnNames.forEach(function(fnName) {
            array[fnName + key] = Generator.createBoundFn(fnName, fns[key]);
        });
    });
}());
},{"./array":34,"./is":36}],43:[function(require,module,exports){
var is = require('./is');

function _strict(val1, val2){
    return val1 === val2;
}

function _compareArrayLength(val1, val2) {
    return(is.isArray(val1) && is.isArray(val2)  && val1.length === val2.length);
}

function _shallowArray(val1, val2) {
    var i = 0,
        len;
    
    if(!_compareArrayLength(val1, val2)) {
        return false;
    }

    for(len = val1.length; i < len; ++i) {
        if(val1[i] !== val2[i]) {
            return false;
        }
    }

    return true;
}

function _deepArray(val1, val2, config) {
    var i = 0,
        len;
    
    if(!_compareArrayLength(val1, val2)) {
        return false;
    }

    for(len = val1.length; i < len; ++i) {
        if(!compare(val1[i],val2[i], config)) {
            return false;
        }
    }

    return true;
}

function _compareObjectKeysLength(val1, val2) {
    return (is.isObject(val1) && is.isObject(val2) && Object.keys(val1).length === Object.keys(val2).length);
}

function _shallowObject(val1, val2) {
    var key, val;

    if (!_compareObjectKeysLength(val1, val2)) {
        return false;
    }

    for (key in val1) {
        if (val1.hasOwnProperty(key)) {
            value = val1[key];
            if (!val2.hasOwnProperty(key) || val2[key] !== value) {
                return false;
            }
        }
    }

    return true;
}

function _deepObject(val1, val2, config) {
    var key, val;

    if (!_compareObjectKeysLength(val1, val2)) {
        return false;
    }

    for (key in val1) {
        if (val1.hasOwnProperty(key)) {
            value = val1[key];
            if (!val2.hasOwnProperty(key) || compare(value, val2[key], config) !== true) {
                return false;
            }
        }
    }

    return true;

}

function _looseObject(val1, val2, config) {
    var key, val;

    if(!(is.isObject(val1) && is.isObject(val2))) {
        return false;
    }

    if(config.type === 'looseRight') {
        for (key in val2) {
            if (val2.hasOwnProperty(key)) {
                value = val2[key];
                if (compare(value, val1[key], config) !== true) {
                    return false;
                }
            }
        }
    }
    else {
        for (key in val1) {
            if (val1.hasOwnProperty(key)) {
                value = val1[key];
                if (compare(value, val2[key], config) !== true) {
                    return false;
                }
            }
        }
    }


    return true;

}

function _date(val1, val2) {
    if(is.isDate(val1) && is.isDate(val2)) {
        return val1.getTime() === val2.getTime();
    }

    return false;
}

function _createBoundCompare(object, fn) {
    return function(value) {
        return fn(object, value);
    };
}

function getCompareFn(object, c) {
    var compareFn = _strict,
        config = c || {},
        type = config.type;

    if (type === 'deep' || type === 'loose' || type === 'looseRight' || type === undefined) {
        if (is.isObject(object)) {
            compareFn = type === 'loose' || type === 'looseRight' ? _looseObject : _deepObject;
        } else if (is.isArray(object)) {
            compareFn = _deepArray;
        } else if (is.isDate(object)) {
            compareFn = _date;
        }
    } else if (type === 'shallow') {
        if (is.isObject(object)) {
            compareFn = _shallowObject;
        } else if (is.isArray(object)) {
            compareFn = _shallowArray;
        } else if (is.isDate(object)) {
            compareFn = _date;
        }
    } else if (type !== 'strict') {
        //we would be doing a strict comparison on a type-o
        //I think an error is good here.
        throw new Error('You passed in an invalid comparison type');
    }

    return compareFn;
}

/**
 * @member Luc
 * @method compare
 * 
 * Return true if the values are equal to each
 * other.  By default a deep comparison is 
 * done on arrays, dates and objects and a strict comparison
 * is done on other types.
 * 
 * @param  {Any} val1  
 * @param  {Any} val2   
 * @param  {Object} [config]
 * @param {String} config.type pass in 'shallow' for a shallow
 * comparison, 'deep' (default) for a deep comparison
 * 'strict' for a strict === comparison for all objects or 
 * 'loose' for a loose comparison on objects.  A loose comparison
 *  will compare the keys and values of val1 to val2 and does not
 *  check if keys from val2 do not exist in val1.
 *
 *
    Luc.compare('1', 1)
    >false
    Luc.compare({a: 1}, {a: 1})
    >true
    Luc.compare({a: 1, b: {}}, {a: 1, b: {} }, {type:'shallow'})
    >false
    Luc.compare({a: 1, b: {}}, {a: 1, b: {} }, {type: 'deep'})
    >true
    Luc.compare({a: 1, b: {}}, {a: 1, b: {} }, {type: 'strict'})
    >false
    Luc.compare({a: 1}, {a:1,b:1})
    >false
    Luc.compare({a: 1}, {a:1,b:1}, {type: 'loose'})
    >true
    Luc.compare({a: 1}, {a:1,b:1}, {type: 'loose'})
    >true
    Luc.compare([{a: 1}], [{a:1,b:1}], {type: 'loose'})
    >true
    Luc.compare([{a: 1}, {}], [{a:1,b:1}], {type: 'loose'})
    >false
    Luc.compare([{a: 1}, {}], [{a:1,b:1}, {}], {type: 'loose'})
    >true
    Luc.compare([{a:1,b:1}], [{a: 1}], {type: 'loose'})
    >false

 * @return {Boolean}
 */
function compare(val1, val2, config) {
    return getCompareFn(val1, config)(val1, val2, config);
}


function createBoundCompareFn(object, c) {
    var compareFn = getCompareFn(object, c);

    return _createBoundCompare(object, compareFn);
}

exports.compare = compare;
exports.createBoundCompareFn = createBoundCompareFn;
},{"./is":36}],38:[function(require,module,exports){
var emptyFn = require('../function').emptyFn,
    apply = require('../object').apply;

/**
 * @class Luc.Base
 * Simple class that by default {@link Luc#apply applies} the 
 * first argument to the instance and then calls
 * Luc.Base.init.
 *
    var b = new Luc.Base({
        a: 1,
        init: function() {
            console.log('hey')
        }
    })
    b.a
    >hey
    >1
 *
 * We found that most of our classes do this so we made
 * it the default.  Having a config object as the first and only 
 * param keeps a clean api as well.
 *
    var C = Luc.define({
        init: function() {
            Luc.Array.each(this.items, this.logItems)
        },

        logItems: function(item) {
            console.log(item);
        }
    });

    var c = new C({items: [1,2,3]});
    >1
    >2
    >3
    var d = new C({items: 'A'});
    >'A'
    var e = new C();
 *
 * If you don't like the applying of the config to the instance it 
 * can always be "disabled"
 *
    var NoApply = Luc.define({
        beforeInit: function() {

        },
        init: function() {
            Luc.Array.each(this.items, this.logItems)
        },

        logItems: function(item) {
            console.log(item);
        }
    });

    var c = new NoApply({items: [1,2,3]});
 * 
 */
function Base() {
    this.beforeInit.apply(this, arguments);
    this.init();
}

Base.prototype = {
    /**
     * By default apply the config to the 
     * instance.
     */
    beforeInit: function(config) {
        apply(this, config);
    },
    /**
     * @method
     * Simple hook to initialize
     * the class.  Defaults to Luc.emptyFn
     */
    init: emptyFn
};

module.exports = Base;
},{"../function":33,"../object":32}],39:[function(require,module,exports){
var Base = require('./base'),
    Composition = require('./composition'),
    obj = require('../object'),
    arrayFns = require('../array'),
    emptyFn = require('../function').emptyFn,
    is = require('../is'),
    aEach = arrayFns.each,
    apply = obj.apply,
    oEach = obj.each,
    oFilter = obj.filter,
    mix = obj.mix,
    arraySlice = Array.prototype.slice,
    ClassDefiner;

/**
 * @class Luc.ClassDefiner
 * @singleton
 *
 * Singleton that {@link Luc.define#define Luc.define} uses to define classes.  The defualt type can
 * be changed to any Constructor
 *
    function MyClass(){};
    Luc.ClassDefiner.defaultType = MyClass;
    var C = Luc.define();
    new C() instanceof Luc.Base
    >false
    new C() instanceof MyClass
    >true
 */

/**
 * @cfg {Function} defaultType this can be changed to any Constructor.  Defaults
 * to Luc.Base.
 */

ClassDefiner = {

    COMPOSITIONS_NAME: '$compositions',

    defaultType: Base,

    processorKeys: {
        $mixins: '_applyMixins',
        $statics: '_applyStatics',
        $compositions: '_applyComposerMethods',
        $super: '_applySuper'
    },

    define: function(opts) {
        var options = opts || {},
            //if super is a falsy value besides undefined that means no superclass
            Super = options.$super || (options.$super === undefined ? this.defaultType : false),
            Constructor;

        options.$super = Super;

        Constructor = this._createConstructor(options);

        this._processAfterCreate(Constructor, options);

        return Constructor;
    },

    _createConstructor: function(options) {
        var superclass = options.$super,
            Constructor = this._createConstructorFn(options);

        if(superclass) {
            Constructor.prototype = Object.create(superclass.prototype);
        }
        
        return Constructor;
    },

    _createConstructorFn: function(options) {
        var superclass = options.$super,
            Constructor;

        if (this._hasConstructorModifyingOptions(options)) {
            Constructor = this._createConstructorFromOptions(options);
        }
        else if(!superclass) {
            Constructor = function() {};
        }
        else {
            Constructor = function() {
                superclass.apply(this, arguments);
            };
        }

        return Constructor;
    },

    _hasConstructorModifyingOptions: function(options) {
        return options.$compositions;
    },

    _createConstructorFromOptions: function(options) {
        var superclass = options.$super,
            me = this,
            initBeforeSuperclass,
            initAfterSuperclass,
            init;

        if (!superclass) {
            init = this._createInitClassFn(options, {
                all: true
            });

            return function() {
                var args = arraySlice.call(arguments);
                init.call(this, options, args);
            };
        }

        initBeforeSuperclass = this._createInitClassFn(options, {
            before: true
        });

        initAfterSuperclass = this._createInitClassFn(options, {
            before: false
        });

        return function() {
            var args = arraySlice.call(arguments);

            initBeforeSuperclass.call(this, options, args);
            superclass.apply(this, arguments);
            initAfterSuperclass.call(this, options, args);
        };
    },

    _createInitClassFn: function(options, config) {
        var me = this,
            compositions = this._filterCompositions(config, options.$compositions);

        if(compositions.length === 0) {
            return emptyFn;
        }
        
        return function(options, instanceArgs) {
            me._initCompositions.call(this, compositions, instanceArgs);
        };
    },

    _filterCompositions: function(config, compositions) {
        var before = config.before, 
            filtered = [];

        if(config.all) {
            return compositions;
        }

        aEach(compositions, function(composition) {
            if(before && composition.initAfter !== true || (!before && composition.initAfter === true)) {
                    filtered.push(composition);
            }
        });

        return filtered;
    },

    _processAfterCreate: function($class, options) {
        this._applyValuesToProto($class, options);
        this._handlePostProcessors($class, options);
    },

    _applyValuesToProto: function($class, options) {
        var proto = $class.prototype,
            values = apply({
                $class: $class
            }, options);

        //Don't put the define specific properties
        //on the prototype
        oEach(values, function(key, value) {
            if (!this._getProcessorKey(key)) {
                proto[key] = value;
            }
        }, this);
    },

    _getProcessorKey: function(key) {
        return this.processorKeys[key];
    },

    _handlePostProcessors: function($class, options) {
        oEach(options, function(key, value) {
            var method = this._getProcessorKey(key);

            if (is.isFunction(this[method])) {
                this[method].call(this, $class, options[key]);
            }
        }, this);
    },

    _applyMixins: function($class, mixins) {
        var proto = $class.prototype;
        aEach(mixins, function(mixin) {
            //accept Constructors or Objects
            var toMix = mixin.prototype || mixin;
            mix(proto, toMix);
        });
    },

    _applyStatics: function($class, statics) {
        var prototype = $class.prototype;

        apply($class, statics);

        if(prototype.getStaticValue === undefined) {
            prototype.getStaticValue = this.getStaticValue;
        }
    },

    _applyComposerMethods: function($class, compositions) {
        var prototype = $class.prototype,
            methodsToCompose;

        aEach(compositions, function(compositionConfig) {
            var composition = new Composition(compositionConfig),
                name = composition.name,
                Constructor = composition.Constructor;

            composition.validate();

            methodsToCompose = composition.getMethodsToCompose();

            methodsToCompose.forEach(function(key) {
                if (prototype[key] === undefined) {
                    prototype[key] = this._createComposerProtoFn(key, name);
                }
            }, this);

            if(prototype.getComposition === undefined) {
                prototype.getComposition = this.getComposition;
            }

        }, this);
    },

    _applySuper: function($class, $super) {
        var proto;
        //super can be falsy to signify no superclass
        if ($super) {
            proto = $class.prototype;
            proto.$super = $super;
            proto.$superclass = $super.prototype;
        }
    },

    _createComposerProtoFn: function(methodName, compositionName) {
        return function() {
            var comp = this[ClassDefiner.COMPOSITIONS_NAME][compositionName];
            return comp[methodName].apply(comp, arguments);
        };
    },

    /**
     * @private
     * @ignore
     * options {Object} the composition config object
     * instanceArgs {Array} the arguments passed to the instance's
     * constructor.
     */
    _initCompositions: function(compositions, instanceArgs) {
        if(!this[ClassDefiner.COMPOSITIONS_NAME]) {
            this[ClassDefiner.COMPOSITIONS_NAME] = {};
        }

        aEach(compositions, function(compositionConfig) {
            var config = apply({
                instance: this,
                instanceArgs: instanceArgs
            }, compositionConfig), 
            composition;

            composition = new Composition(config);

            this[ClassDefiner.COMPOSITIONS_NAME][composition.name] = composition.getInstance();
        }, this);
    },

    //Methods that can get added to the prototype
    //they will be called in the context of the instance.
    //
    getComposition: function(key) {
        return this[ClassDefiner.COMPOSITIONS_NAME][key];
    },

    getStaticValue: function (key, $class) {
        var classToFindValue = $class || this.$class,
            $super,
            value;

        value = classToFindValue[key];

        if(value === undefined) {
            $super = classToFindValue.prototype.$super;
            if($super) {
                return this.getStaticValue(key, $super);
            }
        }

        return value;
    }

};

ClassDefiner.define = ClassDefiner.define.bind(ClassDefiner);

module.exports = ClassDefiner;

/**
 * @class  Luc.define
 * This is actually a function but has a decent amount of important options
 * so we are documenting it like it is a class.  Properties are things that will get
 * applied to instances of classes defined with {@link Luc.define#define define}.  None
 * are needed for {@link Luc.define#define defining} a class.  {@link Luc.define#define define}
 * just takes the passed in config and puts the properties on the prototype and returns
 * a Constructor.
 *

    var C = Luc.define({
        a: 1,
        doLog: true,
        logA: function() {
            if (this.doLog) {
                console.log(this.a);
            }
        }
    });
    var c = new C();
    c.logA();
    >1
    c.a = 45;
    c.logA();
    >45
    c.doLog = false;
    c.logA();

    new C().logA()
    >1

 *
 * Check out the following configs to add functionality to a class without messing
 * up the inheritance chain.  All the configs have examples and documentation on 
 * how to use them.
 *
 * {@link Luc.define#$super super} <br>
 * {@link Luc.define#$compositions compositions} <br>
 * {@link Luc.define#$mixins mixins} <br>
 * {@link Luc.define#$statics statics} <br>
 * 
 * 
 */

/**
 * @method  define
 * @param {Object} config config object used when creating the class.  Any property that
 * is not apart of the special configs will be applied to the prototype.  Check out
 * Luc.define for all the config options.   No configs are needed to define a class.
 * 
 * @return {Function} the defined class
 *
    var C = Luc.define({
        logA: function() {
            console.log(this.a)
        },
        a: 1
    });
    var c = new C();
    c.logA();
    >1

    c.a = 4;
    c.logA();
    >4
 *
 *
 */

/**
 * @property {Function} $class reference to the instances own constructor.  This
 * will get added to any class that is defined with Luc.define.
 * 
    var C = Luc.define()
    var c = new C()
    c.$class === C
    >true
 *
 * There are some really good use cases to have a reference to it's
 * own constructor.  <br> Add functionality to an instance in a simple
 * and generic way.
 *
    var C = Luc.define({
        add: function(a,b) {
            return a + b;
        }
    });

    //Luc.Base applies first 
    //arg to the instance

    var c = new C({
        add: function(a,b,c) {
            return this.$class.prototype.add.call(this, a,b) + c;
        }
    });

    c.add(1,2,3)
    >6
    new C().add(1,2,3)
    >3
 *
 * Or have a simple generic clone method :
 *
    var C = Luc.define({
        clone: function() {
            var myOwnProps = {};
            Luc.Object.each(this, function(key, value) {
                myOwnProps[key] = value;
            });

            return new this.$class(myOwnProps);
        }
    });

    var c = new C({a:1,b:2,c:3});
    c.d = 4;
    var clone = c.clone();

    clone === c
    >false

    clone.a
    >1
    clone.b
    >2
    clone.c
    >3
    clone.d
    >4
 */

/**
 * @property {Function} [$super] If $super is not false or null 
 * the $super property will be added to every instance of the defined class,
 * $super is the Constructor passed in with the $super config or the {@link Luc.ClassDefiner#defaultType default}
 * 
    var C = Luc.define()
    var c = new C()
    //Luc.Base is the default 
    c.$super === Luc.Base
    >true
 */

/**
 * @property {Function} [$superclass] If $super is defined it
 * will be the prototype of $super.  It can be used to call a parent's
 * method
 * 
    function MyCoolClass() {}
    MyCoolClass.prototype.addNums = function(a,b) {
        return a + b;
    }

    var MyOtherCoolClass = Luc.define({
        $super: MyCoolClass,
        addNums: function(a, b, c) {
            return this.$superclass.addNums.call(this, a, b) + c;
        }
    })

    var m = new MyOtherCoolClass();
    m.addNums(1,2,3);
    >6
 */

/**
 * @property {Function} getStaticValue this method
 * will be added to instances that use the {@link Luc.define#$statics $statics}
 * config.
 *
 * 
 * This should be used over this.$class.staticName to
 * get the value of static.  If the class gets inherited
 * from, this.$class will not be the same.  getStatic value
 * deals with this issue.
 * 
    var A = Luc.define({
        $statics: {
            a: 1
            },
        getABetter: function() {
            return this.getStaticValue('a');
        },
        getA: function() {
            return this.$class.a;
        }
    });

    var B = Luc.define({
        $super: A,
        $statics: {
            b: 2,
            c: 3
        }
    });

    
    var b = new B();
    b.getA();
    >undefined
    b.getABetter();
    >1

 * @return {Object} the static value of the key
 */

    
/**
 * @property {Function} getComposition this method will be
 * to instances that use the {@link Luc.define#$compositions $compositions}  config
 *
 *  This will return the composition instance based off the composition {@link Luc.Composition#name name}
    
    this.getComposition("name");
    
 *
 */


/**
 * @cfg {Object} $statics (optional) Add static properties or methods
 * to the class.  These properties/methods will not be able to be
 * directly modified by the instance so they are good for defining default
 * configs.  Using this config adds the {@link Luc.define#getStaticValue getStaticValue}
 * method to instances.
 *
    var C = Luc.define({
        $statics: {
            number: 1
        }
    });

    var c = new C();
    c.number
    >undefined
    C.number
    >1
    
 *
 * Bad things can happen if non primitives are placed on the 
 * prototype and instance sharing is not wanted.  Using statics
 * prevent subclasses and instances from unknowingly modifying
 * all instances.
 * 
    var C = Luc.define({
        cfg: {
            a: 1
        }
    });

    var c = new C();
    c.cfg.a
    >1
    c.cfg.a = 5
    new C().cfg.a
    >5
 *
 */

/**
 * @property {Function} [$superclass] If $super is defined it
 * will the prototype of $super.  It can be used to call parent's
 * method
 * 
    function MyCoolClass() {}
    MyCoolClass.prototype.addNums = function(a,b) {
        return a + b;
    }

    var MyOtherCoolClass = Luc.define({
        $super: MyCoolClass,
        addNums: function(a, b, c) {
            return this.$superclass.addNums.call(this, a, b) + c;
        }
    })

    var m = new MyOtherCoolClass();
    m.addNums(1,2,3);
    >6
 */

/**
 * @cfg {Object/Constructor/Object[]/Constructor[]} $mixins (optional)  Mixins are a way to add functionality
 * to a class that should not add state to the instance unknowingly.  Mixins can be either objects or Constructors.
 *
    function Logger() {}
    Logger.prototype.log = function() {
        console.log(arguments)
    }

    var C = Luc.define({
        $mixins: [Logger, {
            warn: function() {
                console.warn(arguments)
            }
        }]
    });

    var c = new C();

    c.log(1,2)
    >[1,2]

    c.warn(3,4)
    >[3,4]
 *
 */
/**
 * @cfg {Constructor} $super (optional)  super for the defining class.  By Luc.Base
 * is the default if super is not passed in.  To define a class without a superclass
 * you can pass in false or null.
 *
     function Counter() {
        this.count = 0;
     };

     Counter.prototype = {
        getCount: function() {
            return this.count;
        },
        increaseCount: function() {
            this.count++;
        }
     }

     var C = Luc.define({
        $super:Counter
    });

    var c = new C()

    c instanceof Counter
    >true
    c.increaseCount();
    c.getCount();
    >1
    c.count
    >1
 *
 * Check out Luc.Base to see why we have it as the default.
 * 
    var B = Luc.define({
        amIALucBase: function() {
            return this instanceof Luc.Base
        }
    })
    var b = new B();
    b.amIALucBase();
    >true
 *
 * 
 */



/**
 * @cfg {Object/Object[]} $compositions (optional) config objects for 
 * Luc.Composition.  Compositions are a great way to add behavior to a class
 * without extending it.  A {@link Luc.define#$mixins mixin} can offer similar functionality but should
 * not be adding an unneeded state.  A Constructor and a name are needed for the config object.
 *  Using this config adds the {@link Luc.define#getComposition getComposition}
 * method to instances.
 * <br>
 * The methods property is optional here but it is saying take all of 
 * Luc.EventEmitter's instance methods and make them instance methods for C.
 * You can check out all of the config options by looking at Luc.Composition.
 * 
        var C = Luc.define({
            $compositions: {
                Constructor: Luc.EventEmitter,
                name: 'emitter',
                methods: 'allMethods'
            }
        });

        var c = new C();

        c.on('hey', function() {
            console.log(arguments);
        });

        c.emit('hey', 1,2,3, 'a');
        >[1, 2, 3, "a"]
        c instanceof Luc.EventEmitter
        >false
        c._events
        >undefined
 *
 * Luc.EventEmitter is preferred as a composition over a mixin because
 * it adds a state "_events" to the this instance when on is called.  It
 * also shouldn't have to know that it may be instantiated alone or mixed into classes
 * so the initing of state is not done in the constructor like it probably should.
 * It is not terrible practice by any means but it is not good to have a standalone class
 * that knows that it may be mixin.  Even worse than that would be a mixin that needs
 * to be inited by the defining class.  Encapsulating logic in a class
 * and using it anywhere seamlessly is where compositions shine. Luc comes with two common 
 * {@link Luc#compositionEnums enums} that we expect will be used often.
 * 
 * <br>
 * Here is an example of a simple composition see how the functionality 
 * is added but we are not inheriting and this.count is
 * undefined.
 *
         function Counter() {
            this.count = 0;
         };

         Counter.prototype = {
            getCount: function() {
                return this.count;
            },
            increaseCount: function() {
                this.count++;
            }
         }

         var C = Luc.define({
                $compositions: {
                    name: 'counter',
                    Constructor: Counter,
                    methods: 'allMethods'
                }
        });

        var c = new C()

        c.increaseCount();
        c.increaseCount();
        c.increaseCount();
        c.getCount();
        >3
        c.count
        >undefined
 *
 * Luc comes with two default composition objects Luc.compositionEnums.PluginManager
 * and Luc.compositionEnums.EventEmitter.
 * 
 * Here is the plugin manager enum, keep in mind that this
 * functionality can be added to any class, not just ones defined with 
 * Luc.define.  Check out Luc.PluginManager to see all of the public 
 * methods that gets added to the defined instance.
   
    function MyClass() {};

    function MyPlugin() {
        this.myCoolName = 'coo';

        this.init = function() {
            console.log('im getting initted');
        }
        this.destroy = function() {
            console.log('MyPlugin instance being destroyed')
        }
    }

    var C = Luc.define({
        $super: MyClass,
        $compositions: Luc.compositionEnums.PluginManager
    });

    var c = new C({
        plugins: [{
                Constructor: MyPlugin,
                myCoolName: 'coo'
            }
        ]
    });
    >im getting initted
    c instanceof MyClass
    >true

    c.getPlugin({myCoolName: 'coo'}) instanceof MyPlugin
    > true


    c.a = 1;
    //This will be the default Luc.Plugin
    c.addPlugin({
        init: function(owner) {
            console.log(owner.a)
        },
        destroy: function() {
            console.log('Im getting destroyed')
        }
    });

    >1

    c.destroyAllPlugins();
    >MyPlugin instance being destroyed
    >I'm getting destroyed.

    c.getPlugin({myCoolName: 'coo'})
    >false
 *
 * You can see that it can add plugin like behavior to any defining
 * class with Luc.PluginManager which is less than 75 SLOC.
 */
},{"./base":38,"./composition":48,"../object":32,"../function":33,"../array":34,"../is":36}],40:[function(require,module,exports){
var aEach = require('../array').each,
    obj = require('../object'),
    emptyFn = require('../function').emptyFn,
    apply = obj.apply;

/**
 * @class Luc.Plugin
 * Simple class that is the default plugin type for Luc.PluginManager
 */
function Plugin(config) {
    apply(this, config);
}

Plugin.prototype = {
    /**
     * @method
     * @param {Object} owner the owner instance
     * Simple hook to initialize the plugin
     * Defaults to Luc.emptyFn.
     */
    init: emptyFn,
    /**
     * @method Defaults to Luc.emptyFn.
     * Called when the plugin is being {@link Luc.PluginManager#destroyPlugin destroyed}.
     */
    destroy: emptyFn
};

module.exports = Plugin;

},{"../array":34,"../object":32,"../function":33}],41:[function(require,module,exports){
var Plugin = require('./plugin'),
    is = require('../is'),
    obj = require('../object'),
    arr = require('../array'),
    aEach = arr.each,
    mix = obj.mix,
    apply = obj.apply;

function PluginManager(config) {
    this._init(config);
}

/**
 * @protected
 * @class Luc.PluginManager
 * This class is used by Luc.compositionEnums#PluginManager to add its functionality 
 * to any class.   By {@link Luc.compositionEnums#PluginManager default} it adds
 * all of these public methods to the instance.This class is designed to work as a composition, 
 * it is exposed as not private so it can be extended if needed.   Check "protected" which
 * is a part of the Show v dropdown on the right to see the protected methods.
 *
    function MyPlugin() {
        this.myCoolName = 'coo';

        this.init = function() {
            console.log('im getting initted');
        }
        this.destroy = function() {
            console.log('MyPlugin instance being destroyed')
        }
    }

    var C = Luc.define({
        $compositions: Luc.compositionEnums.PluginManager
    });

    var c = new C({
        plugins: [{
                Constructor: MyPlugin,
                myCoolName: 'coo'
            }
        ]
    });

    >im getting initted

    var plugInstance = c.addPlugin({
        destroy: function() {
            console.log('Im getting destroyed')
        }
    });

    c.getPlugin(Luc.Plugin)
    > Plugin {destroy: function, owner: MyClass, init: function, destroy: function}

    c.getPlugin(MyPlugin)
    > MyPlugin {myCoolName: "coo", init: function, destroy: function}

    c.destroyAllPlugins()

    >MyPlugin instance being destroyed
    >Im getting destroyed

    c.getPlugin(MyPlugin)
    >false

 */
PluginManager.prototype = {
   /**
    * @cfg {Constructor} defaultPlugin
    */
    defaultPlugin: Plugin,

    /**
     * @protected
     */
    _init: function(instanceValues) {
        apply(this, instanceValues);
        this.plugins = [];
        this._createPlugins();
    },

    /**
     * @protected
     */
    _createPlugins: function() {
        aEach(this._getPluginConfigFromInstance(), function(pluginConfig) {
            this.addPlugin(pluginConfig);
        }, this);
    },

    /**
     * @protected
     */
    _getPluginConfigFromInstance: function() {
        var config = this.instanceArgs[0] || {};
        return config.plugins;
    },

    /**
     * Add a plugin to the instance and init the 
     * plugin.
     * @param  {Object} pluginConfig
     * @return {Object} the created plugin instance
     */
    addPlugin: function(pluginConfig) {
        var pluginInstance = this._createPlugin(pluginConfig);

        this._initPlugin(pluginInstance);

        this.plugins.push(pluginInstance);

        return pluginInstance;
    },

    /**
     * @protected
     */
    _createPlugin: function(config) {
        config.owner = this.instance;

        if (config.Constructor) {
            //call the configed Constructor with the 
            //passed in config but take off the Constructor
            //config.
             
            //The plugin Constructor 
            //should not need to know about itself
            return new config.Constructor(apply(config, {
                Constructor: undefined
            }));
        }

        return new this.defaultPlugin(config);
    },

    /**
     * @protected
     */
    _initPlugin: function(plugin) {
        if (is.isFunction(plugin.init)) {
            plugin.init(this.instance);
        }
    },

    /**
     * Call destroy on all of the plugins
     * and remove them.
     */
    destroyAllPlugins: function() {
        this.plugins.forEach(function(plugin) {
            this._destroyPlugin(plugin);
        }, this);

        this.plugins = [];
    },

    _destroyPlugin: function(plugin) {
        if (is.isFunction(plugin.destroy)) {
            plugin.destroy(this.instance);
        }
    },

    /**
     * Remove the plugin and if found destroy it.
     * @param  {Object/Constructor} object to use to match 
     * the plugin to remove.
     * @return {Object} the destroyed plugin.
     */
    destroyPlugin: function(obj) {
        var plugin = this.getPlugin(obj);

        if(plugin) {
            this._destroyPlugin(plugin);
            arr.removeFirst(this.plugins, plugin, {type: 'strict'});
        }

        return plugin;
    },

    /**
     * Get a plugin instance.  A Constructor or an object can be used
     * to find a plugin.
     *
          c.addPlugin({a:1})
          c.getPlugin({a:1})
          >Luc.Plugin({a:1})

     * @param  {Object} obj 
     * @return {Object} the plugin instance if found.
     */
    getPlugin: function(obj) {
        if (is.isFunction(obj)) {
            return arr.findFirstInstanceOf(this.plugins, obj);
        }
        return arr.findFirst(this.plugins, obj, {type: 'loose'});
    }
};

module.exports = PluginManager;
},{"./plugin":40,"../is":36,"../object":32,"../array":34}],42:[function(require,module,exports){
var EventEmitter = require('../events/eventEmitter'),
    PluginManager = require('./pluginManager');

/**
 * @class Luc.compositionEnums
 * Composition enums are just common config objects for Luc.Composition.
 * Here is an example of a composition that uses EventEmitter but only
 * puts the emit method on the prototype.
 *
    var C = Luc.define({
        $compositions: {
            defaults: Luc.compositionEnums.EventEmitter,
            methods: ['emit']
        }
    });

    var c = new C();

    typeof c.emit
    >"function"
    typeof c.on
    "undefined"
 * 
 */

/**
 * @property {Object} EventEmitter
 */
module.exports.EventEmitter = {
    Constructor: EventEmitter,
    name: 'emitter',
    methods: 'allMethods'
};


/**
 * @property {Object} PluginManager
 */
module.exports.PluginManager = {
    name: 'plugins',
    initAfter: true,
    Constructor: PluginManager,
    create: function() {
        var manager = new this.Constructor({
            instance: this.instance,
            instanceArgs: this.instanceArgs
        });

        return manager;
    },
    ignoreMethods: 'defaultPlugin',
    methods: 'publicMethods'
};
},{"../events/eventEmitter":37,"./pluginManager":41}],45:[function(require,module,exports){
/* automatically generated by JSCoverage - do not edit */
if (typeof _$jscoverage === 'undefined') _$jscoverage = {};
if (! _$jscoverage['class/composition.js']) {
  _$jscoverage['class/composition.js'] = [];
  _$jscoverage['class/composition.js'][1] = 0;
  _$jscoverage['class/composition.js'][66] = 0;
  _$jscoverage['class/composition.js'][67] = 0;
  _$jscoverage['class/composition.js'][70] = 0;
  _$jscoverage['class/composition.js'][71] = 0;
  _$jscoverage['class/composition.js'][72] = 0;
  _$jscoverage['class/composition.js'][75] = 0;
  _$jscoverage['class/composition.js'][78] = 0;
  _$jscoverage['class/composition.js'][139] = 0;
  _$jscoverage['class/composition.js'][140] = 0;
  _$jscoverage['class/composition.js'][144] = 0;
  _$jscoverage['class/composition.js'][148] = 0;
  _$jscoverage['class/composition.js'][149] = 0;
  _$jscoverage['class/composition.js'][151] = 0;
  _$jscoverage['class/composition.js'][152] = 0;
  _$jscoverage['class/composition.js'][168] = 0;
  _$jscoverage['class/composition.js'][171] = 0;
  _$jscoverage['class/composition.js'][233] = 0;
  _$jscoverage['class/composition.js'][234] = 0;
  _$jscoverage['class/composition.js'][235] = 0;
  _$jscoverage['class/composition.js'][236] = 0;
  _$jscoverage['class/composition.js'][237] = 0;
  _$jscoverage['class/composition.js'][241] = 0;
  _$jscoverage['class/composition.js'][245] = 0;
  _$jscoverage['class/composition.js'][250] = 0;
  _$jscoverage['class/composition.js'][251] = 0;
  _$jscoverage['class/composition.js'][253] = 0;
  _$jscoverage['class/composition.js'][255] = 0;
  _$jscoverage['class/composition.js'][256] = 0;
  _$jscoverage['class/composition.js'][260] = 0;
  _$jscoverage['class/composition.js'][266] = 0;
  _$jscoverage['class/composition.js'][270] = 0;
}
_$jscoverage['class/composition.js'][1]++;
var obj = require("../object"), array = require("../array"), apply = obj.apply, mix = obj.mix, oFilter = obj.filter, emptyFn = "../function".emptyFn, is = require("../is");
_$jscoverage['class/composition.js'][66]++;
function Composition(c) {
  _$jscoverage['class/composition.js'][67]++;
  var defaults = c.defaults, config = c;
  _$jscoverage['class/composition.js'][70]++;
  if (defaults) {
    _$jscoverage['class/composition.js'][71]++;
    mix(config, config.defaults);
    _$jscoverage['class/composition.js'][72]++;
    delete config.defaults;
  }
  _$jscoverage['class/composition.js'][75]++;
  apply(this, config);
}
_$jscoverage['class/composition.js'][78]++;
Composition.prototype = {create: (function () {
  _$jscoverage['class/composition.js'][139]++;
  var Constructor = this.Constructor;
  _$jscoverage['class/composition.js'][140]++;
  return new Constructor();
}), getInstance: (function () {
  _$jscoverage['class/composition.js'][144]++;
  return this.create();
}), validate: (function () {
  _$jscoverage['class/composition.js'][148]++;
  if (this.name === undefined) {
    _$jscoverage['class/composition.js'][149]++;
    throw new Error("A name must be defined");
  }
  _$jscoverage['class/composition.js'][151]++;
  if (! is.isFunction(this.Constructor) && this.create === Composition.prototype.create) {
    _$jscoverage['class/composition.js'][152]++;
    throw new Error("The Constructor must be function if create is not overridden");
  }
}), filterMethodFns: {allMethods: (function (key, value) {
  _$jscoverage['class/composition.js'][168]++;
  return is.isFunction(value);
}), publicMethods: (function (key, value) {
  _$jscoverage['class/composition.js'][171]++;
  return is.isFunction(value) && key.charAt(0) !== "_";
})}, methods: emptyFn, ignoreMethods: undefined, getObjectWithMethods: (function () {
  _$jscoverage['class/composition.js'][233]++;
  var methodsObj = this.Constructor && this.Constructor.prototype;
  _$jscoverage['class/composition.js'][234]++;
  if (this.ignoreMethods) {
    _$jscoverage['class/composition.js'][235]++;
    methodsObj = apply({}, methodsObj);
    _$jscoverage['class/composition.js'][236]++;
    array.each(this.ignoreMethods, (function (value) {
  _$jscoverage['class/composition.js'][237]++;
  delete methodsObj[value];
}));
  }
  _$jscoverage['class/composition.js'][241]++;
  return methodsObj;
}), getMethodsToCompose: (function () {
  _$jscoverage['class/composition.js'][245]++;
  var methods = this.methods, pairsToAdd, filterFn;
  _$jscoverage['class/composition.js'][250]++;
  if (is.isArray(methods)) {
    _$jscoverage['class/composition.js'][251]++;
    pairsToAdd = methods;
  }
  else {
    _$jscoverage['class/composition.js'][253]++;
    filterFn = methods;
    _$jscoverage['class/composition.js'][255]++;
    if (is.isString(methods)) {
      _$jscoverage['class/composition.js'][256]++;
      filterFn = this.filterMethodFns[methods];
    }
    _$jscoverage['class/composition.js'][260]++;
    pairsToAdd = oFilter(this.getObjectWithMethods(), filterFn, this, {ownProperties: false, keys: true});
  }
  _$jscoverage['class/composition.js'][266]++;
  return pairsToAdd;
})};
_$jscoverage['class/composition.js'][270]++;
module.exports = Composition;
_$jscoverage['class/composition.js'].source = ["var obj = require('../object'),","    array = require('../array'),","    apply = obj.apply,","    mix = obj.mix,","    oFilter = obj.filter,","    emptyFn = ('../function').emptyFn,","    is = require('../is');","","/**"," * @class  Luc.Composition"," * @protected"," * Class that wraps {@link Luc.define#$compositions composition} config objects"," * to conform to an api. This class is not available externally.  The config object"," * will override any protected methods and default configs.  Defaults"," * can be used for often used configs, keys that are not defaults will"," * override the defaults."," *","    var C = Luc.define({","        $compositions: {","            defaults: Luc.compositionEnums.EventEmitter,","            methods: ['emit']","        }","    });","","    var c = new C()","    typeof c.emit","    &gt;\"function\"","    typeof c.on","    &gt;\"undefined\""," *"," * If you want to add your own composition all you need to have is"," * a name and a Constructor, the rest of the configs of this class and Luc.Composition.create"," * can be used to inject behavior if needed."," * ","     function Counter() {","        this.count = 0;","     };","","     Counter.prototype = {","        getCount: function() {","            return this.count;","        },","        increaseCount: function() {","            this.count++;","        }","     }","","     var C = Luc.define({","            $compositions: {","                name: 'counter',","                Constructor: Counter,","                methods: 'allMethods'","            }","    });","","    var c = new C()","","    c.increaseCount();","    c.increaseCount();","    c.increaseCount();","    c.getCount();","    &gt;3","    c.count","    &gt;undefined"," */","function Composition(c) {","    var defaults = c.defaults,","        config = c;","","    if(defaults) {","        mix(config, config.defaults);","        delete config.defaults;","    }","","    apply(this, config);","}","","Composition.prototype = {","    /**","     * @cfg {String} name (required) the name","     */","    ","    /**","     * @cfg {Object} defaults","     */","    ","    /**","     * @cfg {Boolean} initAfter  defaults to false","     * pass in true to init the composition instance after the ","     * superclass has been called.","     */","","    /**","     * @cfg {Function} Constructor (required) the Constructor","     * to use when creating the composition instance.  This","     * is required if Luc.Composition.create is not overwritten by","     * the passed in composition config object.","     */","    ","    /**","     * @protected","     * By default just return a newly created Constructor instance.","     * ","     * When create is called the following properties can be used :","     * ","     * this.instance The instance that is creating","     * the composition.","     * ","     * this.Constructor the constructor that is passed in from","     * the composition config. ","     *","     * this.instanceArgs the arguments passed into the instance when it ","     * is being created.  For example","","        new MyClassWithAComposition({plugins: []})","        //inside of the create method","        this.instanceArgs","        &gt;[{plugins: []}]","","     * @return {Object} ","     * the composition instance.","     *","     * For example set the emitters maxListeners","     * to what the instance has configed.","      ","        maxListeners: 100,","        $compositions: {","            Constructor: Luc.EventEmitter,","            create: function() {","                var emitter = new this.Constructor();","                emitter.setMaxListeners(this.instance.maxListeners);","                return emitter;","            },","            name: 'emitter'","        }","","     */","    create: function() {","        var Constructor = this.Constructor;","        return new Constructor();","    },","","    getInstance: function() {","        return this.create();","    },","","    validate: function() {","        if(this.name  === undefined) {","            throw new Error('A name must be defined');","        }","        if(!is.isFunction(this.Constructor) &amp;&amp; this.create === Composition.prototype.create) {","            throw new Error('The Constructor must be function if create is not overridden');","        }","    },","","    /**","     * @property filterMethodFns","     * @type {Object}","     * @property filterMethodFns.allMethods return all methods from the","     * constructors prototype","     * @property filterMethodFns.public return all methods that don't","     * start with _.  We know not everyone follows this convention, but we","     * do and so do many others.","     * @type {Function}","     */","    filterMethodFns: {","        allMethods: function(key, value) {","            return is.isFunction(value);","        },","        publicMethods: function(key, value) {","            return is.isFunction(value) &amp;&amp; key.charAt(0) !== '_';","        }","    },","","    /**","     * @cfg {Function/String/Array[]} methods","     * The keys to add to the definers prototype that will in turn call","     * the compositions method.","     * ","     * Defaults to Luc.emptyFn. ","     * If an array is passed it will just use that Array.","     * ","     * If a string is passed and matches a method from ","     * Luc.Composition.filterMethodFns it will call that instead.","     * ","     * If a function is defined it","     * will get called while iterating over each key value pair of the ","     * Constructor's prototype, if a truthy value is ","     * returned the property will be added to the defining","     * classes prototype.","     * ","     * For example this config will only expose the emit method ","     * to the defining class","     ","        $compositions: {","            Constructor: Luc.EventEmitter,","            methods: function(key, value) {","                return key === 'emit';","            },","            name: 'emitter'","        }","     * this is also a valid config","     * ","        $compositions: {","            Constructor: Luc.EventEmitter,","            methods: ['emitter'],","            name: 'emitter'","        }","     * ","     */","    methods: emptyFn,","","    /**","     * @cfg {String[]/String} ignoreMethods methods that will always","     * be ignored if methods is not an Array.","     *","        ","        var C = Luc.define({","                $compositions: {","                    defaults: Luc.compositionEnums.EventEmitter,","                    methods: 'allMethods',","                    ignoreMethods: ['emit']","                }","            });","","            var c = new C();","            typeof c.emit","            &gt;\"undefined\"","     */","    ignoreMethods: undefined,","","    getObjectWithMethods: function() {","        var methodsObj = this.Constructor &amp;&amp; this.Constructor.prototype;","        if (this.ignoreMethods) {","            methodsObj = apply({}, methodsObj);","            array.each(this.ignoreMethods, function(value) {","                delete methodsObj[value];","            });","        }","","        return methodsObj;","    },","","    getMethodsToCompose: function() {","        var methods = this.methods,","            pairsToAdd,","            filterFn;","","","        if (is.isArray(methods)) {","            pairsToAdd = methods;","        } else {","            filterFn = methods;","","            if (is.isString(methods)) {","                filterFn = this.filterMethodFns[methods];","            }","","            //Constructors are not needed if create is overwritten","            pairsToAdd = oFilter(this.getObjectWithMethods(), filterFn, this, {","                ownProperties: false,","                keys: true","            });","        }","","        return pairsToAdd;","    }","};","","module.exports = Composition;"];

},{"../object":17,"../array":18,"../is":19}],46:[function(require,module,exports){
(function(){// Copyright 2009-2012 by contributors, MIT License
// vim: ts=4 sts=4 sw=4 expandtab

// Module systems magic dance
(function (definition) {
    // RequireJS
    if (typeof define == "function") {
        define(definition);
    // YUI3
    } else if (typeof YUI == "function") {
        YUI.add("es5", definition);
    // CommonJS and <script>
    } else {
        definition();
    }
})(function () {

/**
 * Brings an environment as close to ECMAScript 5 compliance
 * as is possible with the facilities of erstwhile engines.
 *
 * Annotated ES5: http://es5.github.com/ (specific links below)
 * ES5 Spec: http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf
 * Required reading: http://javascriptweblog.wordpress.com/2011/12/05/extending-javascript-natives/
 */

//
// Function
// ========
//

// ES-5 15.3.4.5
// http://es5.github.com/#x15.3.4.5

function Empty() {}

if (!Function.prototype.bind) {
    Function.prototype.bind = function bind(that) { // .length is 1
        // 1. Let Target be the this value.
        var target = this;
        // 2. If IsCallable(Target) is false, throw a TypeError exception.
        if (typeof target != "function") {
            throw new TypeError("Function.prototype.bind called on incompatible " + target);
        }
        // 3. Let A be a new (possibly empty) internal list of all of the
        //   argument values provided after thisArg (arg1, arg2 etc), in order.
        // XXX slicedArgs will stand in for "A" if used
        var args = _Array_slice_.call(arguments, 1); // for normal call
        // 4. Let F be a new native ECMAScript object.
        // 11. Set the [[Prototype]] internal property of F to the standard
        //   built-in Function prototype object as specified in 15.3.3.1.
        // 12. Set the [[Call]] internal property of F as described in
        //   15.3.4.5.1.
        // 13. Set the [[Construct]] internal property of F as described in
        //   15.3.4.5.2.
        // 14. Set the [[HasInstance]] internal property of F as described in
        //   15.3.4.5.3.
        var bound = function () {

            if (this instanceof bound) {
                // 15.3.4.5.2 [[Construct]]
                // When the [[Construct]] internal method of a function object,
                // F that was created using the bind function is called with a
                // list of arguments ExtraArgs, the following steps are taken:
                // 1. Let target be the value of F's [[TargetFunction]]
                //   internal property.
                // 2. If target has no [[Construct]] internal method, a
                //   TypeError exception is thrown.
                // 3. Let boundArgs be the value of F's [[BoundArgs]] internal
                //   property.
                // 4. Let args be a new list containing the same values as the
                //   list boundArgs in the same order followed by the same
                //   values as the list ExtraArgs in the same order.
                // 5. Return the result of calling the [[Construct]] internal
                //   method of target providing args as the arguments.

                var result = target.apply(
                    this,
                    args.concat(_Array_slice_.call(arguments))
                );
                if (Object(result) === result) {
                    return result;
                }
                return this;

            } else {
                // 15.3.4.5.1 [[Call]]
                // When the [[Call]] internal method of a function object, F,
                // which was created using the bind function is called with a
                // this value and a list of arguments ExtraArgs, the following
                // steps are taken:
                // 1. Let boundArgs be the value of F's [[BoundArgs]] internal
                //   property.
                // 2. Let boundThis be the value of F's [[BoundThis]] internal
                //   property.
                // 3. Let target be the value of F's [[TargetFunction]] internal
                //   property.
                // 4. Let args be a new list containing the same values as the
                //   list boundArgs in the same order followed by the same
                //   values as the list ExtraArgs in the same order.
                // 5. Return the result of calling the [[Call]] internal method
                //   of target providing boundThis as the this value and
                //   providing args as the arguments.

                // equiv: target.call(this, ...boundArgs, ...args)
                return target.apply(
                    that,
                    args.concat(_Array_slice_.call(arguments))
                );

            }

        };
        if(target.prototype) {
            Empty.prototype = target.prototype;
            bound.prototype = new Empty();
            // Clean up dangling references.
            Empty.prototype = null;
        }
        // XXX bound.length is never writable, so don't even try
        //
        // 15. If the [[Class]] internal property of Target is "Function", then
        //     a. Let L be the length property of Target minus the length of A.
        //     b. Set the length own property of F to either 0 or L, whichever is
        //       larger.
        // 16. Else set the length own property of F to 0.
        // 17. Set the attributes of the length own property of F to the values
        //   specified in 15.3.5.1.

        // TODO
        // 18. Set the [[Extensible]] internal property of F to true.

        // TODO
        // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).
        // 20. Call the [[DefineOwnProperty]] internal method of F with
        //   arguments "caller", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
        //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and
        //   false.
        // 21. Call the [[DefineOwnProperty]] internal method of F with
        //   arguments "arguments", PropertyDescriptor {[[Get]]: thrower,
        //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},
        //   and false.

        // TODO
        // NOTE Function objects created using Function.prototype.bind do not
        // have a prototype property or the [[Code]], [[FormalParameters]], and
        // [[Scope]] internal properties.
        // XXX can't delete prototype in pure-js.

        // 22. Return F.
        return bound;
    };
}

// Shortcut to an often accessed properties, in order to avoid multiple
// dereference that costs universally.
// _Please note: Shortcuts are defined after `Function.prototype.bind` as we
// us it in defining shortcuts.
var call = Function.prototype.call;
var prototypeOfArray = Array.prototype;
var prototypeOfObject = Object.prototype;
var _Array_slice_ = prototypeOfArray.slice;
// Having a toString local variable name breaks in Opera so use _toString.
var _toString = call.bind(prototypeOfObject.toString);
var owns = call.bind(prototypeOfObject.hasOwnProperty);

// If JS engine supports accessors creating shortcuts.
var defineGetter;
var defineSetter;
var lookupGetter;
var lookupSetter;
var supportsAccessors;
if ((supportsAccessors = owns(prototypeOfObject, "__defineGetter__"))) {
    defineGetter = call.bind(prototypeOfObject.__defineGetter__);
    defineSetter = call.bind(prototypeOfObject.__defineSetter__);
    lookupGetter = call.bind(prototypeOfObject.__lookupGetter__);
    lookupSetter = call.bind(prototypeOfObject.__lookupSetter__);
}

//
// Array
// =====
//

// ES5 15.4.4.12
// http://es5.github.com/#x15.4.4.12
// Default value for second param
// [bugfix, ielt9, old browsers]
// IE < 9 bug: [1,2].splice(0).join("") == "" but should be "12"
if ([1,2].splice(0).length != 2) {
    var array_splice = Array.prototype.splice;

    if(function() { // test IE < 9 to splice bug - see issue #138
        function makeArray(l) {
            var a = [];
            while (l--) {
                a.unshift(l)
            }
            return a
        }

        var array = []
            , lengthBefore
        ;

        array.splice.bind(array, 0, 0).apply(null, makeArray(20));
        array.splice.bind(array, 0, 0).apply(null, makeArray(26));

        lengthBefore = array.length; //20
        array.splice(5, 0, "XXX"); // add one element

        if(lengthBefore + 1 == array.length) {
            return true;// has right splice implementation without bugs
        }
        // else {
        //    IE8 bug
        // }
    }()) {//IE 6/7
        Array.prototype.splice = function(start, deleteCount) {
            if (!arguments.length) {
                return [];
            } else {
                return array_splice.apply(this, [
                    start === void 0 ? 0 : start,
                    deleteCount === void 0 ? (this.length - start) : deleteCount
                ].concat(_Array_slice_.call(arguments, 2)))
            }
        };
    }
    else {//IE8
        Array.prototype.splice = function(start, deleteCount) {
            var result
                , args = _Array_slice_.call(arguments, 2)
                , addElementsCount = args.length
            ;

            if(!arguments.length) {
                return [];
            }

            if(start === void 0) { // default
                start = 0;
            }
            if(deleteCount === void 0) { // default
                deleteCount = this.length - start;
            }

            if(addElementsCount > 0) {
                if(deleteCount <= 0) {
                    if(start == this.length) { // tiny optimisation #1
                        this.push.apply(this, args);
                        return [];
                    }

                    if(start == 0) { // tiny optimisation #2
                        this.unshift.apply(this, args);
                        return [];
                    }
                }

                // Array.prototype.splice implementation
                result = _Array_slice_.call(this, start, start + deleteCount);// delete part
                args.push.apply(args, _Array_slice_.call(this, start + deleteCount, this.length));// right part
                args.unshift.apply(args, _Array_slice_.call(this, 0, start));// left part

                // delete all items from this array and replace it to 'left part' + _Array_slice_.call(arguments, 2) + 'right part'
                args.unshift(0, this.length);

                array_splice.apply(this, args);

                return result;
            }

            return array_splice.call(this, start, deleteCount);
        }

    }
}

// ES5 15.4.4.12
// http://es5.github.com/#x15.4.4.13
// Return len+argCount.
// [bugfix, ielt8]
// IE < 8 bug: [].unshift(0) == undefined but should be "1"
if ([].unshift(0) != 1) {
    var array_unshift = Array.prototype.unshift;
    Array.prototype.unshift = function() {
        array_unshift.apply(this, arguments);
        return this.length;
    };
}

// ES5 15.4.3.2
// http://es5.github.com/#x15.4.3.2
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray
if (!Array.isArray) {
    Array.isArray = function isArray(obj) {
        return _toString(obj) == "[object Array]";
    };
}

// The IsCallable() check in the Array functions
// has been replaced with a strict check on the
// internal class of the object to trap cases where
// the provided function was actually a regular
// expression literal, which in V8 and
// JavaScriptCore is a typeof "function".  Only in
// V8 are regular expression literals permitted as
// reduce parameters, so it is desirable in the
// general case for the shim to match the more
// strict and common behavior of rejecting regular
// expressions.

// ES5 15.4.4.18
// http://es5.github.com/#x15.4.4.18
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/array/forEach

// Check failure of by-index access of string characters (IE < 9)
// and failure of `0 in boxedString` (Rhino)
var boxedString = Object("a"),
    splitString = boxedString[0] != "a" || !(0 in boxedString);

if (!Array.prototype.forEach) {
    Array.prototype.forEach = function forEach(fun /*, thisp*/) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                object,
            thisp = arguments[1],
            i = -1,
            length = self.length >>> 0;

        // If no callback function or if callback is not a callable function
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(); // TODO message
        }

        while (++i < length) {
            if (i in self) {
                // Invoke the callback function with call, passing arguments:
                // context, property value, property key, thisArg object
                // context
                fun.call(thisp, self[i], i, object);
            }
        }
    };
}

// ES5 15.4.4.19
// http://es5.github.com/#x15.4.4.19
// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map
if (!Array.prototype.map) {
    Array.prototype.map = function map(fun /*, thisp*/) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                object,
            length = self.length >>> 0,
            result = Array(length),
            thisp = arguments[1];

        // If no callback function or if callback is not a callable function
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
        }

        for (var i = 0; i < length; i++) {
            if (i in self)
                result[i] = fun.call(thisp, self[i], i, object);
        }
        return result;
    };
}

// ES5 15.4.4.20
// http://es5.github.com/#x15.4.4.20
// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter
if (!Array.prototype.filter) {
    Array.prototype.filter = function filter(fun /*, thisp */) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                    object,
            length = self.length >>> 0,
            result = [],
            value,
            thisp = arguments[1];

        // If no callback function or if callback is not a callable function
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
        }

        for (var i = 0; i < length; i++) {
            if (i in self) {
                value = self[i];
                if (fun.call(thisp, value, i, object)) {
                    result.push(value);
                }
            }
        }
        return result;
    };
}

// ES5 15.4.4.16
// http://es5.github.com/#x15.4.4.16
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/every
if (!Array.prototype.every) {
    Array.prototype.every = function every(fun /*, thisp */) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                object,
            length = self.length >>> 0,
            thisp = arguments[1];

        // If no callback function or if callback is not a callable function
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
        }

        for (var i = 0; i < length; i++) {
            if (i in self && !fun.call(thisp, self[i], i, object)) {
                return false;
            }
        }
        return true;
    };
}

// ES5 15.4.4.17
// http://es5.github.com/#x15.4.4.17
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/some
if (!Array.prototype.some) {
    Array.prototype.some = function some(fun /*, thisp */) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                object,
            length = self.length >>> 0,
            thisp = arguments[1];

        // If no callback function or if callback is not a callable function
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
        }

        for (var i = 0; i < length; i++) {
            if (i in self && fun.call(thisp, self[i], i, object)) {
                return true;
            }
        }
        return false;
    };
}

// ES5 15.4.4.21
// http://es5.github.com/#x15.4.4.21
// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/reduce
if (!Array.prototype.reduce) {
    Array.prototype.reduce = function reduce(fun /*, initial*/) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                object,
            length = self.length >>> 0;

        // If no callback function or if callback is not a callable function
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
        }

        // no value to return if no initial value and an empty array
        if (!length && arguments.length == 1) {
            throw new TypeError("reduce of empty array with no initial value");
        }

        var i = 0;
        var result;
        if (arguments.length >= 2) {
            result = arguments[1];
        } else {
            do {
                if (i in self) {
                    result = self[i++];
                    break;
                }

                // if array contains no values, no initial value to return
                if (++i >= length) {
                    throw new TypeError("reduce of empty array with no initial value");
                }
            } while (true);
        }

        for (; i < length; i++) {
            if (i in self) {
                result = fun.call(void 0, result, self[i], i, object);
            }
        }

        return result;
    };
}

// ES5 15.4.4.22
// http://es5.github.com/#x15.4.4.22
// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/reduceRight
if (!Array.prototype.reduceRight) {
    Array.prototype.reduceRight = function reduceRight(fun /*, initial*/) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                object,
            length = self.length >>> 0;

        // If no callback function or if callback is not a callable function
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
        }

        // no value to return if no initial value, empty array
        if (!length && arguments.length == 1) {
            throw new TypeError("reduceRight of empty array with no initial value");
        }

        var result, i = length - 1;
        if (arguments.length >= 2) {
            result = arguments[1];
        } else {
            do {
                if (i in self) {
                    result = self[i--];
                    break;
                }

                // if array contains no values, no initial value to return
                if (--i < 0) {
                    throw new TypeError("reduceRight of empty array with no initial value");
                }
            } while (true);
        }

        if (i < 0) {
            return result;
        }

        do {
            if (i in this) {
                result = fun.call(void 0, result, self[i], i, object);
            }
        } while (i--);

        return result;
    };
}

// ES5 15.4.4.14
// http://es5.github.com/#x15.4.4.14
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf
if (!Array.prototype.indexOf || ([0, 1].indexOf(1, 2) != -1)) {
    Array.prototype.indexOf = function indexOf(sought /*, fromIndex */ ) {
        var self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                toObject(this),
            length = self.length >>> 0;

        if (!length) {
            return -1;
        }

        var i = 0;
        if (arguments.length > 1) {
            i = toInteger(arguments[1]);
        }

        // handle negative indices
        i = i >= 0 ? i : Math.max(0, length + i);
        for (; i < length; i++) {
            if (i in self && self[i] === sought) {
                return i;
            }
        }
        return -1;
    };
}

// ES5 15.4.4.15
// http://es5.github.com/#x15.4.4.15
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/lastIndexOf
if (!Array.prototype.lastIndexOf || ([0, 1].lastIndexOf(0, -3) != -1)) {
    Array.prototype.lastIndexOf = function lastIndexOf(sought /*, fromIndex */) {
        var self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                toObject(this),
            length = self.length >>> 0;

        if (!length) {
            return -1;
        }
        var i = length - 1;
        if (arguments.length > 1) {
            i = Math.min(i, toInteger(arguments[1]));
        }
        // handle negative indices
        i = i >= 0 ? i : length - Math.abs(i);
        for (; i >= 0; i--) {
            if (i in self && sought === self[i]) {
                return i;
            }
        }
        return -1;
    };
}

//
// Object
// ======
//

// ES5 15.2.3.14
// http://es5.github.com/#x15.2.3.14
if (!Object.keys) {
    // http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
    var hasDontEnumBug = true,
        dontEnums = [
            "toString",
            "toLocaleString",
            "valueOf",
            "hasOwnProperty",
            "isPrototypeOf",
            "propertyIsEnumerable",
            "constructor"
        ],
        dontEnumsLength = dontEnums.length;

    for (var key in {"toString": null}) {
        hasDontEnumBug = false;
    }

    Object.keys = function keys(object) {

        if (
            (typeof object != "object" && typeof object != "function") ||
            object === null
        ) {
            throw new TypeError("Object.keys called on a non-object");
        }

        var keys = [];
        for (var name in object) {
            if (owns(object, name)) {
                keys.push(name);
            }
        }

        if (hasDontEnumBug) {
            for (var i = 0, ii = dontEnumsLength; i < ii; i++) {
                var dontEnum = dontEnums[i];
                if (owns(object, dontEnum)) {
                    keys.push(dontEnum);
                }
            }
        }
        return keys;
    };

}

//
// Date
// ====
//

// ES5 15.9.5.43
// http://es5.github.com/#x15.9.5.43
// This function returns a String value represent the instance in time
// represented by this Date object. The format of the String is the Date Time
// string format defined in 15.9.1.15. All fields are present in the String.
// The time zone is always UTC, denoted by the suffix Z. If the time value of
// this object is not a finite Number a RangeError exception is thrown.
var negativeDate = -62198755200000,
    negativeYearString = "-000001";
if (
    !Date.prototype.toISOString ||
    (new Date(negativeDate).toISOString().indexOf(negativeYearString) === -1)
) {
    Date.prototype.toISOString = function toISOString() {
        var result, length, value, year, month;
        if (!isFinite(this)) {
            throw new RangeError("Date.prototype.toISOString called on non-finite value.");
        }

        year = this.getUTCFullYear();

        month = this.getUTCMonth();
        // see https://github.com/kriskowal/es5-shim/issues/111
        year += Math.floor(month / 12);
        month = (month % 12 + 12) % 12;

        // the date time string format is specified in 15.9.1.15.
        result = [month + 1, this.getUTCDate(),
            this.getUTCHours(), this.getUTCMinutes(), this.getUTCSeconds()];
        year = (
            (year < 0 ? "-" : (year > 9999 ? "+" : "")) +
            ("00000" + Math.abs(year))
            .slice(0 <= year && year <= 9999 ? -4 : -6)
        );

        length = result.length;
        while (length--) {
            value = result[length];
            // pad months, days, hours, minutes, and seconds to have two
            // digits.
            if (value < 10) {
                result[length] = "0" + value;
            }
        }
        // pad milliseconds to have three digits.
        return (
            year + "-" + result.slice(0, 2).join("-") +
            "T" + result.slice(2).join(":") + "." +
            ("000" + this.getUTCMilliseconds()).slice(-3) + "Z"
        );
    };
}


// ES5 15.9.5.44
// http://es5.github.com/#x15.9.5.44
// This function provides a String representation of a Date object for use by
// JSON.stringify (15.12.3).
var dateToJSONIsSupported = false;
try {
    dateToJSONIsSupported = (
        Date.prototype.toJSON &&
        new Date(NaN).toJSON() === null &&
        new Date(negativeDate).toJSON().indexOf(negativeYearString) !== -1 &&
        Date.prototype.toJSON.call({ // generic
            toISOString: function () {
                return true;
            }
        })
    );
} catch (e) {
}
if (!dateToJSONIsSupported) {
    Date.prototype.toJSON = function toJSON(key) {
        // When the toJSON method is called with argument key, the following
        // steps are taken:

        // 1.  Let O be the result of calling ToObject, giving it the this
        // value as its argument.
        // 2. Let tv be toPrimitive(O, hint Number).
        var o = Object(this),
            tv = toPrimitive(o),
            toISO;
        // 3. If tv is a Number and is not finite, return null.
        if (typeof tv === "number" && !isFinite(tv)) {
            return null;
        }
        // 4. Let toISO be the result of calling the [[Get]] internal method of
        // O with argument "toISOString".
        toISO = o.toISOString;
        // 5. If IsCallable(toISO) is false, throw a TypeError exception.
        if (typeof toISO != "function") {
            throw new TypeError("toISOString property is not callable");
        }
        // 6. Return the result of calling the [[Call]] internal method of
        //  toISO with O as the this value and an empty argument list.
        return toISO.call(o);

        // NOTE 1 The argument is ignored.

        // NOTE 2 The toJSON function is intentionally generic; it does not
        // require that its this value be a Date object. Therefore, it can be
        // transferred to other kinds of objects for use as a method. However,
        // it does require that any such object have a toISOString method. An
        // object is free to use the argument key to filter its
        // stringification.
    };
}

// ES5 15.9.4.2
// http://es5.github.com/#x15.9.4.2
// based on work shared by Daniel Friesen (dantman)
// http://gist.github.com/303249
if (!Date.parse || "Date.parse is buggy") {
    // XXX global assignment won't work in embeddings that use
    // an alternate object for the context.
    Date = (function(NativeDate) {

        // Date.length === 7
        function Date(Y, M, D, h, m, s, ms) {
            var length = arguments.length;
            if (this instanceof NativeDate) {
                var date = length == 1 && String(Y) === Y ? // isString(Y)
                    // We explicitly pass it through parse:
                    new NativeDate(Date.parse(Y)) :
                    // We have to manually make calls depending on argument
                    // length here
                    length >= 7 ? new NativeDate(Y, M, D, h, m, s, ms) :
                    length >= 6 ? new NativeDate(Y, M, D, h, m, s) :
                    length >= 5 ? new NativeDate(Y, M, D, h, m) :
                    length >= 4 ? new NativeDate(Y, M, D, h) :
                    length >= 3 ? new NativeDate(Y, M, D) :
                    length >= 2 ? new NativeDate(Y, M) :
                    length >= 1 ? new NativeDate(Y) :
                                  new NativeDate();
                // Prevent mixups with unfixed Date object
                date.constructor = Date;
                return date;
            }
            return NativeDate.apply(this, arguments);
        };

        // 15.9.1.15 Date Time String Format.
        var isoDateExpression = new RegExp("^" +
            "(\\d{4}|[\+\-]\\d{6})" + // four-digit year capture or sign +
                                      // 6-digit extended year
            "(?:-(\\d{2})" + // optional month capture
            "(?:-(\\d{2})" + // optional day capture
            "(?:" + // capture hours:minutes:seconds.milliseconds
                "T(\\d{2})" + // hours capture
                ":(\\d{2})" + // minutes capture
                "(?:" + // optional :seconds.milliseconds
                    ":(\\d{2})" + // seconds capture
                    "(?:(\\.\\d{1,}))?" + // milliseconds capture
                ")?" +
            "(" + // capture UTC offset component
                "Z|" + // UTC capture
                "(?:" + // offset specifier +/-hours:minutes
                    "([-+])" + // sign capture
                    "(\\d{2})" + // hours offset capture
                    ":(\\d{2})" + // minutes offset capture
                ")" +
            ")?)?)?)?" +
        "$");

        var months = [
            0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365
        ];

        function dayFromMonth(year, month) {
            var t = month > 1 ? 1 : 0;
            return (
                months[month] +
                Math.floor((year - 1969 + t) / 4) -
                Math.floor((year - 1901 + t) / 100) +
                Math.floor((year - 1601 + t) / 400) +
                365 * (year - 1970)
            );
        }

        // Copy any custom methods a 3rd party library may have added
        for (var key in NativeDate) {
            Date[key] = NativeDate[key];
        }

        // Copy "native" methods explicitly; they may be non-enumerable
        Date.now = NativeDate.now;
        Date.UTC = NativeDate.UTC;
        Date.prototype = NativeDate.prototype;
        Date.prototype.constructor = Date;

        // Upgrade Date.parse to handle simplified ISO 8601 strings
        Date.parse = function parse(string) {
            var match = isoDateExpression.exec(string);
            if (match) {
                // parse months, days, hours, minutes, seconds, and milliseconds
                // provide default values if necessary
                // parse the UTC offset component
                var year = Number(match[1]),
                    month = Number(match[2] || 1) - 1,
                    day = Number(match[3] || 1) - 1,
                    hour = Number(match[4] || 0),
                    minute = Number(match[5] || 0),
                    second = Number(match[6] || 0),
                    millisecond = Math.floor(Number(match[7] || 0) * 1000),
                    // When time zone is missed, local offset should be used
                    // (ES 5.1 bug)
                    // see https://bugs.ecmascript.org/show_bug.cgi?id=112
                    offset = !match[4] || match[8] ?
                        0 : Number(new NativeDate(1970, 0)),
                    signOffset = match[9] === "-" ? 1 : -1,
                    hourOffset = Number(match[10] || 0),
                    minuteOffset = Number(match[11] || 0),
                    result;
                if (
                    hour < (
                        minute > 0 || second > 0 || millisecond > 0 ?
                        24 : 25
                    ) &&
                    minute < 60 && second < 60 && millisecond < 1000 &&
                    month > -1 && month < 12 && hourOffset < 24 &&
                    minuteOffset < 60 && // detect invalid offsets
                    day > -1 &&
                    day < (
                        dayFromMonth(year, month + 1) -
                        dayFromMonth(year, month)
                    )
                ) {
                    result = (
                        (dayFromMonth(year, month) + day) * 24 +
                        hour +
                        hourOffset * signOffset
                    ) * 60;
                    result = (
                        (result + minute + minuteOffset * signOffset) * 60 +
                        second
                    ) * 1000 + millisecond + offset;
                    if (-8.64e15 <= result && result <= 8.64e15) {
                        return result;
                    }
                }
                return NaN;
            }
            return NativeDate.parse.apply(this, arguments);
        };

        return Date;
    })(Date);
}

// ES5 15.9.4.4
// http://es5.github.com/#x15.9.4.4
if (!Date.now) {
    Date.now = function now() {
        return new Date().getTime();
    };
}


//
// Number
// ======
//

// ES5.1 15.7.4.5
// http://es5.github.com/#x15.7.4.5
if (!Number.prototype.toFixed || (0.00008).toFixed(3) !== '0.000' || (0.9).toFixed(0) === '0' || (1.255).toFixed(2) !== '1.25' || (1000000000000000128).toFixed(0) !== "1000000000000000128") {
    // Hide these variables and functions
    (function () {
        var base, size, data, i;

        base = 1e7;
        size = 6;
        data = [0, 0, 0, 0, 0, 0];

        function multiply(n, c) {
            var i = -1;
            while (++i < size) {
                c += n * data[i];
                data[i] = c % base;
                c = Math.floor(c / base);
            }
        }

        function divide(n) {
            var i = size, c = 0;
            while (--i >= 0) {
                c += data[i];
                data[i] = Math.floor(c / n);
                c = (c % n) * base;
            }
        }

        function toString() {
            var i = size;
            var s = '';
            while (--i >= 0) {
                if (s !== '' || i === 0 || data[i] !== 0) {
                    var t = String(data[i]);
                    if (s === '') {
                        s = t;
                    } else {
                        s += '0000000'.slice(0, 7 - t.length) + t;
                    }
                }
            }
            return s;
        }

        function pow(x, n, acc) {
            return (n === 0 ? acc : (n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc)));
        }

        function log(x) {
            var n = 0;
            while (x >= 4096) {
                n += 12;
                x /= 4096;
            }
            while (x >= 2) {
                n += 1;
                x /= 2;
            }
            return n;
        }

        Number.prototype.toFixed = function (fractionDigits) {
            var f, x, s, m, e, z, j, k;

            // Test for NaN and round fractionDigits down
            f = Number(fractionDigits);
            f = f !== f ? 0 : Math.floor(f);

            if (f < 0 || f > 20) {
                throw new RangeError("Number.toFixed called with invalid number of decimals");
            }

            x = Number(this);

            // Test for NaN
            if (x !== x) {
                return "NaN";
            }

            // If it is too big or small, return the string value of the number
            if (x <= -1e21 || x >= 1e21) {
                return String(x);
            }

            s = "";

            if (x < 0) {
                s = "-";
                x = -x;
            }

            m = "0";

            if (x > 1e-21) {
                // 1e-21 < x < 1e21
                // -70 < log2(x) < 70
                e = log(x * pow(2, 69, 1)) - 69;
                z = (e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1));
                z *= 0x10000000000000; // Math.pow(2, 52);
                e = 52 - e;

                // -18 < e < 122
                // x = z / 2 ^ e
                if (e > 0) {
                    multiply(0, z);
                    j = f;

                    while (j >= 7) {
                        multiply(1e7, 0);
                        j -= 7;
                    }

                    multiply(pow(10, j, 1), 0);
                    j = e - 1;

                    while (j >= 23) {
                        divide(1 << 23);
                        j -= 23;
                    }

                    divide(1 << j);
                    multiply(1, 1);
                    divide(2);
                    m = toString();
                } else {
                    multiply(0, z);
                    multiply(1 << (-e), 0);
                    m = toString() + '0.00000000000000000000'.slice(2, 2 + f);
                }
            }

            if (f > 0) {
                k = m.length;

                if (k <= f) {
                    m = s + '0.0000000000000000000'.slice(0, f - k + 2) + m;
                } else {
                    m = s + m.slice(0, k - f) + '.' + m.slice(k - f);
                }
            } else {
                m = s + m;
            }

            return m;
        }
    }());
}


//
// String
// ======
//


// ES5 15.5.4.14
// http://es5.github.com/#x15.5.4.14

// [bugfix, IE lt 9, firefox 4, Konqueror, Opera, obscure browsers]
// Many browsers do not split properly with regular expressions or they
// do not perform the split correctly under obscure conditions.
// See http://blog.stevenlevithan.com/archives/cross-browser-split
// I've tested in many browsers and this seems to cover the deviant ones:
//    'ab'.split(/(?:ab)*/) should be ["", ""], not [""]
//    '.'.split(/(.?)(.?)/) should be ["", ".", "", ""], not ["", ""]
//    'tesst'.split(/(s)*/) should be ["t", undefined, "e", "s", "t"], not
//       [undefined, "t", undefined, "e", ...]
//    ''.split(/.?/) should be [], not [""]
//    '.'.split(/()()/) should be ["."], not ["", "", "."]

var string_split = String.prototype.split;
if (
    'ab'.split(/(?:ab)*/).length !== 2 ||
    '.'.split(/(.?)(.?)/).length !== 4 ||
    'tesst'.split(/(s)*/)[1] === "t" ||
    ''.split(/.?/).length === 0 ||
    '.'.split(/()()/).length > 1
) {
    (function () {
        var compliantExecNpcg = /()??/.exec("")[1] === void 0; // NPCG: nonparticipating capturing group

        String.prototype.split = function (separator, limit) {
            var string = this;
            if (separator === void 0 && limit === 0)
                return [];

            // If `separator` is not a regex, use native split
            if (Object.prototype.toString.call(separator) !== "[object RegExp]") {
                return string_split.apply(this, arguments);
            }

            var output = [],
                flags = (separator.ignoreCase ? "i" : "") +
                        (separator.multiline  ? "m" : "") +
                        (separator.extended   ? "x" : "") + // Proposed for ES6
                        (separator.sticky     ? "y" : ""), // Firefox 3+
                lastLastIndex = 0,
                // Make `global` and avoid `lastIndex` issues by working with a copy
                separator = new RegExp(separator.source, flags + "g"),
                separator2, match, lastIndex, lastLength;
            string += ""; // Type-convert
            if (!compliantExecNpcg) {
                // Doesn't need flags gy, but they don't hurt
                separator2 = new RegExp("^" + separator.source + "$(?!\\s)", flags);
            }
            /* Values for `limit`, per the spec:
             * If undefined: 4294967295 // Math.pow(2, 32) - 1
             * If 0, Infinity, or NaN: 0
             * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
             * If negative number: 4294967296 - Math.floor(Math.abs(limit))
             * If other: Type-convert, then use the above rules
             */
            limit = limit === void 0 ?
                -1 >>> 0 : // Math.pow(2, 32) - 1
                limit >>> 0; // ToUint32(limit)
            while (match = separator.exec(string)) {
                // `separator.lastIndex` is not reliable cross-browser
                lastIndex = match.index + match[0].length;
                if (lastIndex > lastLastIndex) {
                    output.push(string.slice(lastLastIndex, match.index));
                    // Fix browsers whose `exec` methods don't consistently return `undefined` for
                    // nonparticipating capturing groups
                    if (!compliantExecNpcg && match.length > 1) {
                        match[0].replace(separator2, function () {
                            for (var i = 1; i < arguments.length - 2; i++) {
                                if (arguments[i] === void 0) {
                                    match[i] = void 0;
                                }
                            }
                        });
                    }
                    if (match.length > 1 && match.index < string.length) {
                        Array.prototype.push.apply(output, match.slice(1));
                    }
                    lastLength = match[0].length;
                    lastLastIndex = lastIndex;
                    if (output.length >= limit) {
                        break;
                    }
                }
                if (separator.lastIndex === match.index) {
                    separator.lastIndex++; // Avoid an infinite loop
                }
            }
            if (lastLastIndex === string.length) {
                if (lastLength || !separator.test("")) {
                    output.push("");
                }
            } else {
                output.push(string.slice(lastLastIndex));
            }
            return output.length > limit ? output.slice(0, limit) : output;
        };
    }());

// [bugfix, chrome]
// If separator is undefined, then the result array contains just one String,
// which is the this value (converted to a String). If limit is not undefined,
// then the output array is truncated so that it contains no more than limit
// elements.
// "0".split(undefined, 0) -> []
} else if ("0".split(void 0, 0).length) {
    String.prototype.split = function(separator, limit) {
        if (separator === void 0 && limit === 0) return [];
        return string_split.apply(this, arguments);
    }
}


// ECMA-262, 3rd B.2.3
// Note an ECMAScript standart, although ECMAScript 3rd Edition has a
// non-normative section suggesting uniform semantics and it should be
// normalized across all browsers
// [bugfix, IE lt 9] IE < 9 substr() with negative value not working in IE
if("".substr && "0b".substr(-1) !== "b") {
    var string_substr = String.prototype.substr;
    /**
     *  Get the substring of a string
     *  @param  {integer}  start   where to start the substring
     *  @param  {integer}  length  how many characters to return
     *  @return {string}
     */
    String.prototype.substr = function(start, length) {
        return string_substr.call(
            this,
            start < 0 ? ((start = this.length + start) < 0 ? 0 : start) : start,
            length
        );
    }
}

// ES5 15.5.4.20
// http://es5.github.com/#x15.5.4.20
var ws = "\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003" +
    "\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028" +
    "\u2029\uFEFF";
if (!String.prototype.trim || ws.trim()) {
    // http://blog.stevenlevithan.com/archives/faster-trim-javascript
    // http://perfectionkills.com/whitespace-deviations/
    ws = "[" + ws + "]";
    var trimBeginRegexp = new RegExp("^" + ws + ws + "*"),
        trimEndRegexp = new RegExp(ws + ws + "*$");
    String.prototype.trim = function trim() {
        if (this === void 0 || this === null) {
            throw new TypeError("can't convert "+this+" to object");
        }
        return String(this)
            .replace(trimBeginRegexp, "")
            .replace(trimEndRegexp, "");
    };
}

//
// Util
// ======
//

// ES5 9.4
// http://es5.github.com/#x9.4
// http://jsperf.com/to-integer

function toInteger(n) {
    n = +n;
    if (n !== n) { // isNaN
        n = 0;
    } else if (n !== 0 && n !== (1/0) && n !== -(1/0)) {
        n = (n > 0 || -1) * Math.floor(Math.abs(n));
    }
    return n;
}

function isPrimitive(input) {
    var type = typeof input;
    return (
        input === null ||
        type === "undefined" ||
        type === "boolean" ||
        type === "number" ||
        type === "string"
    );
}

function toPrimitive(input) {
    var val, valueOf, toString;
    if (isPrimitive(input)) {
        return input;
    }
    valueOf = input.valueOf;
    if (typeof valueOf === "function") {
        val = valueOf.call(input);
        if (isPrimitive(val)) {
            return val;
        }
    }
    toString = input.toString;
    if (typeof toString === "function") {
        val = toString.call(input);
        if (isPrimitive(val)) {
            return val;
        }
    }
    throw new TypeError();
}

// ES5 9.9
// http://es5.github.com/#x9.9
var toObject = function (o) {
    if (o == null) { // this matches both null and undefined
        throw new TypeError("can't convert "+o+" to object");
    }
    return Object(o);
};

});

})()
},{}],47:[function(require,module,exports){
(function(){// Copyright 2009-2012 by contributors, MIT License
// vim: ts=4 sts=4 sw=4 expandtab

// Module systems magic dance
(function (definition) {
    // RequireJS
    if (typeof define == "function") {
        define(definition);
    // YUI3
    } else if (typeof YUI == "function") {
        YUI.add("es5-sham", definition);
    // CommonJS and <script>
    } else {
        definition();
    }
})(function () {


var call = Function.prototype.call;
var prototypeOfObject = Object.prototype;
var owns = call.bind(prototypeOfObject.hasOwnProperty);

// If JS engine supports accessors creating shortcuts.
var defineGetter;
var defineSetter;
var lookupGetter;
var lookupSetter;
var supportsAccessors;
if ((supportsAccessors = owns(prototypeOfObject, "__defineGetter__"))) {
    defineGetter = call.bind(prototypeOfObject.__defineGetter__);
    defineSetter = call.bind(prototypeOfObject.__defineSetter__);
    lookupGetter = call.bind(prototypeOfObject.__lookupGetter__);
    lookupSetter = call.bind(prototypeOfObject.__lookupSetter__);
}

// ES5 15.2.3.2
// http://es5.github.com/#x15.2.3.2
if (!Object.getPrototypeOf) {
    // https://github.com/kriskowal/es5-shim/issues#issue/2
    // http://ejohn.org/blog/objectgetprototypeof/
    // recommended by fschaefer on github
    Object.getPrototypeOf = function getPrototypeOf(object) {
        return object.__proto__ || (
            object.constructor
                ? object.constructor.prototype
                : prototypeOfObject
        );
    };
}

//ES5 15.2.3.3
//http://es5.github.com/#x15.2.3.3

function doesGetOwnPropertyDescriptorWork(object) {
    try {
        object.sentinel = 0;
        return Object.getOwnPropertyDescriptor(
                object,
                "sentinel"
        ).value === 0;
    } catch (exception) {
        // returns falsy
    }
}

//check whether getOwnPropertyDescriptor works if it's given. Otherwise,
//shim partially.
if (Object.defineProperty) {
    var getOwnPropertyDescriptorWorksOnObject = 
        doesGetOwnPropertyDescriptorWork({});
    var getOwnPropertyDescriptorWorksOnDom = typeof document == "undefined" ||
    doesGetOwnPropertyDescriptorWork(document.createElement("div"));
    if (!getOwnPropertyDescriptorWorksOnDom || 
            !getOwnPropertyDescriptorWorksOnObject
    ) {
        var getOwnPropertyDescriptorFallback = Object.getOwnPropertyDescriptor;
    }
}

if (!Object.getOwnPropertyDescriptor || getOwnPropertyDescriptorFallback) {
    var ERR_NON_OBJECT = "Object.getOwnPropertyDescriptor called on a non-object: ";

    Object.getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {
        if ((typeof object != "object" && typeof object != "function") || object === null) {
            throw new TypeError(ERR_NON_OBJECT + object);
        }

        // make a valiant attempt to use the real getOwnPropertyDescriptor
        // for I8's DOM elements.
        if (getOwnPropertyDescriptorFallback) {
            try {
                return getOwnPropertyDescriptorFallback.call(Object, object, property);
            } catch (exception) {
                // try the shim if the real one doesn't work
            }
        }

        // If object does not owns property return undefined immediately.
        if (!owns(object, property)) {
            return;
        }

        // If object has a property then it's for sure both `enumerable` and
        // `configurable`.
        var descriptor =  { enumerable: true, configurable: true };

        // If JS engine supports accessor properties then property may be a
        // getter or setter.
        if (supportsAccessors) {
            // Unfortunately `__lookupGetter__` will return a getter even
            // if object has own non getter property along with a same named
            // inherited getter. To avoid misbehavior we temporary remove
            // `__proto__` so that `__lookupGetter__` will return getter only
            // if it's owned by an object.
            var prototype = object.__proto__;
            object.__proto__ = prototypeOfObject;

            var getter = lookupGetter(object, property);
            var setter = lookupSetter(object, property);

            // Once we have getter and setter we can put values back.
            object.__proto__ = prototype;

            if (getter || setter) {
                if (getter) {
                    descriptor.get = getter;
                }
                if (setter) {
                    descriptor.set = setter;
                }
                // If it was accessor property we're done and return here
                // in order to avoid adding `value` to the descriptor.
                return descriptor;
            }
        }

        // If we got this far we know that object has an own property that is
        // not an accessor so we set it as a value and return descriptor.
        descriptor.value = object[property];
        descriptor.writable = true;
        return descriptor;
    };
}

// ES5 15.2.3.4
// http://es5.github.com/#x15.2.3.4
if (!Object.getOwnPropertyNames) {
    Object.getOwnPropertyNames = function getOwnPropertyNames(object) {
        return Object.keys(object);
    };
}

// ES5 15.2.3.5
// http://es5.github.com/#x15.2.3.5
if (!Object.create) {

    // Contributed by Brandon Benvie, October, 2012
    var createEmpty;
    var supportsProto = Object.prototype.__proto__ === null;
    if (supportsProto || typeof document == 'undefined') {
        createEmpty = function () {
            return { "__proto__": null };
        };
    } else {
        // In old IE __proto__ can't be used to manually set `null`, nor does
        // any other method exist to make an object that inherits from nothing,
        // aside from Object.prototype itself. Instead, create a new global
        // object and *steal* its Object.prototype and strip it bare. This is
        // used as the prototype to create nullary objects.
        createEmpty = function () {
            var iframe = document.createElement('iframe');
            var parent = document.body || document.documentElement;
            iframe.style.display = 'none';
            parent.appendChild(iframe);
            iframe.src = 'javascript:';
            var empty = iframe.contentWindow.Object.prototype;
            parent.removeChild(iframe);
            iframe = null;
            delete empty.constructor;
            delete empty.hasOwnProperty;
            delete empty.propertyIsEnumerable;
            delete empty.isPrototypeOf;
            delete empty.toLocaleString;
            delete empty.toString;
            delete empty.valueOf;
            empty.__proto__ = null;

            function Empty() {}
            Empty.prototype = empty;
            // short-circuit future calls
            createEmpty = function () {
                return new Empty();
            };
            return new Empty();
        };
    }

    Object.create = function create(prototype, properties) {

        var object;
        function Type() {}  // An empty constructor.

        if (prototype === null) {
            object = createEmpty();
        } else {
            if (typeof prototype !== "object" && typeof prototype !== "function") {
                // In the native implementation `parent` can be `null`
                // OR *any* `instanceof Object`  (Object|Function|Array|RegExp|etc)
                // Use `typeof` tho, b/c in old IE, DOM elements are not `instanceof Object`
                // like they are in modern browsers. Using `Object.create` on DOM elements
                // is...err...probably inappropriate, but the native version allows for it.
                throw new TypeError("Object prototype may only be an Object or null"); // same msg as Chrome
            }
            Type.prototype = prototype;
            object = new Type();
            // IE has no built-in implementation of `Object.getPrototypeOf`
            // neither `__proto__`, but this manually setting `__proto__` will
            // guarantee that `Object.getPrototypeOf` will work as expected with
            // objects created using `Object.create`
            object.__proto__ = prototype;
        }

        if (properties !== void 0) {
            Object.defineProperties(object, properties);
        }

        return object;
    };
}

// ES5 15.2.3.6
// http://es5.github.com/#x15.2.3.6

// Patch for WebKit and IE8 standard mode
// Designed by hax <hax.github.com>
// related issue: https://github.com/kriskowal/es5-shim/issues#issue/5
// IE8 Reference:
//     http://msdn.microsoft.com/en-us/library/dd282900.aspx
//     http://msdn.microsoft.com/en-us/library/dd229916.aspx
// WebKit Bugs:
//     https://bugs.webkit.org/show_bug.cgi?id=36423

function doesDefinePropertyWork(object) {
    try {
        Object.defineProperty(object, "sentinel", {});
        return "sentinel" in object;
    } catch (exception) {
        // returns falsy
    }
}

// check whether defineProperty works if it's given. Otherwise,
// shim partially.
if (Object.defineProperty) {
    var definePropertyWorksOnObject = doesDefinePropertyWork({});
    var definePropertyWorksOnDom = typeof document == "undefined" ||
        doesDefinePropertyWork(document.createElement("div"));
    if (!definePropertyWorksOnObject || !definePropertyWorksOnDom) {
        var definePropertyFallback = Object.defineProperty,
            definePropertiesFallback = Object.defineProperties;
    }
}

if (!Object.defineProperty || definePropertyFallback) {
    var ERR_NON_OBJECT_DESCRIPTOR = "Property description must be an object: ";
    var ERR_NON_OBJECT_TARGET = "Object.defineProperty called on non-object: "
    var ERR_ACCESSORS_NOT_SUPPORTED = "getters & setters can not be defined " +
                                      "on this javascript engine";

    Object.defineProperty = function defineProperty(object, property, descriptor) {
        if ((typeof object != "object" && typeof object != "function") || object === null) {
            throw new TypeError(ERR_NON_OBJECT_TARGET + object);
        }
        if ((typeof descriptor != "object" && typeof descriptor != "function") || descriptor === null) {
            throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR + descriptor);
        }
        // make a valiant attempt to use the real defineProperty
        // for I8's DOM elements.
        if (definePropertyFallback) {
            try {
                return definePropertyFallback.call(Object, object, property, descriptor);
            } catch (exception) {
                // try the shim if the real one doesn't work
            }
        }

        // If it's a data property.
        if (owns(descriptor, "value")) {
            // fail silently if "writable", "enumerable", or "configurable"
            // are requested but not supported
            /*
            // alternate approach:
            if ( // can't implement these features; allow false but not true
                !(owns(descriptor, "writable") ? descriptor.writable : true) ||
                !(owns(descriptor, "enumerable") ? descriptor.enumerable : true) ||
                !(owns(descriptor, "configurable") ? descriptor.configurable : true)
            )
                throw new RangeError(
                    "This implementation of Object.defineProperty does not " +
                    "support configurable, enumerable, or writable."
                );
            */

            if (supportsAccessors && (lookupGetter(object, property) ||
                                      lookupSetter(object, property)))
            {
                // As accessors are supported only on engines implementing
                // `__proto__` we can safely override `__proto__` while defining
                // a property to make sure that we don't hit an inherited
                // accessor.
                var prototype = object.__proto__;
                object.__proto__ = prototypeOfObject;
                // Deleting a property anyway since getter / setter may be
                // defined on object itself.
                delete object[property];
                object[property] = descriptor.value;
                // Setting original `__proto__` back now.
                object.__proto__ = prototype;
            } else {
                object[property] = descriptor.value;
            }
        } else {
            if (!supportsAccessors) {
                throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);
            }
            // If we got that far then getters and setters can be defined !!
            if (owns(descriptor, "get")) {
                defineGetter(object, property, descriptor.get);
            }
            if (owns(descriptor, "set")) {
                defineSetter(object, property, descriptor.set);
            }
        }
        return object;
    };
}

// ES5 15.2.3.7
// http://es5.github.com/#x15.2.3.7
if (!Object.defineProperties || definePropertiesFallback) {
    Object.defineProperties = function defineProperties(object, properties) {
        // make a valiant attempt to use the real defineProperties
        if (definePropertiesFallback) {
            try {
                return definePropertiesFallback.call(Object, object, properties);
            } catch (exception) {
                // try the shim if the real one doesn't work
            }
        }

        for (var property in properties) {
            if (owns(properties, property) && property != "__proto__") {
                Object.defineProperty(object, property, properties[property]);
            }
        }
        return object;
    };
}

// ES5 15.2.3.8
// http://es5.github.com/#x15.2.3.8
if (!Object.seal) {
    Object.seal = function seal(object) {
        // this is misleading and breaks feature-detection, but
        // allows "securable" code to "gracefully" degrade to working
        // but insecure code.
        return object;
    };
}

// ES5 15.2.3.9
// http://es5.github.com/#x15.2.3.9
if (!Object.freeze) {
    Object.freeze = function freeze(object) {
        // this is misleading and breaks feature-detection, but
        // allows "securable" code to "gracefully" degrade to working
        // but insecure code.
        return object;
    };
}

// detect a Rhino bug and patch it
try {
    Object.freeze(function () {});
} catch (exception) {
    Object.freeze = (function freeze(freezeObject) {
        return function freeze(object) {
            if (typeof object == "function") {
                return object;
            } else {
                return freezeObject(object);
            }
        };
    })(Object.freeze);
}

// ES5 15.2.3.10
// http://es5.github.com/#x15.2.3.10
if (!Object.preventExtensions) {
    Object.preventExtensions = function preventExtensions(object) {
        // this is misleading and breaks feature-detection, but
        // allows "securable" code to "gracefully" degrade to working
        // but insecure code.
        return object;
    };
}

// ES5 15.2.3.11
// http://es5.github.com/#x15.2.3.11
if (!Object.isSealed) {
    Object.isSealed = function isSealed(object) {
        return false;
    };
}

// ES5 15.2.3.12
// http://es5.github.com/#x15.2.3.12
if (!Object.isFrozen) {
    Object.isFrozen = function isFrozen(object) {
        return false;
    };
}

// ES5 15.2.3.13
// http://es5.github.com/#x15.2.3.13
if (!Object.isExtensible) {
    Object.isExtensible = function isExtensible(object) {
        // 1. If Type(O) is not Object throw a TypeError exception.
        if (Object(object) !== object) {
            throw new TypeError(); // TODO message
        }
        // 2. Return the Boolean value of the [[Extensible]] internal property of O.
        var name = '';
        while (owns(object, name)) {
            name += '?';
        }
        object[name] = true;
        var returnValue = owns(object, name);
        delete object[name];
        return returnValue;
    };
}

});

})()
},{}],48:[function(require,module,exports){
var obj = require('../object'),
    array = require('../array'),
    apply = obj.apply,
    mix = obj.mix,
    oFilter = obj.filter,
    emptyFn = ('../function').emptyFn,
    is = require('../is');

/**
 * @class  Luc.Composition
 * @protected
 * Class that wraps {@link Luc.define#$compositions composition} config objects
 * to conform to an api. This class is not available externally.  The config object
 * will override any protected methods and default configs.  Defaults
 * can be used for often used configs, keys that are not defaults will
 * override the defaults.
 *
    var C = Luc.define({
        $compositions: {
            defaults: Luc.compositionEnums.EventEmitter,
            methods: ['emit']
        }
    });

    var c = new C()
    typeof c.emit
    >"function"
    typeof c.on
    >"undefined"
 *
 * If you want to add your own composition all you need to have is
 * a name and a Constructor, the rest of the configs of this class and Luc.Composition.create
 * can be used to inject behavior if needed.
 * 
     function Counter() {
        this.count = 0;
     };

     Counter.prototype = {
        getCount: function() {
            return this.count;
        },
        increaseCount: function() {
            this.count++;
        }
     }

     var C = Luc.define({
            $compositions: {
                name: 'counter',
                Constructor: Counter,
                methods: 'allMethods'
            }
    });

    var c = new C()

    c.increaseCount();
    c.increaseCount();
    c.increaseCount();
    c.getCount();
    >3
    c.count
    >undefined
 */
function Composition(c) {
    var defaults = c.defaults,
        config = c;

    if(defaults) {
        mix(config, config.defaults);
        delete config.defaults;
    }

    apply(this, config);
}

Composition.prototype = {
    /**
     * @cfg {String} name (required) the name which the composition
     * will be referred to by the instance.
     */
    
    /**
     * @cfg {Object} defaults
     */
    
    /**
     * @cfg {Boolean} initAfter  defaults to false
     * pass in true to init the composition instance after the 
     * superclass has been called.
     */

    /**
     * @cfg {Function} Constructor (required) the Constructor
     * to use when creating the composition instance.  This
     * is required if Luc.Composition.create is not overwritten by
     * the passed in composition config object.
     */
    
    /**
     * @protected
     * By default just return a newly created Constructor instance.
     * 
     * When create is called the following properties can be used :
     * 
     * this.instance The instance that is creating
     * the composition.
     * 
     * this.Constructor the constructor that is passed in from
     * the composition config. 
     *
     * this.instanceArgs the arguments passed into the instance when it 
     * is being created.  For example

        new MyClassWithAComposition({plugins: []})
        //inside of the create method
        this.instanceArgs
        >[{plugins: []}]

     * @return {Object} 
     * the composition instance.
     *
     * For example set the emitters maxListeners
     * to what the instance has configed.
      
        maxListeners: 100,
        $compositions: {
            Constructor: Luc.EventEmitter,
            create: function() {
                var emitter = new this.Constructor();
                emitter.setMaxListeners(this.instance.maxListeners);
                return emitter;
            },
            name: 'emitter'
        }

     */
    create: function() {
        var Constructor = this.Constructor;
        return new Constructor();
    },

    getInstance: function() {
        return this.create();
    },

    validate: function() {
        if(this.name  === undefined) {
            throw new Error('A name must be defined');
        }
        if(!is.isFunction(this.Constructor) && this.create === Composition.prototype.create) {
            throw new Error('The Constructor must be function if create is not overridden');
        }
    },

    /**
     * @property filterMethodFns
     * @type {Object}
     * @property filterMethodFns.allMethods return all methods from the
     * constructors prototype
     * @property filterMethodFns.public return all methods that don't
     * start with _.  We know not everyone follows this convention, but we
     * do and so do many others.
     * @type {Function}
     */
    filterMethodFns: {
        allMethods: function(key, value) {
            return is.isFunction(value);
        },
        publicMethods: function(key, value) {
            return is.isFunction(value) && key.charAt(0) !== '_';
        }
    },

    /**
     * @cfg {Function/String/Array[]} methods
     * The keys to add to the definers prototype that will in turn call
     * the compositions method.
     * 
     * Defaults to Luc.emptyFn. 
     * If an array is passed it will just use that Array.
     * 
     * If a string is passed and matches a method from 
     * Luc.Composition.filterMethodFns it will call that instead.
     * 
     * If a function is defined it
     * will get called while iterating over each key value pair of the 
     * Constructor's prototype, if a truthy value is 
     * returned the property will be added to the defining
     * classes prototype.
     * 
     * For example this config will only expose the emit method 
     * to the defining class
     
        $compositions: {
            Constructor: Luc.EventEmitter,
            methods: function(key, value) {
                return key === 'emit';
            },
            name: 'emitter'
        }
     * this is also a valid config
     * 
        $compositions: {
            Constructor: Luc.EventEmitter,
            methods: ['emitter'],
            name: 'emitter'
        }
     * 
     */
    methods: emptyFn,

    /**
     * @cfg {String[]/String} ignoreMethods methods that will always
     * be ignored if methods is not an Array.
     *
        
        var C = Luc.define({
                $compositions: {
                    defaults: Luc.compositionEnums.EventEmitter,
                    methods: 'allMethods',
                    ignoreMethods: ['emit']
                }
            });

            var c = new C();
            typeof c.emit
            >"undefined"
     */
    ignoreMethods: undefined,

    getObjectWithMethods: function() {
        var methodsObj = this.Constructor && this.Constructor.prototype;
        if (this.ignoreMethods) {
            methodsObj = apply({}, methodsObj);
            array.each(this.ignoreMethods, function(value) {
                delete methodsObj[value];
            });
        }

        return methodsObj;
    },

    getMethodsToCompose: function() {
        var methods = this.methods,
            pairsToAdd,
            filterFn;


        if (is.isArray(methods)) {
            pairsToAdd = methods;
        } else {
            filterFn = methods;

            if (is.isString(methods)) {
                filterFn = this.filterMethodFns[methods];
            }

            //Constructors are not needed if create is overwritten
            pairsToAdd = oFilter(this.getObjectWithMethods(), filterFn, this, {
                ownProperties: false,
                keys: true
            });
        }

        return pairsToAdd;
    }
};

module.exports = Composition;
},{"../object":32,"../array":34,"../is":36}]},{},[1])
//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlcyI6WyIvaG9tZS9wbGxlZS9kZXYvZ2l0L2x1Yy90ZXN0L2xpYi9sdWMuanMiLCIvaG9tZS9wbGxlZS9kZXYvZ2l0L2x1Yy9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaW5zZXJ0LW1vZHVsZS1nbG9iYWxzL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCIvaG9tZS9wbGxlZS9kZXYvZ2l0L2x1Yy90ZXN0L2x1Y1Rlc3RMaWIuanMiLCIvaG9tZS9wbGxlZS9kZXYvZ2l0L2x1Yy90ZXN0L2FycmF5LmpzIiwiL2hvbWUvcGxsZWUvZGV2L2dpdC9sdWMvdGVzdC9vYmplY3QuanMiLCIvaG9tZS9wbGxlZS9kZXYvZ2l0L2x1Yy90ZXN0L25vZGV0LmpzIiwiL2hvbWUvcGxsZWUvZGV2L2dpdC9sdWMvdGVzdC9jbGFzcy5qcyIsIi9ob21lL3BsbGVlL2Rldi9naXQvbHVjL3Rlc3QvaXMuanMiLCIvaG9tZS9wbGxlZS9kZXYvZ2l0L2x1Yy90ZXN0L2NvbXBhcmUuanMiLCIvaG9tZS9wbGxlZS9kZXYvZ2l0L2x1Yy90ZXN0L2Z1bmN0aW9uLmpzIiwiL2hvbWUvcGxsZWUvZGV2L2dpdC9sdWMvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2luc2VydC1tb2R1bGUtZ2xvYmFscy9idWZmZXIuanMiLCIvaG9tZS9wbGxlZS9kZXYvZ2l0L2x1Yy9ub2RlX21vZHVsZXMvZXhwZWN0LmpzL2V4cGVjdC5qcyIsIi9ob21lL3BsbGVlL2Rldi9naXQvbHVjL2xpYi1jb3YvbHVjLmpzIiwiL2hvbWUvcGxsZWUvZGV2L2dpdC9sdWMvdGVzdC9jb21tb24uanMiLCIvaG9tZS9wbGxlZS9kZXYvZ2l0L2x1Yy9saWItY292L29iamVjdC5qcyIsIi9ob21lL3BsbGVlL2Rldi9naXQvbHVjL2xpYi1jb3YvaXMuanMiLCIvaG9tZS9wbGxlZS9kZXYvZ2l0L2x1Yy9saWItY292L2lkLmpzIiwiL2hvbWUvcGxsZWUvZGV2L2dpdC9sdWMvbGliLWNvdi9ldmVudHMvZXZlbnRFbWl0dGVyLmpzIiwiL2hvbWUvcGxsZWUvZGV2L2dpdC9sdWMvbGliL2x1Yy1lczUtc2hpbS5qcyIsIi9ob21lL3BsbGVlL2Rldi9naXQvbHVjL2xpYi9sdWMuanMiLCIvaG9tZS9wbGxlZS9kZXYvZ2l0L2x1Yy9saWItY292L2Z1bmN0aW9uLmpzIiwiL2hvbWUvcGxsZWUvZGV2L2dpdC9sdWMvbGliLWNvdi9hcnJheS5qcyIsIi9ob21lL3BsbGVlL2Rldi9naXQvbHVjL2xpYi1jb3YvYXJyYXlGbkdlbmVyYXRvci5qcyIsIi9ob21lL3BsbGVlL2Rldi9naXQvbHVjL2xpYi1jb3YvY29tcGFyZS5qcyIsIi9ob21lL3BsbGVlL2Rldi9naXQvbHVjL2xpYi1jb3YvY2xhc3MvYmFzZS5qcyIsIi9ob21lL3BsbGVlL2Rldi9naXQvbHVjL2xpYi1jb3YvY2xhc3MvcGx1Z2luLmpzIiwiL2hvbWUvcGxsZWUvZGV2L2dpdC9sdWMvbGliLWNvdi9jbGFzcy9kZWZpbmVyLmpzIiwiL2hvbWUvcGxsZWUvZGV2L2dpdC9sdWMvbGliLWNvdi9jbGFzcy9wbHVnaW5NYW5hZ2VyLmpzIiwiL2hvbWUvcGxsZWUvZGV2L2dpdC9sdWMvbGliLWNvdi9jbGFzcy9jb21wb3NpdGlvbkVudW1zLmpzIiwiL2hvbWUvcGxsZWUvZGV2L2dpdC9sdWMvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItYnVpbHRpbnMvYnVpbHRpbi9ldmVudHMuanMiLCIvaG9tZS9wbGxlZS9kZXYvZ2l0L2x1Yy9saWIvb2JqZWN0LmpzIiwiL2hvbWUvcGxsZWUvZGV2L2dpdC9sdWMvbGliL2lzLmpzIiwiL2hvbWUvcGxsZWUvZGV2L2dpdC9sdWMvbGliL2lkLmpzIiwiL2hvbWUvcGxsZWUvZGV2L2dpdC9sdWMvbGliL2V2ZW50cy9ldmVudEVtaXR0ZXIuanMiLCIvaG9tZS9wbGxlZS9kZXYvZ2l0L2x1Yy9ub2RlX21vZHVsZXMvZXM1LXNoaW0tc2hhbS9pbmRleC5qcyIsIi9ob21lL3BsbGVlL2Rldi9naXQvbHVjL2xpYi9hcnJheS5qcyIsIi9ob21lL3BsbGVlL2Rldi9naXQvbHVjL2xpYi9mdW5jdGlvbi5qcyIsIi9ob21lL3BsbGVlL2Rldi9naXQvbHVjL2xpYi9hcnJheUZuR2VuZXJhdG9yLmpzIiwiL2hvbWUvcGxsZWUvZGV2L2dpdC9sdWMvbGliL2NvbXBhcmUuanMiLCIvaG9tZS9wbGxlZS9kZXYvZ2l0L2x1Yy9saWIvY2xhc3MvYmFzZS5qcyIsIi9ob21lL3BsbGVlL2Rldi9naXQvbHVjL2xpYi9jbGFzcy9kZWZpbmVyLmpzIiwiL2hvbWUvcGxsZWUvZGV2L2dpdC9sdWMvbGliL2NsYXNzL3BsdWdpbi5qcyIsIi9ob21lL3BsbGVlL2Rldi9naXQvbHVjL2xpYi9jbGFzcy9wbHVnaW5NYW5hZ2VyLmpzIiwiL2hvbWUvcGxsZWUvZGV2L2dpdC9sdWMvbGliL2NsYXNzL2NvbXBvc2l0aW9uRW51bXMuanMiLCIvaG9tZS9wbGxlZS9kZXYvZ2l0L2x1Yy9saWItY292L2NsYXNzL2NvbXBvc2l0aW9uLmpzIiwiL2hvbWUvcGxsZWUvZGV2L2dpdC9sdWMvbm9kZV9tb2R1bGVzL2VzNS1zaGltLXNoYW0vbm9kZV9tb2R1bGVzL2VzNS1zaGltL2VzNS1zaGltLmpzIiwiL2hvbWUvcGxsZWUvZGV2L2dpdC9sdWMvbm9kZV9tb2R1bGVzL2VzNS1zaGltLXNoYW0vbm9kZV9tb2R1bGVzL2VzNS1zaGltL2VzNS1zaGFtLmpzIiwiL2hvbWUvcGxsZWUvZGV2L2dpdC9sdWMvbGliL2NsYXNzL2NvbXBvc2l0aW9uLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25aQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9aQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3B4SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdHVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0WUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0VkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2V0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzN5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbnlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoJy4uL2FycmF5Jyk7XG5yZXF1aXJlKCcuLi9vYmplY3QnKTtcbnJlcXVpcmUoJy4uL25vZGV0Jyk7XG5yZXF1aXJlKCcuLi9jbGFzcycpO1xucmVxdWlyZSgnLi4vaXMnKTtcbnJlcXVpcmUoJy4uL2Z1bmN0aW9uJyk7XG5yZXF1aXJlKCcuLi9jb21wYXJlJyk7IiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxucHJvY2Vzcy5uZXh0VGljayA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNhblNldEltbWVkaWF0ZSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnNldEltbWVkaWF0ZTtcbiAgICB2YXIgY2FuUG9zdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnBvc3RNZXNzYWdlICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyXG4gICAgO1xuXG4gICAgaWYgKGNhblNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIHdpbmRvdy5zZXRJbW1lZGlhdGUoZikgfTtcbiAgICB9XG5cbiAgICBpZiAoY2FuUG9zdCkge1xuICAgICAgICB2YXIgcXVldWUgPSBbXTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIGlmIChldi5zb3VyY2UgPT09IHdpbmRvdyAmJiBldi5kYXRhID09PSAncHJvY2Vzcy10aWNrJykge1xuICAgICAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmbiA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0cnVlKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goZm4pO1xuICAgICAgICAgICAgd2luZG93LnBvc3RNZXNzYWdlKCdwcm9jZXNzLXRpY2snLCAnKicpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICBzZXRUaW1lb3V0KGZuLCAwKTtcbiAgICB9O1xufSkoKTtcblxucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufVxuXG4vLyBUT0RPKHNodHlsbWFuKVxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG4iLCIoZnVuY3Rpb24ocHJvY2Vzcyl7IG1vZHVsZS5leHBvcnRzID0gcHJvY2Vzcy5lbnYuQ09WRVJBR0UgXG4gICA/IHJlcXVpcmUoJy4uL2xpYi1jb3YvbHVjJylcbiAgIDogcmVxdWlyZSgnLi4vbGliL2x1Yy1lczUtc2hpbScpO1xufSkocmVxdWlyZShcIl9fYnJvd3NlcmlmeV9wcm9jZXNzXCIpKSIsInZhciBMdWMgPSByZXF1aXJlKCcuL2x1Y1Rlc3RMaWInKSxcbiAgICBleHBlY3QgPSByZXF1aXJlKCdleHBlY3QuanMnKTtcblxuZGVzY3JpYmUoJ0x1YyBBcnJheSBmdW5jdGlvbnMnLCBmdW5jdGlvbigpIHtcbiAgICBpdCgnZWFjaCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJyID0gWydhJywgJ2InLCAneiddLCBvYmogPSB7c3RyIDonJyB9O1xuXG4gICAgICAgIEx1Yy5BcnJheS5lYWNoKGFyciwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBhKSB7XG4gICAgICAgICAgICB0aGlzLnN0ciArPSB2YWx1ZSArIGluZGV4ICsgYS5sZW5ndGg7XG4gICAgICAgIH0sIG9iaik7XG4gICAgICAgIGV4cGVjdChvYmouc3RyKS50by5lcWwoJ2EwM2IxM3oyMycpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3RvQXJyYXknLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZXhwZWN0KEx1Yy5BcnJheS50b0FycmF5KHVuZGVmaW5lZCkpLnRvLmVxbChbXSk7XG4gICAgICAgIGV4cGVjdChMdWMuQXJyYXkudG9BcnJheShudWxsKSkudG8uZXFsKFtdKTtcbiAgICAgICAgZXhwZWN0KEx1Yy5BcnJheS50b0FycmF5KFtdKSkudG8uZXFsKFtdKTtcbiAgICAgICAgZXhwZWN0KEx1Yy5BcnJheS50b0FycmF5KCcnKSkudG8uZXFsKFsnJ10pO1xuICAgICAgICBleHBlY3QoTHVjLkFycmF5LnRvQXJyYXkoWzFdKSkudG8uZXFsKFsxXSk7XG4gICAgfSk7XG5cbiAgICBpdCgnaW5zZXJ0IGFwcGVuZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJyMSA9IFsxLCAyLCAzXSxcbiAgICAgICAgICAgIGFycjIgPSBbNCwgNSwgNl07XG4gICAgICAgIGV4cGVjdChMdWMuQXJyYXkuaW5zZXJ0KGFycjEsIGFycjIsIHRydWUpKS50by5iZS5lcWwoWzEsIDIsIDMsIDQsIDUsIDZdKTtcbiAgICAgICAgZXhwZWN0KEx1Yy5BcnJheS5pbnNlcnQoYXJyMiwgYXJyMSwgdHJ1ZSkpLnRvLmJlLmVxbChbNCwgNSwgNiwgMSwgMiwgM10pO1xuICAgIH0pO1xuXG4gICAgaXQoJ2luc2VydCBmcm9tIGluZGV4ZXMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFycjEgPSBbMSwgMiwgM10sXG4gICAgICAgICAgICBhcnIyID0gWzQsIDUsIDZdO1xuXG4gICAgICAgICAgICBleHBlY3QoTHVjLkFycmF5Lmluc2VydChhcnIxLCBhcnIyLCAzKSkudG8uYmUuZXFsKFsxLDIsMyw0LDUsNl0pO1xuICAgICAgICAgICAgZXhwZWN0KEx1Yy5BcnJheS5pbnNlcnQoYXJyMSwgYXJyMiwgMikpLnRvLmJlLmVxbChbMSwyLDQsNSw2LDNdKTtcbiAgICAgICAgICAgIGV4cGVjdChMdWMuQXJyYXkuaW5zZXJ0KGFycjEsIGFycjIsIDEpKS50by5iZS5lcWwoWzEsNCw1LDYsMiwzXSk7XG4gICAgICAgICAgICBleHBlY3QoTHVjLkFycmF5Lmluc2VydChhcnIxLCBhcnIyLCAwKSkudG8uYmUuZXFsKFs0LDUsNiwgMSwyLDNdKTtcblxuICAgICAgICAgICAgZXhwZWN0KEx1Yy5BcnJheS5pbnNlcnQoYXJyMiwgYXJyMSwgMykpLnRvLmJlLmVxbChbNCw1LDYsMSwyLDNdKTtcbiAgICAgICAgICAgIGV4cGVjdChMdWMuQXJyYXkuaW5zZXJ0KGFycjIsIGFycjEsIDIpKS50by5iZS5lcWwoWzQsNSwxLDIsMyw2XSk7XG4gICAgICAgICAgICBleHBlY3QoTHVjLkFycmF5Lmluc2VydChhcnIyLCBhcnIxLCAxKSkudG8uYmUuZXFsKFs0LDEsMiwzLDUsNl0pO1xuICAgICAgICAgICAgZXhwZWN0KEx1Yy5BcnJheS5pbnNlcnQoYXJyMiwgYXJyMSwgMCkpLnRvLmJlLmVxbChbMSwyLDMsNCw1LDZdKTtcblxuICAgIH0pO1xuXG5cbiAgICBpdCgnaW5zZXJ0IGFycmF5cyBhcmUgbm90IG1vZGlmaWVkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcnIxID0gWzEsIDIsIDNdLFxuICAgICAgICAgICAgYXJyMiA9IFs0LCA1LCA2XTtcbiAgICAgICAgTHVjLkFycmF5Lmluc2VydChhcnIxLCBhcnIyLCAxKTtcbiAgICAgICAgTHVjLkFycmF5Lmluc2VydChhcnIyLCBhcnIxLCAxKTtcbiAgICAgICAgLy90ZXN0IG5vIG1vZGlmeVxuICAgICAgICBleHBlY3QoYXJyMSkudG8uYmUuZXFsKFsxLCAyLCAzXSk7XG4gICAgICAgIGV4cGVjdChhcnIyKS50by5iZS5lcWwoWzQsIDUsIDZdKTtcbiAgICB9KTtcblxuICAgIGl0KCdyZW1vdmVBbGwgd2l0aCBzaW5nbGUgZmFsc3knLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyciA9IFtmYWxzZSwgZmFsc2UsIDAsICcnXTtcbiAgICAgICAgdmFyIHJldCA9IEx1Yy5BcnJheS5yZW1vdmVBbGwoYXJyLCAnJyk7XG5cbiAgICAgICAgZXhwZWN0KGFycikudG8uYmUuZXFsKFtmYWxzZSwgZmFsc2UsIDBdKTtcbiAgICAgICAgZXhwZWN0KHJldCkudG8uYmUuZXFsKFsnJ10pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3JlbW92ZUFsbCBhbGwgdmFsdWVzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcnIgPSBbZmFsc2UsIGZhbHNlLCBmYWxzZV07XG4gICAgICAgIHZhciByZXQgPSBMdWMuQXJyYXkucmVtb3ZlQWxsKGFyciwgZmFsc2UpO1xuXG4gICAgICAgIGV4cGVjdChhcnIpLnRvLmJlLmVxbChbXSk7XG4gICAgICAgIGV4cGVjdChyZXQpLnRvLmJlLmVxbChbZmFsc2UsIGZhbHNlLCBmYWxzZV0pO1xuICAgICAgICBleHBlY3QoTHVjLkFycmF5LnJlbW92ZUFsbChhcnIsIGZhbHNlKSkudG8uYmUuZXFsKFtdKTtcbiAgICB9KTtcblxuICAgIGl0KCdyZW1vdmVBbGwgbG9vc2UgY29tcGFyaXNvbicsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJyID0gW3t9LCB7YToxfSwge2E6MSwgYjoyfV07XG4gICAgICAgIHZhciByZXQgPSBMdWMuQXJyYXkucmVtb3ZlQWxsKGFyciwge2E6IDF9KTtcblxuICAgICAgICBleHBlY3QocmV0KS50by5iZS5lcWwoW3thOjF9LCB7YToxLCBiOjJ9XSk7XG4gICAgICAgIGV4cGVjdChhcnIpLnRvLmJlLmVxbChbe31dKTtcbiAgICB9KTtcblxuICAgIGl0KCdyZW1vdmVBbGwgZGVlcCBjb21wYXJpc29uJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcnIgPSBbe30sIHthOjF9LCB7YToxLCBiOjJ9XTtcbiAgICAgICAgdmFyIHJldCA9IEx1Yy5BcnJheS5yZW1vdmVBbGwoYXJyLCB7YTogMX0sIHt0eXBlOiAnZGVlcCd9KTtcblxuICAgICAgICBleHBlY3QocmV0KS50by5iZS5lcWwoW3thOjF9XSk7XG4gICAgICAgIGV4cGVjdChhcnIpLnRvLmJlLmVxbChbe30se2E6MSwgYjoyfV0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3JlbW92ZUFsbE5vdCBzaW5nbGUgZmFsc3knLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyciA9IFtmYWxzZSwgZmFsc2UsIDAsICcnXSxcbiAgICAgICAgICAgIHJldCA9IEx1Yy5BcnJheS5yZW1vdmVBbGxOb3QoYXJyLCAnJyk7XG5cbiAgICAgICAgZXhwZWN0KGFycikudG8uYmUuZXFsKFsnJ10pO1xuICAgICAgICBleHBlY3QocmV0KS50by5iZS5lcWwoW2ZhbHNlLCBmYWxzZSwgMF0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3JlbW92ZUFsbE5vdCBubyBtYXRjaGVzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcnIgPSBbZmFsc2UsIGZhbHNlLCBmYWxzZV07XG4gICAgICAgIHZhciByZXQgPSBMdWMuQXJyYXkucmVtb3ZlQWxsTm90KGFyciwgZmFsc2UpO1xuXG4gICAgICAgIGV4cGVjdChhcnIpLnRvLmJlLmVxbChbZmFsc2UsIGZhbHNlLCBmYWxzZV0pO1xuICAgICAgICBleHBlY3QocmV0KS50by5iZS5lcWwoW10pO1xuXG4gICAgfSk7XG5cbiAgICBpdCgncmVtb3ZlQWxsTm90IHNpbmdsZSBsb29zZSBjb21wYXJlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcnIgPSBbe30sIHthOjF9LCB7YToxLCBiOjJ9XTtcbiAgICAgICAgdmFyIHJldCA9IEx1Yy5BcnJheS5yZW1vdmVBbGxOb3QoYXJyLCB7YTogMX0pO1xuXG4gICAgICAgIGV4cGVjdChhcnIpLnRvLmJlLmVxbChbe2E6MX0sIHthOjEsIGI6Mn1dKTtcbiAgICAgICAgZXhwZWN0KHJldCkudG8uYmUuZXFsKFt7fV0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3JlbW92ZUZpcnN0IGZpcnN0IG11bHRpIGFycmF5IG1hdGNoJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcnIgPSBbW10sWzEsMl0sIFsxLDJdXTtcbiAgICAgICAgdmFyIHJldCA9IEx1Yy5BcnJheS5yZW1vdmVGaXJzdChhcnIsIFsxLDJdKTtcblxuICAgICAgICBleHBlY3QoYXJyKS50by5iZS5lcWwoW1tdLFsxLDJdXSk7XG4gICAgICAgIGV4cGVjdChyZXQpLnRvLmJlLmVxbChbMSwyXSk7XG4gICAgICAgIGV4cGVjdChMdWMuQXJyYXkucmVtb3ZlRmlyc3QoYXJyLCBbMSwyXSkpLnRvLmJlLmVxbChbMSwyXSk7XG4gICAgfSk7XG5cbiAgICBpdCgncmVtb3ZlRmlyc3QgZW1wdHkgYXJyYXkgc3RyaWN0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcnIgPSBbW10sIFtdLCBbXV07XG4gICAgICAgIHZhciByZXQgPSBMdWMuQXJyYXkucmVtb3ZlRmlyc3QoYXJyLCBbXSwge3R5cGU6ICdzdHJpY3QnfSk7XG4gICAgICAgIGV4cGVjdChhcnIpLnRvLmJlLmVxbChbW10sW10sW11dKTtcbiAgICAgICAgZXhwZWN0KHJldCkudG8uYmUuZXFsKGZhbHNlKTtcbiAgICB9KTtcblxuICAgIGl0KCdyZW1vdmVGaXJzdCBlbXB0eSBhcnJheSBzaGFsbG93JywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcnIgPSBbW10sIFtdLCBbXV07XG4gICAgICAgIHZhciByZXQgPSBMdWMuQXJyYXkucmVtb3ZlRmlyc3QoYXJyLCBbXSwge3R5cGU6ICdzaGFsbG93J30pO1xuICAgICAgICBleHBlY3QoYXJyKS50by5iZS5lcWwoW1tdLFtdXSk7XG4gICAgICAgIGV4cGVjdChyZXQpLnRvLmJlLmVxbChbXSk7XG4gICAgfSk7XG5cbiAgICBpdCgncmVtb3ZlRmlyc3ROb3QgbXVsdGkgYXJyYXkgbWF0Y2gnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyciA9IFtbXSxbMSwyXSwgWzEsMl1dO1xuICAgICAgICB2YXIgcmV0ID0gTHVjLkFycmF5LnJlbW92ZUZpcnN0Tm90KGFyciwgW10pO1xuXG4gICAgICAgIGV4cGVjdChhcnIpLnRvLmJlLmVxbChbW10sWzEsMl1dKTtcbiAgICAgICAgZXhwZWN0KHJldCkudG8uYmUuZXFsKFsxLDJdKTtcbiAgICAgICAgZXhwZWN0KEx1Yy5BcnJheS5yZW1vdmVGaXJzdE5vdChhcnIsIFsxLDJdKSkudG8uYmUuZXFsKFtdKTtcbiAgICAgICAgZXhwZWN0KEx1Yy5BcnJheS5yZW1vdmVGaXJzdE5vdChhcnIsIFsxLDJdKSkudG8uYmUoZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3JlbW92ZUZpcnN0Tm90IG5vdCBtYXRjaGVzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcnIgPSBbe2E6MX0sIHthOjEsIGI6Mn0sIHthOjF9XTtcbiAgICAgICAgdmFyIHJldCA9IEx1Yy5BcnJheS5yZW1vdmVGaXJzdE5vdChhcnIsIHthOiAxfSk7XG5cbiAgICAgICAgZXhwZWN0KGFycikudG8uYmUuZXFsKFt7YToxfSwge2E6MSwgYjoyfSwge2E6MX1dKTtcbiAgICAgICAgZXhwZWN0KHJldCkudG8uYmUuZXFsKGZhbHNlKTtcbiAgICB9KTtcblxuICAgIGl0KCdyZW1vdmVGaXJzdE5vdCBub3Qgc3RyaWN0IGNvbXBhcmUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGEgPSB7YTogMX07XG4gICAgICAgIHZhciBhcnIgPSBbe2E6MX0sIHthOjEsIGI6Mn0sIGFdO1xuXG4gICAgICAgIHZhciByZXQgPSBMdWMuQXJyYXkucmVtb3ZlRmlyc3ROb3QoYXJyLCB7YToxfSwge3R5cGU6ICdzdHJpY3QnfSk7XG4gICAgICAgIGV4cGVjdChhcnIpLnRvLmJlLmVxbChbe2E6MSwgYjoyfSwge2E6MX1dKTtcbiAgICAgICAgZXhwZWN0KHJldCkudG8uYmUuZXFsKHthOjF9KTtcbiAgICAgICAgTHVjLkFycmF5LnJlbW92ZUZpcnN0Tm90KGFyciwgYSwge3R5cGU6ICdzdHJpY3QnfSk7XG4gICAgICAgIEx1Yy5BcnJheS5yZW1vdmVGaXJzdE5vdChhcnIsIGEsIHt0eXBlOiAnc3RyaWN0J30pO1xuICAgICAgICByZXQgPSBMdWMuQXJyYXkucmVtb3ZlRmlyc3ROb3QoYXJyLCBhLCB7dHlwZTogJ3N0cmljdCd9KTtcbiAgICAgICAgZXhwZWN0KGFycikudG8uYmUuZXFsKFt7YToxfV0pO1xuICAgICAgICBleHBlY3QocmV0KS50by5iZShmYWxzZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnZmluZEZpcnN0IGhhbmRsZSBsb29zZSBjb21wYXJlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICB2YXIgYXJyID0gW3thOjF9LCB7YToxfSwge2E6MX0sIHthOjEsIGI6Mn1dO1xuICAgICAgICAgZXhwZWN0KEx1Yy5BcnJheS5maW5kRmlyc3QoYXJyLCB7YToxLCBiOjJ9KSkudG8uYmUuZXFsKHthOjEsIGI6Mn0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ2ZpbmRGaXJzdCBzdHJpY3QgY29tcGFyZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJyID0gW3thOjF9LCB7YToxfSwge2E6MX0sIHthOjEsIGI6Mn1dO1xuICAgICAgICAgZXhwZWN0KEx1Yy5BcnJheS5maW5kRmlyc3QoYXJyLCB7YToxLCBiOjJ9LCB7dHlwZTogJ3N0cmljdCd9KSkudG8uYmUuZXFsKGZhbHNlKTtcbiAgICB9KTtcblxuICAgIGl0KCdmaW5kRmlyc3QgbWF0Y2ggYWxsIHByb3BzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcnIgPSBbe2E6MX0sIHthOjF9LCB7YToxfSwge2E6MSwgYjoyfV07XG4gICAgICAgIGV4cGVjdChMdWMuQXJyYXkuZmluZEZpcnN0KGFyciwge2E6MSwgYjoyLCBjOjN9KSkudG8uYmUuZXFsKGZhbHNlKTtcbiAgICB9KTtcblxuICAgIGl0KCdmaW5kRmlyc3QgYWxsIGZhbHN5cycsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJyID0gW2ZhbHNlLCAwLCB1bmRlZmluZWQsIG51bGwsICcnXTtcbiAgICAgICAgLy9zaGltL0lFIGJ1Z1xuICAgICAgICBpZigwIGluIFt1bmRlZmluZWRdKSB7XG4gICAgICAgIGV4cGVjdChMdWMuQXJyYXkuZmluZEZpcnN0KGFyciwgbnVsbCkpLnRvLmJlLmVxbChudWxsKTtcbiAgICAgICAgZXhwZWN0KEx1Yy5BcnJheS5maW5kRmlyc3QoYXJyLCBmYWxzZSkpLnRvLmJlLmVxbChmYWxzZSk7XG4gICAgICAgIGV4cGVjdChMdWMuQXJyYXkuZmluZEZpcnN0KGFyciwgdW5kZWZpbmVkKSkudG8uYmUuZXFsKHVuZGVmaW5lZCk7XG4gICAgICAgIGV4cGVjdChMdWMuQXJyYXkuZmluZEZpcnN0KGFyciwgMCkpLnRvLmJlLmVxbCgwKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ2ZpbmRGaXJzdCBkYXRlcycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgdmFyIGFyciA9IFtuZXcgRGF0ZSgxMDAwKSwgbmV3IERhdGUoMTAwMCksIG5ldyBEYXRlKDEwMDEpXTtcbiAgICAgICAgIGV4cGVjdChMdWMuQXJyYXkuZmluZEZpcnN0KGFyciwgbmV3IERhdGUoMTAwMSkpKS50by5iZS5lcWwobmV3IERhdGUoMTAwMSkpO1xuICAgICAgICAgZXhwZWN0KEx1Yy5BcnJheS5maW5kRmlyc3QoYXJyLCBuZXcgRGF0ZSgxMDAyKSkpLnRvLmJlKGZhbHNlKTtcbiAgICB9KTtcblxuICAgIGl0KCdmaW5kRmlyc3Qgc3RyaWN0IGFuZCBzaGFsbG93IGRhdGVzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gICAgICAgICB2YXIgYXJyID0gW25ldyBEYXRlKDEwMDApLCBuZXcgRGF0ZSgxMDAwKSwgZF07XG4gICAgICAgICBleHBlY3QoTHVjLkFycmF5LmZpbmRGaXJzdChhcnIsIGQsIHt0eXBlOiAnc3RyaWN0J30pKS50by5iZShkKTtcbiAgICAgICAgIGV4cGVjdChMdWMuQXJyYXkuZmluZEZpcnN0KGFyciwgZCwge3R5cGU6ICdzaGFsbG93J30pKS50by5iZShkKTtcbiAgICB9KTtcblxuICAgIGl0KCdmaW5kRmlyc3ROb3QgbWF0Y2hpbmcgZmlyc3Qga2V5IHZhbHVlJywgZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGFyciA9IFt7YToxfSwge2E6MX0sIHthOjF9LCB7YToxLCBiOjJ9XTtcbiAgICAgICAgZXhwZWN0KEx1Yy5BcnJheS5maW5kRmlyc3ROb3QoYXJyLCB7YToxLCBiOjJ9KSkudG8uYmUuZXFsKHthOjF9KTtcbiAgICB9KVxuXG4gICAgaXQoJ2ZpbmRGaXJzdE5vdCBmYWxzeXMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyciA9IFsnJywgJycsICcnLCBudWxsXTtcbiAgICAgICAgZXhwZWN0KEx1Yy5BcnJheS5maW5kRmlyc3ROb3QoYXJyLCBudWxsKSkudG8uYmUuZXFsKCcnKTtcbiAgICAgICAgZXhwZWN0KEx1Yy5BcnJheS5maW5kRmlyc3ROb3QoYXJyLCAnJykpLnRvLmJlLmVxbChudWxsKTtcbiAgICAgICAgYXJyID0gWycnLCAnJywgJyddO1xuICAgICAgICBleHBlY3QoTHVjLkFycmF5LmZpbmRGaXJzdE5vdChhcnIsICcnKSkudG8uYmUuZXFsKGZhbHNlKTtcbiAgICB9KTtcblxuICAgIGl0KCdmaW5kRmlyc3ROb3QgcHJpbWl0aXZlcyBhbmQgbm9uLXByaW1pdGl2ZXMnLCBmdW5jdGlvbigpe1xuICAgICAgICAgZXhwZWN0KEx1Yy5BcnJheS5maW5kRmlyc3ROb3QoWzEsMiwzLHt9XSwge30pKS50by5iZSgxKTtcbiAgICB9KTtcblxuICAgIGl0KCdmaW5kQWxsIGZpbmQgZXhhY3Qgb2JqZWN0IGtleXMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyciA9IFt7YToxfSwge2E6MX0sIHthOjF9LCB7YToxLCBiOjJ9LCB7YjoyfV07XG4gICAgICAgIGV4cGVjdChMdWMuQXJyYXkuZmluZEFsbChhcnIsIHthOjEsIGI6Mn0pKS50by5iZS5lcWwoW3thOjEsIGI6Mn1dKTtcbiAgICAgICAgZXhwZWN0KEx1Yy5BcnJheS5maW5kQWxsKGFyciwge2E6MX0pKS50by5iZS5lcWwoW3thOjF9LHthOjF9LHthOjF9LHthOjEsIGI6Mn1dKTtcbiAgICAgICAgZXhwZWN0KEx1Yy5BcnJheS5maW5kQWxsKGFyciwge2E6MSwgYjoyfSwge3R5cGU6ICdzdHJpY3QnfSkpLnRvLmJlLmVxbChbXSk7XG4gICAgICAgIGV4cGVjdChMdWMuQXJyYXkuZmluZEFsbChhcnIsIHthOjEsIGI6MiwgYzozfSkpLnRvLmJlLmVxbChbXSk7XG4gICAgfSk7XG5cbiAgICBpdCgnZmluZEFsbCBmaW5kIGV4YWN0IGFycmF5IHZhbHVlcycsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJyID0gW1tdLFsxLDJdLCBbMSwyXV07XG4gICAgICAgIGV4cGVjdChMdWMuQXJyYXkuZmluZEFsbChhcnIsIFsxLDJdKSkudG8uYmUuZXFsKFtbMSwyXSwgWzEsMl1dKTtcbiAgICAgICAgZXhwZWN0KEx1Yy5BcnJheS5maW5kQWxsKGFyciwgWzFdKSkudG8uZXFsKFtdKTtcbiAgICAgICAgZXhwZWN0KEx1Yy5BcnJheS5maW5kQWxsKGFyciwgWzIsMl0pKS50by5lcWwoW10pO1xuICAgIH0pO1xuXG4gICAgaXQoJ2ZpbmRBbGwgZmFsc3kgdmFsdWVzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcnIgPSBbZmFsc2UsIDAsIHVuZGVmaW5lZCwgbnVsbCwgJyddO1xuICAgICAgICBleHBlY3QoTHVjLkFycmF5LmZpbmRBbGwoYXJyLCBudWxsKSkudG8uYmUuZXFsKFtudWxsXSk7XG4gICAgICAgIGV4cGVjdChMdWMuQXJyYXkuZmluZEFsbChhcnIsIGZhbHNlKSkudG8uYmUuZXFsKFtmYWxzZV0pO1xuICAgICAgICBleHBlY3QoTHVjLkFycmF5LmZpbmRBbGwoYXJyLCB1bmRlZmluZWQpKS50by5iZS5lcWwoW3VuZGVmaW5lZF0pO1xuICAgICAgICBleHBlY3QoTHVjLkFycmF5LmZpbmRBbGwoYXJyLCAwKSkudG8uYmUuZXFsKFswXSk7XG4gICAgfSk7XG5cbiAgICBpdCgnZmluZEFsbCBkYXRlIHZhbHVlcycsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJyID0gW25ldyBEYXRlKDEwMDApLCBuZXcgRGF0ZSgxMDAwKSwgbmV3IERhdGUoMTAwMSksIGZhbHNlXTtcbiAgICAgICAgZXhwZWN0KEx1Yy5BcnJheS5maW5kQWxsKGFyciwgbmV3IERhdGUoMTAwMSkpKS50by5iZS5lcWwoW25ldyBEYXRlKDEwMDEpXSk7XG4gICAgfSk7XG5cbiAgICBpdCgnZmluZEFsbE5vdCBtYXRjaCBhbGwga2V5cycsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJyID0gW3thOjF9LCB7YToxfSwge2E6MX0sIHthOjEsIGI6Mn1dO1xuICAgICAgICBleHBlY3QoTHVjLkFycmF5LmZpbmRBbGxOb3QoYXJyLCB7YToxLCBiOjJ9KSkudG8uYmUuZXFsKFt7YToxfSx7YToxfSx7YToxfV0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ2ZpbmRBbGxOb3QgZmFsc3kgdmFsdWVzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGFyciA9IFsnJywgJycsICcnLCBudWxsXTtcbiAgICAgICAgZXhwZWN0KEx1Yy5BcnJheS5maW5kQWxsTm90KGFyciwgbnVsbCkpLnRvLmJlLmVxbChbJycsJycsJyddKTtcbiAgICAgICAgZXhwZWN0KEx1Yy5BcnJheS5maW5kQWxsTm90KGFyciwgJycpKS50by5iZS5lcWwoW251bGxdKTtcbiAgICAgICAgYXJyID0gWycnLCAnJywgJyddO1xuICAgICAgICBleHBlY3QoTHVjLkFycmF5LmZpbmRBbGxOb3QoYXJyLCAnJykpLnRvLmJlLmVxbChbXSk7XG4gICAgfSk7XG5cbiAgICBpdCgnZHluYW1pYyBmaW5kRmlyc3ROb3QnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZXhwZWN0KEx1Yy5BcnJheS5maW5kRmlyc3ROb3RGYWxzZShbZmFsc2UsIDFdKSkudG8uYmUoMSk7XG4gICAgICAgIGV4cGVjdChMdWMuQXJyYXkuZmluZEZpcnN0Tm90VHJ1ZShbdHJ1ZSwgMV0pKS50by5iZSgxKTtcbiAgICAgICAgZXhwZWN0KEx1Yy5BcnJheS5maW5kRmlyc3ROb3ROdWxsKFtudWxsLCAxXSkpLnRvLmJlKDEpO1xuICAgICAgICBleHBlY3QoTHVjLkFycmF5LmZpbmRGaXJzdE5vdFVuZGVmaW5lZChbdW5kZWZpbmVkLCAxXSkpLnRvLmJlKDEpO1xuICAgIH0pO1xuXG4gICAgaXQoJ2R5bmFtaWMgZmluZEFsbE5vdCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICBleHBlY3QoTHVjLkFycmF5LmZpbmRBbGxOb3RGYWxzZShbZmFsc2UsIDFdKSkudG8uYmUuZXFsKFsxXSk7XG4gICAgICAgIGV4cGVjdChMdWMuQXJyYXkuZmluZEFsbE5vdFRydWUoW3RydWUsIDFdKSkudG8uYmUuZXFsKFsxXSk7XG4gICAgICAgIGV4cGVjdChMdWMuQXJyYXkuZmluZEFsbE5vdE51bGwoW251bGwsIDFdKSkudG8uYmUuZXFsKFsxXSk7XG4gICAgICAgIGV4cGVjdChMdWMuQXJyYXkuZmluZEFsbE5vdFVuZGVmaW5lZChbdW5kZWZpbmVkLCAxXSkpLnRvLmJlLmVxbChbMV0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ2R5bmFtaWMgcmVtb3ZlRmlyc3ROb3QnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZXhwZWN0KEx1Yy5BcnJheS5yZW1vdmVGaXJzdE5vdEZhbHNlKFtmYWxzZSwgMV0pKS50by5iZSgxKTtcbiAgICAgICAgZXhwZWN0KEx1Yy5BcnJheS5yZW1vdmVGaXJzdE5vdFRydWUoW3RydWUsIDFdKSkudG8uYmUoMSk7XG4gICAgICAgIGV4cGVjdChMdWMuQXJyYXkucmVtb3ZlRmlyc3ROb3ROdWxsKFtudWxsLCAxXSkpLnRvLmJlKDEpO1xuICAgICAgICBleHBlY3QoTHVjLkFycmF5LnJlbW92ZUZpcnN0Tm90VW5kZWZpbmVkKFt1bmRlZmluZWQsIDFdKSkudG8uYmUoMSk7XG4gICAgfSk7XG5cbiAgICBpdCgnZHluYW1pYyByZW1vdmVBbGxOb3QnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZXhwZWN0KEx1Yy5BcnJheS5yZW1vdmVBbGxOb3RGYWxzZShbZmFsc2UsIDFdKSkudG8uYmUuZXFsKFsxXSk7XG4gICAgICAgIGV4cGVjdChMdWMuQXJyYXkucmVtb3ZlQWxsTm90VHJ1ZShbdHJ1ZSwgMV0pKS50by5iZS5lcWwoWzFdKTtcbiAgICAgICAgZXhwZWN0KEx1Yy5BcnJheS5yZW1vdmVBbGxOb3ROdWxsKFtudWxsLCAxXSkpLnRvLmJlLmVxbChbMV0pO1xuICAgICAgICBleHBlY3QoTHVjLkFycmF5LnJlbW92ZUFsbE5vdFVuZGVmaW5lZChbdW5kZWZpbmVkLCAxXSkpLnRvLmJlLmVxbChbMV0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ2R5bmFtaWMgcmVtb3ZlRmlyc3QnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZXhwZWN0KEx1Yy5BcnJheS5yZW1vdmVGaXJzdEZhbHNlKFtmYWxzZSwgMV0pKS50by5iZShmYWxzZSk7XG4gICAgICAgIGV4cGVjdChMdWMuQXJyYXkucmVtb3ZlRmlyc3RUcnVlKFt0cnVlLCAxXSkpLnRvLmJlKHRydWUpO1xuICAgICAgICBleHBlY3QoTHVjLkFycmF5LnJlbW92ZUZpcnN0TnVsbChbbnVsbCwgMV0pKS50by5iZShudWxsKTtcbiAgICAgICAgLy9zaGltL0lFIGJ1Z1xuICAgICAgICBpZigwIGluIFt1bmRlZmluZWRdKSB7XG4gICAgICAgICAgICBleHBlY3QoTHVjLkFycmF5LnJlbW92ZUZpcnN0VW5kZWZpbmVkKFt1bmRlZmluZWQsIDFdKSkudG8uYmUodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ2R5bmFtaWMgcmVtb3ZlQWxsJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGV4cGVjdChMdWMuQXJyYXkucmVtb3ZlQWxsRmFsc2UoW2ZhbHNlLCAxXSkpLnRvLmJlLmVxbChbZmFsc2VdKTtcbiAgICAgICAgZXhwZWN0KEx1Yy5BcnJheS5yZW1vdmVBbGxUcnVlKFt0cnVlLCAxXSkpLnRvLmJlLmVxbChbdHJ1ZV0pO1xuICAgICAgICBleHBlY3QoTHVjLkFycmF5LnJlbW92ZUFsbE51bGwoW251bGwsIDFdKSkudG8uYmUuZXFsKFtudWxsXSk7XG4gICAgICAgIGV4cGVjdChMdWMuQXJyYXkucmVtb3ZlQWxsVW5kZWZpbmVkKFt1bmRlZmluZWQsIDFdKSkudG8uYmUuZXFsKFt1bmRlZmluZWRdKTtcbiAgICB9KTtcblxuICAgIGl0KCdkeW5hbWljIHJlbW92ZUxhc3ROb3QnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZXhwZWN0KEx1Yy5BcnJheS5yZW1vdmVMYXN0Tm90RmFsc2UoW2ZhbHNlLCAxXSkpLnRvLmJlKDEpO1xuICAgICAgICBleHBlY3QoTHVjLkFycmF5LnJlbW92ZUxhc3ROb3RUcnVlKFt0cnVlLCAxXSkpLnRvLmJlKDEpO1xuICAgICAgICBleHBlY3QoTHVjLkFycmF5LnJlbW92ZUxhc3ROb3ROdWxsKFtudWxsLCAxXSkpLnRvLmJlKDEpO1xuICAgICAgICBleHBlY3QoTHVjLkFycmF5LnJlbW92ZUxhc3ROb3RVbmRlZmluZWQoW3VuZGVmaW5lZCwgMV0pKS50by5iZSgxKTtcbiAgICB9KTtcblxuICAgIGl0KCdkeW5hbWljIHJlbW92ZUxhc3QnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZXhwZWN0KEx1Yy5BcnJheS5yZW1vdmVMYXN0RmFsc2UoW2ZhbHNlLCAxXSkpLnRvLmJlKGZhbHNlKTtcbiAgICAgICAgZXhwZWN0KEx1Yy5BcnJheS5yZW1vdmVMYXN0VHJ1ZShbdHJ1ZSwgMV0pKS50by5iZSh0cnVlKTtcbiAgICAgICAgZXhwZWN0KEx1Yy5BcnJheS5yZW1vdmVMYXN0TnVsbChbbnVsbCwgMV0pKS50by5iZShudWxsKTtcbiAgICAgICAgLy9zaGltL0lFIGJ1Z1xuICAgICAgICBpZigwIGluIFt1bmRlZmluZWRdKSB7XG4gICAgICAgICAgICBleHBlY3QoTHVjLkFycmF5LnJlbW92ZUxhc3RVbmRlZmluZWQoW3VuZGVmaW5lZCwgMV0pKS50by5iZSh1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnZHluYW1pYyBmaW5kTGFzdE5vdCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICBleHBlY3QoTHVjLkFycmF5LmZpbmRMYXN0Tm90RmFsc2UoW2ZhbHNlLCAxXSkpLnRvLmJlLmVxbCgxKTtcbiAgICAgICAgZXhwZWN0KEx1Yy5BcnJheS5maW5kTGFzdE5vdFRydWUoW3RydWUsIDFdKSkudG8uYmUuZXFsKDEpO1xuICAgICAgICBleHBlY3QoTHVjLkFycmF5LmZpbmRMYXN0Tm90TnVsbChbbnVsbCwgMV0pKS50by5iZS5lcWwoMSk7XG4gICAgICAgIGV4cGVjdChMdWMuQXJyYXkuZmluZExhc3ROb3RVbmRlZmluZWQoW3VuZGVmaW5lZCwgMV0pKS50by5iZS5lcWwoMSk7XG5cbiAgICB9KTtcblxuICAgIGl0KCdyZW1vdmUvZmluZCB3aXRoIGl0ZXJhdG9yIGFuZCB0aGlzQXJnJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcnIgPSBbe2E6MX0sIHthOjF9LCB7YToxfSwge2E6MSwgYjoyfV07XG5cbiAgICAgICAgZXhwZWN0KEx1Yy5BcnJheS5maW5kQWxsKGFyciwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bSA9PT0gdmFsdWUuYVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBudW06IDFcbiAgICAgICAgfSkpLnRvLmJlLmVxbChbe1xuICAgICAgICAgICAgICAgIGE6IDFcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBhOiAxXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgYTogMVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGE6IDEsXG4gICAgICAgICAgICAgICAgYjogMlxuICAgICAgICAgICAgfVxuICAgICAgICBdKTtcblxuICAgICAgIGV4cGVjdChMdWMuQXJyYXkuZmluZEFsbE5vdChhcnIsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0gPT09IHZhbHVlLmFcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbnVtOiAxXG4gICAgICAgIH0pKS50by5iZS5lcWwoW10pO1xuICAgfSk7XG5cbiAgICAgaXQoJ2RpcmVjdCBmdW5jdGlvbiBjb21wYXJpc29uJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGV4cGVjdChMdWMuQXJyYXkuZmluZEFsbE5vdChhcnIsIGZ1bmN0aW9uKCl7fSwge3R5cGU6J3N0cmljdCd9KSkudG8uYmUuZXFsKGFycik7XG4gICAgfSk7XG5cbiAgICBpdCgnTm90IHJlbW92ZS9maW5kIHdpdGggaXRlcmF0b3IgYW5kIHRoaXNBcmcnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZXhwZWN0KEx1Yy5BcnJheS5maW5kQWxsTm90KGFyciwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH0pKS50by5iZS5lcWwoW10pO1xuICAgIH0pO1xuXG4gICAgaXQoJ2ZpbmQgaW4nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZXhwZWN0KEx1Yy5BcnJheS5maW5kQWxsSW4oWzEsMiwzLCB7YToxLGI6Mn0sIHtiOjF9XSwgWzIse2E6MX1dKSkudG8uYmUuZXFsKFsyLHthOjEsYjoyfV0pO1xuICAgICAgICBleHBlY3QoTHVjLkFycmF5LmZpbmRBbGxJbihbMSwyLDMsIHthOjEsYjoyfSwge2I6MX1dLCBbMix7YToxfV0sIHt0eXBlOiAnZGVlcCd9KSkudG8uYmUuZXFsKFsyXSk7XG4gICAgICAgIGV4cGVjdChMdWMuQXJyYXkuZmluZEFsbEluKFsxLDIsMywge2E6MSxiOjJ9LCB7YjoxfV0sIFsyLHthOjF9XSwge3R5cGU6ICdsb29zZSd9KSkudG8uYmUuZXFsKFsyLHthOjEsYjoyfV0pO1xuICAgICAgICBleHBlY3QoTHVjLkFycmF5LmZpbmRBbGxJbihbMSwyLDMsIHthOjEsYjoyfSwge2I6MX1dLCBbMix7YToxfV0sIHt0eXBlOiAnc3RyaWN0J30pKS50by5iZS5lcWwoWzJdKTtcbiAgICAgICAgZXhwZWN0KEx1Yy5BcnJheS5maW5kQWxsSW4oWzEsMiwzXSwgWzIsM10pKS50by5iZS5lcWwoWzIsM10pO1xuICAgICAgICBleHBlY3QoTHVjLkFycmF5LmZpbmRGaXJzdEluKFsxLDIsM10sIFsyLDNdKSkudG8uYmUuZXFsKDIpO1xuICAgICAgICBleHBlY3QoTHVjLkFycmF5LmZpbmRMYXN0SW4oWzEsMiwzXSwgWzIsM10pKS50by5iZS5lcWwoMyk7XG4gICAgICAgIGV4cGVjdChMdWMuQXJyYXkuZmluZExhc3RJbihbMSwyLDNdLCBbZmFsc2UsIDIsMywgZmFsc2VdKSkudG8uYmUuZXFsKDMpO1xuICAgICAgICBleHBlY3QoTHVjLkFycmF5LmZpbmRBbGxJbihbMSwyLDMsIGZhbHNlXSwgW2ZhbHNlLCAyLDMsIGZhbHNlXSkpLnRvLmJlLmVxbChbMiwzLGZhbHNlXSk7XG4gICAgfSk7XG5cbiAgICBpdCgnbGFzdCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICBleHBlY3QoTHVjLkFycmF5Lmxhc3QoWzEsMiwzXSkpLnRvLmJlKDMpO1xuICAgICAgICAoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGV4cGVjdChMdWMuQXJyYXkubGFzdChhcmd1bWVudHMpKS50by5iZSgzKTtcbiAgICAgICAgfSkoMSwyLDMpXG4gICAgfSk7XG5cbiAgICBpdCgnZnJvbSBpbmRleCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICBleHBlY3QoTHVjLkFycmF5LmZyb21JbmRleChbMSwyLDNdLCAxKSkudG8uYmUuZXFsKFsyLDNdKTtcbiAgICAgICAgKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBleHBlY3QoTHVjLkFycmF5LmZyb21JbmRleChhcmd1bWVudHMsIDEpKS50by5iZS5lcWwoWzIsM10pO1xuICAgICAgICAgICAgZXhwZWN0KEx1Yy5BcnJheS5mcm9tSW5kZXgoYXJndW1lbnRzLCAwKSkudG8uYmUuZXFsKFsxLDIsM10pO1xuICAgICAgICAgICAgZXhwZWN0KEx1Yy5BcnJheS5mcm9tSW5kZXgoYXJndW1lbnRzLCAyKSkudG8uYmUuZXFsKFszXSk7XG4gICAgICAgIH0pKDEsMiwzKVxuICAgIH0pO1xuXG4gICAgaXQoJ3BsdWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGV4cGVjdChMdWMuQXJyYXkucGx1Y2soW3thOicxJywgYjoyfSwge2I6M30sIHtiOjR9XSwgJ2InKSkudG8uYmUuZXFsKFsyLDMsNF0pO1xuICAgIH0pO1xufSk7IiwidmFyIEx1YyA9IHJlcXVpcmUoJy4vbHVjVGVzdExpYicpLFxuICAgIGV4cGVjdCA9IHJlcXVpcmUoJ2V4cGVjdC5qcycpO1xuZGVzY3JpYmUoJ0x1YyBPYmplY3QgZnVuY3Rpb25zJywgZnVuY3Rpb24oKSB7XG4gICAgaXQoJ2VhY2gnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHQgPSB7XG4gICAgICAgICAgICBhOiAnYScsXG4gICAgICAgICAgICBiOiAnYicsXG4gICAgICAgICAgICB6OiAneidcbiAgICAgICAgfSwgb2JqID0ge3N0ciA6ICcnfTtcblxuICAgICAgICBMdWMuT2JqZWN0LmVhY2godCwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5zdHIgKz0ga2V5ICsgdmFsdWU7XG4gICAgICAgIH0sIG9iaik7XG4gICAgICAgIGV4cGVjdChvYmouc3RyKS50by5lcWwoJ2FhYmJ6eicpO1xuICAgIH0pO1xuXG4gICAgaXQoJ2FwcGx5JywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhID0ge2I6IDN9O1xuICAgICAgICBMdWMuYXBwbHkoYSwge2E6IDEsIGI6Mn0pO1xuICAgICAgICBleHBlY3QoYSkudG8uZXFsKHthOiAxLCBiOjJ9KTtcbiAgICAgICAgYSA9IHtiOiAzfTtcbiAgICAgICAgTHVjLmFwcGx5KGEsIHthOiAxfSk7XG4gICAgICAgIGV4cGVjdChhKS50by5lcWwoe2E6IDEsIGI6IDN9KTtcbiAgICAgICAgZXhwZWN0KEx1Yy5hcHBseSh7fSwgdW5kZWZpbmVkKSkudG8uZXFsKHt9KTtcbiAgICAgICAgZXhwZWN0KEx1Yy5hcHBseSh1bmRlZmluZWQsIHt9KSkudG8uZXFsKHt9KTtcbiAgICB9KTtcblxuICAgIGl0KCdtaXgnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGEgPSB7YjogM307XG4gICAgICAgIEx1Yy5taXgoYSwge2E6IDEsIGI6Mn0pO1xuICAgICAgICBleHBlY3QoYSkudG8uZXFsKHthOiAxLCBiOjN9KTtcbiAgICB9KTtcblxuICAgIGl0KCd0b09iamVjdCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYSA9IHt9LFxuICAgICAgICAgICAgYiA9IFtdLFxuICAgICAgICAgICAgdG9PYmplY3RBcmdzLFxuICAgICAgICAgICAgdG9PYmplY3RBcnJheTtcblxuICAgICAgICB0b09iamVjdEFycmF5ID0gTHVjLk9iamVjdC50b09iamVjdChbJ25hbWUxJywgJ25hbWUyJ10sIFthLGJdKTtcbiAgICAgICAgZXhwZWN0KHRvT2JqZWN0QXJyYXkubmFtZTEpLnRvLmVxbChhKTtcbiAgICAgICAgZXhwZWN0KHRvT2JqZWN0QXJyYXkubmFtZTIpLnRvLmVxbChiKTtcblxuICAgICAgICAoZnVuY3Rpb24oYyxkKXtcbiAgICAgICAgICAgIHRvT2JqZWN0QXJncyA9IEx1Yy5PYmplY3QudG9PYmplY3QoWyduYW1lMScsICduYW1lMiddLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgZXhwZWN0KHRvT2JqZWN0QXJncy5uYW1lMSkudG8uZXFsKGEpO1xuICAgICAgICAgICAgZXhwZWN0KHRvT2JqZWN0QXJncy5uYW1lMikudG8uZXFsKGIpO1xuICAgICAgICB9KGEsYikpO1xuICAgIH0pO1xuXG4gICAgaXQoJ2ZpbHRlciBub24gb3duUHJvcGVydGllcycsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb2JqID0gT2JqZWN0LmNyZWF0ZSh7YTogMSwgYjoyfSksXG4gICAgICAgICAgICBmaWx0ZXJlZDtcblxuICAgICAgICBmaWx0ZXJlZCA9IEx1Yy5PYmplY3QuZmlsdGVyKG9iaiwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGtleSA9PT0gJ2EnO1xuICAgICAgICB9LCB1bmRlZmluZWQsIHtcbiAgICAgICAgICAgIG93blByb3BlcnRpZXM6IGZhbHNlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV4cGVjdChmaWx0ZXJlZCkudG8uZXFsKFt7a2V5OiAnYScsIHZhbHVlOiAxfV0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ2ZpbHRlciBvd25Qcm9wZXJ0aWVzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvYmogPSBPYmplY3QuY3JlYXRlKHthOiAxLCBiOjJ9KSxcbiAgICAgICAgICAgIGZpbHRlcmVkO1xuXG4gICAgICAgIG9iai5jID0gMztcblxuICAgICAgICBmaWx0ZXJlZCA9IEx1Yy5PYmplY3QuZmlsdGVyKG9iaiwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGtleSA9PT0gJ2EnO1xuICAgICAgICB9LCB1bmRlZmluZWQsIHtcbiAgICAgICAgICAgIG93blByb3BlcnRpZXM6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXhwZWN0KGZpbHRlcmVkKS50by5lcWwoW10pO1xuXG4gICAgICAgIGZpbHRlcmVkID0gTHVjLk9iamVjdC5maWx0ZXIob2JqLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4ga2V5ID09PSAnYyc7XG4gICAgICAgIH0sIHVuZGVmaW5lZCwge1xuICAgICAgICAgICAgb3duUHJvcGVydGllczogdHJ1ZVxuICAgICAgICB9KTtcblxuICAgICAgICBleHBlY3QoZmlsdGVyZWQpLnRvLmVxbChbe2tleTogJ2MnLCB2YWx1ZTogM31dKTtcbiAgICB9KTtcbn0pOyIsInZhciBMdWMgPSByZXF1aXJlKCcuL2x1Y1Rlc3RMaWInKSxcbiAgICBleHBlY3QgPSByZXF1aXJlKCdleHBlY3QuanMnKTtcbnZhciBlbWl0dGVyVGVzdCA9IHJlcXVpcmUoJy4vY29tbW9uJykudGVzdEVtaXR0ZXI7XG4vL1Nhbml0eSBjaGVjayB0byBtYWtlIHN1cmUgbm9kZSBjb21wb25lbnRzIHdvcmsgb24gdGhlIGJyb3dzZXIuXG5kZXNjcmliZSgnTHVjIE5vZGUgZnVuY3Rpb25zJywgZnVuY3Rpb24oKSB7XG5cbiAgICBpdCgnRW1pdHRlcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICBlbWl0dGVyVGVzdChuZXcgTHVjLkV2ZW50RW1pdHRlcigpKTtcbiAgICB9KTtcbn0pIiwidmFyIGVtaXR0ZXJUZXN0ID0gcmVxdWlyZSgnLi9jb21tb24nKS50ZXN0RW1pdHRlcjtcbnZhciBMdWMgPSByZXF1aXJlKCcuL2x1Y1Rlc3RMaWInKSxcbiAgICBleHBlY3QgPSByZXF1aXJlKCdleHBlY3QuanMnKTtcblxuXG5mdW5jdGlvbiBkZWZpbmVDbGFzc1dpdGhBbGxPcHRpb25zKCkge1xuICAgIGZ1bmN0aW9uIEFkZGVyKCkge31cblxuICAgIEFkZGVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIHJldHVybiBhICsgYjtcbiAgICB9O1xuICAgIHJldHVybiBMdWMuZGVmaW5lKHtcbiAgICAgICAgJHN1cGVyOiBBZGRlcixcbiAgICAgICAgJHN0YXRpY3M6IHtcbiAgICAgICAgICAgIHRvdGFsOiAwXG4gICAgICAgIH0sXG4gICAgICAgICRtaXhpbnM6IHtcbiAgICAgICAgICAgIG1ha2VTdHJpbmc6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlICsgJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgICRjb21wb3NpdGlvbnM6IHtcbiAgICAgICAgICAgIENvbnN0cnVjdG9yOiBMdWMuRXZlbnRFbWl0dGVyLFxuICAgICAgICAgICAgbmFtZTogJ2VtaXR0ZXInLFxuICAgICAgICAgICAgbWV0aG9kczogJ2FsbE1ldGhvZHMnXG4gICAgICAgIH0sXG4gICAgICAgIGFkZDogZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAgICAgICAgdmFyIHR3byA9IHRoaXMuJHN1cGVyY2xhc3MuYWRkLmNhbGwodGhpcywgYSwgYiksXG4gICAgICAgICAgICAgICAgcmV0ID0gdHdvICsgYztcblxuICAgICAgICAgICAgdGhpcy5lbWl0KCd0b1N0cmluZycsIHRoaXMubWFrZVN0cmluZyhyZXQpKTtcblxuICAgICAgICAgICAgdGhpcy4kY2xhc3MudG90YWwgKz0gcmV0O1xuXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmRlc2NyaWJlKCdMdWMgQ2xhc3MnLCBmdW5jdGlvbigpIHtcbiAgICBpdCgnQmFzZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYiA9IG5ldyBMdWMuQmFzZSh7XG4gICAgICAgICAgICBhOiAxLFxuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBleHBlY3QoYi5hKS50by5iZSgyKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaW1wbGUgZGVmaW5lJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBDID0gTHVjLmRlZmluZSh7XG4gICAgICAgICAgICBiOiAnMidcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBiID0gbmV3IEMoe1xuICAgICAgICAgICAgYTogMVxuICAgICAgICB9KTtcbiAgICAgICAgZXhwZWN0KGIuYSkudG8uZXFsKDEpO1xuICAgICAgICBleHBlY3QoYi5iKS50by5lcWwoJzInKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaW5nbGUgbWl4aW4nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIEMgPSBMdWMuZGVmaW5lKHtcbiAgICAgICAgICAgICRtaXhpbnM6IEx1Yy5FdmVudEVtaXR0ZXJcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGIgPSBuZXcgQyh7XG4gICAgICAgICAgICBhOiAxXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGVtaXR0ZXJUZXN0KGIpO1xuICAgIH0pO1xuXG4gICAgaXQoJ211bHRpcGxlIG1peGlucycsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbWl4aW5PYmogPSB7XG4gICAgICAgICAgICBhOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByb3A6IHt9XG4gICAgICAgIH0sIEMgPSBMdWMuZGVmaW5lKHtcbiAgICAgICAgICAgICRtaXhpbnM6IFtMdWMuRXZlbnRFbWl0dGVyLCBtaXhpbk9ial1cbiAgICAgICAgfSksXG4gICAgICAgIGMgPSBuZXcgQygpO1xuXG4gICAgICAgIGV4cGVjdChjLmEpLnRvLmJlKG1peGluT2JqLmEpO1xuICAgICAgICBleHBlY3QoYy5wcm9wKS50by5iZShtaXhpbk9iai5wcm9wKTtcbiAgICAgICAgZXhwZWN0KGMuZW1pdCkudG8uYmUoTHVjLkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc3RhdGljcycsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgQyA9IEx1Yy5kZWZpbmUoe1xuICAgICAgICAgICAgJHN0YXRpY3M6IHtcbiAgICAgICAgICAgICAgICBiOiAxXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBjID0gbmV3IEMoKTtcblxuICAgICAgICBleHBlY3QoQy5iKS50by5iZSgxKTtcbiAgICAgICAgZXhwZWN0KGMuJGNsYXNzLmIpLnRvLmJlKDEpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Rlc3QgZ2V0IHN0YXRpYyB2YWx1ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgQSA9IEx1Yy5kZWZpbmUoe1xuICAgICAgICAgICAgJHN0YXRpY3M6IHtcbiAgICAgICAgICAgICAgICBhOiAxXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBCID0gTHVjLmRlZmluZSh7XG4gICAgICAgICAgICAkc3VwZXI6IEEsXG4gICAgICAgICAgICAkc3RhdGljczoge1xuICAgICAgICAgICAgICAgIGI6IDIsXG4gICAgICAgICAgICAgICAgYzozXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBDID0gTHVjLmRlZmluZSh7XG4gICAgICAgICAgICAkc3VwZXI6IEIsXG4gICAgICAgICAgICAkc3RhdGljczoge1xuICAgICAgICAgICAgICAgIGE6IDVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGEgPSBuZXcgQSgpLCBiID0gbmV3IEIoKSwgYyA9IG5ldyBDKCk7XG5cbiAgICAgICAgZXhwZWN0KGEuZ2V0U3RhdGljVmFsdWUoJ2EnKSkudG8uYmUoMSk7XG4gICAgICAgIGV4cGVjdChhLmdldFN0YXRpY1ZhbHVlKCdiJykpLnRvLmJlKHVuZGVmaW5lZCk7XG5cbiAgICAgICAgZXhwZWN0KGIuZ2V0U3RhdGljVmFsdWUoJ2EnKSkudG8uYmUoMSk7XG4gICAgICAgIGV4cGVjdChiLmdldFN0YXRpY1ZhbHVlKCdiJykpLnRvLmJlKDIpO1xuICAgICAgICBleHBlY3QoYi5nZXRTdGF0aWNWYWx1ZSgnYycpKS50by5iZSgzKTtcbiAgICAgICAgZXhwZWN0KGIuZ2V0U3RhdGljVmFsdWUoJ2QnKSkudG8uYmUodW5kZWZpbmVkKTtcblxuICAgICAgICBleHBlY3QoYy5nZXRTdGF0aWNWYWx1ZSgnYScpKS50by5iZSg1KTtcbiAgICAgICAgZXhwZWN0KGMuZ2V0U3RhdGljVmFsdWUoJ2InKSkudG8uYmUoMik7XG4gICAgICAgIGV4cGVjdChjLmdldFN0YXRpY1ZhbHVlKCdjJykpLnRvLmJlKDMpO1xuICAgICAgICBleHBlY3QoYy5nZXRTdGF0aWNWYWx1ZSgnZCcpKS50by5iZSh1bmRlZmluZWQpO1xuICAgIH0pO1xuXG4gICAgaXQoJyRjbGFzcycsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgQyA9IEx1Yy5kZWZpbmUoe30pLFxuICAgICAgICAgICAgYyA9IG5ldyBDKCk7XG5cbiAgICAgICAgZXhwZWN0KGMuJGNsYXNzKS50by5iZShDKTtcbiAgICB9KTtcblxuICAgIGl0KCdzdXBlcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIEMgPSBMdWMuZGVmaW5lKHtcbiAgICAgICAgICAgICRzdXBlcjogTHVjLkV2ZW50RW1pdHRlcixcbiAgICAgICAgICAgIGVtaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuJHN1cGVyY2xhc3MuZW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuXG4gICAgICAgIHZhciBjID0gbmV3IEMoe30pO1xuICAgICAgICBlbWl0dGVyVGVzdChjKTtcbiAgICAgICAgZXhwZWN0KGkpLnRvLmJlKDApO1xuICAgICAgICBleHBlY3QoYyBpbnN0YW5jZW9mIEx1Yy5FdmVudEVtaXR0ZXIpLnRvLmJlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ2NvbXBvc2l0aW9uJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBFbWl0dGVyUGFyZW50ID0gIEx1Yy5kZWZpbmUoe1xuICAgICAgICAgICAgJHN1cGVyOiBMdWMuRXZlbnRFbWl0dGVyXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBCYXNlRW1pdHRlciA9IEx1Yy5kZWZpbmUoe1xuICAgICAgICAgICAgJGNvbXBvc2l0aW9uczogW3tDb25zdHJ1Y3RvcjogRW1pdHRlclBhcmVudCwgbmFtZTogJ2VtaXR0ZXInLCBtZXRob2RzOiAnYWxsTWV0aG9kcyd9XVxuICAgICAgICB9KTtcblxuXG4gICAgICAgIHZhciBiYXNlID0gbmV3IEJhc2VFbWl0dGVyKHt9KTtcbiAgICAgICAgZW1pdHRlclRlc3QoYmFzZSk7XG4gICAgICAgIGV4cGVjdChiYXNlIGluc3RhbmNlb2YgTHVjLkV2ZW50RW1pdHRlcikudG8uYmUoZmFsc2UpO1xuICAgICAgICBleHBlY3QoYmFzZS5ldmVudHMpLnRvLmJlKHVuZGVmaW5lZCk7XG4gICAgfSk7XG5cbiAgICBpdCgnYWxsIGNsYXNzIG9wdGlvbnMgdG9nZXRoZXInLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIEFkZGVyRW1pdHRlciA9IGRlZmluZUNsYXNzV2l0aEFsbE9wdGlvbnMoKSxcbiAgICAgICAgICAgIHN0cmluZ1ZhbHVlLCByZXN1bHQsXG4gICAgICAgICAgICBhZGRlckVtaXQgPSBuZXcgQWRkZXJFbWl0dGVyKCk7XG5cbiAgICAgICAgYWRkZXJFbWl0Lm9uKCd0b1N0cmluZycsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBzdHJpbmdWYWx1ZSA9IHZhbHVlO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXN1bHQgPSBhZGRlckVtaXQuYWRkKDEsIDIsIDMpO1xuXG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvLmJlKDYpO1xuICAgICAgICBleHBlY3Qoc3RyaW5nVmFsdWUpLnRvLmJlKCc2Jyk7XG5cbiAgICAgICAgYWRkZXJFbWl0LmFkZCgzLCAzLCAzKTtcblxuICAgICAgICBleHBlY3Qoc3RyaW5nVmFsdWUpLnRvLmJlKCc5Jyk7XG5cbiAgICAgICAgZXhwZWN0KEFkZGVyRW1pdHRlci50b3RhbCkudG8uYmUoMTUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ2NsYXNzIG9wdGlvbnMgZG8gbm90IGdldCBhcHBsaWVkIHRvIHRoZSBpbnN0YW5jZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgQWRkZXJFbWl0dGVyID0gZGVmaW5lQ2xhc3NXaXRoQWxsT3B0aW9ucygpLFxuICAgICAgICAgICAgYWxsT3B0aW9ucyA9IEx1Yy5DbGFzc0RlZmluZXIucHJvY2Vzc29yS2V5cyxcbiAgICAgICAgICAgIGlnbm9yZUtleXMgPSBbJyRzdXBlciddO1xuXG4gICAgICAgIE9iamVjdC5rZXlzKGFsbE9wdGlvbnMpLmZvckVhY2goZnVuY3Rpb24ob3B0aW9uKSB7XG4gICAgICAgICAgICBpZihpZ25vcmVLZXlzLmluZGV4T2Yob3B0aW9uKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBleHBlY3QoQWRkZXJFbWl0dGVyLnByb3RvdHlwZVtvcHRpb25dKS50by5iZSh1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdnZXQgY29tcG9zaXRpb24nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gQSgpIHt9XG4gICAgICAgIGZ1bmN0aW9uIEIoKXt9XG4gICAgICAgIGZ1bmN0aW9uIEMoKXt9XG4gICAgICAgIHZhciBDb21wcyA9IEx1Yy5kZWZpbmUoe1xuICAgICAgICAgICAgJGNvbXBvc2l0aW9uczogW3tcbiAgICAgICAgICAgICAgICAgICAgQ29uc3RydWN0b3I6IEEsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdhJ1xuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgQ29uc3RydWN0b3I6IEIsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdiJ1xuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgQ29uc3RydWN0b3I6IEMsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdjJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGMgPSBuZXcgQ29tcHMoKTtcblxuICAgICAgICBleHBlY3QoYy5nZXRDb21wb3NpdGlvbignYScpKS50by5iZS5hKEEpO1xuICAgICAgICBleHBlY3QoYy5nZXRDb21wb3NpdGlvbignYicpKS50by5iZS5hKEIpO1xuICAgICAgICBleHBlY3QoYy5nZXRDb21wb3NpdGlvbignYycpKS50by5iZS5hKEMpO1xuICAgIH0pO1xuXG4gICAgaXQoJ2luaXRDb21wb3NpdGlvbiBiZWZvcmUgYW5kIGFmdGVyJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoYXNBQmVlbkluaXRlZCA9IGZhbHNlLFxuICAgICAgICAgICAgaGFzQkJlZW5Jbml0ZWQgPSBmYWxzZSxcbiAgICAgICAgICAgIGhhc0NCZWVuSW5pdGVkID0gZmFsc2U7XG4gICAgICAgIGZ1bmN0aW9uIEEoKSB7XG4gICAgICAgICAgICBoYXNBQmVlbkluaXRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gQigpe1xuICAgICAgICAgICAgaGFzQkJlZW5Jbml0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIEMoKXtcbiAgICAgICAgICAgIGhhc0NCZWVuSW5pdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGV4cGVjdChoYXNBQmVlbkluaXRlZCkudG8uYmUoZmFsc2UpO1xuICAgICAgICAgICAgZXhwZWN0KGhhc0JCZWVuSW5pdGVkKS50by5iZSh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgQ29tcHMgPSBMdWMuZGVmaW5lKHtcbiAgICAgICAgICAgICRjb21wb3NpdGlvbnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIENvbnN0cnVjdG9yOiBBLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnYScsXG4gICAgICAgICAgICAgICAgICAgIGluaXRBZnRlcjogdHJ1ZVxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgQ29uc3RydWN0b3I6IEIsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdiJyxcbiAgICAgICAgICAgICAgICAgICAgaW5pdEFmdGVyOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgQ29uc3RydWN0b3I6IEMsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdjJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGMgPSBuZXcgQ29tcHMoKTtcbiAgICAgICAgZXhwZWN0KGhhc0NCZWVuSW5pdGVkKS50by5iZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIGl0KCd0ZXN0IG5vIHN1cGVyY2xhc3MnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIE5vU3VwZXIgPSBMdWMuZGVmaW5lKHtcbiAgICAgICAgICAgICRzdXBlcjogZmFsc2UsXG4gICAgICAgICAgICAkc3RhdGljczoge1xuICAgICAgICAgICAgICAgIHRvdGFsOiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJG1peGluczoge1xuICAgICAgICAgICAgICAgIG1ha2VTdHJpbmc6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSArICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAkY29tcG9zaXRpb25zOiB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdHMgOiBMdWMuY29tcG9zaXRpb25FbnVtcy5FdmVudEVtaXR0ZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIE5vU3VwZXJOb0NvbXAgPSBMdWMuZGVmaW5lKHtcbiAgICAgICAgICAgICRzdXBlcjogZmFsc2UsXG4gICAgICAgICAgICAkc3RhdGljczoge1xuICAgICAgICAgICAgICAgIHRvdGFsOiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJG1peGluczoge1xuICAgICAgICAgICAgICAgIG1ha2VTdHJpbmc6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSArICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIG5vU3VwZXIgPSBuZXcgTm9TdXBlcigpO1xuICAgICAgICBleHBlY3QobmV3ICBOb1N1cGVyTm9Db21wKCkubWFrZVN0cmluZyhub1N1cGVyLiRjbGFzcy50b3RhbCkpLnRvLmJlKCcwJyk7XG4gICAgICAgIGV4cGVjdChub1N1cGVyLm1ha2VTdHJpbmcobm9TdXBlci4kY2xhc3MudG90YWwpKS50by5iZSgnMCcpO1xuICAgICAgICBlbWl0dGVyVGVzdChub1N1cGVyKTtcbiAgICAgICAgZXhwZWN0KG5vU3VwZXIpLnRvLm5vdC5iZS5hKEx1Yy5CYXNlKTtcbiAgICAgICAgZXhwZWN0KG5vU3VwZXIuJHN1cGVyY2xhc3MpLnRvLmJlKHVuZGVmaW5lZCk7XG4gICAgfSk7XG5cbiAgICBpdCgndGVzdCBjb21wb3NpdGlvbiB2YWxpZGF0aW9uJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIGRlZmluZU5vTmFtZSgpIHtcbiAgICAgICAgICAgIEx1Yy5kZWZpbmUoe1xuICAgICAgICAgICAgICAgICRjb21wb3NpdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgQ29uc3RydWN0b3I6IEx1Yy5FdmVudEVtaXR0ZXJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkZWZpbmVOb0NvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgTHVjLmRlZmluZSh7XG4gICAgICAgICAgICAgICAgJGNvbXBvc2l0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnYSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBleHBlY3QoZGVmaW5lTm9OYW1lKS50by50aHJvd0V4Y2VwdGlvbigpO1xuXG4gICAgICAgIGV4cGVjdChkZWZpbmVOb0NvbnN0cnVjdG9yKS50by50aHJvd0V4Y2VwdGlvbigpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Rlc3QgZGVmYXVsdCBwbHVnaW4gY29tcG9zaXRpb24nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRlc3RJbnRhbmNlLFxuICAgICAgICBDbGFzc1dpdGhQbHVnaW5zID0gTHVjLmRlZmluZSh7XG4gICAgICAgICAgICAkY29tcG9zaXRpb25zOiB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdHM6IEx1Yy5jb21wb3NpdGlvbkVudW1zLlBsdWdpbk1hbmFnZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGMgPSBuZXcgQ2xhc3NXaXRoUGx1Z2lucyh7XG4gICAgICAgICAgICBwbHVnaW5zOiBbe1xuICAgICAgICAgICAgICAgICAgICBpbml0OiBmdW5jdGlvbihpbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVzdEluc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ215UGx1Z2luJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXhwZWN0KHRlc3RJbnN0YW5jZSkudG8uYmUoYyk7XG4gICAgICAgIGV4cGVjdChjLmdldFBsdWdpbihMdWMuUGx1Z2luKSkudG8uYmUuYShMdWMuUGx1Z2luKTtcbiAgICAgICAgZXhwZWN0KGMuZ2V0UGx1Z2luKHtuYW1lOiAnbXlQbHVnaW4nfSkpLnRvLmJlLmEoTHVjLlBsdWdpbik7XG4gICAgICAgIGMuZGVzdHJveVBsdWdpbih7bmFtZTogJ215UGx1Z2luJ30pO1xuICAgICAgICBleHBlY3QoYy5nZXRQbHVnaW4oTHVjLlBsdWdpbikpLnRvLmJlKGZhbHNlKTtcbiAgICAgICAgdmFyIHJldCA9IGMuYWRkUGx1Z2luKHtuYW1lOiAnbXlQbHVnaW4nfSk7XG4gICAgICAgIGV4cGVjdChyZXQpLnRvLmJlLmEoTHVjLlBsdWdpbik7XG5cbiAgICAgICAgZnVuY3Rpb24gQSgpe1xuXG4gICAgICAgIH1cbiAgICAgICAgcmV0ID0gYy5hZGRQbHVnaW4oe0NvbnN0cnVjdG9yOiBBLCBuYW1lOiAnbXlQbHVnaW4nfSk7XG4gICAgICAgIGV4cGVjdChyZXQpLnRvLmJlLmEoQSk7XG4gICAgfSk7XG5cbiAgICBpdCgndGVzdCBjb25maWd1cmVkIHBsdWdpbiBjb25zdHJ1Y3RvcnMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRlc3RJbnRhbmNlLFxuICAgICAgICAgICAgQ29uZmlndXJlZFBsdWdpbiA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICAgICAgICAgIHRoaXMubXlPd25lciA9IGNvbmZpZy5vd25lcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBDbGFzc1dpdGhQbHVnaW5zID0gTHVjLmRlZmluZSh7XG4gICAgICAgICAgICAgICAgJGNvbXBvc2l0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0czogTHVjLmNvbXBvc2l0aW9uRW51bXMuUGx1Z2luTWFuYWdlclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBjID0gbmV3IENsYXNzV2l0aFBsdWdpbnMoe1xuICAgICAgICAgICAgcGx1Z2luczogW3t9LCB7XG4gICAgICAgICAgICAgICAgICAgIENvbnN0cnVjdG9yOiBDb25maWd1cmVkUGx1Z2luXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9KTtcblxuICAgICAgICBleHBlY3QoYy5nZXRDb21wb3NpdGlvbigncGx1Z2lucycpLnBsdWdpbnNbMF0pLnRvLmJlLmEoTHVjLlBsdWdpbik7XG4gICAgICAgIHZhciBjb25maWdlZFBsdWdpbiA9IGMuZ2V0Q29tcG9zaXRpb24oJ3BsdWdpbnMnKS5wbHVnaW5zWzFdO1xuICAgICAgICBleHBlY3QoY29uZmlnZWRQbHVnaW4pLnRvLmJlLmEoQ29uZmlndXJlZFBsdWdpbik7XG4gICAgICAgIGV4cGVjdChjb25maWdlZFBsdWdpbi5teU93bmVyKS50by5iZShjKTtcbiAgICB9KTtcblxuICAgIGl0KCd0ZXN0IGRlZmF1bHQgcGx1Z2luIGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRlc3RWYWx1ZSA9IGZhbHNlLFxuICAgICAgICBDbGFzc1dpdGhQbHVnaW5zID0gTHVjLmRlZmluZSh7XG4gICAgICAgICAgICAkY29tcG9zaXRpb25zOiB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdHM6IEx1Yy5jb21wb3NpdGlvbkVudW1zLlBsdWdpbk1hbmFnZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGMgPSBuZXcgQ2xhc3NXaXRoUGx1Z2lucyh7XG4gICAgICAgICAgICBwbHVnaW5zOiBbe1xuICAgICAgICAgICAgICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlc3RWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCB7fVxuICAgICAgICAgICAgXVxuICAgICAgICB9KTtcblxuICAgICAgICBleHBlY3QodGVzdFZhbHVlKS50by5iZShmYWxzZSk7XG4gICAgICAgIGMuZGVzdHJveUFsbFBsdWdpbnMoKTtcbiAgICAgICAgZXhwZWN0KHRlc3RWYWx1ZSkudG8uYmUodHJ1ZSk7XG4gICAgfSk7XG59KTtcblxuXG5cblxuIiwidmFyIEx1YyA9IHJlcXVpcmUoJy4vbHVjVGVzdExpYicpLFxuICAgIGV4cGVjdCA9IHJlcXVpcmUoJ2V4cGVjdC5qcycpO1xuXG5kZXNjcmliZSgnTHVjIGlzJywgZnVuY3Rpb24oKSB7XG5cbiAgICBpdCgnaXNBcnJheScsIGZ1bmN0aW9uKCkge1xuICAgICAgICBleHBlY3QoTHVjLmlzQXJyYXkoe30pKS50by5iZShmYWxzZSk7XG4gICAgICAgIGV4cGVjdChMdWMuaXNBcnJheShbXSkpLnRvLmJlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ2lzUmVnRXhwJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGV4cGVjdChMdWMuaXNSZWdFeHAoe30pKS50by5iZShmYWxzZSk7XG4gICAgICAgIGV4cGVjdChMdWMuaXNSZWdFeHAobmV3IFJlZ0V4cCgpKSkudG8uYmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnaXNEYXRlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGV4cGVjdChMdWMuaXNEYXRlKHt9KSkudG8uYmUoZmFsc2UpO1xuICAgICAgICBleHBlY3QoTHVjLmlzRGF0ZShuZXcgRGF0ZSgpKSkudG8uYmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnaXNTdHJpbmcnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZXhwZWN0KEx1Yy5pc1N0cmluZyh7fSkpLnRvLmJlKGZhbHNlKTtcbiAgICAgICAgZXhwZWN0KEx1Yy5pc1N0cmluZyhuZXcgU3RyaW5nKCkpKS50by5iZSh0cnVlKTtcbiAgICAgICAgZXhwZWN0KEx1Yy5pc1N0cmluZygnJykpLnRvLmJlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ2lzT2JqZWN0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGV4cGVjdChMdWMuaXNPYmplY3Qoe30pKS50by5iZSh0cnVlKTtcbiAgICAgICAgZXhwZWN0KEx1Yy5pc09iamVjdChbXSkpLnRvLmJlKGZhbHNlKTtcbiAgICB9KTtcblxuICAgIGl0KCdpc051bWJlcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICBleHBlY3QoTHVjLmlzTnVtYmVyKHt9KSkudG8uYmUoZmFsc2UpO1xuICAgICAgICBleHBlY3QoTHVjLmlzTnVtYmVyKDApKS50by5iZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIGl0KCdpc0Z1bmN0aW9uJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGV4cGVjdChMdWMuaXNGdW5jdGlvbih7fSkpLnRvLmJlKGZhbHNlKTtcbiAgICAgICAgZXhwZWN0KEx1Yy5pc0Z1bmN0aW9uKG5ldyBGdW5jdGlvbigpKSkudG8uYmUodHJ1ZSk7XG4gICAgICAgIGV4cGVjdChMdWMuaXNGdW5jdGlvbihmdW5jdGlvbigpe30pKS50by5iZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIGl0KCdpc0ZhbHN5JywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGV4cGVjdChMdWMuaXNGYWxzeSgwKSkudG8uYmUoZmFsc2UpO1xuICAgICAgICBleHBlY3QoTHVjLmlzRmFsc3koJycpKS50by5iZSh0cnVlKTtcbiAgICAgICAgZXhwZWN0KEx1Yy5pc0ZhbHN5KHVuZGVmaW5lZCkpLnRvLmJlKHRydWUpO1xuICAgICAgICBleHBlY3QoTHVjLmlzRmFsc3kobnVsbCkpLnRvLmJlKHRydWUpO1xuICAgICAgICBleHBlY3QoTHVjLmlzRmFsc3koZmFsc2UpKS50by5iZSh0cnVlKTtcbiAgICAgICAgZXhwZWN0KEx1Yy5pc0ZhbHN5KE5hTikpLnRvLmJlKHRydWUpO1xuICAgICAgICBleHBlY3QoTHVjLmlzRmFsc3koe30pKS50by5iZShmYWxzZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnaXNFbXB0eScsIGZ1bmN0aW9uKCkge1xuICAgICAgICBleHBlY3QoTHVjLmlzRW1wdHkoMCkpLnRvLmJlKGZhbHNlKTtcbiAgICAgICAgZXhwZWN0KEx1Yy5pc0VtcHR5KCcnKSkudG8uYmUodHJ1ZSk7XG4gICAgICAgIGV4cGVjdChMdWMuaXNFbXB0eSh1bmRlZmluZWQpKS50by5iZSh0cnVlKTtcbiAgICAgICAgZXhwZWN0KEx1Yy5pc0VtcHR5KG51bGwpKS50by5iZSh0cnVlKTtcbiAgICAgICAgZXhwZWN0KEx1Yy5pc0VtcHR5KGZhbHNlKSkudG8uYmUodHJ1ZSk7XG5cbiAgICAgICAgZXhwZWN0KEx1Yy5pc0VtcHR5KFtdKSkudG8uYmUodHJ1ZSk7XG4gICAgICAgIGV4cGVjdChMdWMuaXNFbXB0eSh7fSkpLnRvLmJlKHRydWUpO1xuXG4gICAgICAgIGV4cGVjdChMdWMuaXNFbXB0eShbMF0pKS50by5iZShmYWxzZSk7XG4gICAgICAgIGV4cGVjdChMdWMuaXNFbXB0eSh7MDowfSkpLnRvLmJlKGZhbHNlKTtcbiAgICB9KTtcblxuICAgIGl0KCdpc0FyZ3VtZW50cycsIGZ1bmN0aW9uKCkge1xuICAgICAgICBleHBlY3QoTHVjLmlzQXJndW1lbnRzKHt9KSkudG8uYmUoZmFsc2UpO1xuICAgICAgICBleHBlY3QoTHVjLmlzQXJndW1lbnRzKFtdKSkudG8uYmUoZmFsc2UpO1xuICAgICAgICAoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGV4cGVjdChMdWMuaXNBcmd1bWVudHMoYXJndW1lbnRzKSkudG8uYmUodHJ1ZSk7XG4gICAgICAgIH0oKSk7XG4gICAgICAgIFxuICAgIH0pO1xufSk7IiwidmFyIEx1YyA9IHJlcXVpcmUoJy4vbHVjVGVzdExpYicpLFxuICAgIGV4cGVjdCA9IHJlcXVpcmUoJ2V4cGVjdC5qcycpO1xuXG5kZXNjcmliZSgnTHVjIGNvbXBhcmUgZm4nLCBmdW5jdGlvbigpIHtcblxuICAgIGl0KCdjb21wYXJlIGVtcHR5IG9iamVjdHMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZXhwZWN0KEx1Yy5jb21wYXJlKHt9LCB7fSkpLnRvLmJlKHRydWUpO1xuICAgICAgICBleHBlY3QoTHVjLmNvbXBhcmUoW10sIFtdKSkudG8uYmUodHJ1ZSk7XG4gICAgICAgIGV4cGVjdChMdWMuY29tcGFyZShuZXcgRGF0ZSgxMDAwKSwgbmV3IERhdGUoMTAwMCkpKS50by5iZSh0cnVlKTtcbiAgICAgICAgZXhwZWN0KEx1Yy5jb21wYXJlKG5ldyBEYXRlKDEwMDApLCBuZXcgRGF0ZSgxMDAxKSkpLnRvLmJlKGZhbHNlKTtcbiAgICB9KTtcblxuICAgIGl0KCdjb21wYXJlIHZhbHVlcycsIGZ1bmN0aW9uKCkge1xuICAgICAgICBleHBlY3QoTHVjLmNvbXBhcmUoe30sIHtcbiAgICAgICAgICAgIGE6IDFcbiAgICAgICAgfSkpLnRvLmJlKGZhbHNlKTtcblxuICAgICAgICBleHBlY3QoTHVjLmNvbXBhcmUoe1xuICAgICAgICAgICAgYTogMVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBhOiAxXG4gICAgICAgIH0pKS50by5iZSh0cnVlKTtcblxuICAgICAgICBleHBlY3QoTHVjLmNvbXBhcmUoe1xuICAgICAgICAgICAgYTogMSxcbiAgICAgICAgICAgIGI6IDFcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgYTogMVxuICAgICAgICB9KSkudG8uYmUoZmFsc2UpO1xuICAgIH0pO1xuXG5cbiAgICBpdCgnY29tcGFyZSBkaWZmZXJlbnQgb2JqZWN0IHR5cGVzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGV4cGVjdChMdWMuY29tcGFyZShuZXcgRGF0ZSgxMDAwMCksIHt9KSkudG8uYmUoZmFsc2UpO1xuICAgICAgICBleHBlY3QoTHVjLmNvbXBhcmUobmV3IERhdGUoMTAwMDApLCB1bmRlZmluZWQpKS50by5iZShmYWxzZSk7XG4gICAgICAgIGV4cGVjdChMdWMuY29tcGFyZShuZXcgRGF0ZSgxMDAwMCksIFtdKSkudG8uYmUoZmFsc2UpO1xuXG4gICAgfSk7XG5cbiAgICBpdCgnY29tcGFyZSBmYWxzeXMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZXhwZWN0KEx1Yy5jb21wYXJlKGZhbHNlLCBmYWxzZSkpLnRvLmJlKHRydWUpO1xuICAgICAgICBleHBlY3QoTHVjLmNvbXBhcmUoMCwgZmFsc2UpKS50by5iZShmYWxzZSk7XG4gICAgICAgIGV4cGVjdChMdWMuY29tcGFyZSgnJywgZmFsc2UpKS50by5iZShmYWxzZSk7XG4gICAgICAgIGV4cGVjdChMdWMuY29tcGFyZShudWxsLCBmYWxzZSkpLnRvLmJlKGZhbHNlKTtcbiAgICAgICAgZXhwZWN0KEx1Yy5jb21wYXJlKHVuZGVmaW5lZCwgZmFsc2UpKS50by5iZShmYWxzZSk7XG4gICAgICAgIGV4cGVjdChMdWMuY29tcGFyZShOYU4sIGZhbHNlKSkudG8uYmUoZmFsc2UpO1xuICAgICAgICBleHBlY3QoTHVjLmNvbXBhcmUoW10sIFsxXSwge3R5cGU6ICdkZWVwJ30pKS50by5iZShmYWxzZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnZGVlcCBjb21wYXJlJywgZnVuY3Rpb24oKSB7IFxuICAgICAgICB2YXIgZGVlcFRydWUgPSBMdWMuY29tcGFyZSh7XG4gICAgICAgICAgICBhOiB7XG4gICAgICAgICAgICAgICAgYTogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGI6IFsxLCAnYScsIG5ldyBEYXRlKDEwMDApLCB7XG4gICAgICAgICAgICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGI6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBhOiB7XG4gICAgICAgICAgICAgICAgYTogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGI6IFsxLCAnYScsIG5ldyBEYXRlKDEwMDApLCB7XG4gICAgICAgICAgICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGI6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICB0eXBlOiAnZGVlcCdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGRlZXBGYWxzZSA9IEx1Yy5jb21wYXJlKHtcbiAgICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgICAgICBhOiAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYjogWzEsICdhJywgbmV3IERhdGUoMTAwMCksIHtcbiAgICAgICAgICAgICAgICAgICAgYToge1xuICAgICAgICAgICAgICAgICAgICAgICAgYToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGE6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYjogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgICAgICBhOiAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYjogWzEsICdhJywgbmV3IERhdGUoMTAwMCksIHtcbiAgICAgICAgICAgICAgICAgICAgYToge1xuICAgICAgICAgICAgICAgICAgICAgICAgYToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGE6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGM6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICB0eXBlOiAnZGVlcCdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXhwZWN0KGRlZXBUcnVlKS50by5iZSh0cnVlKTtcbiAgICAgICAgZXhwZWN0KGRlZXBGYWxzZSkudG8uYmUoZmFsc2UpO1xuICAgICAgICB9KVxuXG4gICAgaXQoJ3NpbXBsZSBkZWVwIGFuZCBzaGFsbG93IGNvbXBhcmUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZXhwZWN0KEx1Yy5jb21wYXJlKHthOjF9LCB7YToxfSwge3R5cGU6ICdzaGFsbG93J30pKS50by5iZSh0cnVlKTtcbiAgICAgICAgZXhwZWN0KEx1Yy5jb21wYXJlKHthOjEsIGI6IHt9fSwge2E6MSwgYjoge319LCB7dHlwZTogJ3NoYWxsb3cnfSkpLnRvLmJlKGZhbHNlKTtcbiAgICAgICAgZXhwZWN0KEx1Yy5jb21wYXJlKHthOjF9LCB7YToxfSwge3R5cGU6ICdkZWVwJ30pKS50by5iZSh0cnVlKTtcbiAgICAgICAgZXhwZWN0KEx1Yy5jb21wYXJlKHthOjEsIGI6IHt9fSwge2E6MSwgYjoge319LCB7dHlwZTogJ2RlZXAnfSkpLnRvLmJlKHRydWUpO1xuICAgICAgICBleHBlY3QoTHVjLmNvbXBhcmUoe2E6MX0sIHthOjF9LCB7dHlwZTogJ3N0cmljdCd9KSkudG8uYmUoZmFsc2UpO1xuXG4gICAgfSk7XG5cbiAgICBpdCgnaW52YWxpZCB0eXBlIHRocm93cyBhbiBleGNlcHRpb24nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGludmFsaWRUeXBlID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIEx1Yy5jb21wYXJlKHRydWUsIHRydWUsIHt0eXBlOiAnZGVlZWVlcCd9KTtcbiAgICAgICAgfTtcbiAgICAgICAgZXhwZWN0KGludmFsaWRUeXBlKS50by50aHJvd0V4Y2VwdGlvbigpO1xuICAgIH0pO1xuXG4gICAgaXQoJ2xvb3NlIGNvbXBhcmUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZXhwZWN0KEx1Yy5jb21wYXJlKG5ldyBEYXRlKDEwMDAwKSwge30pLCB7dHlwZTogJ2xvb3NlJ30pLnRvLmJlKGZhbHNlKTtcbiAgICAgICAgZXhwZWN0KEx1Yy5jb21wYXJlKHt9LCBuZXcgRGF0ZSgxMDAwMCkpLCB7dHlwZTogJ2xvb3NlJ30pLnRvLmJlKGZhbHNlKTtcblxuICAgICAgICBleHBlY3QoTHVjLmNvbXBhcmUoe2E6MX0sIHthOjEsIGI6Mn0sIHt0eXBlOiAnbG9vc2UnfSkpLnRvLmJlKHRydWUpO1xuICAgICAgICBleHBlY3QoTHVjLmNvbXBhcmUoe2E6MX0sIHthOjJ9LCB7dHlwZTogJ2xvb3NlJ30pKS50by5iZShmYWxzZSk7XG5cbiAgICAgICAgZXhwZWN0KEx1Yy5jb21wYXJlKDEsIHthOjJ9LCB7dHlwZTogJ2xvb3NlJ30pKS50by5iZShmYWxzZSk7XG4gICAgICAgIGV4cGVjdChMdWMuY29tcGFyZSh7YToxfSwgMSwge3R5cGU6ICdsb29zZSd9KSkudG8uYmUoZmFsc2UpO1xuXG4gICAgICAgIGV4cGVjdChMdWMuY29tcGFyZShbe2E6MX1dLCBbe2E6MSwgYjoyfV0sIHt0eXBlOiAnbG9vc2UnfSkpLnRvLmJlKHRydWUpO1xuICAgICAgICBleHBlY3QoTHVjLmNvbXBhcmUoW3thOjF9LCAxXSwgW3thOjEsIGI6Mn1dLCB7dHlwZTogJ2xvb3NlJ30pKS50by5iZShmYWxzZSk7XG4gICAgICAgIGV4cGVjdChMdWMuY29tcGFyZShbe2E6MX0sIDFdLCBbe2E6MSwgYjoyfSwgMV0sIHt0eXBlOiAnbG9vc2UnfSkpLnRvLmJlKHRydWUpO1xuICAgICAgICBleHBlY3QoTHVjLmNvbXBhcmUoW3thOjF9LCAxXSwgW3thOjEsIGI6Mn0sIDJdLCB7dHlwZTogJ2xvb3NlJ30pKS50by5iZShmYWxzZSk7XG4gICAgfSlcbn0pOyIsInZhciBMdWMgPSByZXF1aXJlKCcuL2x1Y1Rlc3RMaWInKSxcbiAgICBleHBlY3QgPSByZXF1aXJlKCdleHBlY3QuanMnKSxcbiAgICBhcnJheVNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG5kZXNjcmliZSgnTHVjIEZ1bmN0aW9uIHV0aWxpdGllcycsIGZ1bmN0aW9uKCkge1xuXG4gICAgXG4gICAgICAgIGZ1bmN0aW9uIHRlc3RGbigpIHtcbiAgICAgICAgICAgIHZhciBhcnIgPSBhcnJheVNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0ciArIGFyci5qb2luKCcnKTtcbiAgICAgICAgfVxuXG4gICAgaXQoJ2NyZWF0ZSBhdWdtZW50b3IgYXBwZW5kIGFuZCB0aGlzJywgZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGFwcGVuZEFuZFRoaXMgPSBMdWMuRnVuY3Rpb24uY3JlYXRlQXVnbWVudGVyKHRlc3RGbiwge1xuICAgICAgICAgICAgdGhpc0FyZzoge1xuICAgICAgICAgICAgICAgIHN0cjogJzEnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJnczogWzQsIDVdLFxuICAgICAgICAgICAgaW5kZXg6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXhwZWN0KGFwcGVuZEFuZFRoaXMoMiwgMykpLnRvLmJlKCcxMjM0NScpO1xuICAgIH0pO1xuXG4gICAgaXQoJ2NyZWF0ZSBhdWdtZW50b3IgdGhpc0FyZyB3aXRoIGFwcGVuZCBhZnRlcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXBwZW5kQW5kVGhpc0FyZ3VtZW50c0FmdGVyID0gTHVjLkZ1bmN0aW9uLmNyZWF0ZUF1Z21lbnRlcih0ZXN0Rm4sIHtcbiAgICAgICAgICAgIHRoaXNBcmc6IHtcbiAgICAgICAgICAgICAgICBzdHI6ICcxJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFyZ3M6IFs0LCA1XSxcbiAgICAgICAgICAgIGluZGV4OiB0cnVlLFxuICAgICAgICAgICAgYXJndW1lbnRzRmlyc3Q6IGZhbHNlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV4cGVjdChhcHBlbmRBbmRUaGlzQXJndW1lbnRzQWZ0ZXIoMiwzKSkudG8uYmUoJzE0NTIzJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnY3JlYXRlIGF1Z21lbnRvciB0aGlzQXJnIGluZGV4IGFuZCBhcmdzIGFmdGVyJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmd1bWVudHNBZnRlciA9IEx1Yy5GdW5jdGlvbi5jcmVhdGVBdWdtZW50ZXIodGVzdEZuLCB7XG4gICAgICAgICAgICB0aGlzQXJnOiB7XG4gICAgICAgICAgICAgICAgc3RyOiAnMSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcmdzOiBbNCwgNV0sXG4gICAgICAgICAgICBpbmRleDogMSxcbiAgICAgICAgICAgIGFyZ3VtZW50c0ZpcnN0OiBmYWxzZVxuICAgICAgICB9KTtcblxuICAgICAgICBleHBlY3QoYXJndW1lbnRzQWZ0ZXIoMiwzKSkudG8uYmUoJzE0MjM1Jyk7XG4gICAgfSk7XG5cbiAgICBpdCgnY3JlYXRlIGF1Z21lbnRvciB0aGlzIGFyZyBhbmQgZGVmYXVsdCBpbnNlcnQgYXJncycsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJndW1lbnRzSW5zZXJ0ID0gTHVjLkZ1bmN0aW9uLmNyZWF0ZUF1Z21lbnRlcih0ZXN0Rm4sIHtcbiAgICAgICAgICAgIHRoaXNBcmc6IHtcbiAgICAgICAgICAgICAgICBzdHI6ICcxJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFyZ3M6IFs0LCA1XSxcbiAgICAgICAgICAgIGluZGV4OiAxXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV4cGVjdChhcmd1bWVudHNJbnNlcnQoMiwzKSkudG8uYmUoJzEyNDUzJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnY3JlYXRlIGF1Z21lbnRvciBkZWZhdWx0IGluc2VydCBhcmdzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBub1RoaXNBcmcgPSBMdWMuRnVuY3Rpb24uY3JlYXRlQXVnbWVudGVyKHRlc3RGbiwge1xuICAgICAgICAgICAgYXJnczogWzQsIDVdLFxuICAgICAgICAgICAgaW5kZXg6IDFcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXhwZWN0KG5vVGhpc0FyZy5hcHBseSh7c3RyOiAnMid9LFsyLDNdKSkudG8uYmUoJzIyNDUzJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnY3JlYXRlIGF1Z21lbnRvciBqdXN0IGFyZ3VtZW50cycsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIganVzdEFyZ3MgPSBMdWMuRnVuY3Rpb24uY3JlYXRlQXVnbWVudGVyKHRlc3RGbiwge1xuICAgICAgICAgICAgYXJnczogWzQsIDVdXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV4cGVjdChqdXN0QXJncy5hcHBseSh7c3RyOiAnMid9LFsyLDNdKSkudG8uYmUoJzI0NScpO1xuICAgIH0pO1xuXG4gICAgaXQoJ2NyZWF0ZSBzZXF1ZW5jZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaGFzUnVuMSwgaGFzUnVuMiwgaGFzUnVuMztcblxuICAgICAgICB2YXIgc2VxdWVuY2VkID0gTHVjLkZ1bmN0aW9uLmNyZWF0ZVNlcXVlbmNlKFtcbiAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGhhc1J1bjEgPSB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGhhc1J1bjIgPSB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGhhc1J1bjMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICBdKTtcblxuICAgICAgICB2YXIgcmV0ID0gc2VxdWVuY2VkKCk7XG5cbiAgICAgICAgZXhwZWN0KGhhc1J1bjEpLnRvLmJlKHRydWUpO1xuICAgICAgICBleHBlY3QoaGFzUnVuMikudG8uYmUodHJ1ZSk7XG4gICAgICAgIGV4cGVjdChoYXNSdW4zKS50by5iZSh0cnVlKTtcbiAgICAgICAgZXhwZWN0KHJldCkudG8uYmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnY3JlYXRlIHNlcXVlbmNlIGF1Z21lbnRvciBjb25maWcnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGhhc1J1bjEsIGhhc1J1bjIsIGhhc1J1bjM7XG5cbiAgICAgICAgdmFyIHNlcXVlbmNlZCA9IEx1Yy5GdW5jdGlvbi5jcmVhdGVTZXF1ZW5jZShbXG4gICAgICAgICAgICBmdW5jdGlvbihhLGIpIHtcbiAgICAgICAgICAgICAgICBleHBlY3QoYSkudG8uYmUoMSk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KGIpLnRvLmJlKDIpO1xuICAgICAgICAgICAgICAgIGhhc1J1bjEgPSB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGhhc1J1bjIgPSB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGhhc1J1bjMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICBdLHtcbiAgICAgICAgICAgIHRoaXNBcmc6IHtcbiAgICAgICAgICAgICAgICBhOiAxXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciByZXQgPSBzZXF1ZW5jZWQoMSwyKTtcblxuICAgICAgICBleHBlY3QoaGFzUnVuMSkudG8uYmUodHJ1ZSk7XG4gICAgICAgIGV4cGVjdChoYXNSdW4yKS50by5iZSh0cnVlKTtcbiAgICAgICAgZXhwZWN0KGhhc1J1bjMpLnRvLmJlKHRydWUpO1xuICAgICAgICBleHBlY3QocmV0KS50by5lcWwoe2E6MX0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ2NyZWF0ZSBzZXF1ZW5jZUlmJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoYXNSdW4xLCBoYXNSdW4yLCBoYXNSdW4zO1xuXG4gICAgICAgIHZhciBzZXF1ZW5jZWQgPSBMdWMuRnVuY3Rpb24uY3JlYXRlU2VxdWVuY2VJZihbXG4gICAgICAgICAgICBmdW5jdGlvbihhLGIpIHtcbiAgICAgICAgICAgICAgICBleHBlY3QoYSkudG8uYmUoMSk7XG4gICAgICAgICAgICAgICAgIGV4cGVjdChiKS50by5iZSgyKTtcbiAgICAgICAgICAgICAgICBoYXNSdW4xID0gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBoYXNSdW4yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaGFzUnVuMyA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIF0se1xuICAgICAgICAgICAgdGhpc0FyZzoge1xuICAgICAgICAgICAgICAgIGE6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHJldCA9IHNlcXVlbmNlZCgxLDIpO1xuXG4gICAgICAgIGV4cGVjdChoYXNSdW4xKS50by5iZSh0cnVlKTtcbiAgICAgICAgZXhwZWN0KGhhc1J1bjIpLnRvLmJlKHRydWUpO1xuICAgICAgICBleHBlY3QoaGFzUnVuMykudG8uYmUodW5kZWZpbmVkKTtcbiAgICAgICAgZXhwZWN0KHJldCkudG8uYmUoZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgaXQoJ2NyZWF0ZSByZWxheWVyJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZXF1ZW5jZWQgPSBMdWMuRnVuY3Rpb24uY3JlYXRlUmVsYXllcihbXG4gICAgICAgICAgICBmdW5jdGlvbihhLGIsYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhICsgYiArIGM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy9hY2IsIGJcbiAgICAgICAgICAgIGZ1bmN0aW9uKGEsYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhICsgYSArIGIgKyBiO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vYWNiYWNiYmIsIGJcbiAgICAgICAgICAgIGZ1bmN0aW9uKGEsYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBiICsgYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSx7XG4gICAgICAgICAgICBhcmdzOiBbJ2InXSxcbiAgICAgICAgICAgIGluZGV4OiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciByZXQgPSBzZXF1ZW5jZWQoJ2EnLCAnYycpO1xuXG4gICAgICAgIGV4cGVjdChyZXQpLnRvLmJlKCdiYWNiYWNiYmInKTtcbiAgICB9KTtcblxuICAgIGl0KCdjcmVhdGUgZGVmZXJyZWQnLCBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgIHZhciBoYXNEZWZlcmVkID0gZmFsc2U7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IEx1Yy5GdW5jdGlvbi5jcmVhdGVEZWZlcnJlZChmdW5jdGlvbihhLGIpe1xuICAgICAgICAgICAgaGFzRGVmZXJlZCA9IHRydWU7XG4gICAgICAgICAgICBleHBlY3QoYSkudG8uYmUoMSk7XG4gICAgICAgICAgICBleHBlY3QoYikudG8uYmUoMik7XG4gICAgICAgICAgICBkb25lKCk7XG5cbiAgICAgICAgfSwgMSwge1xuICAgICAgICAgICAgYXJnczogWzJdLFxuICAgICAgICAgICAgaW5kZXg6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZGVmZXJyZWQoMSk7XG5cbiAgICAgICAgZXhwZWN0KGhhc0RlZmVyZWQpLnRvLmJlKGZhbHNlKTtcbiAgICB9KTtcblxuICAgIGl0KCdjcmVhdGUgZGVmZXJyZWQgbm8gbWlsbGlzJywgZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICB2YXIgaGFzRGVmZXJlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSBMdWMuRnVuY3Rpb24uY3JlYXRlRGVmZXJyZWQoZnVuY3Rpb24oYSxiKXtcbiAgICAgICAgICAgIGhhc0RlZmVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgZXhwZWN0KGEpLnRvLmJlKDEpO1xuICAgICAgICAgICAgZXhwZWN0KGIpLnRvLmJlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0sIDApO1xuXG4gICAgICAgIGRlZmVycmVkKDEpO1xuXG4gICAgICAgIGV4cGVjdChoYXNEZWZlcmVkKS50by5iZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIGl0KCdjcmVhdGUgdGhyb3R0ZWxlZCBubyBtaWxsaXMnLCBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgIHZhciBoYXNEZWZlcmVkID0gZmFsc2U7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IEx1Yy5GdW5jdGlvbi5jcmVhdGVUaHJvdHRsZWQoZnVuY3Rpb24oYSxiKXtcbiAgICAgICAgICAgIGhhc0RlZmVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgZXhwZWN0KGEpLnRvLmJlKDEpO1xuICAgICAgICAgICAgZXhwZWN0KGIpLnRvLmJlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0sIDApO1xuXG4gICAgICAgIGRlZmVycmVkKDEpO1xuXG4gICAgICAgIGV4cGVjdChoYXNEZWZlcmVkKS50by5iZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIGl0KCdjcmVhdGUgdGhyb3R0ZWxlZCcsIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgdmFyIGNhbGxDb3VudCA9IDA7XG4gICAgICAgIHZhciB0aHJvdHRsZWQgPSBMdWMuRnVuY3Rpb24uY3JlYXRlVGhyb3R0bGVkKGZ1bmN0aW9uKGEsYixjKXtcbiAgICAgICAgICAgIGNhbGxDb3VudCsrO1xuICAgICAgICAgICAgZXhwZWN0KGEpLnRvLmJlKDEpO1xuICAgICAgICAgICAgZXhwZWN0KGIpLnRvLmJlKDMpO1xuICAgICAgICAgICAgZXhwZWN0KGMpLnRvLmJlKDIpO1xuICAgICAgICAgICAgZXhwZWN0KGNhbGxDb3VudCkudG8uYmUoMSk7XG4gICAgICAgICAgICBkb25lKCk7XG5cbiAgICAgICAgfSwgMSwge1xuICAgICAgICAgICAgYXJnczogWzNdLFxuICAgICAgICAgICAgaW5kZXg6IDFcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IDIwMDsgKytpKSB7XG4gICAgICAgICAgICB0aHJvdHRsZWQoMSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdHRsZWQoMSwyKTtcblxuICAgICAgICBleHBlY3QoY2FsbENvdW50KS50by5iZSgwKTtcbiAgICB9KTtcblxuXG59KTsiLCJyZXF1aXJlPShmdW5jdGlvbihlLHQsbixyKXtmdW5jdGlvbiBpKHIpe2lmKCFuW3JdKXtpZighdFtyXSl7aWYoZSlyZXR1cm4gZShyKTt0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK3IrXCInXCIpfXZhciBzPW5bcl09e2V4cG9ydHM6e319O3Rbcl1bMF0oZnVuY3Rpb24oZSl7dmFyIG49dFtyXVsxXVtlXTtyZXR1cm4gaShuP246ZSl9LHMscy5leHBvcnRzKX1yZXR1cm4gbltyXS5leHBvcnRzfWZvcih2YXIgcz0wO3M8ci5sZW5ndGg7cysrKWkocltzXSk7cmV0dXJuIGl9KSh0eXBlb2YgcmVxdWlyZSE9PVwidW5kZWZpbmVkXCImJnJlcXVpcmUsezE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gVVRJTElUWVxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXI7XG52YXIgcFNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG5mdW5jdGlvbiBvYmplY3RLZXlzKG9iamVjdCkge1xuICBpZiAoT2JqZWN0LmtleXMpIHJldHVybiBPYmplY3Qua2V5cyhvYmplY3QpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIG5hbWUgaW4gb2JqZWN0KSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIG5hbWUpKSB7XG4gICAgICByZXN1bHQucHVzaChuYW1lKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gMS4gVGhlIGFzc2VydCBtb2R1bGUgcHJvdmlkZXMgZnVuY3Rpb25zIHRoYXQgdGhyb3dcbi8vIEFzc2VydGlvbkVycm9yJ3Mgd2hlbiBwYXJ0aWN1bGFyIGNvbmRpdGlvbnMgYXJlIG5vdCBtZXQuIFRoZVxuLy8gYXNzZXJ0IG1vZHVsZSBtdXN0IGNvbmZvcm0gdG8gdGhlIGZvbGxvd2luZyBpbnRlcmZhY2UuXG5cbnZhciBhc3NlcnQgPSBtb2R1bGUuZXhwb3J0cyA9IG9rO1xuXG4vLyAyLiBUaGUgQXNzZXJ0aW9uRXJyb3IgaXMgZGVmaW5lZCBpbiBhc3NlcnQuXG4vLyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHsgbWVzc2FnZTogbWVzc2FnZSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IGFjdHVhbCxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQgfSlcblxuYXNzZXJ0LkFzc2VydGlvbkVycm9yID0gZnVuY3Rpb24gQXNzZXJ0aW9uRXJyb3Iob3B0aW9ucykge1xuICB0aGlzLm5hbWUgPSAnQXNzZXJ0aW9uRXJyb3InO1xuICB0aGlzLm1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2U7XG4gIHRoaXMuYWN0dWFsID0gb3B0aW9ucy5hY3R1YWw7XG4gIHRoaXMuZXhwZWN0ZWQgPSBvcHRpb25zLmV4cGVjdGVkO1xuICB0aGlzLm9wZXJhdG9yID0gb3B0aW9ucy5vcGVyYXRvcjtcbiAgdmFyIHN0YWNrU3RhcnRGdW5jdGlvbiA9IG9wdGlvbnMuc3RhY2tTdGFydEZ1bmN0aW9uIHx8IGZhaWw7XG5cbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgc3RhY2tTdGFydEZ1bmN0aW9uKTtcbiAgfVxufTtcbnV0aWwuaW5oZXJpdHMoYXNzZXJ0LkFzc2VydGlvbkVycm9yLCBFcnJvcik7XG5cbmZ1bmN0aW9uIHJlcGxhY2VyKGtleSwgdmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gJycgKyB2YWx1ZTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAoaXNOYU4odmFsdWUpIHx8ICFpc0Zpbml0ZSh2YWx1ZSkpKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gdHJ1bmNhdGUocywgbikge1xuICBpZiAodHlwZW9mIHMgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcy5sZW5ndGggPCBuID8gcyA6IHMuc2xpY2UoMCwgbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHM7XG4gIH1cbn1cblxuYXNzZXJ0LkFzc2VydGlvbkVycm9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5tZXNzYWdlKSB7XG4gICAgcmV0dXJuIFt0aGlzLm5hbWUgKyAnOicsIHRoaXMubWVzc2FnZV0uam9pbignICcpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbXG4gICAgICB0aGlzLm5hbWUgKyAnOicsXG4gICAgICB0cnVuY2F0ZShKU09OLnN0cmluZ2lmeSh0aGlzLmFjdHVhbCwgcmVwbGFjZXIpLCAxMjgpLFxuICAgICAgdGhpcy5vcGVyYXRvcixcbiAgICAgIHRydW5jYXRlKEpTT04uc3RyaW5naWZ5KHRoaXMuZXhwZWN0ZWQsIHJlcGxhY2VyKSwgMTI4KVxuICAgIF0uam9pbignICcpO1xuICB9XG59O1xuXG4vLyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3IgaW5zdGFuY2VvZiBFcnJvclxuXG5hc3NlcnQuQXNzZXJ0aW9uRXJyb3IuX19wcm90b19fID0gRXJyb3IucHJvdG90eXBlO1xuXG4vLyBBdCBwcmVzZW50IG9ubHkgdGhlIHRocmVlIGtleXMgbWVudGlvbmVkIGFib3ZlIGFyZSB1c2VkIGFuZFxuLy8gdW5kZXJzdG9vZCBieSB0aGUgc3BlYy4gSW1wbGVtZW50YXRpb25zIG9yIHN1YiBtb2R1bGVzIGNhbiBwYXNzXG4vLyBvdGhlciBrZXlzIHRvIHRoZSBBc3NlcnRpb25FcnJvcidzIGNvbnN0cnVjdG9yIC0gdGhleSB3aWxsIGJlXG4vLyBpZ25vcmVkLlxuXG4vLyAzLiBBbGwgb2YgdGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgbXVzdCB0aHJvdyBhbiBBc3NlcnRpb25FcnJvclxuLy8gd2hlbiBhIGNvcnJlc3BvbmRpbmcgY29uZGl0aW9uIGlzIG5vdCBtZXQsIHdpdGggYSBtZXNzYWdlIHRoYXRcbi8vIG1heSBiZSB1bmRlZmluZWQgaWYgbm90IHByb3ZpZGVkLiAgQWxsIGFzc2VydGlvbiBtZXRob2RzIHByb3ZpZGVcbi8vIGJvdGggdGhlIGFjdHVhbCBhbmQgZXhwZWN0ZWQgdmFsdWVzIHRvIHRoZSBhc3NlcnRpb24gZXJyb3IgZm9yXG4vLyBkaXNwbGF5IHB1cnBvc2VzLlxuXG5mdW5jdGlvbiBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsIG9wZXJhdG9yLCBzdGFja1N0YXJ0RnVuY3Rpb24pIHtcbiAgdGhyb3cgbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7XG4gICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgb3BlcmF0b3I6IG9wZXJhdG9yLFxuICAgIHN0YWNrU3RhcnRGdW5jdGlvbjogc3RhY2tTdGFydEZ1bmN0aW9uXG4gIH0pO1xufVxuXG4vLyBFWFRFTlNJT04hIGFsbG93cyBmb3Igd2VsbCBiZWhhdmVkIGVycm9ycyBkZWZpbmVkIGVsc2V3aGVyZS5cbmFzc2VydC5mYWlsID0gZmFpbDtcblxuLy8gNC4gUHVyZSBhc3NlcnRpb24gdGVzdHMgd2hldGhlciBhIHZhbHVlIGlzIHRydXRoeSwgYXMgZGV0ZXJtaW5lZFxuLy8gYnkgISFndWFyZC5cbi8vIGFzc2VydC5vayhndWFyZCwgbWVzc2FnZV9vcHQpO1xuLy8gVGhpcyBzdGF0ZW1lbnQgaXMgZXF1aXZhbGVudCB0byBhc3NlcnQuZXF1YWwodHJ1ZSwgZ3VhcmQsXG4vLyBtZXNzYWdlX29wdCk7LiBUbyB0ZXN0IHN0cmljdGx5IGZvciB0aGUgdmFsdWUgdHJ1ZSwgdXNlXG4vLyBhc3NlcnQuc3RyaWN0RXF1YWwodHJ1ZSwgZ3VhcmQsIG1lc3NhZ2Vfb3B0KTsuXG5cbmZ1bmN0aW9uIG9rKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICghISF2YWx1ZSkgZmFpbCh2YWx1ZSwgdHJ1ZSwgbWVzc2FnZSwgJz09JywgYXNzZXJ0Lm9rKTtcbn1cbmFzc2VydC5vayA9IG9rO1xuXG4vLyA1LiBUaGUgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHNoYWxsb3csIGNvZXJjaXZlIGVxdWFsaXR5IHdpdGhcbi8vID09LlxuLy8gYXNzZXJ0LmVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmVxdWFsID0gZnVuY3Rpb24gZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsICE9IGV4cGVjdGVkKSBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICc9PScsIGFzc2VydC5lcXVhbCk7XG59O1xuXG4vLyA2LiBUaGUgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igd2hldGhlciB0d28gb2JqZWN0cyBhcmUgbm90IGVxdWFsXG4vLyB3aXRoICE9IGFzc2VydC5ub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RFcXVhbCA9IGZ1bmN0aW9uIG5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJyE9JywgYXNzZXJ0Lm5vdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gNy4gVGhlIGVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBhIGRlZXAgZXF1YWxpdHkgcmVsYXRpb24uXG4vLyBhc3NlcnQuZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmRlZXBFcXVhbCA9IGZ1bmN0aW9uIGRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmICghX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ2RlZXBFcXVhbCcsIGFzc2VydC5kZWVwRXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgLy8gNy4xLiBBbGwgaWRlbnRpY2FsIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG5cbiAgfSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIoYWN0dWFsKSAmJiBCdWZmZXIuaXNCdWZmZXIoZXhwZWN0ZWQpKSB7XG4gICAgaWYgKGFjdHVhbC5sZW5ndGggIT0gZXhwZWN0ZWQubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFjdHVhbC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFjdHVhbFtpXSAhPT0gZXhwZWN0ZWRbaV0pIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcblxuICAvLyA3LjIuIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIERhdGUgb2JqZWN0LCB0aGUgYWN0dWFsIHZhbHVlIGlzXG4gIC8vIGVxdWl2YWxlbnQgaWYgaXQgaXMgYWxzbyBhIERhdGUgb2JqZWN0IHRoYXQgcmVmZXJzIHRvIHRoZSBzYW1lIHRpbWUuXG4gIH0gZWxzZSBpZiAoYWN0dWFsIGluc3RhbmNlb2YgRGF0ZSAmJiBleHBlY3RlZCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gYWN0dWFsLmdldFRpbWUoKSA9PT0gZXhwZWN0ZWQuZ2V0VGltZSgpO1xuXG4gIC8vIDcuMy4gT3RoZXIgcGFpcnMgdGhhdCBkbyBub3QgYm90aCBwYXNzIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyxcbiAgLy8gZXF1aXZhbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSA9PS5cbiAgfSBlbHNlIGlmICh0eXBlb2YgYWN0dWFsICE9ICdvYmplY3QnICYmIHR5cGVvZiBleHBlY3RlZCAhPSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBhY3R1YWwgPT0gZXhwZWN0ZWQ7XG5cbiAgLy8gNy40LiBGb3IgYWxsIG90aGVyIE9iamVjdCBwYWlycywgaW5jbHVkaW5nIEFycmF5IG9iamVjdHMsIGVxdWl2YWxlbmNlIGlzXG4gIC8vIGRldGVybWluZWQgYnkgaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChhcyB2ZXJpZmllZFxuICAvLyB3aXRoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCksIHRoZSBzYW1lIHNldCBvZiBrZXlzXG4gIC8vIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLCBlcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnlcbiAgLy8gY29ycmVzcG9uZGluZyBrZXksIGFuZCBhbiBpZGVudGljYWwgJ3Byb3RvdHlwZScgcHJvcGVydHkuIE5vdGU6IHRoaXNcbiAgLy8gYWNjb3VudHMgZm9yIGJvdGggbmFtZWQgYW5kIGluZGV4ZWQgcHJvcGVydGllcyBvbiBBcnJheXMuXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9iakVxdWl2KGFjdHVhbCwgZXhwZWN0ZWQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkT3JOdWxsKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBpc0FyZ3VtZW50cyhvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufVxuXG5mdW5jdGlvbiBvYmpFcXVpdihhLCBiKSB7XG4gIGlmIChpc1VuZGVmaW5lZE9yTnVsbChhKSB8fCBpc1VuZGVmaW5lZE9yTnVsbChiKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS5cbiAgaWYgKGEucHJvdG90eXBlICE9PSBiLnByb3RvdHlwZSkgcmV0dXJuIGZhbHNlO1xuICAvL35+fkkndmUgbWFuYWdlZCB0byBicmVhayBPYmplY3Qua2V5cyB0aHJvdWdoIHNjcmV3eSBhcmd1bWVudHMgcGFzc2luZy5cbiAgLy8gICBDb252ZXJ0aW5nIHRvIGFycmF5IHNvbHZlcyB0aGUgcHJvYmxlbS5cbiAgaWYgKGlzQXJndW1lbnRzKGEpKSB7XG4gICAgaWYgKCFpc0FyZ3VtZW50cyhiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhID0gcFNsaWNlLmNhbGwoYSk7XG4gICAgYiA9IHBTbGljZS5jYWxsKGIpO1xuICAgIHJldHVybiBfZGVlcEVxdWFsKGEsIGIpO1xuICB9XG4gIHRyeSB7XG4gICAgdmFyIGthID0gb2JqZWN0S2V5cyhhKSxcbiAgICAgICAga2IgPSBvYmplY3RLZXlzKGIpLFxuICAgICAgICBrZXksIGk7XG4gIH0gY2F0Y2ggKGUpIHsvL2hhcHBlbnMgd2hlbiBvbmUgaXMgYSBzdHJpbmcgbGl0ZXJhbCBhbmQgdGhlIG90aGVyIGlzbid0XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoa2V5cyBpbmNvcnBvcmF0ZXNcbiAgLy8gaGFzT3duUHJvcGVydHkpXG4gIGlmIChrYS5sZW5ndGggIT0ga2IubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy90aGUgc2FtZSBzZXQgb2Yga2V5cyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSxcbiAga2Euc29ydCgpO1xuICBrYi5zb3J0KCk7XG4gIC8vfn5+Y2hlYXAga2V5IHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoa2FbaV0gIT0ga2JbaV0pXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy9lcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXksIGFuZFxuICAvL35+fnBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBrZXkgPSBrYVtpXTtcbiAgICBpZiAoIV9kZWVwRXF1YWwoYVtrZXldLCBiW2tleV0pKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIDguIFRoZSBub24tZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGZvciBhbnkgZGVlcCBpbmVxdWFsaXR5LlxuLy8gYXNzZXJ0Lm5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3REZWVwRXF1YWwgPSBmdW5jdGlvbiBub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ25vdERlZXBFcXVhbCcsIGFzc2VydC5ub3REZWVwRXF1YWwpO1xuICB9XG59O1xuXG4vLyA5LiBUaGUgc3RyaWN0IGVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBzdHJpY3QgZXF1YWxpdHksIGFzIGRldGVybWluZWQgYnkgPT09LlxuLy8gYXNzZXJ0LnN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LnN0cmljdEVxdWFsID0gZnVuY3Rpb24gc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsICE9PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJz09PScsIGFzc2VydC5zdHJpY3RFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDEwLiBUaGUgc3RyaWN0IG5vbi1lcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgZm9yIHN0cmljdCBpbmVxdWFsaXR5LCBhc1xuLy8gZGV0ZXJtaW5lZCBieSAhPT0uICBhc3NlcnQubm90U3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90U3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnIT09JywgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkge1xuICBpZiAoIWFjdHVhbCB8fCAhZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoZXhwZWN0ZWQgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gZXhwZWN0ZWQudGVzdChhY3R1YWwpO1xuICB9IGVsc2UgaWYgKGFjdHVhbCBpbnN0YW5jZW9mIGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWQuY2FsbCh7fSwgYWN0dWFsKSA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBfdGhyb3dzKHNob3VsZFRocm93LCBibG9jaywgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgdmFyIGFjdHVhbDtcblxuICBpZiAodHlwZW9mIGV4cGVjdGVkID09PSAnc3RyaW5nJykge1xuICAgIG1lc3NhZ2UgPSBleHBlY3RlZDtcbiAgICBleHBlY3RlZCA9IG51bGw7XG4gIH1cblxuICB0cnkge1xuICAgIGJsb2NrKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBhY3R1YWwgPSBlO1xuICB9XG5cbiAgbWVzc2FnZSA9IChleHBlY3RlZCAmJiBleHBlY3RlZC5uYW1lID8gJyAoJyArIGV4cGVjdGVkLm5hbWUgKyAnKS4nIDogJy4nKSArXG4gICAgICAgICAgICAobWVzc2FnZSA/ICcgJyArIG1lc3NhZ2UgOiAnLicpO1xuXG4gIGlmIChzaG91bGRUaHJvdyAmJiAhYWN0dWFsKSB7XG4gICAgZmFpbCgnTWlzc2luZyBleHBlY3RlZCBleGNlcHRpb24nICsgbWVzc2FnZSk7XG4gIH1cblxuICBpZiAoIXNob3VsZFRocm93ICYmIGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgZmFpbCgnR290IHVud2FudGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIGlmICgoc2hvdWxkVGhyb3cgJiYgYWN0dWFsICYmIGV4cGVjdGVkICYmXG4gICAgICAhZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkpIHx8ICghc2hvdWxkVGhyb3cgJiYgYWN0dWFsKSkge1xuICAgIHRocm93IGFjdHVhbDtcbiAgfVxufVxuXG4vLyAxMS4gRXhwZWN0ZWQgdG8gdGhyb3cgYW4gZXJyb3I6XG4vLyBhc3NlcnQudGhyb3dzKGJsb2NrLCBFcnJvcl9vcHQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LnRocm93cyA9IGZ1bmN0aW9uKGJsb2NrLCAvKm9wdGlvbmFsKi9lcnJvciwgLypvcHRpb25hbCovbWVzc2FnZSkge1xuICBfdGhyb3dzLmFwcGx5KHRoaXMsIFt0cnVlXS5jb25jYXQocFNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xufTtcblxuLy8gRVhURU5TSU9OISBUaGlzIGlzIGFubm95aW5nIHRvIHdyaXRlIG91dHNpZGUgdGhpcyBtb2R1bGUuXG5hc3NlcnQuZG9lc05vdFRocm93ID0gZnVuY3Rpb24oYmxvY2ssIC8qb3B0aW9uYWwqL2Vycm9yLCAvKm9wdGlvbmFsKi9tZXNzYWdlKSB7XG4gIF90aHJvd3MuYXBwbHkodGhpcywgW2ZhbHNlXS5jb25jYXQocFNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xufTtcblxuYXNzZXJ0LmlmRXJyb3IgPSBmdW5jdGlvbihlcnIpIHsgaWYgKGVycikge3Rocm93IGVycjt9fTtcblxufSx7XCJ1dGlsXCI6MixcImJ1ZmZlclwiOjN9XSwyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBldmVudHMgPSByZXF1aXJlKCdldmVudHMnKTtcblxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcbmV4cG9ydHMuaXNEYXRlID0gZnVuY3Rpb24ob2JqKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IERhdGVdJ307XG5leHBvcnRzLmlzUmVnRXhwID0gZnVuY3Rpb24ob2JqKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nfTtcblxuXG5leHBvcnRzLnByaW50ID0gZnVuY3Rpb24gKCkge307XG5leHBvcnRzLnB1dHMgPSBmdW5jdGlvbiAoKSB7fTtcbmV4cG9ydHMuZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuXG5leHBvcnRzLmluc3BlY3QgPSBmdW5jdGlvbihvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMpIHtcbiAgdmFyIHNlZW4gPSBbXTtcblxuICB2YXIgc3R5bGl6ZSA9IGZ1bmN0aW9uKHN0ciwgc3R5bGVUeXBlKSB7XG4gICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG4gICAgdmFyIHN0eWxlcyA9XG4gICAgICAgIHsgJ2JvbGQnIDogWzEsIDIyXSxcbiAgICAgICAgICAnaXRhbGljJyA6IFszLCAyM10sXG4gICAgICAgICAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAgICAgICAgICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICAgICAgICAgJ3doaXRlJyA6IFszNywgMzldLFxuICAgICAgICAgICdncmV5JyA6IFs5MCwgMzldLFxuICAgICAgICAgICdibGFjaycgOiBbMzAsIDM5XSxcbiAgICAgICAgICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgICAgICAgICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgICAgICAgICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICAgICAgICAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICAgICAgICAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgICAgICAgICAneWVsbG93JyA6IFszMywgMzldIH07XG5cbiAgICB2YXIgc3R5bGUgPVxuICAgICAgICB7ICdzcGVjaWFsJzogJ2N5YW4nLFxuICAgICAgICAgICdudW1iZXInOiAnYmx1ZScsXG4gICAgICAgICAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgICAgICAgICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAgICAgICAgICdudWxsJzogJ2JvbGQnLFxuICAgICAgICAgICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAgICAgICAgICdkYXRlJzogJ21hZ2VudGEnLFxuICAgICAgICAgIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICAgICAgICAgJ3JlZ2V4cCc6ICdyZWQnIH1bc3R5bGVUeXBlXTtcblxuICAgIGlmIChzdHlsZSkge1xuICAgICAgcmV0dXJuICdcXDAzM1snICsgc3R5bGVzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICAgJ1xcMDMzWycgKyBzdHlsZXNbc3R5bGVdWzFdICsgJ20nO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgfTtcbiAgaWYgKCEgY29sb3JzKSB7XG4gICAgc3R5bGl6ZSA9IGZ1bmN0aW9uKHN0ciwgc3R5bGVUeXBlKSB7IHJldHVybiBzdHI7IH07XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXQodmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAgIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlLmluc3BlY3QgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICAgIHZhbHVlICE9PSBleHBvcnRzICYmXG4gICAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMpO1xuICAgIH1cblxuICAgIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIHJldHVybiBzdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG5cbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgICAgIHJldHVybiBzdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuXG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICByZXR1cm4gc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG5cbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAgIH1cbiAgICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG4gICAgfVxuXG4gICAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICAgIHZhciB2aXNpYmxlX2tleXMgPSBPYmplY3Rfa2V5cyh2YWx1ZSk7XG4gICAgdmFyIGtleXMgPSBzaG93SGlkZGVuID8gT2JqZWN0X2dldE93blByb3BlcnR5TmFtZXModmFsdWUpIDogdmlzaWJsZV9rZXlzO1xuXG4gICAgLy8gRnVuY3Rpb25zIHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gc3R5bGl6ZSgnJyArIHZhbHVlLCAncmVnZXhwJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgICByZXR1cm4gc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRGF0ZXMgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZFxuICAgIGlmIChpc0RhdGUodmFsdWUpICYmIGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gc3R5bGl6ZSh2YWx1ZS50b1VUQ1N0cmluZygpLCAnZGF0ZScpO1xuICAgIH1cblxuICAgIHZhciBiYXNlLCB0eXBlLCBicmFjZXM7XG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBvYmplY3QgdHlwZVxuICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgdHlwZSA9ICdBcnJheSc7XG4gICAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlID0gJ09iamVjdCc7XG4gICAgICBicmFjZXMgPSBbJ3snLCAnfSddO1xuICAgIH1cblxuICAgIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICBiYXNlID0gKGlzUmVnRXhwKHZhbHVlKSkgPyAnICcgKyB2YWx1ZSA6ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhc2UgPSAnJztcbiAgICB9XG5cbiAgICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgYmFzZSA9ICcgJyArIHZhbHVlLnRvVVRDU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgICB9XG5cbiAgICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gc3R5bGl6ZSgnJyArIHZhbHVlLCAncmVnZXhwJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgICB2YXIgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICB2YXIgbmFtZSwgc3RyO1xuICAgICAgaWYgKHZhbHVlLl9fbG9va3VwR2V0dGVyX18pIHtcbiAgICAgICAgaWYgKHZhbHVlLl9fbG9va3VwR2V0dGVyX18oa2V5KSkge1xuICAgICAgICAgIGlmICh2YWx1ZS5fX2xvb2t1cFNldHRlcl9fKGtleSkpIHtcbiAgICAgICAgICAgIHN0ciA9IHN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0ciA9IHN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHZhbHVlLl9fbG9va3VwU2V0dGVyX18oa2V5KSkge1xuICAgICAgICAgICAgc3RyID0gc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHZpc2libGVfa2V5cy5pbmRleE9mKGtleSkgPCAwKSB7XG4gICAgICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gICAgICB9XG4gICAgICBpZiAoIXN0cikge1xuICAgICAgICBpZiAoc2Vlbi5pbmRleE9mKHZhbHVlW2tleV0pIDwgMCkge1xuICAgICAgICAgIGlmIChyZWN1cnNlVGltZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHN0ciA9IGZvcm1hdCh2YWx1ZVtrZXldKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyID0gZm9ybWF0KHZhbHVlW2tleV0sIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdBcnJheScgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgIH1cbiAgICAgICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICAgICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICAgICAgbmFtZSA9IHN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgICAgIG5hbWUgPSBzdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG4gICAgfSk7XG5cbiAgICBzZWVuLnBvcCgpO1xuXG4gICAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICAgIG51bUxpbmVzRXN0Kys7XG4gICAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgICByZXR1cm4gcHJldiArIGN1ci5sZW5ndGggKyAxO1xuICAgIH0sIDApO1xuXG4gICAgaWYgKGxlbmd0aCA+IDUwKSB7XG4gICAgICBvdXRwdXQgPSBicmFjZXNbMF0gK1xuICAgICAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICAgICAnICcgK1xuICAgICAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgICAgICcgJyArXG4gICAgICAgICAgICAgICBicmFjZXNbMV07XG5cbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0ID0gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cbiAgcmV0dXJuIGZvcm1hdChvYmosICh0eXBlb2YgZGVwdGggPT09ICd1bmRlZmluZWQnID8gMiA6IGRlcHRoKSk7XG59O1xuXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIGFyIGluc3RhbmNlb2YgQXJyYXkgfHxcbiAgICAgICAgIEFycmF5LmlzQXJyYXkoYXIpIHx8XG4gICAgICAgICAoYXIgJiYgYXIgIT09IE9iamVjdC5wcm90b3R5cGUgJiYgaXNBcnJheShhci5fX3Byb3RvX18pKTtcbn1cblxuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gcmUgaW5zdGFuY2VvZiBSZWdFeHAgfHxcbiAgICAodHlwZW9mIHJlID09PSAnb2JqZWN0JyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocmUpID09PSAnW29iamVjdCBSZWdFeHBdJyk7XG59XG5cblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgaWYgKGQgaW5zdGFuY2VvZiBEYXRlKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKHR5cGVvZiBkICE9PSAnb2JqZWN0JykgcmV0dXJuIGZhbHNlO1xuICB2YXIgcHJvcGVydGllcyA9IERhdGUucHJvdG90eXBlICYmIE9iamVjdF9nZXRPd25Qcm9wZXJ0eU5hbWVzKERhdGUucHJvdG90eXBlKTtcbiAgdmFyIHByb3RvID0gZC5fX3Byb3RvX18gJiYgT2JqZWN0X2dldE93blByb3BlcnR5TmFtZXMoZC5fX3Byb3RvX18pO1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocHJvdG8pID09PSBKU09OLnN0cmluZ2lmeShwcm9wZXJ0aWVzKTtcbn1cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cbmV4cG9ydHMubG9nID0gZnVuY3Rpb24gKG1zZykge307XG5cbmV4cG9ydHMucHVtcCA9IG51bGw7XG5cbnZhciBPYmplY3Rfa2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgcmVzLnB1c2goa2V5KTtcbiAgICByZXR1cm4gcmVzO1xufTtcblxudmFyIE9iamVjdF9nZXRPd25Qcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHJlcy5wdXNoKGtleSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59O1xuXG52YXIgT2JqZWN0X2NyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gKHByb3RvdHlwZSwgcHJvcGVydGllcykge1xuICAgIC8vIGZyb20gZXM1LXNoaW1cbiAgICB2YXIgb2JqZWN0O1xuICAgIGlmIChwcm90b3R5cGUgPT09IG51bGwpIHtcbiAgICAgICAgb2JqZWN0ID0geyAnX19wcm90b19fJyA6IG51bGwgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvdG90eXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICAndHlwZW9mIHByb3RvdHlwZVsnICsgKHR5cGVvZiBwcm90b3R5cGUpICsgJ10gIT0gXFwnb2JqZWN0XFwnJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgVHlwZSA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICBUeXBlLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgICAgICAgb2JqZWN0ID0gbmV3IFR5cGUoKTtcbiAgICAgICAgb2JqZWN0Ll9fcHJvdG9fXyA9IHByb3RvdHlwZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwcm9wZXJ0aWVzICE9PSAndW5kZWZpbmVkJyAmJiBPYmplY3QuZGVmaW5lUHJvcGVydGllcykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhvYmplY3QsIHByb3BlcnRpZXMpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xufTtcblxuZXhwb3J0cy5pbmhlcml0cyA9IGZ1bmN0aW9uKGN0b3IsIHN1cGVyQ3Rvcikge1xuICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvcjtcbiAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3RfY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbn07XG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICh0eXBlb2YgZiAhPT0gJ3N0cmluZycpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goZXhwb3J0cy5pbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVqJzogcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKXtcbiAgICBpZiAoeCA9PT0gbnVsbCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAnICsgZXhwb3J0cy5pbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxufSx7XCJldmVudHNcIjo0fV0sNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5leHBvcnRzLnJlYWRJRUVFNzU0ID0gZnVuY3Rpb24oYnVmZmVyLCBvZmZzZXQsIGlzQkUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSxcbiAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXG4gICAgICBlTWF4ID0gKDEgPDwgZUxlbikgLSAxLFxuICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXG4gICAgICBuQml0cyA9IC03LFxuICAgICAgaSA9IGlzQkUgPyAwIDogKG5CeXRlcyAtIDEpLFxuICAgICAgZCA9IGlzQkUgPyAxIDogLTEsXG4gICAgICBzID0gYnVmZmVyW29mZnNldCArIGldO1xuXG4gIGkgKz0gZDtcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKTtcbiAgcyA+Pj0gKC1uQml0cyk7XG4gIG5CaXRzICs9IGVMZW47XG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpO1xuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBlID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gbUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCk7XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzO1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSk7XG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICBlID0gZSAtIGVCaWFzO1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pO1xufTtcblxuZXhwb3J0cy53cml0ZUlFRUU3NTQgPSBmdW5jdGlvbihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQkUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgYyxcbiAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXG4gICAgICBlTWF4ID0gKDEgPDwgZUxlbikgLSAxLFxuICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXG4gICAgICBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMCksXG4gICAgICBpID0gaXNCRSA/IChuQnl0ZXMgLSAxKSA6IDAsXG4gICAgICBkID0gaXNCRSA/IC0xIDogMSxcbiAgICAgIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDA7XG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSk7XG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDA7XG4gICAgZSA9IGVNYXg7XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpO1xuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLTtcbiAgICAgIGMgKj0gMjtcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKys7XG4gICAgICBjIC89IDI7XG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMDtcbiAgICAgIGUgPSBlTWF4O1xuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSBlICsgZUJpYXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSAwO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpO1xuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG07XG4gIGVMZW4gKz0gbUxlbjtcbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KTtcblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjg7XG59O1xuXG59LHt9XSw2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnByb2Nlc3MubmV4dFRpY2sgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYW5TZXRJbW1lZGlhdGUgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5zZXRJbW1lZGlhdGU7XG4gICAgdmFyIGNhblBvc3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5wb3N0TWVzc2FnZSAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lclxuICAgIDtcblxuICAgIGlmIChjYW5TZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmKSB7IHJldHVybiB3aW5kb3cuc2V0SW1tZWRpYXRlKGYpIH07XG4gICAgfVxuXG4gICAgaWYgKGNhblBvc3QpIHtcbiAgICAgICAgdmFyIHF1ZXVlID0gW107XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBpZiAoZXYuc291cmNlID09PSB3aW5kb3cgJiYgZXYuZGF0YSA9PT0gJ3Byb2Nlc3MtdGljaycpIHtcbiAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm4gPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGZuKTtcbiAgICAgICAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZSgncHJvY2Vzcy10aWNrJywgJyonKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gICAgfTtcbn0pKCk7XG5cbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn1cblxuLy8gVE9ETyhzaHR5bG1hbilcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG59LHt9XSw0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbihwcm9jZXNzKXtpZiAoIXByb2Nlc3MuRXZlbnRFbWl0dGVyKSBwcm9jZXNzLkV2ZW50RW1pdHRlciA9IGZ1bmN0aW9uICgpIHt9O1xuXG52YXIgRXZlbnRFbWl0dGVyID0gZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSBwcm9jZXNzLkV2ZW50RW1pdHRlcjtcbnZhciBpc0FycmF5ID0gdHlwZW9mIEFycmF5LmlzQXJyYXkgPT09ICdmdW5jdGlvbidcbiAgICA/IEFycmF5LmlzQXJyYXlcbiAgICA6IGZ1bmN0aW9uICh4cykge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJ1xuICAgIH1cbjtcbmZ1bmN0aW9uIGluZGV4T2YgKHhzLCB4KSB7XG4gICAgaWYgKHhzLmluZGV4T2YpIHJldHVybiB4cy5pbmRleE9mKHgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHggPT09IHhzW2ldKSByZXR1cm4gaTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuXG4vLyAxMCBsaXN0ZW5lcnMgYXJlIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2hcbi8vIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuLy9cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghdGhpcy5fZXZlbnRzKSB0aGlzLl9ldmVudHMgPSB7fTtcbiAgdGhpcy5fZXZlbnRzLm1heExpc3RlbmVycyA9IG47XG59O1xuXG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzQXJyYXkodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpXG4gICAge1xuICAgICAgaWYgKGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGFyZ3VtZW50c1sxXTsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuY2F1Z2h0LCB1bnNwZWNpZmllZCAnZXJyb3InIGV2ZW50LlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXRoaXMuX2V2ZW50cykgcmV0dXJuIGZhbHNlO1xuICB2YXIgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgaWYgKCFoYW5kbGVyKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09ICdmdW5jdGlvbicpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9IGVsc2UgaWYgKGlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICB2YXIgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLy8gRXZlbnRFbWl0dGVyIGlzIGRlZmluZWQgaW4gc3JjL25vZGVfZXZlbnRzLmNjXG4vLyBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQoKSBpcyBhbHNvIGRlZmluZWQgdGhlcmUuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCdmdW5jdGlvbicgIT09IHR5cGVvZiBsaXN0ZW5lcikge1xuICAgIHRocm93IG5ldyBFcnJvcignYWRkTGlzdGVuZXIgb25seSB0YWtlcyBpbnN0YW5jZXMgb2YgRnVuY3Rpb24nKTtcbiAgfVxuXG4gIGlmICghdGhpcy5fZXZlbnRzKSB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09IFwibmV3TGlzdGVuZXJzXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyc1wiLlxuICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIH0gZWxzZSBpZiAoaXNBcnJheSh0aGlzLl9ldmVudHNbdHlwZV0pKSB7XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgICAgdmFyIG07XG4gICAgICBpZiAodGhpcy5fZXZlbnRzLm1heExpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG0gPSB0aGlzLl9ldmVudHMubWF4TGlzdGVuZXJzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbSA9IGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgICB9XG5cbiAgICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIH0gZWxzZSB7XG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLm9uKHR5cGUsIGZ1bmN0aW9uIGcoKSB7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcbiAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIGxpc3RlbmVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyZW1vdmVMaXN0ZW5lciBvbmx5IHRha2VzIGluc3RhbmNlcyBvZiBGdW5jdGlvbicpO1xuICB9XG5cbiAgLy8gZG9lcyBub3QgdXNlIGxpc3RlbmVycygpLCBzbyBubyBzaWRlIGVmZmVjdCBvZiBjcmVhdGluZyBfZXZlbnRzW3R5cGVdXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pIHJldHVybiB0aGlzO1xuXG4gIHZhciBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0FycmF5KGxpc3QpKSB7XG4gICAgdmFyIGkgPSBpbmRleE9mKGxpc3QsIGxpc3RlbmVyKTtcbiAgICBpZiAoaSA8IDApIHJldHVybiB0aGlzO1xuICAgIGxpc3Quc3BsaWNlKGksIDEpO1xuICAgIGlmIChsaXN0Lmxlbmd0aCA9PSAwKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgfSBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0gPT09IGxpc3RlbmVyKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBkb2VzIG5vdCB1c2UgbGlzdGVuZXJzKCksIHNvIG5vIHNpZGUgZWZmZWN0IG9mIGNyZWF0aW5nIF9ldmVudHNbdHlwZV1cbiAgaWYgKHR5cGUgJiYgdGhpcy5fZXZlbnRzICYmIHRoaXMuX2V2ZW50c1t0eXBlXSkgdGhpcy5fZXZlbnRzW3R5cGVdID0gbnVsbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKCF0aGlzLl9ldmVudHMpIHRoaXMuX2V2ZW50cyA9IHt9O1xuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSkgdGhpcy5fZXZlbnRzW3R5cGVdID0gW107XG4gIGlmICghaXNBcnJheSh0aGlzLl9ldmVudHNbdHlwZV0pKSB7XG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2V2ZW50c1t0eXBlXTtcbn07XG5cbn0pKHJlcXVpcmUoXCJfX2Jyb3dzZXJpZnlfcHJvY2Vzc1wiKSlcbn0se1wiX19icm93c2VyaWZ5X3Byb2Nlc3NcIjo2fV0sXCJidWZmZXItYnJvd3NlcmlmeVwiOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzPXJlcXVpcmUoJ3E5VHhDQycpO1xufSx7fV0sXCJxOVR4Q0NcIjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5mdW5jdGlvbiBTbG93QnVmZmVyIChzaXplKSB7XG4gICAgdGhpcy5sZW5ndGggPSBzaXplO1xufTtcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xuXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTA7XG5cblxuZnVuY3Rpb24gdG9IZXgobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNik7XG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KTtcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspXG4gICAgaWYgKHN0ci5jaGFyQ29kZUF0KGkpIDw9IDB4N0YpXG4gICAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSk7XG4gICAgZWxzZSB7XG4gICAgICB2YXIgaCA9IGVuY29kZVVSSUNvbXBvbmVudChzdHIuY2hhckF0KGkpKS5zdWJzdHIoMSkuc3BsaXQoJyUnKTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaC5sZW5ndGg7IGorKylcbiAgICAgICAgYnl0ZUFycmF5LnB1c2gocGFyc2VJbnQoaFtqXSwgMTYpKTtcbiAgICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheTtcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKysgKVxuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKCBzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYgKTtcblxuICByZXR1cm4gYnl0ZUFycmF5O1xufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzKHN0cikge1xuICByZXR1cm4gcmVxdWlyZShcImJhc2U2NC1qc1wiKS50b0J5dGVBcnJheShzdHIpO1xufVxuXG5TbG93QnVmZmVyLmJ5dGVMZW5ndGggPSBmdW5jdGlvbiAoc3RyLCBlbmNvZGluZykge1xuICBzd2l0Y2ggKGVuY29kaW5nIHx8IFwidXRmOFwiKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldHVybiBzdHIubGVuZ3RoIC8gMjtcblxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHIpLmxlbmd0aDtcblxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0dXJuIHN0ci5sZW5ndGg7XG5cbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyKS5sZW5ndGg7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJyk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBwb3MsIGkgPSAwO1xuICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgIGlmICgoaStvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpXG4gICAgICBicmVhaztcblxuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXTtcbiAgICBpKys7XG4gIH1cbiAgcmV0dXJuIGk7XG59XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLnV0ZjhXcml0ZSA9IGZ1bmN0aW9uIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBieXRlcywgcG9zO1xuICByZXR1cm4gU2xvd0J1ZmZlci5fY2hhcnNXcml0dGVuID0gIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nKSwgdGhpcywgb2Zmc2V0LCBsZW5ndGgpO1xufTtcblxuU2xvd0J1ZmZlci5wcm90b3R5cGUuYXNjaWlXcml0ZSA9IGZ1bmN0aW9uIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBieXRlcywgcG9zO1xuICByZXR1cm4gU2xvd0J1ZmZlci5fY2hhcnNXcml0dGVuID0gIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIHRoaXMsIG9mZnNldCwgbGVuZ3RoKTtcbn07XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmJpbmFyeVdyaXRlID0gU2xvd0J1ZmZlci5wcm90b3R5cGUuYXNjaWlXcml0ZTtcblxuU2xvd0J1ZmZlci5wcm90b3R5cGUuYmFzZTY0V3JpdGUgPSBmdW5jdGlvbiAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgYnl0ZXMsIHBvcztcbiAgcmV0dXJuIFNsb3dCdWZmZXIuX2NoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCB0aGlzLCBvZmZzZXQsIGxlbmd0aCk7XG59O1xuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5iYXNlNjRTbGljZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gIHJldHVybiByZXF1aXJlKFwiYmFzZTY0LWpzXCIpLmZyb21CeXRlQXJyYXkoYnl0ZXMpO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVVdGY4Q2hhcihzdHIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHN0cik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkZGRCk7IC8vIFVURiA4IGludmFsaWQgY2hhclxuICB9XG59XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLnV0ZjhTbGljZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGJ5dGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIHZhciByZXMgPSBcIlwiO1xuICB2YXIgdG1wID0gXCJcIjtcbiAgdmFyIGkgPSAwO1xuICB3aGlsZSAoaSA8IGJ5dGVzLmxlbmd0aCkge1xuICAgIGlmIChieXRlc1tpXSA8PSAweDdGKSB7XG4gICAgICByZXMgKz0gZGVjb2RlVXRmOENoYXIodG1wKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0pO1xuICAgICAgdG1wID0gXCJcIjtcbiAgICB9IGVsc2VcbiAgICAgIHRtcCArPSBcIiVcIiArIGJ5dGVzW2ldLnRvU3RyaW5nKDE2KTtcblxuICAgIGkrKztcbiAgfVxuXG4gIHJldHVybiByZXMgKyBkZWNvZGVVdGY4Q2hhcih0bXApO1xufVxuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5hc2NpaVNsaWNlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYnl0ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgdmFyIHJldCA9IFwiXCI7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspXG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0pO1xuICByZXR1cm4gcmV0O1xufVxuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5iaW5hcnlTbGljZSA9IFNsb3dCdWZmZXIucHJvdG90eXBlLmFzY2lpU2xpY2U7XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG91dCA9IFtdLFxuICAgICAgbGVuID0gdGhpcy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBvdXRbaV0gPSB0b0hleCh0aGlzW2ldKTtcbiAgICBpZiAoaSA9PSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTKSB7XG4gICAgICBvdXRbaSArIDFdID0gJy4uLic7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICc8U2xvd0J1ZmZlciAnICsgb3V0LmpvaW4oJyAnKSArICc+Jztcbn07XG5cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUuaGV4U2xpY2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aDtcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwO1xuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuO1xuXG4gIHZhciBvdXQgPSAnJztcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBvdXQgKz0gdG9IZXgodGhpc1tpXSk7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCk7XG4gIHN0YXJ0ID0gK3N0YXJ0IHx8IDA7XG4gIGlmICh0eXBlb2YgZW5kID09ICd1bmRlZmluZWQnKSBlbmQgPSB0aGlzLmxlbmd0aDtcblxuICAvLyBGYXN0cGF0aCBlbXB0eSBzdHJpbmdzXG4gIGlmICgrZW5kID09IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXR1cm4gdGhpcy5oZXhTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldHVybiB0aGlzLnV0ZjhTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldHVybiB0aGlzLmFzY2lpU2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0dXJuIHRoaXMuYmluYXJ5U2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0dXJuIHRoaXMuYmFzZTY0U2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgICByZXR1cm4gdGhpcy51Y3MyU2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJyk7XG4gIH1cbn07XG5cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUuaGV4V3JpdGUgPSBmdW5jdGlvbihzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9ICtvZmZzZXQgfHwgMDtcbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0O1xuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSArbGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aDtcbiAgaWYgKHN0ckxlbiAlIDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpO1xuICB9XG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMjtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGJ5dGUgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpO1xuICAgIGlmIChpc05hTihieXRlKSkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKTtcbiAgICB0aGlzW29mZnNldCArIGldID0gYnl0ZTtcbiAgfVxuICBTbG93QnVmZmVyLl9jaGFyc1dyaXR0ZW4gPSBpICogMjtcbiAgcmV0dXJuIGk7XG59O1xuXG5cblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gU3VwcG9ydCBib3RoIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZylcbiAgLy8gYW5kIHRoZSBsZWdhY3kgKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIGlmICghaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGg7XG4gICAgICBsZW5ndGggPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2UgeyAgLy8gbGVnYWN5XG4gICAgdmFyIHN3YXAgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG9mZnNldDtcbiAgICBvZmZzZXQgPSBsZW5ndGg7XG4gICAgbGVuZ3RoID0gc3dhcDtcbiAgfVxuXG4gIG9mZnNldCA9ICtvZmZzZXQgfHwgMDtcbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0O1xuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSArbGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgICB9XG4gIH1cbiAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpO1xuXG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0dXJuIHRoaXMuaGV4V3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXR1cm4gdGhpcy51dGY4V3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBjYXNlICdhc2NpaSc6XG4gICAgICByZXR1cm4gdGhpcy5hc2NpaVdyaXRlKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpO1xuXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldHVybiB0aGlzLmJpbmFyeVdyaXRlKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpO1xuXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldHVybiB0aGlzLmJhc2U2NFdyaXRlKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpO1xuXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgICAgcmV0dXJuIHRoaXMudWNzMldyaXRlKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpO1xuICB9XG59O1xuXG5cbi8vIHNsaWNlKHN0YXJ0LCBlbmQpXG5TbG93QnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSBlbmQgPSB0aGlzLmxlbmd0aDtcblxuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ29vYicpO1xuICB9XG4gIGlmIChzdGFydCA+IGVuZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignb29iJyk7XG4gIH1cblxuICByZXR1cm4gbmV3IEJ1ZmZlcih0aGlzLCBlbmQgLSBzdGFydCwgK3N0YXJ0KTtcbn07XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbih0YXJnZXQsIHRhcmdldHN0YXJ0LCBzb3VyY2VzdGFydCwgc291cmNlZW5kKSB7XG4gIHZhciB0ZW1wID0gW107XG4gIGZvciAodmFyIGk9c291cmNlc3RhcnQ7IGk8c291cmNlZW5kOyBpKyspIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIHRoaXNbaV0gIT09ICd1bmRlZmluZWQnLCBcImNvcHlpbmcgdW5kZWZpbmVkIGJ1ZmZlciBieXRlcyFcIik7XG4gICAgdGVtcC5wdXNoKHRoaXNbaV0pO1xuICB9XG5cbiAgZm9yICh2YXIgaT10YXJnZXRzdGFydDsgaTx0YXJnZXRzdGFydCt0ZW1wLmxlbmd0aDsgaSsrKSB7XG4gICAgdGFyZ2V0W2ldID0gdGVtcFtpLXRhcmdldHN0YXJ0XTtcbiAgfVxufTtcblxuU2xvd0J1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uKHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignb29iJyk7XG4gIH1cbiAgaWYgKHN0YXJ0ID4gZW5kKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdvb2InKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgdGhpc1tpXSA9IHZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvZXJjZShsZW5ndGgpIHtcbiAgLy8gQ29lcmNlIGxlbmd0aCB0byBhIG51bWJlciAocG9zc2libHkgTmFOKSwgcm91bmQgdXBcbiAgLy8gaW4gY2FzZSBpdCdzIGZyYWN0aW9uYWwgKGUuZy4gMTIzLjQ1NikgdGhlbiBkbyBhXG4gIC8vIGRvdWJsZSBuZWdhdGUgdG8gY29lcmNlIGEgTmFOIHRvIDAuIEVhc3ksIHJpZ2h0P1xuICBsZW5ndGggPSB+fk1hdGguY2VpbCgrbGVuZ3RoKTtcbiAgcmV0dXJuIGxlbmd0aCA8IDAgPyAwIDogbGVuZ3RoO1xufVxuXG5cbi8vIEJ1ZmZlclxuXG5mdW5jdGlvbiBCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcsIG9mZnNldCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKHN1YmplY3QsIGVuY29kaW5nLCBvZmZzZXQpO1xuICB9XG5cbiAgdmFyIHR5cGU7XG5cbiAgLy8gQXJlIHdlIHNsaWNpbmc/XG4gIGlmICh0eXBlb2Ygb2Zmc2V0ID09PSAnbnVtYmVyJykge1xuICAgIHRoaXMubGVuZ3RoID0gY29lcmNlKGVuY29kaW5nKTtcbiAgICB0aGlzLnBhcmVudCA9IHN1YmplY3Q7XG4gICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gRmluZCB0aGUgbGVuZ3RoXG4gICAgc3dpdGNoICh0eXBlID0gdHlwZW9mIHN1YmplY3QpIHtcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIHRoaXMubGVuZ3RoID0gY29lcmNlKHN1YmplY3QpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgdGhpcy5sZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChzdWJqZWN0LCBlbmNvZGluZyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdvYmplY3QnOiAvLyBBc3N1bWUgb2JqZWN0IGlzIGFuIGFycmF5XG4gICAgICAgIHRoaXMubGVuZ3RoID0gY29lcmNlKHN1YmplY3QubGVuZ3RoKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgbmVlZHMgdG8gYmUgYSBudW1iZXIsICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2FycmF5IG9yIHN0cmluZy4nKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5sZW5ndGggPiBCdWZmZXIucG9vbFNpemUpIHtcbiAgICAgIC8vIEJpZyBidWZmZXIsIGp1c3QgYWxsb2Mgb25lLlxuICAgICAgdGhpcy5wYXJlbnQgPSBuZXcgU2xvd0J1ZmZlcih0aGlzLmxlbmd0aCk7XG4gICAgICB0aGlzLm9mZnNldCA9IDA7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU21hbGwgYnVmZmVyLlxuICAgICAgaWYgKCFwb29sIHx8IHBvb2wubGVuZ3RoIC0gcG9vbC51c2VkIDwgdGhpcy5sZW5ndGgpIGFsbG9jUG9vbCgpO1xuICAgICAgdGhpcy5wYXJlbnQgPSBwb29sO1xuICAgICAgdGhpcy5vZmZzZXQgPSBwb29sLnVzZWQ7XG4gICAgICBwb29sLnVzZWQgKz0gdGhpcy5sZW5ndGg7XG4gICAgfVxuXG4gICAgLy8gVHJlYXQgYXJyYXktaXNoIG9iamVjdHMgYXMgYSBieXRlIGFycmF5LlxuICAgIGlmIChpc0FycmF5SXNoKHN1YmplY3QpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHN1YmplY3QgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICAgICAgICB0aGlzLnBhcmVudFtpICsgdGhpcy5vZmZzZXRdID0gc3ViamVjdC5yZWFkVUludDgoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdGhpcy5wYXJlbnRbaSArIHRoaXMub2Zmc2V0XSA9IHN1YmplY3RbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFdlIGFyZSBhIHN0cmluZ1xuICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLndyaXRlKHN1YmplY3QsIDAsIGVuY29kaW5nKTtcbiAgICB9XG4gIH1cblxufVxuXG5mdW5jdGlvbiBpc0FycmF5SXNoKHN1YmplY3QpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoc3ViamVjdCkgfHwgQnVmZmVyLmlzQnVmZmVyKHN1YmplY3QpIHx8XG4gICAgICAgICBzdWJqZWN0ICYmIHR5cGVvZiBzdWJqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgdHlwZW9mIHN1YmplY3QubGVuZ3RoID09PSAnbnVtYmVyJztcbn1cblxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlcjtcbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyO1xuXG5CdWZmZXIucG9vbFNpemUgPSA4ICogMTAyNDtcbnZhciBwb29sO1xuXG5mdW5jdGlvbiBhbGxvY1Bvb2woKSB7XG4gIHBvb2wgPSBuZXcgU2xvd0J1ZmZlcihCdWZmZXIucG9vbFNpemUpO1xuICBwb29sLnVzZWQgPSAwO1xufVxuXG5cbi8vIFN0YXRpYyBtZXRob2RzXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlcihiKSB7XG4gIHJldHVybiBiIGluc3RhbmNlb2YgQnVmZmVyIHx8IGIgaW5zdGFuY2VvZiBTbG93QnVmZmVyO1xufTtcblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIChsaXN0LCB0b3RhbExlbmd0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVc2FnZTogQnVmZmVyLmNvbmNhdChsaXN0LCBbdG90YWxMZW5ndGhdKVxcbiBcXFxuICAgICAgbGlzdCBzaG91bGQgYmUgYW4gQXJyYXkuXCIpO1xuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoMCk7XG4gIH0gZWxzZSBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gbGlzdFswXTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdG90YWxMZW5ndGggIT09ICdudW1iZXInKSB7XG4gICAgdG90YWxMZW5ndGggPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGJ1ZiA9IGxpc3RbaV07XG4gICAgICB0b3RhbExlbmd0aCArPSBidWYubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBuZXcgQnVmZmVyKHRvdGFsTGVuZ3RoKTtcbiAgdmFyIHBvcyA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBidWYgPSBsaXN0W2ldO1xuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKTtcbiAgICBwb3MgKz0gYnVmLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gYnVmZmVyO1xufTtcblxuLy8gSW5zcGVjdFxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgdmFyIG91dCA9IFtdLFxuICAgICAgbGVuID0gdGhpcy5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG91dFtpXSA9IHRvSGV4KHRoaXMucGFyZW50W2kgKyB0aGlzLm9mZnNldF0pO1xuICAgIGlmIChpID09IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMpIHtcbiAgICAgIG91dFtpICsgMV0gPSAnLi4uJztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnPEJ1ZmZlciAnICsgb3V0LmpvaW4oJyAnKSArICc+Jztcbn07XG5cblxuQnVmZmVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQoaSkge1xuICBpZiAoaSA8IDAgfHwgaSA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdvb2InKTtcbiAgcmV0dXJuIHRoaXMucGFyZW50W3RoaXMub2Zmc2V0ICsgaV07XG59O1xuXG5cbkJ1ZmZlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0KGksIHYpIHtcbiAgaWYgKGkgPCAwIHx8IGkgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignb29iJyk7XG4gIHJldHVybiB0aGlzLnBhcmVudFt0aGlzLm9mZnNldCArIGldID0gdjtcbn07XG5cblxuLy8gd3JpdGUoc3RyaW5nLCBvZmZzZXQgPSAwLCBsZW5ndGggPSBidWZmZXIubGVuZ3RoLW9mZnNldCwgZW5jb2RpbmcgPSAndXRmOCcpXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gU3VwcG9ydCBib3RoIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZylcbiAgLy8gYW5kIHRoZSBsZWdhY3kgKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIGlmICghaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGg7XG4gICAgICBsZW5ndGggPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2UgeyAgLy8gbGVnYWN5XG4gICAgdmFyIHN3YXAgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG9mZnNldDtcbiAgICBvZmZzZXQgPSBsZW5ndGg7XG4gICAgbGVuZ3RoID0gc3dhcDtcbiAgfVxuXG4gIG9mZnNldCA9ICtvZmZzZXQgfHwgMDtcbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0O1xuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSArbGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgICB9XG4gIH1cbiAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpO1xuXG4gIHZhciByZXQ7XG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gdGhpcy5wYXJlbnQuaGV4V3JpdGUoc3RyaW5nLCB0aGlzLm9mZnNldCArIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0ID0gdGhpcy5wYXJlbnQudXRmOFdyaXRlKHN0cmluZywgdGhpcy5vZmZzZXQgKyBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldCA9IHRoaXMucGFyZW50LmFzY2lpV3JpdGUoc3RyaW5nLCB0aGlzLm9mZnNldCArIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldCA9IHRoaXMucGFyZW50LmJpbmFyeVdyaXRlKHN0cmluZywgdGhpcy5vZmZzZXQgKyBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgcmV0ID0gdGhpcy5wYXJlbnQuYmFzZTY0V3JpdGUoc3RyaW5nLCB0aGlzLm9mZnNldCArIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgICAgcmV0ID0gdGhpcy5wYXJlbnQudWNzMldyaXRlKHN0cmluZywgdGhpcy5vZmZzZXQgKyBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKTtcbiAgfVxuXG4gIEJ1ZmZlci5fY2hhcnNXcml0dGVuID0gU2xvd0J1ZmZlci5fY2hhcnNXcml0dGVuO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5cbi8vIHRvU3RyaW5nKGVuY29kaW5nLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCk7XG5cbiAgaWYgKHR5cGVvZiBzdGFydCA9PSAndW5kZWZpbmVkJyB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDA7XG4gIH0gZWxzZSBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHN0YXJ0ID0gdGhpcy5sZW5ndGg7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuZCA9PSAndW5kZWZpbmVkJyB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICB9IGVsc2UgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgPSAwO1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCArIHRoaXMub2Zmc2V0O1xuICBlbmQgPSBlbmQgKyB0aGlzLm9mZnNldDtcblxuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC5oZXhTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC51dGY4U2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICdhc2NpaSc6XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQuYXNjaWlTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQuYmluYXJ5U2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmJhc2U2NFNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LnVjczJTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKTtcbiAgfVxufTtcblxuXG4vLyBieXRlTGVuZ3RoXG5CdWZmZXIuYnl0ZUxlbmd0aCA9IFNsb3dCdWZmZXIuYnl0ZUxlbmd0aDtcblxuXG4vLyBmaWxsKHZhbHVlLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwodmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgdmFsdWUgfHwgKHZhbHVlID0gMCk7XG4gIHN0YXJ0IHx8IChzdGFydCA9IDApO1xuICBlbmQgfHwgKGVuZCA9IHRoaXMubGVuZ3RoKTtcblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHZhbHVlID0gdmFsdWUuY2hhckNvZGVBdCgwKTtcbiAgfVxuICBpZiAoISh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB8fCBpc05hTih2YWx1ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZhbHVlIGlzIG5vdCBhIG51bWJlcicpO1xuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSB0aHJvdyBuZXcgRXJyb3IoJ2VuZCA8IHN0YXJ0Jyk7XG5cbiAgLy8gRmlsbCAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMDtcbiAgaWYgKHRoaXMubGVuZ3RoID09IDApIHJldHVybiAwO1xuXG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0YXJ0IG91dCBvZiBib3VuZHMnKTtcbiAgfVxuXG4gIGlmIChlbmQgPCAwIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdlbmQgb3V0IG9mIGJvdW5kcycpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMucGFyZW50LmZpbGwodmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ICsgdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCArIHRoaXMub2Zmc2V0KTtcbn07XG5cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24odGFyZ2V0LCB0YXJnZXRfc3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXM7XG4gIHN0YXJ0IHx8IChzdGFydCA9IDApO1xuICBlbmQgfHwgKGVuZCA9IHRoaXMubGVuZ3RoKTtcbiAgdGFyZ2V0X3N0YXJ0IHx8ICh0YXJnZXRfc3RhcnQgPSAwKTtcblxuICBpZiAoZW5kIDwgc3RhcnQpIHRocm93IG5ldyBFcnJvcignc291cmNlRW5kIDwgc291cmNlU3RhcnQnKTtcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwO1xuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PSAwIHx8IHNvdXJjZS5sZW5ndGggPT0gMCkgcmV0dXJuIDA7XG5cbiAgaWYgKHRhcmdldF9zdGFydCA8IDAgfHwgdGFyZ2V0X3N0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKTtcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gc291cmNlLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpO1xuICB9XG5cbiAgaWYgKGVuZCA8IDAgfHwgZW5kID4gc291cmNlLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKTtcbiAgfVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICB9XG5cbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgKyBzdGFydDtcbiAgfVxuXG4gIHJldHVybiB0aGlzLnBhcmVudC5jb3B5KHRhcmdldC5wYXJlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldF9zdGFydCArIHRhcmdldC5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ICsgdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCArIHRoaXMub2Zmc2V0KTtcbn07XG5cblxuLy8gc2xpY2Uoc3RhcnQsIGVuZClcbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkgZW5kID0gdGhpcy5sZW5ndGg7XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdvb2InKTtcbiAgaWYgKHN0YXJ0ID4gZW5kKSB0aHJvdyBuZXcgRXJyb3IoJ29vYicpO1xuXG4gIHJldHVybiBuZXcgQnVmZmVyKHRoaXMucGFyZW50LCBlbmQgLSBzdGFydCwgK3N0YXJ0ICsgdGhpcy5vZmZzZXQpO1xufTtcblxuXG4vLyBMZWdhY3kgbWV0aG9kcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5cbkJ1ZmZlci5wcm90b3R5cGUudXRmOFNsaWNlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gdGhpcy50b1N0cmluZygndXRmOCcsIHN0YXJ0LCBlbmQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5iaW5hcnlTbGljZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIHRoaXMudG9TdHJpbmcoJ2JpbmFyeScsIHN0YXJ0LCBlbmQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5hc2NpaVNsaWNlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gdGhpcy50b1N0cmluZygnYXNjaWknLCBzdGFydCwgZW5kKTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUudXRmOFdyaXRlID0gZnVuY3Rpb24oc3RyaW5nLCBvZmZzZXQpIHtcbiAgcmV0dXJuIHRoaXMud3JpdGUoc3RyaW5nLCBvZmZzZXQsICd1dGY4Jyk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmJpbmFyeVdyaXRlID0gZnVuY3Rpb24oc3RyaW5nLCBvZmZzZXQpIHtcbiAgcmV0dXJuIHRoaXMud3JpdGUoc3RyaW5nLCBvZmZzZXQsICdiaW5hcnknKTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUuYXNjaWlXcml0ZSA9IGZ1bmN0aW9uKHN0cmluZywgb2Zmc2V0KSB7XG4gIHJldHVybiB0aGlzLndyaXRlKHN0cmluZywgb2Zmc2V0LCAnYXNjaWknKTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YXIgYnVmZmVyID0gdGhpcztcblxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0IDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICBpZiAob2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHJldHVybjtcblxuICByZXR1cm4gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRVSW50MTYoYnVmZmVyLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YXIgdmFsID0gMDtcblxuXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkgcmV0dXJuIDA7XG5cbiAgaWYgKGlzQmlnRW5kaWFuKSB7XG4gICAgdmFsID0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XSA8PCA4O1xuICAgIGlmIChvZmZzZXQgKyAxIDwgYnVmZmVyLmxlbmd0aCkge1xuICAgICAgdmFsIHw9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDFdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YWwgPSBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdO1xuICAgIGlmIChvZmZzZXQgKyAxIDwgYnVmZmVyLmxlbmd0aCkge1xuICAgICAgdmFsIHw9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDFdIDw8IDg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkVUludDE2KHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZFVJbnQxNih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRVSW50MzIoYnVmZmVyLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YXIgdmFsID0gMDtcblxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICBpZiAob2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHJldHVybiAwO1xuXG4gIGlmIChpc0JpZ0VuZGlhbikge1xuICAgIGlmIChvZmZzZXQgKyAxIDwgYnVmZmVyLmxlbmd0aClcbiAgICAgIHZhbCA9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDFdIDw8IDE2O1xuICAgIGlmIChvZmZzZXQgKyAyIDwgYnVmZmVyLmxlbmd0aClcbiAgICAgIHZhbCB8PSBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyAyXSA8PCA4O1xuICAgIGlmIChvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aClcbiAgICAgIHZhbCB8PSBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyAzXTtcbiAgICB2YWwgPSB2YWwgKyAoYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XSA8PCAyNCA+Pj4gMCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKG9mZnNldCArIDIgPCBidWZmZXIubGVuZ3RoKVxuICAgICAgdmFsID0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMl0gPDwgMTY7XG4gICAgaWYgKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoKVxuICAgICAgdmFsIHw9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDFdIDw8IDg7XG4gICAgdmFsIHw9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF07XG4gICAgaWYgKG9mZnNldCArIDMgPCBidWZmZXIubGVuZ3RoKVxuICAgICAgdmFsID0gdmFsICsgKGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDNdIDw8IDI0ID4+PiAwKTtcbiAgfVxuXG4gIHJldHVybiB2YWw7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZFVJbnQzMih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRVSW50MzIodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5cbi8qXG4gKiBTaWduZWQgaW50ZWdlciB0eXBlcywgeWF5IHRlYW0hIEEgcmVtaW5kZXIgb24gaG93IHR3bydzIGNvbXBsZW1lbnQgYWN0dWFsbHlcbiAqIHdvcmtzLiBUaGUgZmlyc3QgYml0IGlzIHRoZSBzaWduZWQgYml0LCBpLmUuIHRlbGxzIHVzIHdoZXRoZXIgb3Igbm90IHRoZVxuICogbnVtYmVyIHNob3VsZCBiZSBwb3NpdGl2ZSBvciBuZWdhdGl2ZS4gSWYgdGhlIHR3bydzIGNvbXBsZW1lbnQgdmFsdWUgaXNcbiAqIHBvc2l0aXZlLCB0aGVuIHdlJ3JlIGRvbmUsIGFzIGl0J3MgZXF1aXZhbGVudCB0byB0aGUgdW5zaWduZWQgcmVwcmVzZW50YXRpb24uXG4gKlxuICogTm93IGlmIHRoZSBudW1iZXIgaXMgcG9zaXRpdmUsIHlvdSdyZSBwcmV0dHkgbXVjaCBkb25lLCB5b3UgY2FuIGp1c3QgbGV2ZXJhZ2VcbiAqIHRoZSB1bnNpZ25lZCB0cmFuc2xhdGlvbnMgYW5kIHJldHVybiB0aG9zZS4gVW5mb3J0dW5hdGVseSwgbmVnYXRpdmUgbnVtYmVyc1xuICogYXJlbid0IHF1aXRlIHRoYXQgc3RyYWlnaHRmb3J3YXJkLlxuICpcbiAqIEF0IGZpcnN0IGdsYW5jZSwgb25lIG1pZ2h0IGJlIGluY2xpbmVkIHRvIHVzZSB0aGUgdHJhZGl0aW9uYWwgZm9ybXVsYSB0b1xuICogdHJhbnNsYXRlIGJpbmFyeSBudW1iZXJzIGJldHdlZW4gdGhlIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSB2YWx1ZXMgaW4gdHdvJ3NcbiAqIGNvbXBsZW1lbnQuIChUaG91Z2ggaXQgZG9lc24ndCBxdWl0ZSB3b3JrIGZvciB0aGUgbW9zdCBuZWdhdGl2ZSB2YWx1ZSlcbiAqIE1haW5seTpcbiAqICAtIGludmVydCBhbGwgdGhlIGJpdHNcbiAqICAtIGFkZCBvbmUgdG8gdGhlIHJlc3VsdFxuICpcbiAqIE9mIGNvdXJzZSwgdGhpcyBkb2Vzbid0IHF1aXRlIHdvcmsgaW4gSmF2YXNjcmlwdC4gVGFrZSBmb3IgZXhhbXBsZSB0aGUgdmFsdWVcbiAqIG9mIC0xMjguIFRoaXMgY291bGQgYmUgcmVwcmVzZW50ZWQgaW4gMTYgYml0cyAoYmlnLWVuZGlhbikgYXMgMHhmZjgwLiBCdXQgb2ZcbiAqIGNvdXJzZSwgSmF2YXNjcmlwdCB3aWxsIGRvIHRoZSBmb2xsb3dpbmc6XG4gKlxuICogPiB+MHhmZjgwXG4gKiAtNjU0MDlcbiAqXG4gKiBXaG9oIHRoZXJlLCBKYXZhc2NyaXB0LCB0aGF0J3Mgbm90IHF1aXRlIHJpZ2h0LiBCdXQgd2FpdCwgYWNjb3JkaW5nIHRvXG4gKiBKYXZhc2NyaXB0IHRoYXQncyBwZXJmZWN0bHkgY29ycmVjdC4gV2hlbiBKYXZhc2NyaXB0IGVuZHMgdXAgc2VlaW5nIHRoZVxuICogY29uc3RhbnQgMHhmZjgwLCBpdCBoYXMgbm8gbm90aW9uIHRoYXQgaXQgaXMgYWN0dWFsbHkgYSBzaWduZWQgbnVtYmVyLiBJdFxuICogYXNzdW1lcyB0aGF0IHdlJ3ZlIGlucHV0IHRoZSB1bnNpZ25lZCB2YWx1ZSAweGZmODAuIFRodXMsIHdoZW4gaXQgZG9lcyB0aGVcbiAqIGJpbmFyeSBuZWdhdGlvbiwgaXQgY2FzdHMgaXQgaW50byBhIHNpZ25lZCB2YWx1ZSwgKHBvc2l0aXZlIDB4ZmY4MCkuIFRoZW5cbiAqIHdoZW4geW91IHBlcmZvcm0gYmluYXJ5IG5lZ2F0aW9uIG9uIHRoYXQsIGl0IHR1cm5zIGl0IGludG8gYSBuZWdhdGl2ZSBudW1iZXIuXG4gKlxuICogSW5zdGVhZCwgd2UncmUgZ29pbmcgdG8gaGF2ZSB0byB1c2UgdGhlIGZvbGxvd2luZyBnZW5lcmFsIGZvcm11bGEsIHRoYXQgd29ya3NcbiAqIGluIGEgcmF0aGVyIEphdmFzY3JpcHQgZnJpZW5kbHkgd2F5LiBJJ20gZ2xhZCB3ZSBkb24ndCBzdXBwb3J0IHRoaXMga2luZCBvZlxuICogd2VpcmQgbnVtYmVyaW5nIHNjaGVtZSBpbiB0aGUga2VybmVsLlxuICpcbiAqIChCSVQtTUFYIC0gKHVuc2lnbmVkKXZhbCArIDEpICogLTFcbiAqXG4gKiBUaGUgYXN0dXRlIG9ic2VydmVyLCBtYXkgdGhpbmsgdGhhdCB0aGlzIGRvZXNuJ3QgbWFrZSBzZW5zZSBmb3IgOC1iaXQgbnVtYmVyc1xuICogKHJlYWxseSBpdCBpc24ndCBuZWNlc3NhcnkgZm9yIHRoZW0pLiBIb3dldmVyLCB3aGVuIHlvdSBnZXQgMTYtYml0IG51bWJlcnMsXG4gKiB5b3UgZG8uIExldCdzIGdvIGJhY2sgdG8gb3VyIHByaW9yIGV4YW1wbGUgYW5kIHNlZSBob3cgdGhpcyB3aWxsIGxvb2s6XG4gKlxuICogKDB4ZmZmZiAtIDB4ZmY4MCArIDEpICogLTFcbiAqICgweDAwN2YgKyAxKSAqIC0xXG4gKiAoMHgwMDgwKSAqIC0xXG4gKi9cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhciBidWZmZXIgPSB0aGlzO1xuICB2YXIgbmVnO1xuXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkgcmV0dXJuO1xuXG4gIG5lZyA9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF0gJiAweDgwO1xuICBpZiAoIW5lZykge1xuICAgIHJldHVybiAoYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XSk7XG4gIH1cblxuICByZXR1cm4gKCgweGZmIC0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XSArIDEpICogLTEpO1xufTtcblxuZnVuY3Rpb24gcmVhZEludDE2KGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFyIG5lZywgdmFsO1xuXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcbiAgfVxuXG4gIHZhbCA9IHJlYWRVSW50MTYoYnVmZmVyLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCk7XG4gIG5lZyA9IHZhbCAmIDB4ODAwMDtcbiAgaWYgKCFuZWcpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgcmV0dXJuICgweGZmZmYgLSB2YWwgKyAxKSAqIC0xO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZEludDE2KHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkSW50MTYodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5mdW5jdGlvbiByZWFkSW50MzIoYnVmZmVyLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YXIgbmVnLCB2YWw7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMyA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgdmFsID0gcmVhZFVJbnQzMihidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KTtcbiAgbmVnID0gdmFsICYgMHg4MDAwMDAwMDtcbiAgaWYgKCFuZWcpIHtcbiAgICByZXR1cm4gKHZhbCk7XG4gIH1cblxuICByZXR1cm4gKDB4ZmZmZmZmZmYgLSB2YWwgKyAxKSAqIC0xO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZEludDMyKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkSW50MzIodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5mdW5jdGlvbiByZWFkRmxvYXQoYnVmZmVyLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMyA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgcmV0dXJuIHJlcXVpcmUoJy4vYnVmZmVyX2llZWU3NTQnKS5yZWFkSUVFRTc1NChidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sXG4gICAgICAyMywgNCk7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkRmxvYXQodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRGbG9hdCh0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHJlYWREb3VibGUoYnVmZmVyLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgNyA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgcmV0dXJuIHJlcXVpcmUoJy4vYnVmZmVyX2llZWU3NTQnKS5yZWFkSUVFRTc1NChidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sXG4gICAgICA1MiwgOCk7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZERvdWJsZSh0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWREb3VibGUodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5cbi8qXG4gKiBXZSBoYXZlIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSB2YWx1ZSBpcyBhIHZhbGlkIGludGVnZXIuIFRoaXMgbWVhbnMgdGhhdCBpdCBpc1xuICogbm9uLW5lZ2F0aXZlLiBJdCBoYXMgbm8gZnJhY3Rpb25hbCBjb21wb25lbnQgYW5kIHRoYXQgaXQgZG9lcyBub3QgZXhjZWVkIHRoZVxuICogbWF4aW11bSBhbGxvd2VkIHZhbHVlLlxuICpcbiAqICAgICAgdmFsdWUgICAgICAgICAgIFRoZSBudW1iZXIgdG8gY2hlY2sgZm9yIHZhbGlkaXR5XG4gKlxuICogICAgICBtYXggICAgICAgICAgICAgVGhlIG1heGltdW0gdmFsdWVcbiAqL1xuZnVuY3Rpb24gdmVyaWZ1aW50KHZhbHVlLCBtYXgpIHtcbiAgYXNzZXJ0Lm9rKHR5cGVvZiAodmFsdWUpID09ICdudW1iZXInLFxuICAgICAgJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKTtcblxuICBhc3NlcnQub2sodmFsdWUgPj0gMCxcbiAgICAgICdzcGVjaWZpZWQgYSBuZWdhdGl2ZSB2YWx1ZSBmb3Igd3JpdGluZyBhbiB1bnNpZ25lZCB2YWx1ZScpO1xuXG4gIGFzc2VydC5vayh2YWx1ZSA8PSBtYXgsICd2YWx1ZSBpcyBsYXJnZXIgdGhhbiBtYXhpbXVtIHZhbHVlIGZvciB0eXBlJyk7XG5cbiAgYXNzZXJ0Lm9rKE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZSwgJ3ZhbHVlIGhhcyBhIGZyYWN0aW9uYWwgY29tcG9uZW50Jyk7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhciBidWZmZXIgPSB0aGlzO1xuXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3NpbmcgdmFsdWUnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICd0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcblxuICAgIHZlcmlmdWludCh2YWx1ZSwgMHhmZik7XG4gIH1cblxuICBpZiAob2Zmc2V0IDwgYnVmZmVyLmxlbmd0aCkge1xuICAgIGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF0gPSB2YWx1ZTtcbiAgfVxufTtcblxuZnVuY3Rpb24gd3JpdGVVSW50MTYoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAxIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmZmYpO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBNYXRoLm1pbihidWZmZXIubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSsrKSB7XG4gICAgYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgaV0gPVxuICAgICAgICAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChpc0JpZ0VuZGlhbiA/IDEgLSBpIDogaSkpKSkgPj4+XG4gICAgICAgICAgICAoaXNCaWdFbmRpYW4gPyAxIC0gaSA6IGkpICogODtcbiAgfVxuXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZVVJbnQzMihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDMgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmZmZmZmZmYpO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBNYXRoLm1pbihidWZmZXIubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSsrKSB7XG4gICAgYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgaV0gPVxuICAgICAgICAodmFsdWUgPj4+IChpc0JpZ0VuZGlhbiA/IDMgLSBpIDogaSkgKiA4KSAmIDB4ZmY7XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cblxuLypcbiAqIFdlIG5vdyBtb3ZlIG9udG8gb3VyIGZyaWVuZHMgaW4gdGhlIHNpZ25lZCBudW1iZXIgY2F0ZWdvcnkuIFVubGlrZSB1bnNpZ25lZFxuICogbnVtYmVycywgd2UncmUgZ29pbmcgdG8gaGF2ZSB0byB3b3JyeSBhIGJpdCBtb3JlIGFib3V0IGhvdyB3ZSBwdXQgdmFsdWVzIGludG9cbiAqIGFycmF5cy4gU2luY2Ugd2UgYXJlIG9ubHkgd29ycnlpbmcgYWJvdXQgc2lnbmVkIDMyLWJpdCB2YWx1ZXMsIHdlJ3JlIGluXG4gKiBzbGlnaHRseSBiZXR0ZXIgc2hhcGUuIFVuZm9ydHVuYXRlbHksIHdlIHJlYWxseSBjYW4ndCBkbyBvdXIgZmF2b3JpdGUgYmluYXJ5XG4gKiAmIGluIHRoaXMgc3lzdGVtLiBJdCByZWFsbHkgc2VlbXMgdG8gZG8gdGhlIHdyb25nIHRoaW5nLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiA+IC0zMiAmIDB4ZmZcbiAqIDIyNFxuICpcbiAqIFdoYXQncyBoYXBwZW5pbmcgYWJvdmUgaXMgcmVhbGx5OiAweGUwICYgMHhmZiA9IDB4ZTAuIEhvd2V2ZXIsIHRoZSByZXN1bHRzIG9mXG4gKiB0aGlzIGFyZW4ndCB0cmVhdGVkIGFzIGEgc2lnbmVkIG51bWJlci4gVWx0aW1hdGVseSBhIGJhZCB0aGluZy5cbiAqXG4gKiBXaGF0IHdlJ3JlIGdvaW5nIHRvIHdhbnQgdG8gZG8gaXMgYmFzaWNhbGx5IGNyZWF0ZSB0aGUgdW5zaWduZWQgZXF1aXZhbGVudCBvZlxuICogb3VyIHJlcHJlc2VudGF0aW9uIGFuZCBwYXNzIHRoYXQgb2ZmIHRvIHRoZSB3dWludCogZnVuY3Rpb25zLiBUbyBkbyB0aGF0XG4gKiB3ZSdyZSBnb2luZyB0byBkbyB0aGUgZm9sbG93aW5nOlxuICpcbiAqICAtIGlmIHRoZSB2YWx1ZSBpcyBwb3NpdGl2ZVxuICogICAgICB3ZSBjYW4gcGFzcyBpdCBkaXJlY3RseSBvZmYgdG8gdGhlIGVxdWl2YWxlbnQgd3VpbnRcbiAqICAtIGlmIHRoZSB2YWx1ZSBpcyBuZWdhdGl2ZVxuICogICAgICB3ZSBkbyB0aGUgZm9sbG93aW5nIGNvbXB1dGF0aW9uOlxuICogICAgICAgICBtYiArIHZhbCArIDEsIHdoZXJlXG4gKiAgICAgICAgIG1iICAgaXMgdGhlIG1heGltdW0gdW5zaWduZWQgdmFsdWUgaW4gdGhhdCBieXRlIHNpemVcbiAqICAgICAgICAgdmFsICBpcyB0aGUgSmF2YXNjcmlwdCBuZWdhdGl2ZSBpbnRlZ2VyXG4gKlxuICpcbiAqIEFzIGEgY29uY3JldGUgdmFsdWUsIHRha2UgLTEyOC4gSW4gc2lnbmVkIDE2IGJpdHMgdGhpcyB3b3VsZCBiZSAweGZmODAuIElmXG4gKiB5b3UgZG8gb3V0IHRoZSBjb21wdXRhdGlvbnM6XG4gKlxuICogMHhmZmZmIC0gMTI4ICsgMVxuICogMHhmZmZmIC0gMTI3XG4gKiAweGZmODBcbiAqXG4gKiBZb3UgY2FuIHRoZW4gZW5jb2RlIHRoaXMgdmFsdWUgYXMgdGhlIHNpZ25lZCB2ZXJzaW9uLiBUaGlzIGlzIHJlYWxseSByYXRoZXJcbiAqIGhhY2t5LCBidXQgaXQgc2hvdWxkIHdvcmsgYW5kIGdldCB0aGUgam9iIGRvbmUgd2hpY2ggaXMgb3VyIGdvYWwgaGVyZS5cbiAqL1xuXG4vKlxuICogQSBzZXJpZXMgb2YgY2hlY2tzIHRvIG1ha2Ugc3VyZSB3ZSBhY3R1YWxseSBoYXZlIGEgc2lnbmVkIDMyLWJpdCBudW1iZXJcbiAqL1xuZnVuY3Rpb24gdmVyaWZzaW50KHZhbHVlLCBtYXgsIG1pbikge1xuICBhc3NlcnQub2sodHlwZW9mICh2YWx1ZSkgPT0gJ251bWJlcicsXG4gICAgICAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpO1xuXG4gIGFzc2VydC5vayh2YWx1ZSA8PSBtYXgsICd2YWx1ZSBsYXJnZXIgdGhhbiBtYXhpbXVtIGFsbG93ZWQgdmFsdWUnKTtcblxuICBhc3NlcnQub2sodmFsdWUgPj0gbWluLCAndmFsdWUgc21hbGxlciB0aGFuIG1pbmltdW0gYWxsb3dlZCB2YWx1ZScpO1xuXG4gIGFzc2VydC5vayhNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWUsICd2YWx1ZSBoYXMgYSBmcmFjdGlvbmFsIGNvbXBvbmVudCcpO1xufVxuXG5mdW5jdGlvbiB2ZXJpZklFRUU3NTQodmFsdWUsIG1heCwgbWluKSB7XG4gIGFzc2VydC5vayh0eXBlb2YgKHZhbHVlKSA9PSAnbnVtYmVyJyxcbiAgICAgICdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJyk7XG5cbiAgYXNzZXJ0Lm9rKHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGxhcmdlciB0aGFuIG1heGltdW0gYWxsb3dlZCB2YWx1ZScpO1xuXG4gIGFzc2VydC5vayh2YWx1ZSA+PSBtaW4sICd2YWx1ZSBzbWFsbGVyIHRoYW4gbWluaW11bSBhbGxvd2VkIHZhbHVlJyk7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFyIGJ1ZmZlciA9IHRoaXM7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0IDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmLCAtMHg4MCk7XG4gIH1cblxuICBpZiAodmFsdWUgPj0gMCkge1xuICAgIGJ1ZmZlci53cml0ZVVJbnQ4KHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KTtcbiAgfSBlbHNlIHtcbiAgICBidWZmZXIud3JpdGVVSW50OCgweGZmICsgdmFsdWUgKyAxLCBvZmZzZXQsIG5vQXNzZXJ0KTtcbiAgfVxufTtcblxuZnVuY3Rpb24gd3JpdGVJbnQxNihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2ZmZiwgLTB4ODAwMCk7XG4gIH1cblxuICBpZiAodmFsdWUgPj0gMCkge1xuICAgIHdyaXRlVUludDE2KGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KTtcbiAgfSBlbHNlIHtcbiAgICB3cml0ZVVJbnQxNihidWZmZXIsIDB4ZmZmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpO1xuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlSW50MzIoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMCk7XG4gIH1cblxuICBpZiAodmFsdWUgPj0gMCkge1xuICAgIHdyaXRlVUludDMyKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KTtcbiAgfSBlbHNlIHtcbiAgICB3cml0ZVVJbnQzMihidWZmZXIsIDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDEsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KTtcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUZsb2F0KGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3NpbmcgdmFsdWUnKTtcblxuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMyA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcblxuICAgIHZlcmlmSUVFRTc1NCh2YWx1ZSwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpO1xuICB9XG5cbiAgcmVxdWlyZSgnLi9idWZmZXJfaWVlZTc1NCcpLndyaXRlSUVFRTc1NChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLFxuICAgICAgMjMsIDQpO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZURvdWJsZShidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDcgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZklFRUU3NTQodmFsdWUsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpO1xuICB9XG5cbiAgcmVxdWlyZSgnLi9idWZmZXJfaWVlZTc1NCcpLndyaXRlSUVFRTc1NChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLFxuICAgICAgNTIsIDgpO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDg7XG5TbG93QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50ODtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IEJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4O1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4O1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkU7XG5cbn0se1wiYXNzZXJ0XCI6MSxcIi4vYnVmZmVyX2llZWU3NTRcIjo1LFwiYmFzZTY0LWpzXCI6N31dLDc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgbG9va3VwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuXG5cdGZ1bmN0aW9uIGI2NFRvQnl0ZUFycmF5KGI2NCkge1xuXHRcdHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyO1xuXHRcblx0XHRpZiAoYjY0Lmxlbmd0aCAlIDQgPiAwKSB7XG5cdFx0XHR0aHJvdyAnSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCc7XG5cdFx0fVxuXG5cdFx0Ly8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcblx0XHQvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG5cdFx0Ly8gcmVwcmVzZW50IG9uZSBieXRlXG5cdFx0Ly8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG5cdFx0Ly8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuXHRcdHBsYWNlSG9sZGVycyA9IGI2NC5pbmRleE9mKCc9Jyk7XG5cdFx0cGxhY2VIb2xkZXJzID0gcGxhY2VIb2xkZXJzID4gMCA/IGI2NC5sZW5ndGggLSBwbGFjZUhvbGRlcnMgOiAwO1xuXG5cdFx0Ly8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5cdFx0YXJyID0gW107Ly9uZXcgVWludDhBcnJheShiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpO1xuXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuXHRcdGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gYjY0Lmxlbmd0aCAtIDQgOiBiNjQubGVuZ3RoO1xuXG5cdFx0Zm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuXHRcdFx0dG1wID0gKGxvb2t1cC5pbmRleE9mKGI2NFtpXSkgPDwgMTgpIHwgKGxvb2t1cC5pbmRleE9mKGI2NFtpICsgMV0pIDw8IDEyKSB8IChsb29rdXAuaW5kZXhPZihiNjRbaSArIDJdKSA8PCA2KSB8IGxvb2t1cC5pbmRleE9mKGI2NFtpICsgM10pO1xuXHRcdFx0YXJyLnB1c2goKHRtcCAmIDB4RkYwMDAwKSA+PiAxNik7XG5cdFx0XHRhcnIucHVzaCgodG1wICYgMHhGRjAwKSA+PiA4KTtcblx0XHRcdGFyci5wdXNoKHRtcCAmIDB4RkYpO1xuXHRcdH1cblxuXHRcdGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcblx0XHRcdHRtcCA9IChsb29rdXAuaW5kZXhPZihiNjRbaV0pIDw8IDIpIHwgKGxvb2t1cC5pbmRleE9mKGI2NFtpICsgMV0pID4+IDQpO1xuXHRcdFx0YXJyLnB1c2godG1wICYgMHhGRik7XG5cdFx0fSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcblx0XHRcdHRtcCA9IChsb29rdXAuaW5kZXhPZihiNjRbaV0pIDw8IDEwKSB8IChsb29rdXAuaW5kZXhPZihiNjRbaSArIDFdKSA8PCA0KSB8IChsb29rdXAuaW5kZXhPZihiNjRbaSArIDJdKSA+PiAyKTtcblx0XHRcdGFyci5wdXNoKCh0bXAgPj4gOCkgJiAweEZGKTtcblx0XHRcdGFyci5wdXNoKHRtcCAmIDB4RkYpO1xuXHRcdH1cblxuXHRcdHJldHVybiBhcnI7XG5cdH1cblxuXHRmdW5jdGlvbiB1aW50OFRvQmFzZTY0KHVpbnQ4KSB7XG5cdFx0dmFyIGksXG5cdFx0XHRleHRyYUJ5dGVzID0gdWludDgubGVuZ3RoICUgMywgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcblx0XHRcdG91dHB1dCA9IFwiXCIsXG5cdFx0XHR0ZW1wLCBsZW5ndGg7XG5cblx0XHRmdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuXHRcdFx0cmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICsgbG9va3VwW251bSAmIDB4M0ZdO1xuXHRcdH07XG5cblx0XHQvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG5cdFx0Zm9yIChpID0gMCwgbGVuZ3RoID0gdWludDgubGVuZ3RoIC0gZXh0cmFCeXRlczsgaSA8IGxlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHR0ZW1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKTtcblx0XHRcdG91dHB1dCArPSB0cmlwbGV0VG9CYXNlNjQodGVtcCk7XG5cdFx0fVxuXG5cdFx0Ly8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuXHRcdHN3aXRjaCAoZXh0cmFCeXRlcykge1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHR0ZW1wID0gdWludDhbdWludDgubGVuZ3RoIC0gMV07XG5cdFx0XHRcdG91dHB1dCArPSBsb29rdXBbdGVtcCA+PiAyXTtcblx0XHRcdFx0b3V0cHV0ICs9IGxvb2t1cFsodGVtcCA8PCA0KSAmIDB4M0ZdO1xuXHRcdFx0XHRvdXRwdXQgKz0gJz09Jztcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIDI6XG5cdFx0XHRcdHRlbXAgPSAodWludDhbdWludDgubGVuZ3RoIC0gMl0gPDwgOCkgKyAodWludDhbdWludDgubGVuZ3RoIC0gMV0pO1xuXHRcdFx0XHRvdXRwdXQgKz0gbG9va3VwW3RlbXAgPj4gMTBdO1xuXHRcdFx0XHRvdXRwdXQgKz0gbG9va3VwWyh0ZW1wID4+IDQpICYgMHgzRl07XG5cdFx0XHRcdG91dHB1dCArPSBsb29rdXBbKHRlbXAgPDwgMikgJiAweDNGXTtcblx0XHRcdFx0b3V0cHV0ICs9ICc9Jztcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdG1vZHVsZS5leHBvcnRzLnRvQnl0ZUFycmF5ID0gYjY0VG9CeXRlQXJyYXk7XG5cdG1vZHVsZS5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSB1aW50OFRvQmFzZTY0O1xufSgpKTtcblxufSx7fV0sODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5leHBvcnRzLnJlYWRJRUVFNzU0ID0gZnVuY3Rpb24oYnVmZmVyLCBvZmZzZXQsIGlzQkUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSxcbiAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXG4gICAgICBlTWF4ID0gKDEgPDwgZUxlbikgLSAxLFxuICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXG4gICAgICBuQml0cyA9IC03LFxuICAgICAgaSA9IGlzQkUgPyAwIDogKG5CeXRlcyAtIDEpLFxuICAgICAgZCA9IGlzQkUgPyAxIDogLTEsXG4gICAgICBzID0gYnVmZmVyW29mZnNldCArIGldO1xuXG4gIGkgKz0gZDtcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKTtcbiAgcyA+Pj0gKC1uQml0cyk7XG4gIG5CaXRzICs9IGVMZW47XG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpO1xuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBlID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gbUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCk7XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzO1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSk7XG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICBlID0gZSAtIGVCaWFzO1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pO1xufTtcblxuZXhwb3J0cy53cml0ZUlFRUU3NTQgPSBmdW5jdGlvbihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQkUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgYyxcbiAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXG4gICAgICBlTWF4ID0gKDEgPDwgZUxlbikgLSAxLFxuICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXG4gICAgICBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMCksXG4gICAgICBpID0gaXNCRSA/IChuQnl0ZXMgLSAxKSA6IDAsXG4gICAgICBkID0gaXNCRSA/IC0xIDogMSxcbiAgICAgIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDA7XG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSk7XG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDA7XG4gICAgZSA9IGVNYXg7XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpO1xuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLTtcbiAgICAgIGMgKj0gMjtcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKys7XG4gICAgICBjIC89IDI7XG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMDtcbiAgICAgIGUgPSBlTWF4O1xuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSBlICsgZUJpYXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSAwO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpO1xuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG07XG4gIGVMZW4gKz0gbUxlbjtcbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KTtcblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjg7XG59O1xuXG59LHt9XSwzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKHNpemUpIHtcbiAgICB0aGlzLmxlbmd0aCA9IHNpemU7XG59O1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG5cbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MDtcblxuXG5mdW5jdGlvbiB0b0hleChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KTtcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpO1xufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKylcbiAgICBpZiAoc3RyLmNoYXJDb2RlQXQoaSkgPD0gMHg3RilcbiAgICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpKTtcbiAgICBlbHNlIHtcbiAgICAgIHZhciBoID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0ci5jaGFyQXQoaSkpLnN1YnN0cigxKS5zcGxpdCgnJScpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBoLmxlbmd0aDsgaisrKVxuICAgICAgICBieXRlQXJyYXkucHVzaChwYXJzZUludChoW2pdLCAxNikpO1xuICAgIH1cblxuICByZXR1cm4gYnl0ZUFycmF5O1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKyApXG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goIHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRiApO1xuXG4gIHJldHVybiBieXRlQXJyYXk7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMoc3RyKSB7XG4gIHJldHVybiByZXF1aXJlKFwiYmFzZTY0LWpzXCIpLnRvQnl0ZUFycmF5KHN0cik7XG59XG5cblNsb3dCdWZmZXIuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uIChzdHIsIGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoZW5jb2RpbmcgfHwgXCJ1dGY4XCIpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0dXJuIHN0ci5sZW5ndGggLyAyO1xuXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cikubGVuZ3RoO1xuXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0dXJuIHN0ci5sZW5ndGg7XG5cbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyKS5sZW5ndGg7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJyk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBwb3MsIGkgPSAwO1xuICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgIGlmICgoaStvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpXG4gICAgICBicmVhaztcblxuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXTtcbiAgICBpKys7XG4gIH1cbiAgcmV0dXJuIGk7XG59XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLnV0ZjhXcml0ZSA9IGZ1bmN0aW9uIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBieXRlcywgcG9zO1xuICByZXR1cm4gU2xvd0J1ZmZlci5fY2hhcnNXcml0dGVuID0gIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nKSwgdGhpcywgb2Zmc2V0LCBsZW5ndGgpO1xufTtcblxuU2xvd0J1ZmZlci5wcm90b3R5cGUuYXNjaWlXcml0ZSA9IGZ1bmN0aW9uIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBieXRlcywgcG9zO1xuICByZXR1cm4gU2xvd0J1ZmZlci5fY2hhcnNXcml0dGVuID0gIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIHRoaXMsIG9mZnNldCwgbGVuZ3RoKTtcbn07XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmJhc2U2NFdyaXRlID0gZnVuY3Rpb24gKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGJ5dGVzLCBwb3M7XG4gIHJldHVybiBTbG93QnVmZmVyLl9jaGFyc1dyaXR0ZW4gPSBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgdGhpcywgb2Zmc2V0LCBsZW5ndGgpO1xufTtcblxuU2xvd0J1ZmZlci5wcm90b3R5cGUuYmFzZTY0U2xpY2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICByZXR1cm4gcmVxdWlyZShcImJhc2U2NC1qc1wiKS5mcm9tQnl0ZUFycmF5KGJ5dGVzKTtcbn1cblxuZnVuY3Rpb24gZGVjb2RlVXRmOENoYXIoc3RyKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHIpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgweEZGRkQpOyAvLyBVVEYgOCBpbnZhbGlkIGNoYXJcbiAgfVxufVxuXG5TbG93QnVmZmVyLnByb3RvdHlwZS51dGY4U2xpY2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBieXRlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB2YXIgcmVzID0gXCJcIjtcbiAgdmFyIHRtcCA9IFwiXCI7XG4gIHZhciBpID0gMDtcbiAgd2hpbGUgKGkgPCBieXRlcy5sZW5ndGgpIHtcbiAgICBpZiAoYnl0ZXNbaV0gPD0gMHg3Rikge1xuICAgICAgcmVzICs9IGRlY29kZVV0ZjhDaGFyKHRtcCkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldKTtcbiAgICAgIHRtcCA9IFwiXCI7XG4gICAgfSBlbHNlXG4gICAgICB0bXAgKz0gXCIlXCIgKyBieXRlc1tpXS50b1N0cmluZygxNik7XG5cbiAgICBpKys7XG4gIH1cblxuICByZXR1cm4gcmVzICsgZGVjb2RlVXRmOENoYXIodG1wKTtcbn1cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUuYXNjaWlTbGljZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGJ5dGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIHZhciByZXQgPSBcIlwiO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKVxuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldKTtcbiAgcmV0dXJuIHJldDtcbn1cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgb3V0ID0gW10sXG4gICAgICBsZW4gPSB0aGlzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG91dFtpXSA9IHRvSGV4KHRoaXNbaV0pO1xuICAgIGlmIChpID09IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMpIHtcbiAgICAgIG91dFtpICsgMV0gPSAnLi4uJztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJzxTbG93QnVmZmVyICcgKyBvdXQuam9pbignICcpICsgJz4nO1xufTtcblxuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5oZXhTbGljZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoO1xuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDA7XG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW47XG5cbiAgdmFyIG91dCA9ICcnO1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIG91dCArPSB0b0hleCh0aGlzW2ldKTtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuXG5TbG93QnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKTtcbiAgc3RhcnQgPSArc3RhcnQgfHwgMDtcbiAgaWYgKHR5cGVvZiBlbmQgPT0gJ3VuZGVmaW5lZCcpIGVuZCA9IHRoaXMubGVuZ3RoO1xuXG4gIC8vIEZhc3RwYXRoIGVtcHR5IHN0cmluZ3NcbiAgaWYgKCtlbmQgPT0gc3RhcnQpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldHVybiB0aGlzLmhleFNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0dXJuIHRoaXMudXRmOFNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0dXJuIHRoaXMuYXNjaWlTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXR1cm4gdGhpcy5iaW5hcnlTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXR1cm4gdGhpcy5iYXNlNjRTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIHJldHVybiB0aGlzLnVjczJTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKTtcbiAgfVxufTtcblxuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5oZXhXcml0ZSA9IGZ1bmN0aW9uKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gK29mZnNldCB8fCAwO1xuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXQ7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9ICtsZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoO1xuICBpZiAoc3RyTGVuICUgMikge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYnl0ZSA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNik7XG4gICAgaWYgKGlzTmFOKGJ5dGUpKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpO1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSBieXRlO1xuICB9XG4gIFNsb3dCdWZmZXIuX2NoYXJzV3JpdHRlbiA9IGkgKiAyO1xuICByZXR1cm4gaTtcbn07XG5cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBTdXBwb3J0IGJvdGggKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKVxuICAvLyBhbmQgdGhlIGxlZ2FjeSAoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpXG4gIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgaWYgKCFpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aDtcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSB7ICAvLyBsZWdhY3lcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gb2Zmc2V0O1xuICAgIG9mZnNldCA9IGxlbmd0aDtcbiAgICBsZW5ndGggPSBzd2FwO1xuICB9XG5cbiAgb2Zmc2V0ID0gK29mZnNldCB8fCAwO1xuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXQ7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9ICtsZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICAgIH1cbiAgfVxuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCk7XG5cbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXR1cm4gdGhpcy5oZXhXcml0ZShzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKTtcblxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldHVybiB0aGlzLnV0ZjhXcml0ZShzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKTtcblxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldHVybiB0aGlzLmFzY2lpV3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0dXJuIHRoaXMuYmluYXJ5V3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0dXJuIHRoaXMuYmFzZTY0V3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgICByZXR1cm4gdGhpcy51Y3MyV3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJyk7XG4gIH1cbn07XG5cblxuLy8gc2xpY2Uoc3RhcnQsIGVuZClcblNsb3dCdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIGVuZCA9IHRoaXMubGVuZ3RoO1xuXG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignb29iJyk7XG4gIH1cbiAgaWYgKHN0YXJ0ID4gZW5kKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdvb2InKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgQnVmZmVyKHRoaXMsIGVuZCAtIHN0YXJ0LCArc3RhcnQpO1xufTtcblxuU2xvd0J1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKHRhcmdldCwgdGFyZ2V0c3RhcnQsIHNvdXJjZXN0YXJ0LCBzb3VyY2VlbmQpIHtcbiAgdmFyIHRlbXAgPSBbXTtcbiAgZm9yICh2YXIgaT1zb3VyY2VzdGFydDsgaTxzb3VyY2VlbmQ7IGkrKykge1xuICAgIGFzc2VydC5vayh0eXBlb2YgdGhpc1tpXSAhPT0gJ3VuZGVmaW5lZCcsIFwiY29weWluZyB1bmRlZmluZWQgYnVmZmVyIGJ5dGVzIVwiKTtcbiAgICB0ZW1wLnB1c2godGhpc1tpXSk7XG4gIH1cblxuICBmb3IgKHZhciBpPXRhcmdldHN0YXJ0OyBpPHRhcmdldHN0YXJ0K3RlbXAubGVuZ3RoOyBpKyspIHtcbiAgICB0YXJnZXRbaV0gPSB0ZW1wW2ktdGFyZ2V0c3RhcnRdO1xuICB9XG59O1xuXG5mdW5jdGlvbiBjb2VyY2UobGVuZ3RoKSB7XG4gIC8vIENvZXJjZSBsZW5ndGggdG8gYSBudW1iZXIgKHBvc3NpYmx5IE5hTiksIHJvdW5kIHVwXG4gIC8vIGluIGNhc2UgaXQncyBmcmFjdGlvbmFsIChlLmcuIDEyMy40NTYpIHRoZW4gZG8gYVxuICAvLyBkb3VibGUgbmVnYXRlIHRvIGNvZXJjZSBhIE5hTiB0byAwLiBFYXN5LCByaWdodD9cbiAgbGVuZ3RoID0gfn5NYXRoLmNlaWwoK2xlbmd0aCk7XG4gIHJldHVybiBsZW5ndGggPCAwID8gMCA6IGxlbmd0aDtcbn1cblxuXG4vLyBCdWZmZXJcblxuZnVuY3Rpb24gQnVmZmVyKHN1YmplY3QsIGVuY29kaW5nLCBvZmZzZXQpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihzdWJqZWN0LCBlbmNvZGluZywgb2Zmc2V0KTtcbiAgfVxuXG4gIHZhciB0eXBlO1xuXG4gIC8vIEFyZSB3ZSBzbGljaW5nP1xuICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ251bWJlcicpIHtcbiAgICB0aGlzLmxlbmd0aCA9IGNvZXJjZShlbmNvZGluZyk7XG4gICAgdGhpcy5wYXJlbnQgPSBzdWJqZWN0O1xuICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICB9IGVsc2Uge1xuICAgIC8vIEZpbmQgdGhlIGxlbmd0aFxuICAgIHN3aXRjaCAodHlwZSA9IHR5cGVvZiBzdWJqZWN0KSB7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICB0aGlzLmxlbmd0aCA9IGNvZXJjZShzdWJqZWN0KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIHRoaXMubGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoc3ViamVjdCwgZW5jb2RpbmcpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnb2JqZWN0JzogLy8gQXNzdW1lIG9iamVjdCBpcyBhbiBhcnJheVxuICAgICAgICB0aGlzLmxlbmd0aCA9IGNvZXJjZShzdWJqZWN0Lmxlbmd0aCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG5lZWRzIHRvIGJlIGEgbnVtYmVyLCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdhcnJheSBvciBzdHJpbmcuJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gQnVmZmVyLnBvb2xTaXplKSB7XG4gICAgICAvLyBCaWcgYnVmZmVyLCBqdXN0IGFsbG9jIG9uZS5cbiAgICAgIHRoaXMucGFyZW50ID0gbmV3IFNsb3dCdWZmZXIodGhpcy5sZW5ndGgpO1xuICAgICAgdGhpcy5vZmZzZXQgPSAwO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNtYWxsIGJ1ZmZlci5cbiAgICAgIGlmICghcG9vbCB8fCBwb29sLmxlbmd0aCAtIHBvb2wudXNlZCA8IHRoaXMubGVuZ3RoKSBhbGxvY1Bvb2woKTtcbiAgICAgIHRoaXMucGFyZW50ID0gcG9vbDtcbiAgICAgIHRoaXMub2Zmc2V0ID0gcG9vbC51c2VkO1xuICAgICAgcG9vbC51c2VkICs9IHRoaXMubGVuZ3RoO1xuICAgIH1cblxuICAgIC8vIFRyZWF0IGFycmF5LWlzaCBvYmplY3RzIGFzIGEgYnl0ZSBhcnJheS5cbiAgICBpZiAoaXNBcnJheUlzaChzdWJqZWN0KSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMucGFyZW50W2kgKyB0aGlzLm9mZnNldF0gPSBzdWJqZWN0W2ldO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PSAnc3RyaW5nJykge1xuICAgICAgLy8gV2UgYXJlIGEgc3RyaW5nXG4gICAgICB0aGlzLmxlbmd0aCA9IHRoaXMud3JpdGUoc3ViamVjdCwgMCwgZW5jb2RpbmcpO1xuICAgIH1cbiAgfVxuXG59XG5cbmZ1bmN0aW9uIGlzQXJyYXlJc2goc3ViamVjdCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShzdWJqZWN0KSB8fCBCdWZmZXIuaXNCdWZmZXIoc3ViamVjdCkgfHxcbiAgICAgICAgIHN1YmplY3QgJiYgdHlwZW9mIHN1YmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICAgICB0eXBlb2Ygc3ViamVjdC5sZW5ndGggPT09ICdudW1iZXInO1xufVxuXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyO1xuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXI7XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDggKiAxMDI0O1xudmFyIHBvb2w7XG5cbmZ1bmN0aW9uIGFsbG9jUG9vbCgpIHtcbiAgcG9vbCA9IG5ldyBTbG93QnVmZmVyKEJ1ZmZlci5wb29sU2l6ZSk7XG4gIHBvb2wudXNlZCA9IDA7XG59XG5cblxuLy8gU3RhdGljIG1ldGhvZHNcbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyKGIpIHtcbiAgcmV0dXJuIGIgaW5zdGFuY2VvZiBCdWZmZXIgfHwgYiBpbnN0YW5jZW9mIFNsb3dCdWZmZXI7XG59O1xuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gKGxpc3QsIHRvdGFsTGVuZ3RoKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVzYWdlOiBCdWZmZXIuY29uY2F0KGxpc3QsIFt0b3RhbExlbmd0aF0pXFxuIFxcXG4gICAgICBsaXN0IHNob3VsZCBiZSBhbiBBcnJheS5cIik7XG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcigwKTtcbiAgfSBlbHNlIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBsaXN0WzBdO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0b3RhbExlbmd0aCAhPT0gJ251bWJlcicpIHtcbiAgICB0b3RhbExlbmd0aCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYnVmID0gbGlzdFtpXTtcbiAgICAgIHRvdGFsTGVuZ3RoICs9IGJ1Zi5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IG5ldyBCdWZmZXIodG90YWxMZW5ndGgpO1xuICB2YXIgcG9zID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV07XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpO1xuICAgIHBvcyArPSBidWYubGVuZ3RoO1xuICB9XG4gIHJldHVybiBidWZmZXI7XG59O1xuXG4vLyBJbnNwZWN0XG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICB2YXIgb3V0ID0gW10sXG4gICAgICBsZW4gPSB0aGlzLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgb3V0W2ldID0gdG9IZXgodGhpcy5wYXJlbnRbaSArIHRoaXMub2Zmc2V0XSk7XG4gICAgaWYgKGkgPT0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUykge1xuICAgICAgb3V0W2kgKyAxXSA9ICcuLi4nO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBvdXQuam9pbignICcpICsgJz4nO1xufTtcblxuXG5CdWZmZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldChpKSB7XG4gIGlmIChpIDwgMCB8fCBpID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ29vYicpO1xuICByZXR1cm4gdGhpcy5wYXJlbnRbdGhpcy5vZmZzZXQgKyBpXTtcbn07XG5cblxuQnVmZmVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQoaSwgdikge1xuICBpZiAoaSA8IDAgfHwgaSA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdvb2InKTtcbiAgcmV0dXJuIHRoaXMucGFyZW50W3RoaXMub2Zmc2V0ICsgaV0gPSB2O1xufTtcblxuXG4vLyB3cml0ZShzdHJpbmcsIG9mZnNldCA9IDAsIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGgtb2Zmc2V0LCBlbmNvZGluZyA9ICd1dGY4JylcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBTdXBwb3J0IGJvdGggKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKVxuICAvLyBhbmQgdGhlIGxlZ2FjeSAoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpXG4gIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgaWYgKCFpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aDtcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSB7ICAvLyBsZWdhY3lcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gb2Zmc2V0O1xuICAgIG9mZnNldCA9IGxlbmd0aDtcbiAgICBsZW5ndGggPSBzd2FwO1xuICB9XG5cbiAgb2Zmc2V0ID0gK29mZnNldCB8fCAwO1xuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXQ7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9ICtsZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICAgIH1cbiAgfVxuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCk7XG5cbiAgdmFyIHJldDtcbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSB0aGlzLnBhcmVudC5oZXhXcml0ZShzdHJpbmcsIHRoaXMub2Zmc2V0ICsgb2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSB0aGlzLnBhcmVudC51dGY4V3JpdGUoc3RyaW5nLCB0aGlzLm9mZnNldCArIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0ID0gdGhpcy5wYXJlbnQuYXNjaWlXcml0ZShzdHJpbmcsIHRoaXMub2Zmc2V0ICsgb2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0ID0gdGhpcy5wYXJlbnQuYmluYXJ5V3JpdGUoc3RyaW5nLCB0aGlzLm9mZnNldCArIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICByZXQgPSB0aGlzLnBhcmVudC5iYXNlNjRXcml0ZShzdHJpbmcsIHRoaXMub2Zmc2V0ICsgb2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgICByZXQgPSB0aGlzLnBhcmVudC51Y3MyV3JpdGUoc3RyaW5nLCB0aGlzLm9mZnNldCArIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpO1xuICB9XG5cbiAgQnVmZmVyLl9jaGFyc1dyaXR0ZW4gPSBTbG93QnVmZmVyLl9jaGFyc1dyaXR0ZW47XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cblxuLy8gdG9TdHJpbmcoZW5jb2RpbmcsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKTtcblxuICBpZiAodHlwZW9mIHN0YXJ0ID09ICd1bmRlZmluZWQnIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMDtcbiAgfSBlbHNlIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgc3RhcnQgPSB0aGlzLmxlbmd0aDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5kID09ICd1bmRlZmluZWQnIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGg7XG4gIH0gZWxzZSBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCA9IDA7XG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ICsgdGhpcy5vZmZzZXQ7XG4gIGVuZCA9IGVuZCArIHRoaXMub2Zmc2V0O1xuXG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmhleFNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LnV0ZjhTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC5hc2NpaVNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC5iaW5hcnlTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQuYmFzZTY0U2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQudWNzMlNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpO1xuICB9XG59O1xuXG5cbi8vIGJ5dGVMZW5ndGhcbkJ1ZmZlci5ieXRlTGVuZ3RoID0gU2xvd0J1ZmZlci5ieXRlTGVuZ3RoO1xuXG5cbi8vIGZpbGwodmFsdWUsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCh2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICB2YWx1ZSB8fCAodmFsdWUgPSAwKTtcbiAgc3RhcnQgfHwgKHN0YXJ0ID0gMCk7XG4gIGVuZCB8fCAoZW5kID0gdGhpcy5sZW5ndGgpO1xuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5jaGFyQ29kZUF0KDApO1xuICB9XG4gIGlmICghKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHx8IGlzTmFOKHZhbHVlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcigndmFsdWUgaXMgbm90IGEgbnVtYmVyJyk7XG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIHRocm93IG5ldyBFcnJvcignZW5kIDwgc3RhcnQnKTtcblxuICAvLyBGaWxsIDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwO1xuICBpZiAodGhpcy5sZW5ndGggPT0gMCkgcmV0dXJuIDA7XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc3RhcnQgb3V0IG9mIGJvdW5kcycpO1xuICB9XG5cbiAgaWYgKGVuZCA8IDAgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2VuZCBvdXQgb2YgYm91bmRzJyk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5wYXJlbnQuZmlsbCh2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgKyB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kICsgdGhpcy5vZmZzZXQpO1xufTtcblxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbih0YXJnZXQsIHRhcmdldF9zdGFydCwgc3RhcnQsIGVuZCkge1xuICB2YXIgc291cmNlID0gdGhpcztcbiAgc3RhcnQgfHwgKHN0YXJ0ID0gMCk7XG4gIGVuZCB8fCAoZW5kID0gdGhpcy5sZW5ndGgpO1xuICB0YXJnZXRfc3RhcnQgfHwgKHRhcmdldF9zdGFydCA9IDApO1xuXG4gIGlmIChlbmQgPCBzdGFydCkgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2VFbmQgPCBzb3VyY2VTdGFydCcpO1xuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDA7XG4gIGlmICh0YXJnZXQubGVuZ3RoID09IDAgfHwgc291cmNlLmxlbmd0aCA9PSAwKSByZXR1cm4gMDtcblxuICBpZiAodGFyZ2V0X3N0YXJ0IDwgMCB8fCB0YXJnZXRfc3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpO1xuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSBzb3VyY2UubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJyk7XG4gIH1cblxuICBpZiAoZW5kIDwgMCB8fCBlbmQgPiBzb3VyY2UubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpO1xuICB9XG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGg7XG4gIH1cblxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCArIHN0YXJ0O1xuICB9XG5cbiAgcmV0dXJuIHRoaXMucGFyZW50LmNvcHkodGFyZ2V0LnBhcmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0X3N0YXJ0ICsgdGFyZ2V0Lm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgKyB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kICsgdGhpcy5vZmZzZXQpO1xufTtcblxuXG4vLyBzbGljZShzdGFydCwgZW5kKVxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ29vYicpO1xuICBpZiAoc3RhcnQgPiBlbmQpIHRocm93IG5ldyBFcnJvcignb29iJyk7XG5cbiAgcmV0dXJuIG5ldyBCdWZmZXIodGhpcy5wYXJlbnQsIGVuZCAtIHN0YXJ0LCArc3RhcnQgKyB0aGlzLm9mZnNldCk7XG59O1xuXG5cbi8vIExlZ2FjeSBtZXRob2RzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblxuQnVmZmVyLnByb3RvdHlwZS51dGY4U2xpY2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiB0aGlzLnRvU3RyaW5nKCd1dGY4Jywgc3RhcnQsIGVuZCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmJpbmFyeVNsaWNlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gdGhpcy50b1N0cmluZygnYmluYXJ5Jywgc3RhcnQsIGVuZCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmFzY2lpU2xpY2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiB0aGlzLnRvU3RyaW5nKCdhc2NpaScsIHN0YXJ0LCBlbmQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS51dGY4V3JpdGUgPSBmdW5jdGlvbihzdHJpbmcsIG9mZnNldCkge1xuICByZXR1cm4gdGhpcy53cml0ZShzdHJpbmcsIG9mZnNldCwgJ3V0ZjgnKTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUuYmluYXJ5V3JpdGUgPSBmdW5jdGlvbihzdHJpbmcsIG9mZnNldCkge1xuICByZXR1cm4gdGhpcy53cml0ZShzdHJpbmcsIG9mZnNldCwgJ2JpbmFyeScpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5hc2NpaVdyaXRlID0gZnVuY3Rpb24oc3RyaW5nLCBvZmZzZXQpIHtcbiAgcmV0dXJuIHRoaXMud3JpdGUoc3RyaW5nLCBvZmZzZXQsICdhc2NpaScpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhciBidWZmZXIgPSB0aGlzO1xuXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcbiAgfVxuXG4gIHJldHVybiBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdO1xufTtcblxuZnVuY3Rpb24gcmVhZFVJbnQxNihidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhciB2YWwgPSAwO1xuXG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMSA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgaWYgKGlzQmlnRW5kaWFuKSB7XG4gICAgdmFsID0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XSA8PCA4O1xuICAgIHZhbCB8PSBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyAxXTtcbiAgfSBlbHNlIHtcbiAgICB2YWwgPSBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdO1xuICAgIHZhbCB8PSBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyAxXSA8PCA4O1xuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkVUludDE2KHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZFVJbnQxNih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRVSW50MzIoYnVmZmVyLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YXIgdmFsID0gMDtcblxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICBpZiAoaXNCaWdFbmRpYW4pIHtcbiAgICB2YWwgPSBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyAxXSA8PCAxNjtcbiAgICB2YWwgfD0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMl0gPDwgODtcbiAgICB2YWwgfD0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgM107XG4gICAgdmFsID0gdmFsICsgKGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF0gPDwgMjQgPj4+IDApO1xuICB9IGVsc2Uge1xuICAgIHZhbCA9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDJdIDw8IDE2O1xuICAgIHZhbCB8PSBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyAxXSA8PCA4O1xuICAgIHZhbCB8PSBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdO1xuICAgIHZhbCA9IHZhbCArIChidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyAzXSA8PCAyNCA+Pj4gMCk7XG4gIH1cblxuICByZXR1cm4gdmFsO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRVSW50MzIodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkVUludDMyKHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuXG4vKlxuICogU2lnbmVkIGludGVnZXIgdHlwZXMsIHlheSB0ZWFtISBBIHJlbWluZGVyIG9uIGhvdyB0d28ncyBjb21wbGVtZW50IGFjdHVhbGx5XG4gKiB3b3Jrcy4gVGhlIGZpcnN0IGJpdCBpcyB0aGUgc2lnbmVkIGJpdCwgaS5lLiB0ZWxscyB1cyB3aGV0aGVyIG9yIG5vdCB0aGVcbiAqIG51bWJlciBzaG91bGQgYmUgcG9zaXRpdmUgb3IgbmVnYXRpdmUuIElmIHRoZSB0d28ncyBjb21wbGVtZW50IHZhbHVlIGlzXG4gKiBwb3NpdGl2ZSwgdGhlbiB3ZSdyZSBkb25lLCBhcyBpdCdzIGVxdWl2YWxlbnQgdG8gdGhlIHVuc2lnbmVkIHJlcHJlc2VudGF0aW9uLlxuICpcbiAqIE5vdyBpZiB0aGUgbnVtYmVyIGlzIHBvc2l0aXZlLCB5b3UncmUgcHJldHR5IG11Y2ggZG9uZSwgeW91IGNhbiBqdXN0IGxldmVyYWdlXG4gKiB0aGUgdW5zaWduZWQgdHJhbnNsYXRpb25zIGFuZCByZXR1cm4gdGhvc2UuIFVuZm9ydHVuYXRlbHksIG5lZ2F0aXZlIG51bWJlcnNcbiAqIGFyZW4ndCBxdWl0ZSB0aGF0IHN0cmFpZ2h0Zm9yd2FyZC5cbiAqXG4gKiBBdCBmaXJzdCBnbGFuY2UsIG9uZSBtaWdodCBiZSBpbmNsaW5lZCB0byB1c2UgdGhlIHRyYWRpdGlvbmFsIGZvcm11bGEgdG9cbiAqIHRyYW5zbGF0ZSBiaW5hcnkgbnVtYmVycyBiZXR3ZWVuIHRoZSBwb3NpdGl2ZSBhbmQgbmVnYXRpdmUgdmFsdWVzIGluIHR3bydzXG4gKiBjb21wbGVtZW50LiAoVGhvdWdoIGl0IGRvZXNuJ3QgcXVpdGUgd29yayBmb3IgdGhlIG1vc3QgbmVnYXRpdmUgdmFsdWUpXG4gKiBNYWlubHk6XG4gKiAgLSBpbnZlcnQgYWxsIHRoZSBiaXRzXG4gKiAgLSBhZGQgb25lIHRvIHRoZSByZXN1bHRcbiAqXG4gKiBPZiBjb3Vyc2UsIHRoaXMgZG9lc24ndCBxdWl0ZSB3b3JrIGluIEphdmFzY3JpcHQuIFRha2UgZm9yIGV4YW1wbGUgdGhlIHZhbHVlXG4gKiBvZiAtMTI4LiBUaGlzIGNvdWxkIGJlIHJlcHJlc2VudGVkIGluIDE2IGJpdHMgKGJpZy1lbmRpYW4pIGFzIDB4ZmY4MC4gQnV0IG9mXG4gKiBjb3Vyc2UsIEphdmFzY3JpcHQgd2lsbCBkbyB0aGUgZm9sbG93aW5nOlxuICpcbiAqID4gfjB4ZmY4MFxuICogLTY1NDA5XG4gKlxuICogV2hvaCB0aGVyZSwgSmF2YXNjcmlwdCwgdGhhdCdzIG5vdCBxdWl0ZSByaWdodC4gQnV0IHdhaXQsIGFjY29yZGluZyB0b1xuICogSmF2YXNjcmlwdCB0aGF0J3MgcGVyZmVjdGx5IGNvcnJlY3QuIFdoZW4gSmF2YXNjcmlwdCBlbmRzIHVwIHNlZWluZyB0aGVcbiAqIGNvbnN0YW50IDB4ZmY4MCwgaXQgaGFzIG5vIG5vdGlvbiB0aGF0IGl0IGlzIGFjdHVhbGx5IGEgc2lnbmVkIG51bWJlci4gSXRcbiAqIGFzc3VtZXMgdGhhdCB3ZSd2ZSBpbnB1dCB0aGUgdW5zaWduZWQgdmFsdWUgMHhmZjgwLiBUaHVzLCB3aGVuIGl0IGRvZXMgdGhlXG4gKiBiaW5hcnkgbmVnYXRpb24sIGl0IGNhc3RzIGl0IGludG8gYSBzaWduZWQgdmFsdWUsIChwb3NpdGl2ZSAweGZmODApLiBUaGVuXG4gKiB3aGVuIHlvdSBwZXJmb3JtIGJpbmFyeSBuZWdhdGlvbiBvbiB0aGF0LCBpdCB0dXJucyBpdCBpbnRvIGEgbmVnYXRpdmUgbnVtYmVyLlxuICpcbiAqIEluc3RlYWQsIHdlJ3JlIGdvaW5nIHRvIGhhdmUgdG8gdXNlIHRoZSBmb2xsb3dpbmcgZ2VuZXJhbCBmb3JtdWxhLCB0aGF0IHdvcmtzXG4gKiBpbiBhIHJhdGhlciBKYXZhc2NyaXB0IGZyaWVuZGx5IHdheS4gSSdtIGdsYWQgd2UgZG9uJ3Qgc3VwcG9ydCB0aGlzIGtpbmQgb2ZcbiAqIHdlaXJkIG51bWJlcmluZyBzY2hlbWUgaW4gdGhlIGtlcm5lbC5cbiAqXG4gKiAoQklULU1BWCAtICh1bnNpZ25lZCl2YWwgKyAxKSAqIC0xXG4gKlxuICogVGhlIGFzdHV0ZSBvYnNlcnZlciwgbWF5IHRoaW5rIHRoYXQgdGhpcyBkb2Vzbid0IG1ha2Ugc2Vuc2UgZm9yIDgtYml0IG51bWJlcnNcbiAqIChyZWFsbHkgaXQgaXNuJ3QgbmVjZXNzYXJ5IGZvciB0aGVtKS4gSG93ZXZlciwgd2hlbiB5b3UgZ2V0IDE2LWJpdCBudW1iZXJzLFxuICogeW91IGRvLiBMZXQncyBnbyBiYWNrIHRvIG91ciBwcmlvciBleGFtcGxlIGFuZCBzZWUgaG93IHRoaXMgd2lsbCBsb29rOlxuICpcbiAqICgweGZmZmYgLSAweGZmODAgKyAxKSAqIC0xXG4gKiAoMHgwMDdmICsgMSkgKiAtMVxuICogKDB4MDA4MCkgKiAtMVxuICovXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YXIgYnVmZmVyID0gdGhpcztcbiAgdmFyIG5lZztcblxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0IDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICBuZWcgPSBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdICYgMHg4MDtcbiAgaWYgKCFuZWcpIHtcbiAgICByZXR1cm4gKGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF0pO1xuICB9XG5cbiAgcmV0dXJuICgoMHhmZiAtIGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF0gKyAxKSAqIC0xKTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRJbnQxNihidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhciBuZWcsIHZhbDtcblxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAxIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICB2YWwgPSByZWFkVUludDE2KGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpO1xuICBuZWcgPSB2YWwgJiAweDgwMDA7XG4gIGlmICghbmVnKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIHJldHVybiAoMHhmZmZmIC0gdmFsICsgMSkgKiAtMTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRJbnQxNih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZEludDE2KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuZnVuY3Rpb24gcmVhZEludDMyKGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFyIG5lZywgdmFsO1xuXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDMgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcbiAgfVxuXG4gIHZhbCA9IHJlYWRVSW50MzIoYnVmZmVyLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCk7XG4gIG5lZyA9IHZhbCAmIDB4ODAwMDAwMDA7XG4gIGlmICghbmVnKSB7XG4gICAgcmV0dXJuICh2YWwpO1xuICB9XG5cbiAgcmV0dXJuICgweGZmZmZmZmZmIC0gdmFsICsgMSkgKiAtMTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRJbnQzMih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZEludDMyKHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuZnVuY3Rpb24gcmVhZEZsb2F0KGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDMgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcbiAgfVxuXG4gIHJldHVybiByZXF1aXJlKCcuL2J1ZmZlcl9pZWVlNzU0JykucmVhZElFRUU3NTQoYnVmZmVyLCBvZmZzZXQsIGlzQmlnRW5kaWFuLFxuICAgICAgMjMsIDQpO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZEZsb2F0KHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkRmxvYXQodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5mdW5jdGlvbiByZWFkRG91YmxlKGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDcgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcbiAgfVxuXG4gIHJldHVybiByZXF1aXJlKCcuL2J1ZmZlcl9pZWVlNzU0JykucmVhZElFRUU3NTQoYnVmZmVyLCBvZmZzZXQsIGlzQmlnRW5kaWFuLFxuICAgICAgNTIsIDgpO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWREb3VibGUodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkRG91YmxlKHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuXG4vKlxuICogV2UgaGF2ZSB0byBtYWtlIHN1cmUgdGhhdCB0aGUgdmFsdWUgaXMgYSB2YWxpZCBpbnRlZ2VyLiBUaGlzIG1lYW5zIHRoYXQgaXQgaXNcbiAqIG5vbi1uZWdhdGl2ZS4gSXQgaGFzIG5vIGZyYWN0aW9uYWwgY29tcG9uZW50IGFuZCB0aGF0IGl0IGRvZXMgbm90IGV4Y2VlZCB0aGVcbiAqIG1heGltdW0gYWxsb3dlZCB2YWx1ZS5cbiAqXG4gKiAgICAgIHZhbHVlICAgICAgICAgICBUaGUgbnVtYmVyIHRvIGNoZWNrIGZvciB2YWxpZGl0eVxuICpcbiAqICAgICAgbWF4ICAgICAgICAgICAgIFRoZSBtYXhpbXVtIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHZlcmlmdWludCh2YWx1ZSwgbWF4KSB7XG4gIGFzc2VydC5vayh0eXBlb2YgKHZhbHVlKSA9PSAnbnVtYmVyJyxcbiAgICAgICdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJyk7XG5cbiAgYXNzZXJ0Lm9rKHZhbHVlID49IDAsXG4gICAgICAnc3BlY2lmaWVkIGEgbmVnYXRpdmUgdmFsdWUgZm9yIHdyaXRpbmcgYW4gdW5zaWduZWQgdmFsdWUnKTtcblxuICBhc3NlcnQub2sodmFsdWUgPD0gbWF4LCAndmFsdWUgaXMgbGFyZ2VyIHRoYW4gbWF4aW11bSB2YWx1ZSBmb3IgdHlwZScpO1xuXG4gIGFzc2VydC5vayhNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWUsICd2YWx1ZSBoYXMgYSBmcmFjdGlvbmFsIGNvbXBvbmVudCcpO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YXIgYnVmZmVyID0gdGhpcztcblxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmYpO1xuICB9XG5cbiAgYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XSA9IHZhbHVlO1xufTtcblxuZnVuY3Rpb24gd3JpdGVVSW50MTYoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAxIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmZmYpO1xuICB9XG5cbiAgaWYgKGlzQmlnRW5kaWFuKSB7XG4gICAgYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYwMCkgPj4+IDg7XG4gICAgYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV0gPSB2YWx1ZSAmIDB4MDBmZjtcbiAgfSBlbHNlIHtcbiAgICBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYwMCkgPj4+IDg7XG4gICAgYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XSA9IHZhbHVlICYgMHgwMGZmO1xuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZVVJbnQzMihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDMgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmZmZmZmZmYpO1xuICB9XG5cbiAgaWYgKGlzQmlnRW5kaWFuKSB7XG4gICAgYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpICYgMHhmZjtcbiAgICBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpICYgMHhmZjtcbiAgICBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOCkgJiAweGZmO1xuICAgIGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDNdID0gdmFsdWUgJiAweGZmO1xuICB9IGVsc2Uge1xuICAgIGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNCkgJiAweGZmO1xuICAgIGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNikgJiAweGZmO1xuICAgIGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KSAmIDB4ZmY7XG4gICAgYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XSA9IHZhbHVlICYgMHhmZjtcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuXG4vKlxuICogV2Ugbm93IG1vdmUgb250byBvdXIgZnJpZW5kcyBpbiB0aGUgc2lnbmVkIG51bWJlciBjYXRlZ29yeS4gVW5saWtlIHVuc2lnbmVkXG4gKiBudW1iZXJzLCB3ZSdyZSBnb2luZyB0byBoYXZlIHRvIHdvcnJ5IGEgYml0IG1vcmUgYWJvdXQgaG93IHdlIHB1dCB2YWx1ZXMgaW50b1xuICogYXJyYXlzLiBTaW5jZSB3ZSBhcmUgb25seSB3b3JyeWluZyBhYm91dCBzaWduZWQgMzItYml0IHZhbHVlcywgd2UncmUgaW5cbiAqIHNsaWdodGx5IGJldHRlciBzaGFwZS4gVW5mb3J0dW5hdGVseSwgd2UgcmVhbGx5IGNhbid0IGRvIG91ciBmYXZvcml0ZSBiaW5hcnlcbiAqICYgaW4gdGhpcyBzeXN0ZW0uIEl0IHJlYWxseSBzZWVtcyB0byBkbyB0aGUgd3JvbmcgdGhpbmcuIEZvciBleGFtcGxlOlxuICpcbiAqID4gLTMyICYgMHhmZlxuICogMjI0XG4gKlxuICogV2hhdCdzIGhhcHBlbmluZyBhYm92ZSBpcyByZWFsbHk6IDB4ZTAgJiAweGZmID0gMHhlMC4gSG93ZXZlciwgdGhlIHJlc3VsdHMgb2ZcbiAqIHRoaXMgYXJlbid0IHRyZWF0ZWQgYXMgYSBzaWduZWQgbnVtYmVyLiBVbHRpbWF0ZWx5IGEgYmFkIHRoaW5nLlxuICpcbiAqIFdoYXQgd2UncmUgZ29pbmcgdG8gd2FudCB0byBkbyBpcyBiYXNpY2FsbHkgY3JlYXRlIHRoZSB1bnNpZ25lZCBlcXVpdmFsZW50IG9mXG4gKiBvdXIgcmVwcmVzZW50YXRpb24gYW5kIHBhc3MgdGhhdCBvZmYgdG8gdGhlIHd1aW50KiBmdW5jdGlvbnMuIFRvIGRvIHRoYXRcbiAqIHdlJ3JlIGdvaW5nIHRvIGRvIHRoZSBmb2xsb3dpbmc6XG4gKlxuICogIC0gaWYgdGhlIHZhbHVlIGlzIHBvc2l0aXZlXG4gKiAgICAgIHdlIGNhbiBwYXNzIGl0IGRpcmVjdGx5IG9mZiB0byB0aGUgZXF1aXZhbGVudCB3dWludFxuICogIC0gaWYgdGhlIHZhbHVlIGlzIG5lZ2F0aXZlXG4gKiAgICAgIHdlIGRvIHRoZSBmb2xsb3dpbmcgY29tcHV0YXRpb246XG4gKiAgICAgICAgIG1iICsgdmFsICsgMSwgd2hlcmVcbiAqICAgICAgICAgbWIgICBpcyB0aGUgbWF4aW11bSB1bnNpZ25lZCB2YWx1ZSBpbiB0aGF0IGJ5dGUgc2l6ZVxuICogICAgICAgICB2YWwgIGlzIHRoZSBKYXZhc2NyaXB0IG5lZ2F0aXZlIGludGVnZXJcbiAqXG4gKlxuICogQXMgYSBjb25jcmV0ZSB2YWx1ZSwgdGFrZSAtMTI4LiBJbiBzaWduZWQgMTYgYml0cyB0aGlzIHdvdWxkIGJlIDB4ZmY4MC4gSWZcbiAqIHlvdSBkbyBvdXQgdGhlIGNvbXB1dGF0aW9uczpcbiAqXG4gKiAweGZmZmYgLSAxMjggKyAxXG4gKiAweGZmZmYgLSAxMjdcbiAqIDB4ZmY4MFxuICpcbiAqIFlvdSBjYW4gdGhlbiBlbmNvZGUgdGhpcyB2YWx1ZSBhcyB0aGUgc2lnbmVkIHZlcnNpb24uIFRoaXMgaXMgcmVhbGx5IHJhdGhlclxuICogaGFja3ksIGJ1dCBpdCBzaG91bGQgd29yayBhbmQgZ2V0IHRoZSBqb2IgZG9uZSB3aGljaCBpcyBvdXIgZ29hbCBoZXJlLlxuICovXG5cbi8qXG4gKiBBIHNlcmllcyBvZiBjaGVja3MgdG8gbWFrZSBzdXJlIHdlIGFjdHVhbGx5IGhhdmUgYSBzaWduZWQgMzItYml0IG51bWJlclxuICovXG5mdW5jdGlvbiB2ZXJpZnNpbnQodmFsdWUsIG1heCwgbWluKSB7XG4gIGFzc2VydC5vayh0eXBlb2YgKHZhbHVlKSA9PSAnbnVtYmVyJyxcbiAgICAgICdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJyk7XG5cbiAgYXNzZXJ0Lm9rKHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGxhcmdlciB0aGFuIG1heGltdW0gYWxsb3dlZCB2YWx1ZScpO1xuXG4gIGFzc2VydC5vayh2YWx1ZSA+PSBtaW4sICd2YWx1ZSBzbWFsbGVyIHRoYW4gbWluaW11bSBhbGxvd2VkIHZhbHVlJyk7XG5cbiAgYXNzZXJ0Lm9rKE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZSwgJ3ZhbHVlIGhhcyBhIGZyYWN0aW9uYWwgY29tcG9uZW50Jyk7XG59XG5cbmZ1bmN0aW9uIHZlcmlmSUVFRTc1NCh2YWx1ZSwgbWF4LCBtaW4pIHtcbiAgYXNzZXJ0Lm9rKHR5cGVvZiAodmFsdWUpID09ICdudW1iZXInLFxuICAgICAgJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKTtcblxuICBhc3NlcnQub2sodmFsdWUgPD0gbWF4LCAndmFsdWUgbGFyZ2VyIHRoYW4gbWF4aW11bSBhbGxvd2VkIHZhbHVlJyk7XG5cbiAgYXNzZXJ0Lm9rKHZhbHVlID49IG1pbiwgJ3ZhbHVlIHNtYWxsZXIgdGhhbiBtaW5pbXVtIGFsbG93ZWQgdmFsdWUnKTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YXIgYnVmZmVyID0gdGhpcztcblxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2YsIC0weDgwKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA+PSAwKSB7XG4gICAgYnVmZmVyLndyaXRlVUludDgodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpO1xuICB9IGVsc2Uge1xuICAgIGJ1ZmZlci53cml0ZVVJbnQ4KDB4ZmYgKyB2YWx1ZSArIDEsIG9mZnNldCwgbm9Bc3NlcnQpO1xuICB9XG59O1xuXG5mdW5jdGlvbiB3cml0ZUludDE2KGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3NpbmcgdmFsdWUnKTtcblxuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMSA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcblxuICAgIHZlcmlmc2ludCh2YWx1ZSwgMHg3ZmZmLCAtMHg4MDAwKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA+PSAwKSB7XG4gICAgd3JpdGVVSW50MTYoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpO1xuICB9IGVsc2Uge1xuICAgIHdyaXRlVUludDE2KGJ1ZmZlciwgMHhmZmZmICsgdmFsdWUgKyAxLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCk7XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVJbnQzMihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDMgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA+PSAwKSB7XG4gICAgd3JpdGVVSW50MzIoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpO1xuICB9IGVsc2Uge1xuICAgIHdyaXRlVUludDMyKGJ1ZmZlciwgMHhmZmZmZmZmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpO1xuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZJRUVFNzU0KHZhbHVlLCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOCk7XG4gIH1cblxuICByZXF1aXJlKCcuL2J1ZmZlcl9pZWVlNzU0Jykud3JpdGVJRUVFNzU0KGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sXG4gICAgICAyMywgNCk7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3NpbmcgdmFsdWUnKTtcblxuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgNyA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcblxuICAgIHZlcmlmSUVFRTc1NCh2YWx1ZSwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCk7XG4gIH1cblxuICByZXF1aXJlKCcuL2J1ZmZlcl9pZWVlNzU0Jykud3JpdGVJRUVFNzU0KGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sXG4gICAgICA1MiwgOCk7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50ODtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4O1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDg7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDg7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRTtcblxufSx7XCJhc3NlcnRcIjoxLFwiLi9idWZmZXJfaWVlZTc1NFwiOjgsXCJiYXNlNjQtanNcIjo5fV0sOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBsb29rdXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG5cblx0ZnVuY3Rpb24gYjY0VG9CeXRlQXJyYXkoYjY0KSB7XG5cdFx0dmFyIGksIGosIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnI7XG5cdFxuXHRcdGlmIChiNjQubGVuZ3RoICUgNCA+IDApIHtcblx0XHRcdHRocm93ICdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0Jztcblx0XHR9XG5cblx0XHQvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuXHRcdC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcblx0XHQvLyByZXByZXNlbnQgb25lIGJ5dGVcblx0XHQvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcblx0XHQvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG5cdFx0cGxhY2VIb2xkZXJzID0gYjY0LmluZGV4T2YoJz0nKTtcblx0XHRwbGFjZUhvbGRlcnMgPSBwbGFjZUhvbGRlcnMgPiAwID8gYjY0Lmxlbmd0aCAtIHBsYWNlSG9sZGVycyA6IDA7XG5cblx0XHQvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcblx0XHRhcnIgPSBbXTsvL25ldyBVaW50OEFycmF5KGI2NC5sZW5ndGggKiAzIC8gNCAtIHBsYWNlSG9sZGVycyk7XG5cblx0XHQvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG5cdFx0bCA9IHBsYWNlSG9sZGVycyA+IDAgPyBiNjQubGVuZ3RoIC0gNCA6IGI2NC5sZW5ndGg7XG5cblx0XHRmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG5cdFx0XHR0bXAgPSAobG9va3VwLmluZGV4T2YoYjY0W2ldKSA8PCAxOCkgfCAobG9va3VwLmluZGV4T2YoYjY0W2kgKyAxXSkgPDwgMTIpIHwgKGxvb2t1cC5pbmRleE9mKGI2NFtpICsgMl0pIDw8IDYpIHwgbG9va3VwLmluZGV4T2YoYjY0W2kgKyAzXSk7XG5cdFx0XHRhcnIucHVzaCgodG1wICYgMHhGRjAwMDApID4+IDE2KTtcblx0XHRcdGFyci5wdXNoKCh0bXAgJiAweEZGMDApID4+IDgpO1xuXHRcdFx0YXJyLnB1c2godG1wICYgMHhGRik7XG5cdFx0fVxuXG5cdFx0aWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuXHRcdFx0dG1wID0gKGxvb2t1cC5pbmRleE9mKGI2NFtpXSkgPDwgMikgfCAobG9va3VwLmluZGV4T2YoYjY0W2kgKyAxXSkgPj4gNCk7XG5cdFx0XHRhcnIucHVzaCh0bXAgJiAweEZGKTtcblx0XHR9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuXHRcdFx0dG1wID0gKGxvb2t1cC5pbmRleE9mKGI2NFtpXSkgPDwgMTApIHwgKGxvb2t1cC5pbmRleE9mKGI2NFtpICsgMV0pIDw8IDQpIHwgKGxvb2t1cC5pbmRleE9mKGI2NFtpICsgMl0pID4+IDIpO1xuXHRcdFx0YXJyLnB1c2goKHRtcCA+PiA4KSAmIDB4RkYpO1xuXHRcdFx0YXJyLnB1c2godG1wICYgMHhGRik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFycjtcblx0fVxuXG5cdGZ1bmN0aW9uIHVpbnQ4VG9CYXNlNjQodWludDgpIHtcblx0XHR2YXIgaSxcblx0XHRcdGV4dHJhQnl0ZXMgPSB1aW50OC5sZW5ndGggJSAzLCAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuXHRcdFx0b3V0cHV0ID0gXCJcIixcblx0XHRcdHRlbXAsIGxlbmd0aDtcblxuXHRcdGZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG5cdFx0XHRyZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICsgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICsgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gKyBsb29rdXBbbnVtICYgMHgzRl07XG5cdFx0fTtcblxuXHRcdC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcblx0XHRmb3IgKGkgPSAwLCBsZW5ndGggPSB1aW50OC5sZW5ndGggLSBleHRyYUJ5dGVzOyBpIDwgbGVuZ3RoOyBpICs9IDMpIHtcblx0XHRcdHRlbXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pO1xuXHRcdFx0b3V0cHV0ICs9IHRyaXBsZXRUb0Jhc2U2NCh0ZW1wKTtcblx0XHR9XG5cblx0XHQvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG5cdFx0c3dpdGNoIChleHRyYUJ5dGVzKSB7XG5cdFx0XHRjYXNlIDE6XG5cdFx0XHRcdHRlbXAgPSB1aW50OFt1aW50OC5sZW5ndGggLSAxXTtcblx0XHRcdFx0b3V0cHV0ICs9IGxvb2t1cFt0ZW1wID4+IDJdO1xuXHRcdFx0XHRvdXRwdXQgKz0gbG9va3VwWyh0ZW1wIDw8IDQpICYgMHgzRl07XG5cdFx0XHRcdG91dHB1dCArPSAnPT0nO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgMjpcblx0XHRcdFx0dGVtcCA9ICh1aW50OFt1aW50OC5sZW5ndGggLSAyXSA8PCA4KSArICh1aW50OFt1aW50OC5sZW5ndGggLSAxXSk7XG5cdFx0XHRcdG91dHB1dCArPSBsb29rdXBbdGVtcCA+PiAxMF07XG5cdFx0XHRcdG91dHB1dCArPSBsb29rdXBbKHRlbXAgPj4gNCkgJiAweDNGXTtcblx0XHRcdFx0b3V0cHV0ICs9IGxvb2t1cFsodGVtcCA8PCAyKSAmIDB4M0ZdO1xuXHRcdFx0XHRvdXRwdXQgKz0gJz0nO1xuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0bW9kdWxlLmV4cG9ydHMudG9CeXRlQXJyYXkgPSBiNjRUb0J5dGVBcnJheTtcblx0bW9kdWxlLmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IHVpbnQ4VG9CYXNlNjQ7XG59KCkpO1xuXG59LHt9XX0se30sW10pXG47O21vZHVsZS5leHBvcnRzPXJlcXVpcmUoXCJidWZmZXItYnJvd3NlcmlmeVwiKVxuIiwiKGZ1bmN0aW9uKEJ1ZmZlcil7XG4oZnVuY3Rpb24gKGdsb2JhbCwgbW9kdWxlKSB7XG5cbiAgaWYgKCd1bmRlZmluZWQnID09IHR5cGVvZiBtb2R1bGUpIHtcbiAgICB2YXIgbW9kdWxlID0geyBleHBvcnRzOiB7fSB9XG4gICAgICAsIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0c1xuICB9XG5cbiAgLyoqXG4gICAqIEV4cG9ydHMuXG4gICAqL1xuXG4gIG1vZHVsZS5leHBvcnRzID0gZXhwZWN0O1xuICBleHBlY3QuQXNzZXJ0aW9uID0gQXNzZXJ0aW9uO1xuXG4gIC8qKlxuICAgKiBFeHBvcnRzIHZlcnNpb24uXG4gICAqL1xuXG4gIGV4cGVjdC52ZXJzaW9uID0gJzAuMS4yJztcblxuICAvKipcbiAgICogUG9zc2libGUgYXNzZXJ0aW9uIGZsYWdzLlxuICAgKi9cblxuICB2YXIgZmxhZ3MgPSB7XG4gICAgICBub3Q6IFsndG8nLCAnYmUnLCAnaGF2ZScsICdpbmNsdWRlJywgJ29ubHknXVxuICAgICwgdG86IFsnYmUnLCAnaGF2ZScsICdpbmNsdWRlJywgJ29ubHknLCAnbm90J11cbiAgICAsIG9ubHk6IFsnaGF2ZSddXG4gICAgLCBoYXZlOiBbJ293biddXG4gICAgLCBiZTogWydhbiddXG4gIH07XG5cbiAgZnVuY3Rpb24gZXhwZWN0IChvYmopIHtcbiAgICByZXR1cm4gbmV3IEFzc2VydGlvbihvYmopO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cblxuICBmdW5jdGlvbiBBc3NlcnRpb24gKG9iaiwgZmxhZywgcGFyZW50KSB7XG4gICAgdGhpcy5vYmogPSBvYmo7XG4gICAgdGhpcy5mbGFncyA9IHt9O1xuXG4gICAgaWYgKHVuZGVmaW5lZCAhPSBwYXJlbnQpIHtcbiAgICAgIHRoaXMuZmxhZ3NbZmxhZ10gPSB0cnVlO1xuXG4gICAgICBmb3IgKHZhciBpIGluIHBhcmVudC5mbGFncykge1xuICAgICAgICBpZiAocGFyZW50LmZsYWdzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgdGhpcy5mbGFnc1tpXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgJGZsYWdzID0gZmxhZyA/IGZsYWdzW2ZsYWddIDoga2V5cyhmbGFncylcbiAgICAgICwgc2VsZiA9IHRoaXNcblxuICAgIGlmICgkZmxhZ3MpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gJGZsYWdzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAvLyBhdm9pZCByZWN1cnNpb25cbiAgICAgICAgaWYgKHRoaXMuZmxhZ3NbJGZsYWdzW2ldXSkgY29udGludWU7XG5cbiAgICAgICAgdmFyIG5hbWUgPSAkZmxhZ3NbaV1cbiAgICAgICAgICAsIGFzc2VydGlvbiA9IG5ldyBBc3NlcnRpb24odGhpcy5vYmosIG5hbWUsIHRoaXMpXG5cbiAgICAgICAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIEFzc2VydGlvbi5wcm90b3R5cGVbbmFtZV0pIHtcbiAgICAgICAgICAvLyBjbG9uZSB0aGUgZnVuY3Rpb24sIG1ha2Ugc3VyZSB3ZSBkb250IHRvdWNoIHRoZSBwcm90IHJlZmVyZW5jZVxuICAgICAgICAgIHZhciBvbGQgPSB0aGlzW25hbWVdO1xuICAgICAgICAgIHRoaXNbbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gb2xkLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgZm4gaW4gQXNzZXJ0aW9uLnByb3RvdHlwZSkge1xuICAgICAgICAgICAgaWYgKEFzc2VydGlvbi5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoZm4pICYmIGZuICE9IG5hbWUpIHtcbiAgICAgICAgICAgICAgdGhpc1tuYW1lXVtmbl0gPSBiaW5kKGFzc2VydGlvbltmbl0sIGFzc2VydGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXNbbmFtZV0gPSBhc3NlcnRpb247XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGFuIGFzc2VydGlvblxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG5cbiAgQXNzZXJ0aW9uLnByb3RvdHlwZS5hc3NlcnQgPSBmdW5jdGlvbiAodHJ1dGgsIG1zZywgZXJyb3IpIHtcbiAgICB2YXIgbXNnID0gdGhpcy5mbGFncy5ub3QgPyBlcnJvciA6IG1zZ1xuICAgICAgLCBvayA9IHRoaXMuZmxhZ3Mubm90ID8gIXRydXRoIDogdHJ1dGg7XG5cbiAgICBpZiAoIW9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobXNnLmNhbGwodGhpcykpO1xuICAgIH1cblxuICAgIHRoaXMuYW5kID0gbmV3IEFzc2VydGlvbih0aGlzLm9iaik7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSB2YWx1ZSBpcyB0cnV0aHlcbiAgICpcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLnByb3RvdHlwZS5vayA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgISF0aGlzLm9ialxuICAgICAgLCBmdW5jdGlvbigpeyByZXR1cm4gJ2V4cGVjdGVkICcgKyBpKHRoaXMub2JqKSArICcgdG8gYmUgdHJ1dGh5JyB9XG4gICAgICAsIGZ1bmN0aW9uKCl7IHJldHVybiAnZXhwZWN0ZWQgJyArIGkodGhpcy5vYmopICsgJyB0byBiZSBmYWxzeScgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFzc2VydCB0aGF0IHRoZSBmdW5jdGlvbiB0aHJvd3MuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb258UmVnRXhwfSBjYWxsYmFjaywgb3IgcmVnZXhwIHRvIG1hdGNoIGVycm9yIHN0cmluZyBhZ2FpbnN0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5wcm90b3R5cGUudGhyb3dFcnJvciA9XG4gIEFzc2VydGlvbi5wcm90b3R5cGUudGhyb3dFeGNlcHRpb24gPSBmdW5jdGlvbiAoZm4pIHtcbiAgICBleHBlY3QodGhpcy5vYmopLnRvLmJlLmEoJ2Z1bmN0aW9uJyk7XG5cbiAgICB2YXIgdGhyb3duID0gZmFsc2VcbiAgICAgICwgbm90ID0gdGhpcy5mbGFncy5ub3RcblxuICAgIHRyeSB7XG4gICAgICB0aGlzLm9iaigpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBmbikge1xuICAgICAgICBmbihlKTtcbiAgICAgIH0gZWxzZSBpZiAoJ29iamVjdCcgPT0gdHlwZW9mIGZuKSB7XG4gICAgICAgIHZhciBzdWJqZWN0ID0gJ3N0cmluZycgPT0gdHlwZW9mIGUgPyBlIDogZS5tZXNzYWdlO1xuICAgICAgICBpZiAobm90KSB7XG4gICAgICAgICAgZXhwZWN0KHN1YmplY3QpLnRvLm5vdC5tYXRjaChmbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXhwZWN0KHN1YmplY3QpLnRvLm1hdGNoKGZuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhyb3duID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoJ29iamVjdCcgPT0gdHlwZW9mIGZuICYmIG5vdCkge1xuICAgICAgLy8gaW4gdGhlIHByZXNlbmNlIG9mIGEgbWF0Y2hlciwgZW5zdXJlIHRoZSBgbm90YCBvbmx5IGFwcGxpZXMgdG9cbiAgICAgIC8vIHRoZSBtYXRjaGluZy5cbiAgICAgIHRoaXMuZmxhZ3Mubm90ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIG5hbWUgPSB0aGlzLm9iai5uYW1lIHx8ICdmbic7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIHRocm93blxuICAgICAgLCBmdW5jdGlvbigpeyByZXR1cm4gJ2V4cGVjdGVkICcgKyBuYW1lICsgJyB0byB0aHJvdyBhbiBleGNlcHRpb24nIH1cbiAgICAgICwgZnVuY3Rpb24oKXsgcmV0dXJuICdleHBlY3RlZCAnICsgbmFtZSArICcgbm90IHRvIHRocm93IGFuIGV4Y2VwdGlvbicgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgYXJyYXkgaXMgZW1wdHkuXG4gICAqXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5wcm90b3R5cGUuZW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4cGVjdGF0aW9uO1xuXG4gICAgaWYgKCdvYmplY3QnID09IHR5cGVvZiB0aGlzLm9iaiAmJiBudWxsICE9PSB0aGlzLm9iaiAmJiAhaXNBcnJheSh0aGlzLm9iaikpIHtcbiAgICAgIGlmICgnbnVtYmVyJyA9PSB0eXBlb2YgdGhpcy5vYmoubGVuZ3RoKSB7XG4gICAgICAgIGV4cGVjdGF0aW9uID0gIXRoaXMub2JqLmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4cGVjdGF0aW9uID0gIWtleXModGhpcy5vYmopLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCdzdHJpbmcnICE9IHR5cGVvZiB0aGlzLm9iaikge1xuICAgICAgICBleHBlY3QodGhpcy5vYmopLnRvLmJlLmFuKCdvYmplY3QnKTtcbiAgICAgIH1cblxuICAgICAgZXhwZWN0KHRoaXMub2JqKS50by5oYXZlLnByb3BlcnR5KCdsZW5ndGgnKTtcbiAgICAgIGV4cGVjdGF0aW9uID0gIXRoaXMub2JqLmxlbmd0aDtcbiAgICB9XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgZXhwZWN0YXRpb25cbiAgICAgICwgZnVuY3Rpb24oKXsgcmV0dXJuICdleHBlY3RlZCAnICsgaSh0aGlzLm9iaikgKyAnIHRvIGJlIGVtcHR5JyB9XG4gICAgICAsIGZ1bmN0aW9uKCl7IHJldHVybiAnZXhwZWN0ZWQgJyArIGkodGhpcy5vYmopICsgJyB0byBub3QgYmUgZW1wdHknIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIG9iaiBleGFjdGx5IGVxdWFscyBhbm90aGVyLlxuICAgKlxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24ucHJvdG90eXBlLmJlID1cbiAgQXNzZXJ0aW9uLnByb3RvdHlwZS5lcXVhbCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgb2JqID09PSB0aGlzLm9ialxuICAgICAgLCBmdW5jdGlvbigpeyByZXR1cm4gJ2V4cGVjdGVkICcgKyBpKHRoaXMub2JqKSArICcgdG8gZXF1YWwgJyArIGkob2JqKSB9XG4gICAgICAsIGZ1bmN0aW9uKCl7IHJldHVybiAnZXhwZWN0ZWQgJyArIGkodGhpcy5vYmopICsgJyB0byBub3QgZXF1YWwgJyArIGkob2JqKSB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBvYmogc29ydG9mIGVxdWFscyBhbm90aGVyLlxuICAgKlxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24ucHJvdG90eXBlLmVxbCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgZXhwZWN0LmVxbChvYmosIHRoaXMub2JqKVxuICAgICAgLCBmdW5jdGlvbigpeyByZXR1cm4gJ2V4cGVjdGVkICcgKyBpKHRoaXMub2JqKSArICcgdG8gc29ydCBvZiBlcXVhbCAnICsgaShvYmopIH1cbiAgICAgICwgZnVuY3Rpb24oKXsgcmV0dXJuICdleHBlY3RlZCAnICsgaSh0aGlzLm9iaikgKyAnIHRvIHNvcnQgb2Ygbm90IGVxdWFsICcgKyBpKG9iaikgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFzc2VydCB3aXRoaW4gc3RhcnQgdG8gZmluaXNoIChpbmNsdXNpdmUpLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZpbmlzaFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24ucHJvdG90eXBlLndpdGhpbiA9IGZ1bmN0aW9uIChzdGFydCwgZmluaXNoKSB7XG4gICAgdmFyIHJhbmdlID0gc3RhcnQgKyAnLi4nICsgZmluaXNoO1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICB0aGlzLm9iaiA+PSBzdGFydCAmJiB0aGlzLm9iaiA8PSBmaW5pc2hcbiAgICAgICwgZnVuY3Rpb24oKXsgcmV0dXJuICdleHBlY3RlZCAnICsgaSh0aGlzLm9iaikgKyAnIHRvIGJlIHdpdGhpbiAnICsgcmFuZ2UgfVxuICAgICAgLCBmdW5jdGlvbigpeyByZXR1cm4gJ2V4cGVjdGVkICcgKyBpKHRoaXMub2JqKSArICcgdG8gbm90IGJlIHdpdGhpbiAnICsgcmFuZ2UgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFzc2VydCB0eXBlb2YgLyBpbnN0YW5jZSBvZlxuICAgKlxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24ucHJvdG90eXBlLmEgPVxuICBBc3NlcnRpb24ucHJvdG90eXBlLmFuID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIHR5cGUpIHtcbiAgICAgIC8vIHByb3BlciBlbmdsaXNoIGluIGVycm9yIG1zZ1xuICAgICAgdmFyIG4gPSAvXlthZWlvdV0vLnRlc3QodHlwZSkgPyAnbicgOiAnJztcblxuICAgICAgLy8gdHlwZW9mIHdpdGggc3VwcG9ydCBmb3IgJ2FycmF5J1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgJ2FycmF5JyA9PSB0eXBlID8gaXNBcnJheSh0aGlzLm9iaikgOlxuICAgICAgICAgICAgJ29iamVjdCcgPT0gdHlwZVxuICAgICAgICAgICAgICA/ICdvYmplY3QnID09IHR5cGVvZiB0aGlzLm9iaiAmJiBudWxsICE9PSB0aGlzLm9ialxuICAgICAgICAgICAgICA6IHR5cGUgPT0gdHlwZW9mIHRoaXMub2JqXG4gICAgICAgICwgZnVuY3Rpb24oKXsgcmV0dXJuICdleHBlY3RlZCAnICsgaSh0aGlzLm9iaikgKyAnIHRvIGJlIGEnICsgbiArICcgJyArIHR5cGUgfVxuICAgICAgICAsIGZ1bmN0aW9uKCl7IHJldHVybiAnZXhwZWN0ZWQgJyArIGkodGhpcy5vYmopICsgJyBub3QgdG8gYmUgYScgKyBuICsgJyAnICsgdHlwZSB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaW5zdGFuY2VvZlxuICAgICAgdmFyIG5hbWUgPSB0eXBlLm5hbWUgfHwgJ3N1cHBsaWVkIGNvbnN0cnVjdG9yJztcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIHRoaXMub2JqIGluc3RhbmNlb2YgdHlwZVxuICAgICAgICAsIGZ1bmN0aW9uKCl7IHJldHVybiAnZXhwZWN0ZWQgJyArIGkodGhpcy5vYmopICsgJyB0byBiZSBhbiBpbnN0YW5jZSBvZiAnICsgbmFtZSB9XG4gICAgICAgICwgZnVuY3Rpb24oKXsgcmV0dXJuICdleHBlY3RlZCAnICsgaSh0aGlzLm9iaikgKyAnIG5vdCB0byBiZSBhbiBpbnN0YW5jZSBvZiAnICsgbmFtZSB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQXNzZXJ0IG51bWVyaWMgdmFsdWUgYWJvdmUgX25fLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gblxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24ucHJvdG90eXBlLmdyZWF0ZXJUaGFuID1cbiAgQXNzZXJ0aW9uLnByb3RvdHlwZS5hYm92ZSA9IGZ1bmN0aW9uIChuKSB7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIHRoaXMub2JqID4gblxuICAgICAgLCBmdW5jdGlvbigpeyByZXR1cm4gJ2V4cGVjdGVkICcgKyBpKHRoaXMub2JqKSArICcgdG8gYmUgYWJvdmUgJyArIG4gfVxuICAgICAgLCBmdW5jdGlvbigpeyByZXR1cm4gJ2V4cGVjdGVkICcgKyBpKHRoaXMub2JqKSArICcgdG8gYmUgYmVsb3cgJyArIG4gfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFzc2VydCBudW1lcmljIHZhbHVlIGJlbG93IF9uXy5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLnByb3RvdHlwZS5sZXNzVGhhbiA9XG4gIEFzc2VydGlvbi5wcm90b3R5cGUuYmVsb3cgPSBmdW5jdGlvbiAobikge1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICB0aGlzLm9iaiA8IG5cbiAgICAgICwgZnVuY3Rpb24oKXsgcmV0dXJuICdleHBlY3RlZCAnICsgaSh0aGlzLm9iaikgKyAnIHRvIGJlIGJlbG93ICcgKyBuIH1cbiAgICAgICwgZnVuY3Rpb24oKXsgcmV0dXJuICdleHBlY3RlZCAnICsgaSh0aGlzLm9iaikgKyAnIHRvIGJlIGFib3ZlICcgKyBuIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBc3NlcnQgc3RyaW5nIHZhbHVlIG1hdGNoZXMgX3JlZ2V4cF8uXG4gICAqXG4gICAqIEBwYXJhbSB7UmVnRXhwfSByZWdleHBcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uIChyZWdleHApIHtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgcmVnZXhwLmV4ZWModGhpcy5vYmopXG4gICAgICAsIGZ1bmN0aW9uKCl7IHJldHVybiAnZXhwZWN0ZWQgJyArIGkodGhpcy5vYmopICsgJyB0byBtYXRjaCAnICsgcmVnZXhwIH1cbiAgICAgICwgZnVuY3Rpb24oKXsgcmV0dXJuICdleHBlY3RlZCAnICsgaSh0aGlzLm9iaikgKyAnIG5vdCB0byBtYXRjaCAnICsgcmVnZXhwIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBc3NlcnQgcHJvcGVydHkgXCJsZW5ndGhcIiBleGlzdHMgYW5kIGhhcyB2YWx1ZSBvZiBfbl8uXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gKG4pIHtcbiAgICBleHBlY3QodGhpcy5vYmopLnRvLmhhdmUucHJvcGVydHkoJ2xlbmd0aCcpO1xuICAgIHZhciBsZW4gPSB0aGlzLm9iai5sZW5ndGg7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIG4gPT0gbGVuXG4gICAgICAsIGZ1bmN0aW9uKCl7IHJldHVybiAnZXhwZWN0ZWQgJyArIGkodGhpcy5vYmopICsgJyB0byBoYXZlIGEgbGVuZ3RoIG9mICcgKyBuICsgJyBidXQgZ290ICcgKyBsZW4gfVxuICAgICAgLCBmdW5jdGlvbigpeyByZXR1cm4gJ2V4cGVjdGVkICcgKyBpKHRoaXMub2JqKSArICcgdG8gbm90IGhhdmUgYSBsZW5ndGggb2YgJyArIGxlbiB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQXNzZXJ0IHByb3BlcnR5IF9uYW1lXyBleGlzdHMsIHdpdGggb3B0aW9uYWwgX3ZhbF8uXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24ucHJvdG90eXBlLnByb3BlcnR5ID0gZnVuY3Rpb24gKG5hbWUsIHZhbCkge1xuICAgIGlmICh0aGlzLmZsYWdzLm93bikge1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMub2JqLCBuYW1lKVxuICAgICAgICAsIGZ1bmN0aW9uKCl7IHJldHVybiAnZXhwZWN0ZWQgJyArIGkodGhpcy5vYmopICsgJyB0byBoYXZlIG93biBwcm9wZXJ0eSAnICsgaShuYW1lKSB9XG4gICAgICAgICwgZnVuY3Rpb24oKXsgcmV0dXJuICdleHBlY3RlZCAnICsgaSh0aGlzLm9iaikgKyAnIHRvIG5vdCBoYXZlIG93biBwcm9wZXJ0eSAnICsgaShuYW1lKSB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZsYWdzLm5vdCAmJiB1bmRlZmluZWQgIT09IHZhbCkge1xuICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gdGhpcy5vYmpbbmFtZV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGkodGhpcy5vYmopICsgJyBoYXMgbm8gcHJvcGVydHkgJyArIGkobmFtZSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaGFzUHJvcDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGhhc1Byb3AgPSBuYW1lIGluIHRoaXMub2JqXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGhhc1Byb3AgPSB1bmRlZmluZWQgIT09IHRoaXMub2JqW25hbWVdXG4gICAgICB9XG5cbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIGhhc1Byb3BcbiAgICAgICAgLCBmdW5jdGlvbigpeyByZXR1cm4gJ2V4cGVjdGVkICcgKyBpKHRoaXMub2JqKSArICcgdG8gaGF2ZSBhIHByb3BlcnR5ICcgKyBpKG5hbWUpIH1cbiAgICAgICAgLCBmdW5jdGlvbigpeyByZXR1cm4gJ2V4cGVjdGVkICcgKyBpKHRoaXMub2JqKSArICcgdG8gbm90IGhhdmUgYSBwcm9wZXJ0eSAnICsgaShuYW1lKSB9KTtcbiAgICB9XG5cbiAgICBpZiAodW5kZWZpbmVkICE9PSB2YWwpIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIHZhbCA9PT0gdGhpcy5vYmpbbmFtZV1cbiAgICAgICAgLCBmdW5jdGlvbigpeyByZXR1cm4gJ2V4cGVjdGVkICcgKyBpKHRoaXMub2JqKSArICcgdG8gaGF2ZSBhIHByb3BlcnR5ICcgKyBpKG5hbWUpXG4gICAgICAgICAgKyAnIG9mICcgKyBpKHZhbCkgKyAnLCBidXQgZ290ICcgKyBpKHRoaXMub2JqW25hbWVdKSB9XG4gICAgICAgICwgZnVuY3Rpb24oKXsgcmV0dXJuICdleHBlY3RlZCAnICsgaSh0aGlzLm9iaikgKyAnIHRvIG5vdCBoYXZlIGEgcHJvcGVydHkgJyArIGkobmFtZSlcbiAgICAgICAgICArICcgb2YgJyArIGkodmFsKSB9KTtcbiAgICB9XG5cbiAgICB0aGlzLm9iaiA9IHRoaXMub2JqW25hbWVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBc3NlcnQgdGhhdCB0aGUgYXJyYXkgY29udGFpbnMgX29ial8gb3Igc3RyaW5nIGNvbnRhaW5zIF9vYmpfLlxuICAgKlxuICAgKiBAcGFyYW0ge01peGVkfSBvYmp8c3RyaW5nXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5wcm90b3R5cGUuc3RyaW5nID1cbiAgQXNzZXJ0aW9uLnByb3RvdHlwZS5jb250YWluID0gZnVuY3Rpb24gKG9iaikge1xuICAgIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgdGhpcy5vYmopIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIH50aGlzLm9iai5pbmRleE9mKG9iailcbiAgICAgICAgLCBmdW5jdGlvbigpeyByZXR1cm4gJ2V4cGVjdGVkICcgKyBpKHRoaXMub2JqKSArICcgdG8gY29udGFpbiAnICsgaShvYmopIH1cbiAgICAgICAgLCBmdW5jdGlvbigpeyByZXR1cm4gJ2V4cGVjdGVkICcgKyBpKHRoaXMub2JqKSArICcgdG8gbm90IGNvbnRhaW4gJyArIGkob2JqKSB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgfmluZGV4T2YodGhpcy5vYmosIG9iailcbiAgICAgICAgLCBmdW5jdGlvbigpeyByZXR1cm4gJ2V4cGVjdGVkICcgKyBpKHRoaXMub2JqKSArICcgdG8gY29udGFpbiAnICsgaShvYmopIH1cbiAgICAgICAgLCBmdW5jdGlvbigpeyByZXR1cm4gJ2V4cGVjdGVkICcgKyBpKHRoaXMub2JqKSArICcgdG8gbm90IGNvbnRhaW4gJyArIGkob2JqKSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFzc2VydCBleGFjdCBrZXlzIG9yIGluY2x1c2lvbiBvZiBrZXlzIGJ5IHVzaW5nXG4gICAqIHRoZSBgLm93bmAgbW9kaWZpZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nIC4uLn0ga2V5c1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24ucHJvdG90eXBlLmtleSA9XG4gIEFzc2VydGlvbi5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uICgka2V5cykge1xuICAgIHZhciBzdHJcbiAgICAgICwgb2sgPSB0cnVlO1xuXG4gICAgJGtleXMgPSBpc0FycmF5KCRrZXlzKVxuICAgICAgPyAka2V5c1xuICAgICAgOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gICAgaWYgKCEka2V5cy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcigna2V5cyByZXF1aXJlZCcpO1xuXG4gICAgdmFyIGFjdHVhbCA9IGtleXModGhpcy5vYmopXG4gICAgICAsIGxlbiA9ICRrZXlzLmxlbmd0aDtcblxuICAgIC8vIEluY2x1c2lvblxuICAgIG9rID0gZXZlcnkoJGtleXMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiB+aW5kZXhPZihhY3R1YWwsIGtleSk7XG4gICAgfSk7XG5cbiAgICAvLyBTdHJpY3RcbiAgICBpZiAoIXRoaXMuZmxhZ3Mubm90ICYmIHRoaXMuZmxhZ3Mub25seSkge1xuICAgICAgb2sgPSBvayAmJiAka2V5cy5sZW5ndGggPT0gYWN0dWFsLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBLZXkgc3RyaW5nXG4gICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICRrZXlzID0gbWFwKCRrZXlzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBpKGtleSk7XG4gICAgICB9KTtcbiAgICAgIHZhciBsYXN0ID0gJGtleXMucG9wKCk7XG4gICAgICBzdHIgPSAka2V5cy5qb2luKCcsICcpICsgJywgYW5kICcgKyBsYXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBpKCRrZXlzWzBdKTtcbiAgICB9XG5cbiAgICAvLyBGb3JtXG4gICAgc3RyID0gKGxlbiA+IDEgPyAna2V5cyAnIDogJ2tleSAnKSArIHN0cjtcblxuICAgIC8vIEhhdmUgLyBpbmNsdWRlXG4gICAgc3RyID0gKCF0aGlzLmZsYWdzLm9ubHkgPyAnaW5jbHVkZSAnIDogJ29ubHkgaGF2ZSAnKSArIHN0cjtcblxuICAgIC8vIEFzc2VydGlvblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBva1xuICAgICAgLCBmdW5jdGlvbigpeyByZXR1cm4gJ2V4cGVjdGVkICcgKyBpKHRoaXMub2JqKSArICcgdG8gJyArIHN0ciB9XG4gICAgICAsIGZ1bmN0aW9uKCl7IHJldHVybiAnZXhwZWN0ZWQgJyArIGkodGhpcy5vYmopICsgJyB0byBub3QgJyArIHN0ciB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogQXNzZXJ0IGEgZmFpbHVyZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmcgLi4ufSBjdXN0b20gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cbiAgQXNzZXJ0aW9uLnByb3RvdHlwZS5mYWlsID0gZnVuY3Rpb24gKG1zZykge1xuICAgIG1zZyA9IG1zZyB8fCBcImV4cGxpY2l0IGZhaWx1cmVcIjtcbiAgICB0aGlzLmFzc2VydChmYWxzZSwgbXNnLCBtc2cpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiBiaW5kIGltcGxlbWVudGF0aW9uLlxuICAgKi9cblxuICBmdW5jdGlvbiBiaW5kIChmbiwgc2NvcGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZuLmFwcGx5KHNjb3BlLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBcnJheSBldmVyeSBjb21wYXRpYmlsaXR5XG4gICAqXG4gICAqIEBzZWUgYml0Lmx5LzVGcTFOMlxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBldmVyeSAoYXJyLCBmbiwgdGhpc09iaikge1xuICAgIHZhciBzY29wZSA9IHRoaXNPYmogfHwgZ2xvYmFsO1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gYXJyLmxlbmd0aDsgaSA8IGo7ICsraSkge1xuICAgICAgaWYgKCFmbi5jYWxsKHNjb3BlLCBhcnJbaV0sIGksIGFycikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogQXJyYXkgaW5kZXhPZiBjb21wYXRpYmlsaXR5LlxuICAgKlxuICAgKiBAc2VlIGJpdC5seS9hNUR4YTJcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gaW5kZXhPZiAoYXJyLCBvLCBpKSB7XG4gICAgaWYgKEFycmF5LnByb3RvdHlwZS5pbmRleE9mKSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChhcnIsIG8sIGkpO1xuICAgIH1cblxuICAgIGlmIChhcnIubGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBqID0gYXJyLmxlbmd0aCwgaSA9IGkgPCAwID8gaSArIGogPCAwID8gMCA6IGkgKyBqIDogaSB8fCAwXG4gICAgICAgIDsgaSA8IGogJiYgYXJyW2ldICE9PSBvOyBpKyspO1xuXG4gICAgcmV0dXJuIGogPD0gaSA/IC0xIDogaTtcbiAgfTtcblxuICAvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS8xMDQ0MTI4L1xuICB2YXIgZ2V0T3V0ZXJIVE1MID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIGlmICgnb3V0ZXJIVE1MJyBpbiBlbGVtZW50KSByZXR1cm4gZWxlbWVudC5vdXRlckhUTUw7XG4gICAgdmFyIG5zID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI7XG4gICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhucywgJ18nKTtcbiAgICB2YXIgZWxlbVByb3RvID0gKHdpbmRvdy5IVE1MRWxlbWVudCB8fCB3aW5kb3cuRWxlbWVudCkucHJvdG90eXBlO1xuICAgIHZhciB4bWxTZXJpYWxpemVyID0gbmV3IFhNTFNlcmlhbGl6ZXIoKTtcbiAgICB2YXIgaHRtbDtcbiAgICBpZiAoZG9jdW1lbnQueG1sVmVyc2lvbikge1xuICAgICAgcmV0dXJuIHhtbFNlcmlhbGl6ZXIuc2VyaWFsaXplVG9TdHJpbmcoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbGVtZW50LmNsb25lTm9kZShmYWxzZSkpO1xuICAgICAgaHRtbCA9IGNvbnRhaW5lci5pbm5lckhUTUwucmVwbGFjZSgnPjwnLCAnPicgKyBlbGVtZW50LmlubmVySFRNTCArICc8Jyk7XG4gICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gJyc7XG4gICAgICByZXR1cm4gaHRtbDtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmV0dXJucyB0cnVlIGlmIG9iamVjdCBpcyBhIERPTSBlbGVtZW50LlxuICB2YXIgaXNET01FbGVtZW50ID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIGlmICh0eXBlb2YgSFRNTEVsZW1lbnQgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBvYmplY3QgJiZcbiAgICAgICAgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgb2JqZWN0Lm5vZGVUeXBlID09PSAxICYmXG4gICAgICAgIHR5cGVvZiBvYmplY3Qubm9kZU5hbWUgPT09ICdzdHJpbmcnO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSW5zcGVjdHMgYW4gb2JqZWN0LlxuICAgKlxuICAgKiBAc2VlIHRha2VuIGZyb20gbm9kZS5qcyBgdXRpbGAgbW9kdWxlIChjb3B5cmlnaHQgSm95ZW50LCBNSVQgbGljZW5zZSlcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGkgKG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgpIHtcbiAgICB2YXIgc2VlbiA9IFtdO1xuXG4gICAgZnVuY3Rpb24gc3R5bGl6ZSAoc3RyKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBmb3JtYXQgKHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgICAgIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgICAgIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5pbnNwZWN0ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICAgICAgdmFsdWUgIT09IGV4cG9ydHMgJiZcbiAgICAgICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICAgIHJldHVybiBzdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG5cbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBqc29uLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICAgICAgICByZXR1cm4gc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcblxuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgIHJldHVybiBzdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcblxuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICByZXR1cm4gc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAgICAgfVxuICAgICAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzdHlsaXplKCdudWxsJywgJ251bGwnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRE9NRWxlbWVudCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGdldE91dGVySFRNTCh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgICAgIHZhciB2aXNpYmxlX2tleXMgPSBrZXlzKHZhbHVlKTtcbiAgICAgIHZhciAka2V5cyA9IHNob3dIaWRkZW4gPyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSkgOiB2aXNpYmxlX2tleXM7XG5cbiAgICAgIC8vIEZ1bmN0aW9ucyB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiAka2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBzdHlsaXplKCcnICsgdmFsdWUsICdyZWdleHAnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgICAgIHJldHVybiBzdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBEYXRlcyB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkXG4gICAgICBpZiAoaXNEYXRlKHZhbHVlKSAmJiAka2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHN0eWxpemUodmFsdWUudG9VVENTdHJpbmcoKSwgJ2RhdGUnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGJhc2UsIHR5cGUsIGJyYWNlcztcbiAgICAgIC8vIERldGVybWluZSB0aGUgb2JqZWN0IHR5cGVcbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB0eXBlID0gJ0FycmF5JztcbiAgICAgICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGUgPSAnT2JqZWN0JztcbiAgICAgICAgYnJhY2VzID0gWyd7JywgJ30nXTtcbiAgICAgIH1cblxuICAgICAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICAgIGJhc2UgPSAoaXNSZWdFeHAodmFsdWUpKSA/ICcgJyArIHZhbHVlIDogJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhc2UgPSAnJztcbiAgICAgIH1cblxuICAgICAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gICAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgICBiYXNlID0gJyAnICsgdmFsdWUudG9VVENTdHJpbmcoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCRrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICAgICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBzdHlsaXplKCcnICsgdmFsdWUsICdyZWdleHAnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgICAgIHZhciBvdXRwdXQgPSBtYXAoJGtleXMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIG5hbWUsIHN0cjtcbiAgICAgICAgaWYgKHZhbHVlLl9fbG9va3VwR2V0dGVyX18pIHtcbiAgICAgICAgICBpZiAodmFsdWUuX19sb29rdXBHZXR0ZXJfXyhrZXkpKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUuX19sb29rdXBTZXR0ZXJfXyhrZXkpKSB7XG4gICAgICAgICAgICAgIHN0ciA9IHN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHIgPSBzdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5fX2xvb2t1cFNldHRlcl9fKGtleSkpIHtcbiAgICAgICAgICAgICAgc3RyID0gc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kZXhPZih2aXNpYmxlX2tleXMsIGtleSkgPCAwKSB7XG4gICAgICAgICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0cikge1xuICAgICAgICAgIGlmIChpbmRleE9mKHNlZW4sIHZhbHVlW2tleV0pIDwgMCkge1xuICAgICAgICAgICAgaWYgKHJlY3Vyc2VUaW1lcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBzdHIgPSBmb3JtYXQodmFsdWVba2V5XSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHIgPSBmb3JtYXQodmFsdWVba2V5XSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgc3RyID0gbWFwKHN0ci5zcGxpdCgnXFxuJyksIGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0ciA9ICdcXG4nICsgbWFwKHN0ci5zcGxpdCgnXFxuJyksIGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0ciA9IHN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdBcnJheScgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmFtZSA9IGpzb24uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICAgICAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgICAgICAgbmFtZSA9IHN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICAgICAgICBuYW1lID0gc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xuICAgICAgfSk7XG5cbiAgICAgIHNlZW4ucG9wKCk7XG5cbiAgICAgIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gICAgICB2YXIgbGVuZ3RoID0gcmVkdWNlKG91dHB1dCwgZnVuY3Rpb24gKHByZXYsIGN1cikge1xuICAgICAgICBudW1MaW5lc0VzdCsrO1xuICAgICAgICBpZiAoaW5kZXhPZihjdXIsICdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgICAgICByZXR1cm4gcHJldiArIGN1ci5sZW5ndGggKyAxO1xuICAgICAgfSwgMCk7XG5cbiAgICAgIGlmIChsZW5ndGggPiA1MCkge1xuICAgICAgICBvdXRwdXQgPSBicmFjZXNbMF0gK1xuICAgICAgICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgICAgICAgYnJhY2VzWzFdO1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXRwdXQgPSBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIHJldHVybiBmb3JtYXQob2JqLCAodHlwZW9mIGRlcHRoID09PSAndW5kZWZpbmVkJyA/IDIgOiBkZXB0aCkpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGlzQXJyYXkgKGFyKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcikgPT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcblxuICBmdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICAgIHZhciBzO1xuICAgIHRyeSB7XG4gICAgICBzID0gJycgKyByZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlIGluc3RhbmNlb2YgUmVnRXhwIHx8IC8vIGVhc3kgY2FzZVxuICAgICAgICAgICAvLyBkdWNrLXR5cGUgZm9yIGNvbnRleHQtc3dpdGNoaW5nIGV2YWxjeCBjYXNlXG4gICAgICAgICAgIHR5cGVvZihyZSkgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgcmUuY29uc3RydWN0b3IubmFtZSA9PT0gJ1JlZ0V4cCcgJiZcbiAgICAgICAgICAgcmUuY29tcGlsZSAmJlxuICAgICAgICAgICByZS50ZXN0ICYmXG4gICAgICAgICAgIHJlLmV4ZWMgJiZcbiAgICAgICAgICAgcy5tYXRjaCgvXlxcLy4qXFwvW2dpbV17MCwzfSQvKTtcbiAgfTtcblxuICBmdW5jdGlvbiBpc0RhdGUoZCkge1xuICAgIGlmIChkIGluc3RhbmNlb2YgRGF0ZSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGtleXMgKG9iaikge1xuICAgIGlmIChPYmplY3Qua2V5cykge1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaik7XG4gICAgfVxuXG4gICAgdmFyIGtleXMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIHtcbiAgICAgICAga2V5cy5wdXNoKGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBrZXlzO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFwIChhcnIsIG1hcHBlciwgdGhhdCkge1xuICAgIGlmIChBcnJheS5wcm90b3R5cGUubWFwKSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKGFyciwgbWFwcGVyLCB0aGF0KTtcbiAgICB9XG5cbiAgICB2YXIgb3RoZXI9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGk9IDAsIG4gPSBhcnIubGVuZ3RoOyBpPG47IGkrKylcbiAgICAgIGlmIChpIGluIGFycilcbiAgICAgICAgb3RoZXJbaV0gPSBtYXBwZXIuY2FsbCh0aGF0LCBhcnJbaV0sIGksIGFycik7XG5cbiAgICByZXR1cm4gb3RoZXI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcmVkdWNlIChhcnIsIGZ1bikge1xuICAgIGlmIChBcnJheS5wcm90b3R5cGUucmVkdWNlKSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnJlZHVjZS5hcHBseShcbiAgICAgICAgICBhcnJcbiAgICAgICAgLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciBsZW4gPSArdGhpcy5sZW5ndGg7XG5cbiAgICBpZiAodHlwZW9mIGZ1biAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuXG4gICAgLy8gbm8gdmFsdWUgdG8gcmV0dXJuIGlmIG5vIGluaXRpYWwgdmFsdWUgYW5kIGFuIGVtcHR5IGFycmF5XG4gICAgaWYgKGxlbiA9PT0gMCAmJiBhcmd1bWVudHMubGVuZ3RoID09PSAxKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuXG4gICAgdmFyIGkgPSAwO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDIpIHtcbiAgICAgIHZhciBydiA9IGFyZ3VtZW50c1sxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG8ge1xuICAgICAgICBpZiAoaSBpbiB0aGlzKSB7XG4gICAgICAgICAgcnYgPSB0aGlzW2krK107XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBhcnJheSBjb250YWlucyBubyB2YWx1ZXMsIG5vIGluaXRpYWwgdmFsdWUgdG8gcmV0dXJuXG4gICAgICAgIGlmICgrK2kgPj0gbGVuKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgIH0gd2hpbGUgKHRydWUpO1xuICAgIH1cblxuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChpIGluIHRoaXMpXG4gICAgICAgIHJ2ID0gZnVuLmNhbGwobnVsbCwgcnYsIHRoaXNbaV0sIGksIHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiBydjtcbiAgfTtcblxuICAvKipcbiAgICogQXNzZXJ0cyBkZWVwIGVxdWFsaXR5XG4gICAqXG4gICAqIEBzZWUgdGFrZW4gZnJvbSBub2RlLmpzIGBhc3NlcnRgIG1vZHVsZSAoY29weXJpZ2h0IEpveWVudCwgTUlUIGxpY2Vuc2UpXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cblxuICBleHBlY3QuZXFsID0gZnVuY3Rpb24gZXFsIChhY3R1YWwsIGV4cGVjdGVkKSB7XG4gICAgLy8gNy4xLiBBbGwgaWRlbnRpY2FsIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4gICAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIEJ1ZmZlclxuICAgICAgICAmJiBCdWZmZXIuaXNCdWZmZXIoYWN0dWFsKSAmJiBCdWZmZXIuaXNCdWZmZXIoZXhwZWN0ZWQpKSB7XG4gICAgICBpZiAoYWN0dWFsLmxlbmd0aCAhPSBleHBlY3RlZC5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhY3R1YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFjdHVhbFtpXSAhPT0gZXhwZWN0ZWRbaV0pIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAvLyA3LjIuIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIERhdGUgb2JqZWN0LCB0aGUgYWN0dWFsIHZhbHVlIGlzXG4gICAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgRGF0ZSBvYmplY3QgdGhhdCByZWZlcnMgdG8gdGhlIHNhbWUgdGltZS5cbiAgICB9IGVsc2UgaWYgKGFjdHVhbCBpbnN0YW5jZW9mIERhdGUgJiYgZXhwZWN0ZWQgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICByZXR1cm4gYWN0dWFsLmdldFRpbWUoKSA9PT0gZXhwZWN0ZWQuZ2V0VGltZSgpO1xuXG4gICAgLy8gNy4zLiBPdGhlciBwYWlycyB0aGF0IGRvIG5vdCBib3RoIHBhc3MgdHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIsXG4gICAgLy8gZXF1aXZhbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSA9PS5cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhY3R1YWwgIT0gJ29iamVjdCcgJiYgdHlwZW9mIGV4cGVjdGVkICE9ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gYWN0dWFsID09IGV4cGVjdGVkO1xuXG4gICAgLy8gNy40LiBGb3IgYWxsIG90aGVyIE9iamVjdCBwYWlycywgaW5jbHVkaW5nIEFycmF5IG9iamVjdHMsIGVxdWl2YWxlbmNlIGlzXG4gICAgLy8gZGV0ZXJtaW5lZCBieSBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGFzIHZlcmlmaWVkXG4gICAgLy8gd2l0aCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwpLCB0aGUgc2FtZSBzZXQgb2Yga2V5c1xuICAgIC8vIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLCBlcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnlcbiAgICAvLyBjb3JyZXNwb25kaW5nIGtleSwgYW5kIGFuIGlkZW50aWNhbCBcInByb3RvdHlwZVwiIHByb3BlcnR5LiBOb3RlOiB0aGlzXG4gICAgLy8gYWNjb3VudHMgZm9yIGJvdGggbmFtZWQgYW5kIGluZGV4ZWQgcHJvcGVydGllcyBvbiBBcnJheXMuXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBvYmpFcXVpdihhY3R1YWwsIGV4cGVjdGVkKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1VuZGVmaW5lZE9yTnVsbCAodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQXJndW1lbnRzIChvYmplY3QpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG4gIH1cblxuICBmdW5jdGlvbiBvYmpFcXVpdiAoYSwgYikge1xuICAgIGlmIChpc1VuZGVmaW5lZE9yTnVsbChhKSB8fCBpc1VuZGVmaW5lZE9yTnVsbChiKSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICAvLyBhbiBpZGVudGljYWwgXCJwcm90b3R5cGVcIiBwcm9wZXJ0eS5cbiAgICBpZiAoYS5wcm90b3R5cGUgIT09IGIucHJvdG90eXBlKSByZXR1cm4gZmFsc2U7XG4gICAgLy9+fn5JJ3ZlIG1hbmFnZWQgdG8gYnJlYWsgT2JqZWN0LmtleXMgdGhyb3VnaCBzY3Jld3kgYXJndW1lbnRzIHBhc3NpbmcuXG4gICAgLy8gICBDb252ZXJ0aW5nIHRvIGFycmF5IHNvbHZlcyB0aGUgcHJvYmxlbS5cbiAgICBpZiAoaXNBcmd1bWVudHMoYSkpIHtcbiAgICAgIGlmICghaXNBcmd1bWVudHMoYikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgYSA9IHBTbGljZS5jYWxsKGEpO1xuICAgICAgYiA9IHBTbGljZS5jYWxsKGIpO1xuICAgICAgcmV0dXJuIGV4cGVjdC5lcWwoYSwgYik7XG4gICAgfVxuICAgIHRyeXtcbiAgICAgIHZhciBrYSA9IGtleXMoYSksXG4gICAgICAgIGtiID0ga2V5cyhiKSxcbiAgICAgICAga2V5LCBpO1xuICAgIH0gY2F0Y2ggKGUpIHsvL2hhcHBlbnMgd2hlbiBvbmUgaXMgYSBzdHJpbmcgbGl0ZXJhbCBhbmQgdGhlIG90aGVyIGlzbid0XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoa2V5cyBpbmNvcnBvcmF0ZXMgaGFzT3duUHJvcGVydHkpXG4gICAgaWYgKGthLmxlbmd0aCAhPSBrYi5sZW5ndGgpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgLy90aGUgc2FtZSBzZXQgb2Yga2V5cyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSxcbiAgICBrYS5zb3J0KCk7XG4gICAga2Iuc29ydCgpO1xuICAgIC8vfn5+Y2hlYXAga2V5IHRlc3RcbiAgICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKGthW2ldICE9IGtiW2ldKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5IGNvcnJlc3BvbmRpbmcga2V5LCBhbmRcbiAgICAvL35+fnBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3RcbiAgICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAga2V5ID0ga2FbaV07XG4gICAgICBpZiAoIWV4cGVjdC5lcWwoYVtrZXldLCBiW2tleV0pKVxuICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBqc29uID0gKGZ1bmN0aW9uICgpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmICgnb2JqZWN0JyA9PSB0eXBlb2YgSlNPTiAmJiBKU09OLnBhcnNlICYmIEpTT04uc3RyaW5naWZ5KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhcnNlOiBuYXRpdmVKU09OLnBhcnNlXG4gICAgICAgICwgc3RyaW5naWZ5OiBuYXRpdmVKU09OLnN0cmluZ2lmeVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBKU09OID0ge307XG5cbiAgICBmdW5jdGlvbiBmKG4pIHtcbiAgICAgICAgLy8gRm9ybWF0IGludGVnZXJzIHRvIGhhdmUgYXQgbGVhc3QgdHdvIGRpZ2l0cy5cbiAgICAgICAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4gOiBuO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRhdGUoZCwga2V5KSB7XG4gICAgICByZXR1cm4gaXNGaW5pdGUoZC52YWx1ZU9mKCkpID9cbiAgICAgICAgICBkLmdldFVUQ0Z1bGxZZWFyKCkgICAgICsgJy0nICtcbiAgICAgICAgICBmKGQuZ2V0VVRDTW9udGgoKSArIDEpICsgJy0nICtcbiAgICAgICAgICBmKGQuZ2V0VVRDRGF0ZSgpKSAgICAgICsgJ1QnICtcbiAgICAgICAgICBmKGQuZ2V0VVRDSG91cnMoKSkgICAgICsgJzonICtcbiAgICAgICAgICBmKGQuZ2V0VVRDTWludXRlcygpKSAgICsgJzonICtcbiAgICAgICAgICBmKGQuZ2V0VVRDU2Vjb25kcygpKSAgICsgJ1onIDogbnVsbDtcbiAgICB9O1xuXG4gICAgdmFyIGN4ID0gL1tcXHUwMDAwXFx1MDBhZFxcdTA2MDAtXFx1MDYwNFxcdTA3MGZcXHUxN2I0XFx1MTdiNVxcdTIwMGMtXFx1MjAwZlxcdTIwMjgtXFx1MjAyZlxcdTIwNjAtXFx1MjA2ZlxcdWZlZmZcXHVmZmYwLVxcdWZmZmZdL2csXG4gICAgICAgIGVzY2FwYWJsZSA9IC9bXFxcXFxcXCJcXHgwMC1cXHgxZlxceDdmLVxceDlmXFx1MDBhZFxcdTA2MDAtXFx1MDYwNFxcdTA3MGZcXHUxN2I0XFx1MTdiNVxcdTIwMGMtXFx1MjAwZlxcdTIwMjgtXFx1MjAyZlxcdTIwNjAtXFx1MjA2ZlxcdWZlZmZcXHVmZmYwLVxcdWZmZmZdL2csXG4gICAgICAgIGdhcCxcbiAgICAgICAgaW5kZW50LFxuICAgICAgICBtZXRhID0geyAgICAvLyB0YWJsZSBvZiBjaGFyYWN0ZXIgc3Vic3RpdHV0aW9uc1xuICAgICAgICAgICAgJ1xcYic6ICdcXFxcYicsXG4gICAgICAgICAgICAnXFx0JzogJ1xcXFx0JyxcbiAgICAgICAgICAgICdcXG4nOiAnXFxcXG4nLFxuICAgICAgICAgICAgJ1xcZic6ICdcXFxcZicsXG4gICAgICAgICAgICAnXFxyJzogJ1xcXFxyJyxcbiAgICAgICAgICAgICdcIicgOiAnXFxcXFwiJyxcbiAgICAgICAgICAgICdcXFxcJzogJ1xcXFxcXFxcJ1xuICAgICAgICB9LFxuICAgICAgICByZXA7XG5cblxuICAgIGZ1bmN0aW9uIHF1b3RlKHN0cmluZykge1xuXG4gIC8vIElmIHRoZSBzdHJpbmcgY29udGFpbnMgbm8gY29udHJvbCBjaGFyYWN0ZXJzLCBubyBxdW90ZSBjaGFyYWN0ZXJzLCBhbmQgbm9cbiAgLy8gYmFja3NsYXNoIGNoYXJhY3RlcnMsIHRoZW4gd2UgY2FuIHNhZmVseSBzbGFwIHNvbWUgcXVvdGVzIGFyb3VuZCBpdC5cbiAgLy8gT3RoZXJ3aXNlIHdlIG11c3QgYWxzbyByZXBsYWNlIHRoZSBvZmZlbmRpbmcgY2hhcmFjdGVycyB3aXRoIHNhZmUgZXNjYXBlXG4gIC8vIHNlcXVlbmNlcy5cblxuICAgICAgICBlc2NhcGFibGUubGFzdEluZGV4ID0gMDtcbiAgICAgICAgcmV0dXJuIGVzY2FwYWJsZS50ZXN0KHN0cmluZykgPyAnXCInICsgc3RyaW5nLnJlcGxhY2UoZXNjYXBhYmxlLCBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgdmFyIGMgPSBtZXRhW2FdO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBjID09PSAnc3RyaW5nJyA/IGMgOlxuICAgICAgICAgICAgICAgICdcXFxcdScgKyAoJzAwMDAnICsgYS5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpO1xuICAgICAgICB9KSArICdcIicgOiAnXCInICsgc3RyaW5nICsgJ1wiJztcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIHN0cihrZXksIGhvbGRlcikge1xuXG4gIC8vIFByb2R1Y2UgYSBzdHJpbmcgZnJvbSBob2xkZXJba2V5XS5cblxuICAgICAgICB2YXIgaSwgICAgICAgICAgLy8gVGhlIGxvb3AgY291bnRlci5cbiAgICAgICAgICAgIGssICAgICAgICAgIC8vIFRoZSBtZW1iZXIga2V5LlxuICAgICAgICAgICAgdiwgICAgICAgICAgLy8gVGhlIG1lbWJlciB2YWx1ZS5cbiAgICAgICAgICAgIGxlbmd0aCxcbiAgICAgICAgICAgIG1pbmQgPSBnYXAsXG4gICAgICAgICAgICBwYXJ0aWFsLFxuICAgICAgICAgICAgdmFsdWUgPSBob2xkZXJba2V5XTtcblxuICAvLyBJZiB0aGUgdmFsdWUgaGFzIGEgdG9KU09OIG1ldGhvZCwgY2FsbCBpdCB0byBvYnRhaW4gYSByZXBsYWNlbWVudCB2YWx1ZS5cblxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGRhdGUoa2V5KTtcbiAgICAgICAgfVxuXG4gIC8vIElmIHdlIHdlcmUgY2FsbGVkIHdpdGggYSByZXBsYWNlciBmdW5jdGlvbiwgdGhlbiBjYWxsIHRoZSByZXBsYWNlciB0b1xuICAvLyBvYnRhaW4gYSByZXBsYWNlbWVudCB2YWx1ZS5cblxuICAgICAgICBpZiAodHlwZW9mIHJlcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFsdWUgPSByZXAuY2FsbChob2xkZXIsIGtleSwgdmFsdWUpO1xuICAgICAgICB9XG5cbiAgLy8gV2hhdCBoYXBwZW5zIG5leHQgZGVwZW5kcyBvbiB0aGUgdmFsdWUncyB0eXBlLlxuXG4gICAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICByZXR1cm4gcXVvdGUodmFsdWUpO1xuXG4gICAgICAgIGNhc2UgJ251bWJlcic6XG5cbiAgLy8gSlNPTiBudW1iZXJzIG11c3QgYmUgZmluaXRlLiBFbmNvZGUgbm9uLWZpbml0ZSBudW1iZXJzIGFzIG51bGwuXG5cbiAgICAgICAgICAgIHJldHVybiBpc0Zpbml0ZSh2YWx1ZSkgPyBTdHJpbmcodmFsdWUpIDogJ251bGwnO1xuXG4gICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICBjYXNlICdudWxsJzpcblxuICAvLyBJZiB0aGUgdmFsdWUgaXMgYSBib29sZWFuIG9yIG51bGwsIGNvbnZlcnQgaXQgdG8gYSBzdHJpbmcuIE5vdGU6XG4gIC8vIHR5cGVvZiBudWxsIGRvZXMgbm90IHByb2R1Y2UgJ251bGwnLiBUaGUgY2FzZSBpcyBpbmNsdWRlZCBoZXJlIGluXG4gIC8vIHRoZSByZW1vdGUgY2hhbmNlIHRoYXQgdGhpcyBnZXRzIGZpeGVkIHNvbWVkYXkuXG5cbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuXG4gIC8vIElmIHRoZSB0eXBlIGlzICdvYmplY3QnLCB3ZSBtaWdodCBiZSBkZWFsaW5nIHdpdGggYW4gb2JqZWN0IG9yIGFuIGFycmF5IG9yXG4gIC8vIG51bGwuXG5cbiAgICAgICAgY2FzZSAnb2JqZWN0JzpcblxuICAvLyBEdWUgdG8gYSBzcGVjaWZpY2F0aW9uIGJsdW5kZXIgaW4gRUNNQVNjcmlwdCwgdHlwZW9mIG51bGwgaXMgJ29iamVjdCcsXG4gIC8vIHNvIHdhdGNoIG91dCBmb3IgdGhhdCBjYXNlLlxuXG4gICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICAgICAgICAgIH1cblxuICAvLyBNYWtlIGFuIGFycmF5IHRvIGhvbGQgdGhlIHBhcnRpYWwgcmVzdWx0cyBvZiBzdHJpbmdpZnlpbmcgdGhpcyBvYmplY3QgdmFsdWUuXG5cbiAgICAgICAgICAgIGdhcCArPSBpbmRlbnQ7XG4gICAgICAgICAgICBwYXJ0aWFsID0gW107XG5cbiAgLy8gSXMgdGhlIHZhbHVlIGFuIGFycmF5P1xuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseSh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcblxuICAvLyBUaGUgdmFsdWUgaXMgYW4gYXJyYXkuIFN0cmluZ2lmeSBldmVyeSBlbGVtZW50LiBVc2UgbnVsbCBhcyBhIHBsYWNlaG9sZGVyXG4gIC8vIGZvciBub24tSlNPTiB2YWx1ZXMuXG5cbiAgICAgICAgICAgICAgICBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRpYWxbaV0gPSBzdHIoaSwgdmFsdWUpIHx8ICdudWxsJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgLy8gSm9pbiBhbGwgb2YgdGhlIGVsZW1lbnRzIHRvZ2V0aGVyLCBzZXBhcmF0ZWQgd2l0aCBjb21tYXMsIGFuZCB3cmFwIHRoZW0gaW5cbiAgLy8gYnJhY2tldHMuXG5cbiAgICAgICAgICAgICAgICB2ID0gcGFydGlhbC5sZW5ndGggPT09IDAgPyAnW10nIDogZ2FwID9cbiAgICAgICAgICAgICAgICAgICAgJ1tcXG4nICsgZ2FwICsgcGFydGlhbC5qb2luKCcsXFxuJyArIGdhcCkgKyAnXFxuJyArIG1pbmQgKyAnXScgOlxuICAgICAgICAgICAgICAgICAgICAnWycgKyBwYXJ0aWFsLmpvaW4oJywnKSArICddJztcbiAgICAgICAgICAgICAgICBnYXAgPSBtaW5kO1xuICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgfVxuXG4gIC8vIElmIHRoZSByZXBsYWNlciBpcyBhbiBhcnJheSwgdXNlIGl0IHRvIHNlbGVjdCB0aGUgbWVtYmVycyB0byBiZSBzdHJpbmdpZmllZC5cblxuICAgICAgICAgICAgaWYgKHJlcCAmJiB0eXBlb2YgcmVwID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHJlcC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVwW2ldID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgayA9IHJlcFtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBzdHIoaywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsLnB1c2gocXVvdGUoaykgKyAoZ2FwID8gJzogJyA6ICc6JykgKyB2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgLy8gT3RoZXJ3aXNlLCBpdGVyYXRlIHRocm91Z2ggYWxsIG9mIHRoZSBrZXlzIGluIHRoZSBvYmplY3QuXG5cbiAgICAgICAgICAgICAgICBmb3IgKGsgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgaykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBzdHIoaywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsLnB1c2gocXVvdGUoaykgKyAoZ2FwID8gJzogJyA6ICc6JykgKyB2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAvLyBKb2luIGFsbCBvZiB0aGUgbWVtYmVyIHRleHRzIHRvZ2V0aGVyLCBzZXBhcmF0ZWQgd2l0aCBjb21tYXMsXG4gIC8vIGFuZCB3cmFwIHRoZW0gaW4gYnJhY2VzLlxuXG4gICAgICAgICAgICB2ID0gcGFydGlhbC5sZW5ndGggPT09IDAgPyAne30nIDogZ2FwID9cbiAgICAgICAgICAgICAgICAne1xcbicgKyBnYXAgKyBwYXJ0aWFsLmpvaW4oJyxcXG4nICsgZ2FwKSArICdcXG4nICsgbWluZCArICd9JyA6XG4gICAgICAgICAgICAgICAgJ3snICsgcGFydGlhbC5qb2luKCcsJykgKyAnfSc7XG4gICAgICAgICAgICBnYXAgPSBtaW5kO1xuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgLy8gSWYgdGhlIEpTT04gb2JqZWN0IGRvZXMgbm90IHlldCBoYXZlIGEgc3RyaW5naWZ5IG1ldGhvZCwgZ2l2ZSBpdCBvbmUuXG5cbiAgICBKU09OLnN0cmluZ2lmeSA9IGZ1bmN0aW9uICh2YWx1ZSwgcmVwbGFjZXIsIHNwYWNlKSB7XG5cbiAgLy8gVGhlIHN0cmluZ2lmeSBtZXRob2QgdGFrZXMgYSB2YWx1ZSBhbmQgYW4gb3B0aW9uYWwgcmVwbGFjZXIsIGFuZCBhbiBvcHRpb25hbFxuICAvLyBzcGFjZSBwYXJhbWV0ZXIsIGFuZCByZXR1cm5zIGEgSlNPTiB0ZXh0LiBUaGUgcmVwbGFjZXIgY2FuIGJlIGEgZnVuY3Rpb25cbiAgLy8gdGhhdCBjYW4gcmVwbGFjZSB2YWx1ZXMsIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MgdGhhdCB3aWxsIHNlbGVjdCB0aGUga2V5cy5cbiAgLy8gQSBkZWZhdWx0IHJlcGxhY2VyIG1ldGhvZCBjYW4gYmUgcHJvdmlkZWQuIFVzZSBvZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGNhblxuICAvLyBwcm9kdWNlIHRleHQgdGhhdCBpcyBtb3JlIGVhc2lseSByZWFkYWJsZS5cblxuICAgICAgICB2YXIgaTtcbiAgICAgICAgZ2FwID0gJyc7XG4gICAgICAgIGluZGVudCA9ICcnO1xuXG4gIC8vIElmIHRoZSBzcGFjZSBwYXJhbWV0ZXIgaXMgYSBudW1iZXIsIG1ha2UgYW4gaW5kZW50IHN0cmluZyBjb250YWluaW5nIHRoYXRcbiAgLy8gbWFueSBzcGFjZXMuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBzcGFjZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzcGFjZTsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgaW5kZW50ICs9ICcgJztcbiAgICAgICAgICAgIH1cblxuICAvLyBJZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGlzIGEgc3RyaW5nLCBpdCB3aWxsIGJlIHVzZWQgYXMgdGhlIGluZGVudCBzdHJpbmcuXG5cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3BhY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpbmRlbnQgPSBzcGFjZTtcbiAgICAgICAgfVxuXG4gIC8vIElmIHRoZXJlIGlzIGEgcmVwbGFjZXIsIGl0IG11c3QgYmUgYSBmdW5jdGlvbiBvciBhbiBhcnJheS5cbiAgLy8gT3RoZXJ3aXNlLCB0aHJvdyBhbiBlcnJvci5cblxuICAgICAgICByZXAgPSByZXBsYWNlcjtcbiAgICAgICAgaWYgKHJlcGxhY2VyICYmIHR5cGVvZiByZXBsYWNlciAhPT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgICAgICh0eXBlb2YgcmVwbGFjZXIgIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIHJlcGxhY2VyLmxlbmd0aCAhPT0gJ251bWJlcicpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0pTT04uc3RyaW5naWZ5Jyk7XG4gICAgICAgIH1cblxuICAvLyBNYWtlIGEgZmFrZSByb290IG9iamVjdCBjb250YWluaW5nIG91ciB2YWx1ZSB1bmRlciB0aGUga2V5IG9mICcnLlxuICAvLyBSZXR1cm4gdGhlIHJlc3VsdCBvZiBzdHJpbmdpZnlpbmcgdGhlIHZhbHVlLlxuXG4gICAgICAgIHJldHVybiBzdHIoJycsIHsnJzogdmFsdWV9KTtcbiAgICB9O1xuXG4gIC8vIElmIHRoZSBKU09OIG9iamVjdCBkb2VzIG5vdCB5ZXQgaGF2ZSBhIHBhcnNlIG1ldGhvZCwgZ2l2ZSBpdCBvbmUuXG5cbiAgICBKU09OLnBhcnNlID0gZnVuY3Rpb24gKHRleHQsIHJldml2ZXIpIHtcbiAgICAvLyBUaGUgcGFyc2UgbWV0aG9kIHRha2VzIGEgdGV4dCBhbmQgYW4gb3B0aW9uYWwgcmV2aXZlciBmdW5jdGlvbiwgYW5kIHJldHVybnNcbiAgICAvLyBhIEphdmFTY3JpcHQgdmFsdWUgaWYgdGhlIHRleHQgaXMgYSB2YWxpZCBKU09OIHRleHQuXG5cbiAgICAgICAgdmFyIGo7XG5cbiAgICAgICAgZnVuY3Rpb24gd2Fsayhob2xkZXIsIGtleSkge1xuXG4gICAgLy8gVGhlIHdhbGsgbWV0aG9kIGlzIHVzZWQgdG8gcmVjdXJzaXZlbHkgd2FsayB0aGUgcmVzdWx0aW5nIHN0cnVjdHVyZSBzb1xuICAgIC8vIHRoYXQgbW9kaWZpY2F0aW9ucyBjYW4gYmUgbWFkZS5cblxuICAgICAgICAgICAgdmFyIGssIHYsIHZhbHVlID0gaG9sZGVyW2tleV07XG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGZvciAoayBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHdhbGsodmFsdWUsIGspO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlW2tdID0gdjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHZhbHVlW2tdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldml2ZXIuY2FsbChob2xkZXIsIGtleSwgdmFsdWUpO1xuICAgICAgICB9XG5cblxuICAgIC8vIFBhcnNpbmcgaGFwcGVucyBpbiBmb3VyIHN0YWdlcy4gSW4gdGhlIGZpcnN0IHN0YWdlLCB3ZSByZXBsYWNlIGNlcnRhaW5cbiAgICAvLyBVbmljb2RlIGNoYXJhY3RlcnMgd2l0aCBlc2NhcGUgc2VxdWVuY2VzLiBKYXZhU2NyaXB0IGhhbmRsZXMgbWFueSBjaGFyYWN0ZXJzXG4gICAgLy8gaW5jb3JyZWN0bHksIGVpdGhlciBzaWxlbnRseSBkZWxldGluZyB0aGVtLCBvciB0cmVhdGluZyB0aGVtIGFzIGxpbmUgZW5kaW5ncy5cblxuICAgICAgICB0ZXh0ID0gU3RyaW5nKHRleHQpO1xuICAgICAgICBjeC5sYXN0SW5kZXggPSAwO1xuICAgICAgICBpZiAoY3gudGVzdCh0ZXh0KSkge1xuICAgICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZShjeCwgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1xcXFx1JyArXG4gICAgICAgICAgICAgICAgICAgICgnMDAwMCcgKyBhLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtNCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgLy8gSW4gdGhlIHNlY29uZCBzdGFnZSwgd2UgcnVuIHRoZSB0ZXh0IGFnYWluc3QgcmVndWxhciBleHByZXNzaW9ucyB0aGF0IGxvb2tcbiAgICAvLyBmb3Igbm9uLUpTT04gcGF0dGVybnMuIFdlIGFyZSBlc3BlY2lhbGx5IGNvbmNlcm5lZCB3aXRoICcoKScgYW5kICduZXcnXG4gICAgLy8gYmVjYXVzZSB0aGV5IGNhbiBjYXVzZSBpbnZvY2F0aW9uLCBhbmQgJz0nIGJlY2F1c2UgaXQgY2FuIGNhdXNlIG11dGF0aW9uLlxuICAgIC8vIEJ1dCBqdXN0IHRvIGJlIHNhZmUsIHdlIHdhbnQgdG8gcmVqZWN0IGFsbCB1bmV4cGVjdGVkIGZvcm1zLlxuXG4gICAgLy8gV2Ugc3BsaXQgdGhlIHNlY29uZCBzdGFnZSBpbnRvIDQgcmVnZXhwIG9wZXJhdGlvbnMgaW4gb3JkZXIgdG8gd29yayBhcm91bmRcbiAgICAvLyBjcmlwcGxpbmcgaW5lZmZpY2llbmNpZXMgaW4gSUUncyBhbmQgU2FmYXJpJ3MgcmVnZXhwIGVuZ2luZXMuIEZpcnN0IHdlXG4gICAgLy8gcmVwbGFjZSB0aGUgSlNPTiBiYWNrc2xhc2ggcGFpcnMgd2l0aCAnQCcgKGEgbm9uLUpTT04gY2hhcmFjdGVyKS4gU2Vjb25kLCB3ZVxuICAgIC8vIHJlcGxhY2UgYWxsIHNpbXBsZSB2YWx1ZSB0b2tlbnMgd2l0aCAnXScgY2hhcmFjdGVycy4gVGhpcmQsIHdlIGRlbGV0ZSBhbGxcbiAgICAvLyBvcGVuIGJyYWNrZXRzIHRoYXQgZm9sbG93IGEgY29sb24gb3IgY29tbWEgb3IgdGhhdCBiZWdpbiB0aGUgdGV4dC4gRmluYWxseSxcbiAgICAvLyB3ZSBsb29rIHRvIHNlZSB0aGF0IHRoZSByZW1haW5pbmcgY2hhcmFjdGVycyBhcmUgb25seSB3aGl0ZXNwYWNlIG9yICddJyBvclxuICAgIC8vICcsJyBvciAnOicgb3IgJ3snIG9yICd9Jy4gSWYgdGhhdCBpcyBzbywgdGhlbiB0aGUgdGV4dCBpcyBzYWZlIGZvciBldmFsLlxuXG4gICAgICAgIGlmICgvXltcXF0sOnt9XFxzXSokL1xuICAgICAgICAgICAgICAgIC50ZXN0KHRleHQucmVwbGFjZSgvXFxcXCg/OltcIlxcXFxcXC9iZm5ydF18dVswLTlhLWZBLUZdezR9KS9nLCAnQCcpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cIlteXCJcXFxcXFxuXFxyXSpcInx0cnVlfGZhbHNlfG51bGx8LT9cXGQrKD86XFwuXFxkKik/KD86W2VFXVsrXFwtXT9cXGQrKT8vZywgJ10nKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKD86Xnw6fCwpKD86XFxzKlxcWykrL2csICcnKSkpIHtcblxuICAgIC8vIEluIHRoZSB0aGlyZCBzdGFnZSB3ZSB1c2UgdGhlIGV2YWwgZnVuY3Rpb24gdG8gY29tcGlsZSB0aGUgdGV4dCBpbnRvIGFcbiAgICAvLyBKYXZhU2NyaXB0IHN0cnVjdHVyZS4gVGhlICd7JyBvcGVyYXRvciBpcyBzdWJqZWN0IHRvIGEgc3ludGFjdGljIGFtYmlndWl0eVxuICAgIC8vIGluIEphdmFTY3JpcHQ6IGl0IGNhbiBiZWdpbiBhIGJsb2NrIG9yIGFuIG9iamVjdCBsaXRlcmFsLiBXZSB3cmFwIHRoZSB0ZXh0XG4gICAgLy8gaW4gcGFyZW5zIHRvIGVsaW1pbmF0ZSB0aGUgYW1iaWd1aXR5LlxuXG4gICAgICAgICAgICBqID0gZXZhbCgnKCcgKyB0ZXh0ICsgJyknKTtcblxuICAgIC8vIEluIHRoZSBvcHRpb25hbCBmb3VydGggc3RhZ2UsIHdlIHJlY3Vyc2l2ZWx5IHdhbGsgdGhlIG5ldyBzdHJ1Y3R1cmUsIHBhc3NpbmdcbiAgICAvLyBlYWNoIG5hbWUvdmFsdWUgcGFpciB0byBhIHJldml2ZXIgZnVuY3Rpb24gZm9yIHBvc3NpYmxlIHRyYW5zZm9ybWF0aW9uLlxuXG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHJldml2ZXIgPT09ICdmdW5jdGlvbicgP1xuICAgICAgICAgICAgICAgIHdhbGsoeycnOiBqfSwgJycpIDogajtcbiAgICAgICAgfVxuXG4gICAgLy8gSWYgdGhlIHRleHQgaXMgbm90IEpTT04gcGFyc2VhYmxlLCB0aGVuIGEgU3ludGF4RXJyb3IgaXMgdGhyb3duLlxuXG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignSlNPTi5wYXJzZScpO1xuICAgIH07XG5cbiAgICByZXR1cm4gSlNPTjtcbiAgfSkoKTtcblxuICBpZiAoJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIHdpbmRvdykge1xuICAgIHdpbmRvdy5leHBlY3QgPSBtb2R1bGUuZXhwb3J0cztcbiAgfVxuXG59KShcbiAgICB0aGlzXG4gICwgJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIG1vZHVsZSA/IG1vZHVsZSA6IHt9XG4gICwgJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGV4cG9ydHMgPyBleHBvcnRzIDoge31cbik7XG5cbn0pKHJlcXVpcmUoXCJfX2Jyb3dzZXJpZnlfQnVmZmVyXCIpLkJ1ZmZlcikiLCIvKiBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBieSBKU0NvdmVyYWdlIC0gZG8gbm90IGVkaXQgKi9cbmlmICh0eXBlb2YgXyRqc2NvdmVyYWdlID09PSAndW5kZWZpbmVkJykgXyRqc2NvdmVyYWdlID0ge307XG5pZiAoISBfJGpzY292ZXJhZ2VbJ2x1Yy5qcyddKSB7XG4gIF8kanNjb3ZlcmFnZVsnbHVjLmpzJ10gPSBbXTtcbiAgXyRqc2NvdmVyYWdlWydsdWMuanMnXVsxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbHVjLmpzJ11bN10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2x1Yy5qcyddWzldID0gMDtcbiAgXyRqc2NvdmVyYWdlWydsdWMuanMnXVsxMF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2x1Yy5qcyddWzE2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbHVjLmpzJ11bMjRdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydsdWMuanMnXVszMV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2x1Yy5qcyddWzM0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbHVjLmpzJ11bMzVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydsdWMuanMnXVs0Ml0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2x1Yy5qcyddWzQ5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbHVjLmpzJ11bNTZdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydsdWMuanMnXVs1OF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2x1Yy5qcyddWzU5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbHVjLmpzJ11bNjZdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydsdWMuanMnXVs2OF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2x1Yy5qcyddWzcwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbHVjLmpzJ11bNzJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydsdWMuanMnXVs3NF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2x1Yy5qcyddWzc2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbHVjLmpzJ11bNzhdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydsdWMuanMnXVs4MF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2x1Yy5qcyddWzgyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbHVjLmpzJ11bODldID0gMDtcbiAgXyRqc2NvdmVyYWdlWydsdWMuanMnXVs5MV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2x1Yy5qcyddWzkzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnbHVjLmpzJ11bOTVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydsdWMuanMnXVs5OV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2x1Yy5qcyddWzEwMV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2x1Yy5qcyddWzEwNF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2x1Yy5qcyddWzEwNV0gPSAwO1xufVxuXyRqc2NvdmVyYWdlWydsdWMuanMnXVsxXSsrO1xudmFyIEx1YyA9IHt9O1xuXyRqc2NvdmVyYWdlWydsdWMuanMnXVs3XSsrO1xubW9kdWxlLmV4cG9ydHMgPSBMdWM7XG5fJGpzY292ZXJhZ2VbJ2x1Yy5qcyddWzldKys7XG52YXIgb2JqZWN0ID0gcmVxdWlyZShcIi4vb2JqZWN0XCIpO1xuXyRqc2NvdmVyYWdlWydsdWMuanMnXVsxMF0rKztcbkx1Yy5PYmplY3QgPSBvYmplY3Q7XG5fJGpzY292ZXJhZ2VbJ2x1Yy5qcyddWzE2XSsrO1xuTHVjLk8gPSBvYmplY3Q7XG5fJGpzY292ZXJhZ2VbJ2x1Yy5qcyddWzI0XSsrO1xuTHVjLmFwcGx5ID0gTHVjLk9iamVjdC5hcHBseTtcbl8kanNjb3ZlcmFnZVsnbHVjLmpzJ11bMzFdKys7XG5MdWMubWl4ID0gTHVjLk9iamVjdC5taXg7XG5fJGpzY292ZXJhZ2VbJ2x1Yy5qcyddWzM0XSsrO1xudmFyIGZ1biA9IHJlcXVpcmUoXCIuL2Z1bmN0aW9uXCIpO1xuXyRqc2NvdmVyYWdlWydsdWMuanMnXVszNV0rKztcbkx1Yy5GdW5jdGlvbiA9IGZ1bjtcbl8kanNjb3ZlcmFnZVsnbHVjLmpzJ11bNDJdKys7XG5MdWMuRiA9IGZ1bjtcbl8kanNjb3ZlcmFnZVsnbHVjLmpzJ11bNDldKys7XG5MdWMuZW1wdHlGbiA9IEx1Yy5GdW5jdGlvbi5lbXB0eUZuO1xuXyRqc2NvdmVyYWdlWydsdWMuanMnXVs1Nl0rKztcbkx1Yy5hYnN0cmFjdEZuID0gTHVjLkZ1bmN0aW9uLmFic3RyYWN0Rm47XG5fJGpzY292ZXJhZ2VbJ2x1Yy5qcyddWzU4XSsrO1xudmFyIGFycmF5ID0gcmVxdWlyZShcIi4vYXJyYXlcIik7XG5fJGpzY292ZXJhZ2VbJ2x1Yy5qcyddWzU5XSsrO1xuTHVjLkFycmF5ID0gYXJyYXk7XG5fJGpzY292ZXJhZ2VbJ2x1Yy5qcyddWzY2XSsrO1xuTHVjLkEgPSBhcnJheTtcbl8kanNjb3ZlcmFnZVsnbHVjLmpzJ11bNjhdKys7XG5MdWMuQXJyYXlGbkdlbmVyYXRvciA9IHJlcXVpcmUoXCIuL2FycmF5Rm5HZW5lcmF0b3JcIik7XG5fJGpzY292ZXJhZ2VbJ2x1Yy5qcyddWzcwXSsrO1xuTHVjLmFwcGx5KEx1YywgcmVxdWlyZShcIi4vaXNcIikpO1xuXyRqc2NvdmVyYWdlWydsdWMuanMnXVs3Ml0rKztcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKFwiLi9ldmVudHMvZXZlbnRFbWl0dGVyXCIpO1xuXyRqc2NvdmVyYWdlWydsdWMuanMnXVs3NF0rKztcbkx1Yy5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5fJGpzY292ZXJhZ2VbJ2x1Yy5qcyddWzc2XSsrO1xudmFyIEJhc2UgPSByZXF1aXJlKFwiLi9jbGFzcy9iYXNlXCIpO1xuXyRqc2NvdmVyYWdlWydsdWMuanMnXVs3OF0rKztcbkx1Yy5CYXNlID0gQmFzZTtcbl8kanNjb3ZlcmFnZVsnbHVjLmpzJ11bODBdKys7XG52YXIgRGVmaW5lciA9IHJlcXVpcmUoXCIuL2NsYXNzL2RlZmluZXJcIik7XG5fJGpzY292ZXJhZ2VbJ2x1Yy5qcyddWzgyXSsrO1xuTHVjLkNsYXNzRGVmaW5lciA9IERlZmluZXI7XG5fJGpzY292ZXJhZ2VbJ2x1Yy5qcyddWzg5XSsrO1xuTHVjLmRlZmluZSA9IERlZmluZXIuZGVmaW5lO1xuXyRqc2NvdmVyYWdlWydsdWMuanMnXVs5MV0rKztcbkx1Yy5QbHVnaW4gPSByZXF1aXJlKFwiLi9jbGFzcy9wbHVnaW5cIik7XG5fJGpzY292ZXJhZ2VbJ2x1Yy5qcyddWzkzXSsrO1xuTHVjLlBsdWdpbk1hbmFnZXIgPSByZXF1aXJlKFwiLi9jbGFzcy9wbHVnaW5NYW5hZ2VyXCIpO1xuXyRqc2NvdmVyYWdlWydsdWMuanMnXVs5NV0rKztcbkx1Yy5hcHBseShMdWMsIHtjb21wb3NpdGlvbkVudW1zOiByZXF1aXJlKFwiLi9jbGFzcy9jb21wb3NpdGlvbkVudW1zXCIpfSk7XG5fJGpzY292ZXJhZ2VbJ2x1Yy5qcyddWzk5XSsrO1xuTHVjLmNvbXBhcmUgPSByZXF1aXJlKFwiLi9jb21wYXJlXCIpLmNvbXBhcmU7XG5fJGpzY292ZXJhZ2VbJ2x1Yy5qcyddWzEwMV0rKztcbkx1Yy5pZCA9IHJlcXVpcmUoXCIuL2lkXCIpO1xuXyRqc2NvdmVyYWdlWydsdWMuanMnXVsxMDRdKys7XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICBfJGpzY292ZXJhZ2VbJ2x1Yy5qcyddWzEwNV0rKztcbiAgd2luZG93Lkx1YyA9IEx1Yztcbn1cbl8kanNjb3ZlcmFnZVsnbHVjLmpzJ10uc291cmNlID0gW1widmFyIEx1YyA9IHt9O1wiLFwiLyoqXCIsXCIgKiBAY2xhc3MgTHVjXCIsXCIgKiBBbGlhc2VzIGZvciBjb21tb24gTHVjIG1ldGhvZHMgYW5kIHBhY2thZ2VzLiAgQ2hlY2sgb3V0IEx1Yy5kZWZpbmVcIixcIiAqIHRvIGxvb2sgYXQgdGhlIGNsYXNzIHN5c3RlbSBMdWMgcHJvdmlkZXMuXCIsXCIgKi9cIixcIm1vZHVsZS5leHBvcnRzID0gTHVjO1wiLFwiXCIsXCJ2YXIgb2JqZWN0ID0gcmVxdWlyZSgnLi9vYmplY3QnKTtcIixcIkx1Yy5PYmplY3QgPSBvYmplY3Q7XCIsXCIvKipcIixcIiAqIEBtZW1iZXIgTHVjXCIsXCIgKiBAcHJvcGVydHkgTyBMdWMuT1wiLFwiICogQWxpYXMgZm9yIEx1Yy5PYmplY3RcIixcIiAqL1wiLFwiTHVjLk8gPSBvYmplY3Q7XCIsXCJcIixcIlwiLFwiLyoqXCIsXCIgKiBAbWVtYmVyIEx1Y1wiLFwiICogQG1ldGhvZCBhcHBseVwiLFwiICogQGluaGVyaXRkb2MgTHVjLk9iamVjdCNhcHBseVwiLFwiICovXCIsXCJMdWMuYXBwbHkgPSBMdWMuT2JqZWN0LmFwcGx5O1wiLFwiXCIsXCIvKipcIixcIiAqIEBtZW1iZXIgTHVjXCIsXCIgKiBAbWV0aG9kIG1peFwiLFwiICogQGluaGVyaXRkb2MgTHVjLk9iamVjdCNtaXhcIixcIiAqL1wiLFwiTHVjLm1peCA9IEx1Yy5PYmplY3QubWl4O1wiLFwiXCIsXCJcIixcInZhciBmdW4gPSByZXF1aXJlKCcuL2Z1bmN0aW9uJyk7XCIsXCJMdWMuRnVuY3Rpb24gPSBmdW47XCIsXCJcIixcIi8qKlwiLFwiICogQG1lbWJlciBMdWNcIixcIiAqIEBwcm9wZXJ0eSBGIEx1Yy5GXCIsXCIgKiBBbGlhcyBmb3IgTHVjLkZ1bmN0aW9uXCIsXCIgKi9cIixcIkx1Yy5GID0gZnVuO1wiLFwiXCIsXCIvKipcIixcIiAqIEBtZW1iZXIgTHVjXCIsXCIgKiBAbWV0aG9kIGVtcHR5Rm5cIixcIiAqIEBpbmhlcml0ZG9jIEx1Yy5GdW5jdGlvbiNlbXB0eUZuXCIsXCIgKi9cIixcIkx1Yy5lbXB0eUZuID0gTHVjLkZ1bmN0aW9uLmVtcHR5Rm47XCIsXCJcIixcIi8qKlwiLFwiICogQG1lbWJlciBMdWNcIixcIiAqIEBtZXRob2QgYWJzdHJhY3RGblwiLFwiICogQGluaGVyaXRkb2MgTHVjLkZ1bmN0aW9uI2Fic3RyYWN0Rm5cIixcIiAqL1wiLFwiTHVjLmFic3RyYWN0Rm4gPSBMdWMuRnVuY3Rpb24uYWJzdHJhY3RGbjtcIixcIlwiLFwidmFyIGFycmF5ID0gcmVxdWlyZSgnLi9hcnJheScpO1wiLFwiTHVjLkFycmF5ID0gYXJyYXk7XCIsXCJcIixcIi8qKlwiLFwiICogQG1lbWJlciBMdWNcIixcIiAqIEBwcm9wZXJ0eSBBIEx1Yy5BXCIsXCIgKiBBbGlhcyBmb3IgTHVjLkFycmF5XCIsXCIgKi9cIixcIkx1Yy5BID0gYXJyYXk7XCIsXCJcIixcIkx1Yy5BcnJheUZuR2VuZXJhdG9yID0gcmVxdWlyZSgnLi9hcnJheUZuR2VuZXJhdG9yJyk7XCIsXCJcIixcIkx1Yy5hcHBseShMdWMsIHJlcXVpcmUoJy4vaXMnKSk7XCIsXCJcIixcInZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCcuL2V2ZW50cy9ldmVudEVtaXR0ZXInKTtcIixcIlwiLFwiTHVjLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcIixcIlwiLFwidmFyIEJhc2UgPSByZXF1aXJlKCcuL2NsYXNzL2Jhc2UnKTtcIixcIlwiLFwiTHVjLkJhc2UgPSBCYXNlO1wiLFwiXCIsXCJ2YXIgRGVmaW5lciA9IHJlcXVpcmUoJy4vY2xhc3MvZGVmaW5lcicpO1wiLFwiXCIsXCJMdWMuQ2xhc3NEZWZpbmVyID0gRGVmaW5lcjtcIixcIlwiLFwiLyoqXCIsXCIgKiBAbWVtYmVyIEx1Y1wiLFwiICogQG1ldGhvZCBkZWZpbmVcIixcIiAqIEBpbmhlcml0ZG9jIEx1Yy5kZWZpbmUjZGVmaW5lXCIsXCIgKi9cIixcIkx1Yy5kZWZpbmUgPSBEZWZpbmVyLmRlZmluZTtcIixcIlwiLFwiTHVjLlBsdWdpbiA9IHJlcXVpcmUoJy4vY2xhc3MvcGx1Z2luJyk7XCIsXCJcIixcIkx1Yy5QbHVnaW5NYW5hZ2VyID0gcmVxdWlyZSgnLi9jbGFzcy9wbHVnaW5NYW5hZ2VyJyk7XCIsXCJcIixcIkx1Yy5hcHBseShMdWMsIHtcIixcIiAgICBjb21wb3NpdGlvbkVudW1zOiByZXF1aXJlKCcuL2NsYXNzL2NvbXBvc2l0aW9uRW51bXMnKVwiLFwifSk7XCIsXCJcIixcIkx1Yy5jb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJykuY29tcGFyZTtcIixcIlwiLFwiTHVjLmlkID0gcmVxdWlyZSgnLi9pZCcpO1wiLFwiXCIsXCJcIixcImlmKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XCIsXCIgICAgd2luZG93Lkx1YyA9IEx1YztcIixcIn1cIl07XG4iLCJ2YXIgTHVjID0gcmVxdWlyZSgnLi9sdWNUZXN0TGliJyksXG4gICAgZXhwZWN0ID0gcmVxdWlyZSgnZXhwZWN0LmpzJyk7XG5cbmV4cG9ydHMudGVzdEVtaXR0ZXIgPSBmdW5jdGlvbihlbWl0dGVyKSB7XG5cbiAgICB2YXIgaSA9ICcnO1xuICAgIGVtaXR0ZXIub24oJ2FhYScsIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgaSArPSB2O1xuICAgIH0pO1xuICAgIGVtaXR0ZXIuZW1pdCgnYWFhJywgJ2EnKTtcbiAgICBlbWl0dGVyLmVtaXQoJ2FhYScsICdiJyk7XG4gICAgZW1pdHRlci5lbWl0KCdhYWEnLCAnYycpO1xuICAgIGV4cGVjdChpKS50by5iZSgnYWJjJyk7XG4gICAgaSA9IFwiXCI7XG5cbiAgICBlbWl0dGVyLm9uY2UoJ2JiYicsIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgaSArPSB2O1xuICAgIH0pO1xuXG4gICAgZW1pdHRlci5lbWl0KCdiYmInLCAnYScpO1xuICAgIGVtaXR0ZXIuZW1pdCgnYmJiJywgJ2InKTtcbiAgICBlbWl0dGVyLmVtaXQoJ2JiYicsICdjJyk7XG4gICAgZXhwZWN0KGkpLnRvLmJlKCdhJyk7XG59IiwiLyogYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgYnkgSlNDb3ZlcmFnZSAtIGRvIG5vdCBlZGl0ICovXG5pZiAodHlwZW9mIF8kanNjb3ZlcmFnZSA9PT0gJ3VuZGVmaW5lZCcpIF8kanNjb3ZlcmFnZSA9IHt9O1xuaWYgKCEgXyRqc2NvdmVyYWdlWydvYmplY3QuanMnXSkge1xuICBfJGpzY292ZXJhZ2VbJ29iamVjdC5qcyddID0gW107XG4gIF8kanNjb3ZlcmFnZVsnb2JqZWN0LmpzJ11bMzZdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydvYmplY3QuanMnXVszN10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ29iamVjdC5qcyddWzQxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnb2JqZWN0LmpzJ11bNDJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydvYmplY3QuanMnXVs0M10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ29iamVjdC5qcyddWzQ3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnb2JqZWN0LmpzJ11bNzBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydvYmplY3QuanMnXVs3MV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ29iamVjdC5qcyddWzc1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnb2JqZWN0LmpzJ11bNzZdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydvYmplY3QuanMnXVs3N10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ29iamVjdC5qcyddWzgxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnb2JqZWN0LmpzJ11bMTA2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnb2JqZWN0LmpzJ11bMTA3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnb2JqZWN0LmpzJ11bMTEwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnb2JqZWN0LmpzJ11bMTExXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnb2JqZWN0LmpzJ11bMTEyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnb2JqZWN0LmpzJ11bMTE1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnb2JqZWN0LmpzJ11bMTE2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnb2JqZWN0LmpzJ11bMTE3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnb2JqZWN0LmpzJ11bMTU4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnb2JqZWN0LmpzJ11bMTU5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnb2JqZWN0LmpzJ11bMTYyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnb2JqZWN0LmpzJ11bMTYzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnb2JqZWN0LmpzJ11bMTY2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnb2JqZWN0LmpzJ11bMjE0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnb2JqZWN0LmpzJ11bMjE1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnb2JqZWN0LmpzJ11bMjE4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnb2JqZWN0LmpzJ11bMjE5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnb2JqZWN0LmpzJ11bMjIwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnb2JqZWN0LmpzJ11bMjIxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnb2JqZWN0LmpzJ11bMjIyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnb2JqZWN0LmpzJ11bMjIzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnb2JqZWN0LmpzJ11bMjI1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnb2JqZWN0LmpzJ11bMjMzXSA9IDA7XG59XG5fJGpzY292ZXJhZ2VbJ29iamVjdC5qcyddWzM2XSsrO1xuZXhwb3J0cy5hcHBseSA9IChmdW5jdGlvbiAodG9PYmplY3QsIGZyb21PYmplY3QpIHtcbiAgXyRqc2NvdmVyYWdlWydvYmplY3QuanMnXVszN10rKztcbiAgdmFyIHRvID0gdG9PYmplY3QgfHwge30sIGZyb20gPSBmcm9tT2JqZWN0IHx8IHt9LCBwcm9wO1xuICBfJGpzY292ZXJhZ2VbJ29iamVjdC5qcyddWzQxXSsrO1xuICBmb3IgKHByb3AgaW4gZnJvbSkge1xuICAgIF8kanNjb3ZlcmFnZVsnb2JqZWN0LmpzJ11bNDJdKys7XG4gICAgaWYgKGZyb20uaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgIF8kanNjb3ZlcmFnZVsnb2JqZWN0LmpzJ11bNDNdKys7XG4gICAgICB0b1twcm9wXSA9IGZyb21bcHJvcF07XG4gICAgfVxufVxuICBfJGpzY292ZXJhZ2VbJ29iamVjdC5qcyddWzQ3XSsrO1xuICByZXR1cm4gdG87XG59KTtcbl8kanNjb3ZlcmFnZVsnb2JqZWN0LmpzJ11bNzBdKys7XG5leHBvcnRzLm1peCA9IChmdW5jdGlvbiAodG9PYmplY3QsIGZyb21PYmplY3QpIHtcbiAgXyRqc2NvdmVyYWdlWydvYmplY3QuanMnXVs3MV0rKztcbiAgdmFyIHRvID0gdG9PYmplY3QgfHwge30sIGZyb20gPSBmcm9tT2JqZWN0IHx8IHt9LCBwcm9wO1xuICBfJGpzY292ZXJhZ2VbJ29iamVjdC5qcyddWzc1XSsrO1xuICBmb3IgKHByb3AgaW4gZnJvbSkge1xuICAgIF8kanNjb3ZlcmFnZVsnb2JqZWN0LmpzJ11bNzZdKys7XG4gICAgaWYgKGZyb20uaGFzT3duUHJvcGVydHkocHJvcCkgJiYgdG9bcHJvcF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgXyRqc2NvdmVyYWdlWydvYmplY3QuanMnXVs3N10rKztcbiAgICAgIHRvW3Byb3BdID0gZnJvbVtwcm9wXTtcbiAgICB9XG59XG4gIF8kanNjb3ZlcmFnZVsnb2JqZWN0LmpzJ11bODFdKys7XG4gIHJldHVybiB0bztcbn0pO1xuXyRqc2NvdmVyYWdlWydvYmplY3QuanMnXVsxMDZdKys7XG5leHBvcnRzLmVhY2ggPSAoZnVuY3Rpb24gKG9iaiwgZm4sIHRoaXNBcmcsIGNvbmZpZykge1xuICBfJGpzY292ZXJhZ2VbJ29iamVjdC5qcyddWzEwN10rKztcbiAgdmFyIGtleSwgdmFsdWUsIGFsbFByb3BlcnRpZXMgPSBjb25maWcgJiYgY29uZmlnLm93blByb3BlcnRpZXMgPT09IGZhbHNlO1xuICBfJGpzY292ZXJhZ2VbJ29iamVjdC5qcyddWzExMF0rKztcbiAgaWYgKGFsbFByb3BlcnRpZXMpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ29iamVjdC5qcyddWzExMV0rKztcbiAgICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICAgIF8kanNjb3ZlcmFnZVsnb2JqZWN0LmpzJ11bMTEyXSsrO1xuICAgICAgZm4uY2FsbCh0aGlzQXJnLCBrZXksIG9ialtrZXldKTtcbn1cbiAgfVxuICBlbHNlIHtcbiAgICBfJGpzY292ZXJhZ2VbJ29iamVjdC5qcyddWzExNV0rKztcbiAgICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICAgIF8kanNjb3ZlcmFnZVsnb2JqZWN0LmpzJ11bMTE2XSsrO1xuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIF8kanNjb3ZlcmFnZVsnb2JqZWN0LmpzJ11bMTE3XSsrO1xuICAgICAgICBmbi5jYWxsKHRoaXNBcmcsIGtleSwgb2JqW2tleV0pO1xuICAgICAgfVxufVxuICB9XG59KTtcbl8kanNjb3ZlcmFnZVsnb2JqZWN0LmpzJ11bMTU4XSsrO1xuZXhwb3J0cy50b09iamVjdCA9IChmdW5jdGlvbiAoc3RyaW5ncywgdmFsdWVzKSB7XG4gIF8kanNjb3ZlcmFnZVsnb2JqZWN0LmpzJ11bMTU5XSsrO1xuICB2YXIgb2JqID0ge30sIGkgPSAwLCBsZW4gPSBzdHJpbmdzLmxlbmd0aDtcbiAgXyRqc2NvdmVyYWdlWydvYmplY3QuanMnXVsxNjJdKys7XG4gIGZvciAoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ29iamVjdC5qcyddWzE2M10rKztcbiAgICBvYmpbc3RyaW5nc1tpXV0gPSB2YWx1ZXNbaV07XG59XG4gIF8kanNjb3ZlcmFnZVsnb2JqZWN0LmpzJ11bMTY2XSsrO1xuICByZXR1cm4gb2JqO1xufSk7XG5fJGpzY292ZXJhZ2VbJ29iamVjdC5qcyddWzIxNF0rKztcbmV4cG9ydHMuZmlsdGVyID0gKGZ1bmN0aW9uIChvYmosIGZpbHRlckZuLCB0aGlzQXJnLCBjKSB7XG4gIF8kanNjb3ZlcmFnZVsnb2JqZWN0LmpzJ11bMjE1XSsrO1xuICB2YXIgdmFsdWVzID0gW10sIGNvbmZpZyA9IGMgfHwge307XG4gIF8kanNjb3ZlcmFnZVsnb2JqZWN0LmpzJ11bMjE4XSsrO1xuICBleHBvcnRzLmVhY2gob2JqLCAoZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgXyRqc2NvdmVyYWdlWydvYmplY3QuanMnXVsyMTldKys7XG4gIGlmIChmaWx0ZXJGbi5jYWxsKHRoaXNBcmcsIGtleSwgdmFsdWUpKSB7XG4gICAgXyRqc2NvdmVyYWdlWydvYmplY3QuanMnXVsyMjBdKys7XG4gICAgaWYgKGNvbmZpZy5rZXlzID09PSB0cnVlKSB7XG4gICAgICBfJGpzY292ZXJhZ2VbJ29iamVjdC5qcyddWzIyMV0rKztcbiAgICAgIHZhbHVlcy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgXyRqc2NvdmVyYWdlWydvYmplY3QuanMnXVsyMjJdKys7XG4gICAgICBpZiAoY29uZmlnLnZhbHVlcyA9PT0gdHJ1ZSkge1xuICAgICAgICBfJGpzY292ZXJhZ2VbJ29iamVjdC5qcyddWzIyM10rKztcbiAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIF8kanNjb3ZlcmFnZVsnb2JqZWN0LmpzJ11bMjI1XSsrO1xuICAgICAgICB2YWx1ZXMucHVzaCh7dmFsdWU6IHZhbHVlLCBrZXk6IGtleX0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSksIHRoaXNBcmcsIGNvbmZpZyk7XG4gIF8kanNjb3ZlcmFnZVsnb2JqZWN0LmpzJ11bMjMzXSsrO1xuICByZXR1cm4gdmFsdWVzO1xufSk7XG5fJGpzY292ZXJhZ2VbJ29iamVjdC5qcyddLnNvdXJjZSA9IFtcIi8qKlwiLFwiICogQGNsYXNzIEx1Yy5PYmplY3RcIixcIiAqIFBhY2thZ2UgZm9yIE9iamVjdCBtZXRob2RzLiAgTHVjLk9iamVjdC5hcHBseSBhbmQgTHVjLk9iamVjdC5lYWNoXCIsXCIgKiBhcmUgdXNlZCB2ZXJ5IG9mdGVuLiAgbWl4IGFuZCBhcHBseSBhcmUgYWxpYXNlZCB0byBMdWMuYXBwbHkgYW5kIEx1Yy5taXguXCIsXCIgKi9cIixcIlwiLFwiLyoqXCIsXCIgKiBBcHBseSB0aGUgcHJvcGVydGllcyBmcm9tIGZyb21PYmplY3QgdG8gdGhlIHRvT2JqZWN0LiAgZnJvbU9iamVjdCB3aWxsXCIsXCIgKiBvdmVyd3JpdGUgYW55IHNoYXJlZCBrZXlzLiAgSXQgY2FuIGFsc28gYmUgdXNlZCBhcyBhIHNpbXBsZSBzaGFsbG93IGNsb25lLlwiLFwiICogXCIsXCIgICAgdmFyIHRvID0ge2E6MSwgYzoxfSwgZnJvbSA9IHthOjIsIGI6Mn1cIixcIiAgICBMdWMuT2JqZWN0LmFwcGx5KHRvLCBmcm9tKVwiLFwiICAgICZndDtPYmplY3Qge2E6IDIsIGM6IDEsIGI6IDJ9XCIsXCIgICAgdG8gPT09IHRvXCIsXCIgICAgJmd0O3RydWVcIixcIiAgICB2YXIgY2xvbmUgPSBMdWMuT2JqZWN0LmFwcGx5KHt9LCBmcm9tKVwiLFwiICAgICZndDt1bmRlZmluZWRcIixcIiAgICBjbG9uZVwiLFwiICAgICZndDtPYmplY3Qge2E6IDIsIGI6IDJ9XCIsXCIgICAgY2xvbmUgPT09IGZyb21cIixcIiAgICAmZ3Q7ZmFsc2VcIixcIiAqXCIsXCIgKiBObyBudWxsIGNoZWNrcyBhcmUgbmVlZGVkLlwiLFwiICAgIFwiLFwiICAgIEx1Yy5hcHBseSh1bmRlZmluZWQsIHthOjF9KVwiLFwiICAgICZndDt7YToxfVwiLFwiICAgIEx1Yy5hcHBseSh7YTogMX0pXCIsXCIgICAgJmd0O3thOjF9XCIsXCJcIixcIiAqXCIsXCIgKiBcIixcIiAqIEBwYXJhbSAge09iamVjdH0gW3RvT2JqZWN0XSBPYmplY3QgdG8gcHV0IHRoZSBwcm9wZXJ0aWVzIGZyb21PYmplY3Qgb24uXCIsXCIgKiBAcGFyYW0gIHtPYmplY3R9IFtmcm9tT2JqZWN0XSBPYmplY3QgdG8gcHV0IHRoZSBwcm9wZXJ0aWVzIG9uIHRoZSB0b09iamVjdFwiLFwiICogQHJldHVybiB7T2JqZWN0fSB0aGUgdG9PYmplY3RcIixcIiAqL1wiLFwiZXhwb3J0cy5hcHBseSA9IGZ1bmN0aW9uKHRvT2JqZWN0LCBmcm9tT2JqZWN0KSB7XCIsXCIgICAgdmFyIHRvID0gdG9PYmplY3QgfHwge30sXCIsXCIgICAgICAgIGZyb20gPSBmcm9tT2JqZWN0IHx8IHt9LFwiLFwiICAgICAgICBwcm9wO1wiLFwiXCIsXCIgICAgZm9yIChwcm9wIGluIGZyb20pIHtcIixcIiAgICAgICAgaWYgKGZyb20uaGFzT3duUHJvcGVydHkocHJvcCkpIHtcIixcIiAgICAgICAgICAgIHRvW3Byb3BdID0gZnJvbVtwcm9wXTtcIixcIiAgICAgICAgfVwiLFwiICAgIH1cIixcIlwiLFwiICAgIHJldHVybiB0bztcIixcIn07XCIsXCJcIixcIi8qKlwiLFwiICogU2ltaWxhciB0byBMdWMuT2JqZWN0LmFwcGx5IGV4Y2VwdCB0aGF0IHRoZSBmcm9tT2JqZWN0IHdpbGwgXCIsXCIgKiBOT1Qgb3ZlcndyaXRlIHRoZSBrZXlzIG9mIHRoZSB0b09iamVjdCBpZiB0aGV5IGFyZSBkZWZpbmVkLlwiLFwiICpcIixcIiAgICBMdWMubWl4KHthOjEsYjoyfSwge2E6MyxiOjQsYzo1fSlcIixcIiAgICAmZ3Q7e2E6IDEsIGI6IDIsIGM6IDV9XCIsXCJcIixcIiAqIE5vIG51bGwgY2hlY2tzIGFyZSBuZWVkZWQuXCIsXCIgICAgXCIsXCIgICAgTHVjLm1peCh1bmRlZmluZWQsIHthOjF9KVwiLFwiICAgICZndDt7YToxfVwiLFwiICAgIEx1Yy5taXgoe2E6IDF9KVwiLFwiICAgICZndDt7YToxfVwiLFwiICAgIFwiLFwiICpcIixcIlwiLFwiICogQHBhcmFtICB7T2JqZWN0fSBbdG9PYmplY3RdIE9iamVjdCB0byBwdXQgdGhlIHByb3BlcnRpZXMgZnJvbU9iamVjdCBvbi5cIixcIiAqIEBwYXJhbSAge09iamVjdH0gW2Zyb21PYmplY3RdIGZyb21PYmplY3QgT2JqZWN0IHRvIHB1dCB0aGUgcHJvcGVydGllcyBvbiB0aGUgdG9PYmplY3RcIixcIiAqIEByZXR1cm4ge09iamVjdH0gdGhlIHRvT2JqZWN0XCIsXCIgKi9cIixcImV4cG9ydHMubWl4ID0gZnVuY3Rpb24odG9PYmplY3QsIGZyb21PYmplY3QpIHtcIixcIiAgICB2YXIgdG8gPSB0b09iamVjdCB8fCB7fSxcIixcIiAgICAgICAgZnJvbSA9IGZyb21PYmplY3QgfHwge30sXCIsXCIgICAgICAgIHByb3A7XCIsXCJcIixcIiAgICBmb3IgKHByb3AgaW4gZnJvbSkge1wiLFwiICAgICAgICBpZiAoZnJvbS5oYXNPd25Qcm9wZXJ0eShwcm9wKSAmYW1wOyZhbXA7IHRvW3Byb3BdID09PSB1bmRlZmluZWQpIHtcIixcIiAgICAgICAgICAgIHRvW3Byb3BdID0gZnJvbVtwcm9wXTtcIixcIiAgICAgICAgfVwiLFwiICAgIH1cIixcIlwiLFwiICAgIHJldHVybiB0bztcIixcIn07XCIsXCJcIixcIi8qKlwiLFwiICogSXRlcmF0ZSBvdmVyIGFuIG9iamVjdHMgcHJvcGVydGllc1wiLFwiICogYXMga2V5IHZhbHVlIFxcXCJwYWlyc1xcXCIgd2l0aCB0aGUgcGFzc2VkIGluIGZ1bmN0aW9uLlwiLFwiICogXCIsXCIgICAgdmFyIHRoaXNBcmcgPSB7dmFsOidjJ307XCIsXCIgICAgTHVjLk9iamVjdC5lYWNoKHtcIixcIiAgICAgICAgdTogJ0wnXCIsXCIgICAgfSwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1wiLFwiICAgICAgICBjb25zb2xlLmxvZyh2YWx1ZSArIGtleSArIHRoaXMudmFsKVwiLFwiICAgIH0sIHRoaXNBcmcpXCIsXCIgICAgXCIsXCIgICAgJmd0O0x1YyBcIixcIiBcIixcIiAqIEBwYXJhbSAge09iamVjdH0gICBvYmogIHRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyXCIsXCIgKiBAcGFyYW0gIHtGdW5jdGlvbn0gZm4gICB0aGUgZnVuY3Rpb24gdG8gY2FsbFwiLFwiICogQHBhcmFtICB7U3RyaW5nfSBmbi5rZXkgICB0aGUgb2JqZWN0IGtleVwiLFwiICogQHBhcmFtICB7T2JqZWN0fSBmbi52YWx1ZSAgIHRoZSBvYmplY3QgdmFsdWVcIixcIiAqIEBwYXJhbSAge09iamVjdH0gICBbdGhpc0FyZ10gXCIsXCIgKiBAcGFyYW0ge09iamVjdH0gIFtjb25maWddXCIsXCIgKiBAcGFyYW0ge0Jvb2xlYW59ICBjb25maWcub3duUHJvcGVydGllcyBzZXQgdG8gZmFsc2VcIixcIiAqIHRvIGl0ZXJhdGUgb3ZlciBhbGwgb2YgdGhlIG9iamVjdHMgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlwiLFwiICovXCIsXCJleHBvcnRzLmVhY2ggPSBmdW5jdGlvbihvYmosIGZuLCB0aGlzQXJnLCBjb25maWcpIHtcIixcIiAgICB2YXIga2V5LCB2YWx1ZSxcIixcIiAgICAgICAgYWxsUHJvcGVydGllcyA9IGNvbmZpZyAmYW1wOyZhbXA7IGNvbmZpZy5vd25Qcm9wZXJ0aWVzID09PSBmYWxzZTtcIixcIlwiLFwiICAgIGlmIChhbGxQcm9wZXJ0aWVzKSB7XCIsXCIgICAgICAgIGZvciAoa2V5IGluIG9iaikge1wiLFwiICAgICAgICAgICAgZm4uY2FsbCh0aGlzQXJnLCBrZXksIG9ialtrZXldKTtcIixcIiAgICAgICAgfVwiLFwiICAgIH0gZWxzZSB7XCIsXCIgICAgICAgIGZvciAoa2V5IGluIG9iaikge1wiLFwiICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XCIsXCIgICAgICAgICAgICAgICAgZm4uY2FsbCh0aGlzQXJnLCBrZXksIG9ialtrZXldKTtcIixcIiAgICAgICAgICAgIH1cIixcIiAgICAgICAgfVwiLFwiICAgIH1cIixcIn07XCIsXCJcIixcIi8qKlwiLFwiICogVGFrZSBhbiBhcnJheSBvZiBzdHJpbmdzIGFuZCBhbiBhcnJheS9hcmd1bWVudHMgb2ZcIixcIiAqIHZhbHVlcyBhbmQgcmV0dXJuIGFuIG9iamVjdCBvZiBrZXkgdmFsdWUgcGFpcnNcIixcIiAqIGJhc2VkIG9mZiBlYWNoIGFycmF5cyBpbmRleC4gIEl0IGlzIHVzZWZ1bCBmb3IgdGFraW5nXCIsXCIgKiBhIGxvbmcgbGlzdCBvZiBhcmd1bWVudHMgYW5kIGNyZWF0aW5nIGFuIG9iamVjdCB0aGF0IGNhblwiLFwiICogYmUgcGFzc2VkIHRvIG90aGVyIG1ldGhvZHMuXCIsXCIgKiBcIixcIiAgICBmdW5jdGlvbiBsb25nQXJncyhhLGIsYyxkLGUsZikge1wiLFwiICAgICAgICByZXR1cm4gTHVjLk9iamVjdC50b09iamVjdChbJ2EnLCdiJywgJ2MnLCAnZCcsICdlJywgJ2YnXSwgYXJndW1lbnRzKVwiLFwiICAgIH1cIixcIlwiLFwiICAgIGxvbmdBcmdzKDEsMiwzLDQsNSw2LDcsOCw5KVwiLFwiXCIsXCIgICAgJmd0O09iamVjdCB7YTogMSwgYjogMiwgYzogMywgZDogNCwgZTogNSYjMjI2OyYjMTI4OyYjMTY2O31cIixcIiAgICBhOiAxXCIsXCIgICAgYjogMlwiLFwiICAgIGM6IDNcIixcIiAgICBkOiA0XCIsXCIgICAgZTogNVwiLFwiICAgIGY6IDZcIixcIlwiLFwiICAgIGxvbmdBcmdzKDEsMiwzKVwiLFwiXCIsXCIgICAgJmd0O09iamVjdCB7YTogMSwgYjogMiwgYzogMywgZDogdW5kZWZpbmVkLCBlOiB1bmRlZmluZWQmIzIyNjsmIzEyODsmIzE2Njt9XCIsXCIgICAgYTogMVwiLFwiICAgIGI6IDJcIixcIiAgICBjOiAzXCIsXCIgICAgZDogdW5kZWZpbmVkXCIsXCIgICAgZTogdW5kZWZpbmVkXCIsXCIgICAgZjogdW5kZWZpbmVkXCIsXCJcIixcIiAqIEBwYXJhbSAge1N0cmluZ1tdfSBzdHJpbmdzXCIsXCIgKiBAcGFyYW0gIHtBcnJheS9hcmd1bWVudHN9IHZhbHVlc1wiLFwiICogQHJldHVybiB7T2JqZWN0fVwiLFwiICovXCIsXCJleHBvcnRzLnRvT2JqZWN0ID0gZnVuY3Rpb24oc3RyaW5ncywgdmFsdWVzKSB7XCIsXCIgICAgdmFyIG9iaiA9IHt9LFwiLFwiICAgICAgICBpID0gMCxcIixcIiAgICAgICAgbGVuID0gc3RyaW5ncy5sZW5ndGg7XCIsXCIgICAgZm9yICg7IGkgJmx0OyBsZW47ICsraSkge1wiLFwiICAgICAgICBvYmpbc3RyaW5nc1tpXV0gPSB2YWx1ZXNbaV07XCIsXCIgICAgfVwiLFwiXCIsXCIgICAgcmV0dXJuIG9iajtcIixcIn07XCIsXCJcIixcIi8qKlwiLFwiICogUmV0dXJuIGtleSB2YWx1ZSBwYWlycyBmcm9tIHRoZSBvYmplY3QgaWYgdGhlXCIsXCIgKiBmaWx0ZXJGbiByZXR1cm5zIGEgdHJ1dGh5IHZhbHVlLlwiLFwiICpcIixcIiAgICBMdWMuT2JqZWN0LmZpbHRlcih7XCIsXCIgICAgICAgIGE6IGZhbHNlLFwiLFwiICAgICAgICBiOiB0cnVlLFwiLFwiICAgICAgICBjOiBmYWxzZVwiLFwiICAgIH0sIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcIixcIiAgICAgICAgcmV0dXJuIGtleSA9PT0gJ2EnIHx8IHZhbHVlXCIsXCIgICAgfSlcIixcIiAgICAmZ3Q7W3trZXk6ICdhJywgdmFsdWU6IGZhbHNlfSwge2tleTogJ2InLCB2YWx1ZTogdHJ1ZX1dXCIsXCJcIixcIiAgICBMdWMuT2JqZWN0LmZpbHRlcih7XCIsXCIgICAgICAgIGE6IGZhbHNlLFwiLFwiICAgICAgICBiOiB0cnVlLFwiLFwiICAgICAgICBjOiBmYWxzZVwiLFwiICAgIH0sIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcIixcIiAgICAgICAgcmV0dXJuIGtleSA9PT0gJ2EnIHx8IHZhbHVlXCIsXCIgICAgfSwgdW5kZWZpbmVkLCB7XCIsXCIgICAgICAgIGtleXM6IHRydWVcIixcIiAgICB9KVwiLFwiICAgICZndDtbJ2EnLCAnYiddXCIsXCIgKiBcIixcIiAqIEBwYXJhbSAge09iamVjdH0gICBvYmogIHRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyXCIsXCIgKiBAcGFyYW0gIHtGdW5jdGlvbn0gZmlsdGVyRm4gICB0aGUgZnVuY3Rpb24gdG8gY2FsbCwgcmV0dXJuIGEgdHJ1dGh5IHZhbHVlXCIsXCIgKiB0byBhZGQgdGhlIGtleSB2YWx1ZSBwYWlyXCIsXCIgKiBAcGFyYW0gIHtTdHJpbmd9IGZpbHRlckZuLmtleSAgIHRoZSBvYmplY3Qga2V5XCIsXCIgKiBAcGFyYW0gIHtPYmplY3R9IGZpbHRlckZuLnZhbHVlICAgdGhlIG9iamVjdCB2YWx1ZVwiLFwiICogQHBhcmFtICB7T2JqZWN0fSAgIFt0aGlzQXJnXSBcIixcIiAqIEBwYXJhbSB7T2JqZWN0fSAgW2NvbmZpZ11cIixcIiAqIEBwYXJhbSB7Qm9vbGVhbn0gIGNvbmZpZy5vd25Qcm9wZXJ0aWVzIHNldCB0byBmYWxzZVwiLFwiICogdG8gaXRlcmF0ZSBvdmVyIGFsbCBvZiB0aGUgb2JqZWN0cyBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXCIsXCIgKiBcIixcIiAqIEBwYXJhbSB7Qm9vbGVhbn0gIGNvbmZpZy5rZXlzIHNldCB0byB0cnVlIHRvIHJldHVyblwiLFwiICoganVzdCB0aGUga2V5cy5cIixcIiAqXCIsXCIgKiBAcGFyYW0ge0Jvb2xlYW59ICBjb25maWcudmFsdWVzIHNldCB0byB0cnVlIHRvIHJldHVyblwiLFwiICoganVzdCB0aGUgdmFsdWVzLlwiLFwiICogXCIsXCIgKiBAcmV0dXJuIHtPYmplY3RbXS9TdHJpbmdbXX0gQXJyYXkgb2Yga2V5IHZhbHVlIHBhaXJzIGluIHRoZSBmb3JtXCIsXCIgKiBvZiB7a2V5OiAna2V5JywgdmFsdWU6IHZhbHVlfS4gIElmIGtleXMgb3IgdmFsdWVzIGlzIHRydWUgb24gdGhlIGNvbmZpZ1wiLFwiICoganVzdCB0aGUga2V5cyBvciB2YWx1ZXMgYXJlIHJldHVybmVkLlwiLFwiICpcIixcIiAqL1wiLFwiZXhwb3J0cy5maWx0ZXIgPSBmdW5jdGlvbihvYmosIGZpbHRlckZuLCB0aGlzQXJnLCBjKSB7XCIsXCIgICAgdmFyIHZhbHVlcyA9IFtdLFwiLFwiICAgICAgICBjb25maWcgPSBjIHx8IHt9O1wiLFwiXCIsXCIgICAgZXhwb3J0cy5lYWNoKG9iaiwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1wiLFwiICAgICAgICBpZiAoZmlsdGVyRm4uY2FsbCh0aGlzQXJnLCBrZXksIHZhbHVlKSkge1wiLFwiICAgICAgICAgICAgaWYgKGNvbmZpZy5rZXlzID09PSB0cnVlKSB7XCIsXCIgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goa2V5KTtcIixcIiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29uZmlnLnZhbHVlcyA9PT0gdHJ1ZSkge1wiLFwiICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcIixcIiAgICAgICAgICAgIH0gZWxzZSB7XCIsXCIgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goe1wiLFwiICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXCIsXCIgICAgICAgICAgICAgICAgICAgIGtleToga2V5XCIsXCIgICAgICAgICAgICAgICAgfSk7XCIsXCIgICAgICAgICAgICB9XCIsXCIgICAgICAgIH1cIixcIiAgICB9LCB0aGlzQXJnLCBjb25maWcpO1wiLFwiXCIsXCIgICAgcmV0dXJuIHZhbHVlcztcIixcIn07XCJdO1xuIiwiLyogYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgYnkgSlNDb3ZlcmFnZSAtIGRvIG5vdCBlZGl0ICovXG5pZiAodHlwZW9mIF8kanNjb3ZlcmFnZSA9PT0gJ3VuZGVmaW5lZCcpIF8kanNjb3ZlcmFnZSA9IHt9O1xuaWYgKCEgXyRqc2NvdmVyYWdlWydpcy5qcyddKSB7XG4gIF8kanNjb3ZlcmFnZVsnaXMuanMnXSA9IFtdO1xuICBfJGpzY292ZXJhZ2VbJ2lzLmpzJ11bMV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2lzLmpzJ11bMTFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydpcy5qcyddWzEyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnaXMuanMnXVsyMl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2lzLmpzJ11bMjNdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydpcy5qcyddWzMzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnaXMuanMnXVszNF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2lzLmpzJ11bNDRdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydpcy5qcyddWzQ1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnaXMuanMnXVs1NV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2lzLmpzJ11bNTZdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydpcy5qcyddWzY2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnaXMuanMnXVs2N10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2lzLmpzJ11bNzddID0gMDtcbiAgXyRqc2NvdmVyYWdlWydpcy5qcyddWzc4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnaXMuanMnXVs4OV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2lzLmpzJ11bOTBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydpcy5qcyddWzEwMV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2lzLmpzJ11bMTAyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnaXMuanMnXVsxMTNdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydpcy5qcyddWzExNF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2lzLmpzJ11bMTE2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnaXMuanMnXVsxMTddID0gMDtcbiAgXyRqc2NvdmVyYWdlWydpcy5qcyddWzExOF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2lzLmpzJ11bMTE5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnaXMuanMnXVsxMjBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydpcy5qcyddWzEyMV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2lzLmpzJ11bMTI0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnaXMuanMnXVsxMjddID0gMDtcbn1cbl8kanNjb3ZlcmFnZVsnaXMuanMnXVsxXSsrO1xudmFyIG9Ub1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5fJGpzY292ZXJhZ2VbJ2lzLmpzJ11bMTFdKys7XG5mdW5jdGlvbiBpc0FycmF5KG9iaikge1xuICBfJGpzY292ZXJhZ2VbJ2lzLmpzJ11bMTJdKys7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KG9iaik7XG59XG5fJGpzY292ZXJhZ2VbJ2lzLmpzJ11bMjJdKys7XG5mdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgXyRqc2NvdmVyYWdlWydpcy5qcyddWzIzXSsrO1xuICByZXR1cm4gb2JqICYmIG9Ub1N0cmluZy5jYWxsKG9iaikgPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG59XG5fJGpzY292ZXJhZ2VbJ2lzLmpzJ11bMzNdKys7XG5mdW5jdGlvbiBpc0Z1bmN0aW9uKG9iaikge1xuICBfJGpzY292ZXJhZ2VbJ2lzLmpzJ11bMzRdKys7XG4gIHJldHVybiBvVG9TdHJpbmcuY2FsbChvYmopID09PSBcIltvYmplY3QgRnVuY3Rpb25dXCI7XG59XG5fJGpzY292ZXJhZ2VbJ2lzLmpzJ11bNDRdKys7XG5mdW5jdGlvbiBpc0RhdGUob2JqKSB7XG4gIF8kanNjb3ZlcmFnZVsnaXMuanMnXVs0NV0rKztcbiAgcmV0dXJuIG9Ub1N0cmluZy5jYWxsKG9iaikgPT09IFwiW29iamVjdCBEYXRlXVwiO1xufVxuXyRqc2NvdmVyYWdlWydpcy5qcyddWzU1XSsrO1xuZnVuY3Rpb24gaXNSZWdFeHAob2JqKSB7XG4gIF8kanNjb3ZlcmFnZVsnaXMuanMnXVs1Nl0rKztcbiAgcmV0dXJuIG9Ub1N0cmluZy5jYWxsKG9iaikgPT09IFwiW29iamVjdCBSZWdFeHBdXCI7XG59XG5fJGpzY292ZXJhZ2VbJ2lzLmpzJ11bNjZdKys7XG5mdW5jdGlvbiBpc051bWJlcihvYmopIHtcbiAgXyRqc2NvdmVyYWdlWydpcy5qcyddWzY3XSsrO1xuICByZXR1cm4gb1RvU3RyaW5nLmNhbGwob2JqKSA9PT0gXCJbb2JqZWN0IE51bWJlcl1cIjtcbn1cbl8kanNjb3ZlcmFnZVsnaXMuanMnXVs3N10rKztcbmZ1bmN0aW9uIGlzU3RyaW5nKG9iaikge1xuICBfJGpzY292ZXJhZ2VbJ2lzLmpzJ11bNzhdKys7XG4gIHJldHVybiBvVG9TdHJpbmcuY2FsbChvYmopID09PSBcIltvYmplY3QgU3RyaW5nXVwiO1xufVxuXyRqc2NvdmVyYWdlWydpcy5qcyddWzg5XSsrO1xuZnVuY3Rpb24gaXNBcmd1bWVudHMob2JqKSB7XG4gIF8kanNjb3ZlcmFnZVsnaXMuanMnXVs5MF0rKztcbiAgcmV0dXJuIG9Ub1N0cmluZy5jYWxsKG9iaikgPT09IFwiW29iamVjdCBBcmd1bWVudHNdXCIgfHwgb2JqICYmICEgISBvYmouY2FsbGVlO1xufVxuXyRqc2NvdmVyYWdlWydpcy5qcyddWzEwMV0rKztcbmZ1bmN0aW9uIGlzRmFsc3kob2JqKSB7XG4gIF8kanNjb3ZlcmFnZVsnaXMuanMnXVsxMDJdKys7XG4gIHJldHVybiAoISBvYmogJiYgb2JqICE9PSAwKTtcbn1cbl8kanNjb3ZlcmFnZVsnaXMuanMnXVsxMTNdKys7XG5mdW5jdGlvbiBpc0VtcHR5KG9iaikge1xuICBfJGpzY292ZXJhZ2VbJ2lzLmpzJ11bMTE0XSsrO1xuICB2YXIgZW1wdHkgPSBmYWxzZTtcbiAgXyRqc2NvdmVyYWdlWydpcy5qcyddWzExNl0rKztcbiAgaWYgKGlzRmFsc3kob2JqKSkge1xuICAgIF8kanNjb3ZlcmFnZVsnaXMuanMnXVsxMTddKys7XG4gICAgZW1wdHkgPSB0cnVlO1xuICB9XG4gIGVsc2Uge1xuICAgIF8kanNjb3ZlcmFnZVsnaXMuanMnXVsxMThdKys7XG4gICAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgICAgXyRqc2NvdmVyYWdlWydpcy5qcyddWzExOV0rKztcbiAgICAgIGVtcHR5ID0gb2JqLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBfJGpzY292ZXJhZ2VbJ2lzLmpzJ11bMTIwXSsrO1xuICAgICAgaWYgKGlzT2JqZWN0KG9iaikpIHtcbiAgICAgICAgXyRqc2NvdmVyYWdlWydpcy5qcyddWzEyMV0rKztcbiAgICAgICAgZW1wdHkgPSBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA9PT0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgXyRqc2NvdmVyYWdlWydpcy5qcyddWzEyNF0rKztcbiAgcmV0dXJuIGVtcHR5O1xufVxuXyRqc2NvdmVyYWdlWydpcy5qcyddWzEyN10rKztcbm1vZHVsZS5leHBvcnRzID0ge2lzQXJyYXk6IGlzQXJyYXksIGlzT2JqZWN0OiBpc09iamVjdCwgaXNGdW5jdGlvbjogaXNGdW5jdGlvbiwgaXNEYXRlOiBpc0RhdGUsIGlzU3RyaW5nOiBpc1N0cmluZywgaXNOdW1iZXI6IGlzTnVtYmVyLCBpc1JlZ0V4cDogaXNSZWdFeHAsIGlzQXJndW1lbnRzOiBpc0FyZ3VtZW50cywgaXNGYWxzeTogaXNGYWxzeSwgaXNFbXB0eTogaXNFbXB0eX07XG5fJGpzY292ZXJhZ2VbJ2lzLmpzJ10uc291cmNlID0gW1widmFyIG9Ub1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XCIsXCJcIixcIlwiLFwiLyoqXCIsXCIgKiBAbWVtYmVyIEx1Y1wiLFwiICogUmV0dXJuIHRydWUgaWYgdGhlIHBhc3NlZCBpbiBvYmplY3QgaXMgb2ZcIixcIiAqIHRoZSB0eXBlIHtAbGluayBBcnJheSBBcnJheX1cIixcIiAqIEBwYXJhbSAge09iamVjdH0gIG9iaiBcIixcIiAqIEByZXR1cm4ge0Jvb2xlYW59XCIsXCIgKi9cIixcImZ1bmN0aW9uIGlzQXJyYXkob2JqKSB7XCIsXCIgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkob2JqKTtcIixcIn1cIixcIlwiLFwiLyoqXCIsXCIgKiBAbWVtYmVyIEx1Y1wiLFwiICogUmV0dXJuIHRydWUgaWYgdGhlIHBhc3NlZCBpbiBvYmplY3QgaXMgb2ZcIixcIiAqIHRoZSB0eXBlIHtAbGluayBPYmplY3QgT2JqZWN0fVwiLFwiICogQHBhcmFtICB7T2JqZWN0fSAgb2JqIFwiLFwiICogQHJldHVybiB7Qm9vbGVhbn1cIixcIiAqL1wiLFwiZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XCIsXCIgICAgcmV0dXJuIG9iaiAmYW1wOyZhbXA7IG9Ub1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nO1wiLFwifVwiLFwiXCIsXCIvKipcIixcIiAqIEBtZW1iZXIgTHVjXCIsXCIgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgcGFzc2VkIGluIG9iamVjdCBpcyBvZlwiLFwiICogdGhlIHR5cGUge0BsaW5rIEZ1bmN0aW9uIEZ1bmN0aW9ufVwiLFwiICogQHBhcmFtICB7T2JqZWN0fSAgb2JqIFwiLFwiICogQHJldHVybiB7Qm9vbGVhbn1cIixcIiAqL1wiLFwiZnVuY3Rpb24gaXNGdW5jdGlvbihvYmopIHtcIixcIiAgICByZXR1cm4gb1RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcIixcIn1cIixcIlwiLFwiLyoqXCIsXCIgKiBAbWVtYmVyIEx1Y1wiLFwiICogUmV0dXJuIHRydWUgaWYgdGhlIHBhc3NlZCBpbiBvYmplY3QgaXMgb2ZcIixcIiAqIHRoZSB0eXBlIHtAbGluayBEYXRlIERhdGV9XCIsXCIgKiBAcGFyYW0gIHtPYmplY3R9ICBvYmogXCIsXCIgKiBAcmV0dXJuIHtCb29sZWFufVwiLFwiICovXCIsXCJmdW5jdGlvbiBpc0RhdGUob2JqKSB7XCIsXCIgICAgcmV0dXJuIG9Ub1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IERhdGVdJztcIixcIn1cIixcIlwiLFwiLyoqXCIsXCIgKiBAbWVtYmVyIEx1Y1wiLFwiICogUmV0dXJuIHRydWUgaWYgdGhlIHBhc3NlZCBpbiBvYmplY3QgaXMgb2ZcIixcIiAqIHRoZSB0eXBlIHtAbGluayBSZWdFeHAgUmVnRXhwfVwiLFwiICogQHBhcmFtICB7T2JqZWN0fSAgb2JqIFwiLFwiICogQHJldHVybiB7Qm9vbGVhbn1cIixcIiAqL1wiLFwiZnVuY3Rpb24gaXNSZWdFeHAob2JqKSB7XCIsXCIgICAgcmV0dXJuIG9Ub1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1wiLFwifVwiLFwiXCIsXCIvKipcIixcIiAqIEBtZW1iZXIgTHVjXCIsXCIgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgcGFzc2VkIGluIG9iamVjdCBpcyBvZlwiLFwiICogdGhlIHR5cGUge0BsaW5rIE51bWJlciBOdW1iZXJ9XCIsXCIgKiBAcGFyYW0gIHtPYmplY3R9ICBvYmogXCIsXCIgKiBAcmV0dXJuIHtCb29sZWFufVwiLFwiICovXCIsXCJmdW5jdGlvbiBpc051bWJlcihvYmopIHtcIixcIiAgICByZXR1cm4gb1RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgTnVtYmVyXSc7XCIsXCJ9XCIsXCJcIixcIi8qKlwiLFwiICogQG1lbWJlciBMdWNcIixcIiAqIFJldHVybiB0cnVlIGlmIHRoZSBwYXNzZWQgaW4gb2JqZWN0IGlzIG9mXCIsXCIgKiB0aGUgdHlwZSB7QGxpbmsgU3RyaW5nIFN0cmluZ31cIixcIiAqIEBwYXJhbSAge09iamVjdH0gIG9iaiBcIixcIiAqIEByZXR1cm4ge0Jvb2xlYW59XCIsXCIgKi9cIixcImZ1bmN0aW9uIGlzU3RyaW5nKG9iaikge1wiLFwiICAgIHJldHVybiBvVG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBTdHJpbmddJztcIixcIn1cIixcIlwiLFwiLyoqXCIsXCIgKiBAbWVtYmVyIEx1Y1wiLFwiICogUmV0dXJuIHRydWUgaWYgdGhlIHBhc3NlZCBpbiBvYmplY3QgaXMgb2ZcIixcIiAqIHRoZSB0eXBlIGFyZ3VtZW50cy5cIixcIiAqIFwiLFwiICogQHBhcmFtICB7T2JqZWN0fSAgb2JqIFwiLFwiICogQHJldHVybiB7Qm9vbGVhbn1cIixcIiAqL1wiLFwiZnVuY3Rpb24gaXNBcmd1bWVudHMob2JqKSB7XCIsXCIgICAgcmV0dXJuIG9Ub1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nIHx8IG9iaiAmYW1wOyZhbXA7ICEhb2JqLmNhbGxlZTtcIixcIn1cIixcIlwiLFwiLyoqXCIsXCIgKiBAbWVtYmVyIEx1Y1wiLFwiICogUmV0dXJuIHRydWUgaWYgdGhlIG9iamVjdCBpcyBmYWxzeSBidXQgbm90IHplcm8uICBJZlwiLFwiICogeW91IHdhbnQgZmFsc3kgY2hlY2sgdGhhdCBpbmNsdWRlcyB6ZXJvIHVzZSBhIGdvcmFtIFwiLFwiICogaWYgc3RhdGVtZW50IDopXCIsXCIgKiBAcGFyYW0gIHtPYmplY3R9ICBvYmpcIixcIiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICBcIixcIiAqL1wiLFwiZnVuY3Rpb24gaXNGYWxzeShvYmopIHtcIixcIiAgICByZXR1cm4gKCFvYmogJmFtcDsmYW1wOyBvYmogIT09IDApO1wiLFwifVwiLFwiXCIsXCIvKipcIixcIiAqIEBtZW1iZXIgTHVjXCIsXCIgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGVtcHR5LlwiLFwiICoge30sIFtdLCAnJyxmYWxzZSwgbnVsbCwgdW5kZWZpbmVkLCBOYU4gXCIsXCIgKiBBcmUgYWxsIHRyZWF0ZWQgYXMgZW1wdHkuXCIsXCIgKiBAcGFyYW0gIHtPYmplY3R9ICBvYmpcIixcIiAqIEByZXR1cm4ge0Jvb2xlYW59XCIsXCIgKi9cIixcImZ1bmN0aW9uIGlzRW1wdHkob2JqKSB7XCIsXCIgICAgdmFyIGVtcHR5ID0gZmFsc2U7XCIsXCJcIixcIiAgICBpZiAoaXNGYWxzeShvYmopKSB7XCIsXCIgICAgICAgIGVtcHR5ID0gdHJ1ZTtcIixcIiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqKSkge1wiLFwiICAgICAgICBlbXB0eSA9IG9iai5sZW5ndGggPT09IDA7XCIsXCIgICAgfSBlbHNlIGlmIChpc09iamVjdChvYmopKSB7XCIsXCIgICAgICAgIGVtcHR5ID0gT2JqZWN0LmtleXMob2JqKS5sZW5ndGggPT09IDA7XCIsXCIgICAgfVwiLFwiXCIsXCIgICAgcmV0dXJuIGVtcHR5O1wiLFwifVwiLFwiXCIsXCJtb2R1bGUuZXhwb3J0cyA9IHtcIixcIiAgICBpc0FycmF5OiBpc0FycmF5LFwiLFwiICAgIGlzT2JqZWN0OiBpc09iamVjdCxcIixcIiAgICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFwiLFwiICAgIGlzRGF0ZTogaXNEYXRlLFwiLFwiICAgIGlzU3RyaW5nOiBpc1N0cmluZyxcIixcIiAgICBpc051bWJlcjogaXNOdW1iZXIsXCIsXCIgICAgaXNSZWdFeHA6IGlzUmVnRXhwLFwiLFwiICAgIGlzQXJndW1lbnRzOiBpc0FyZ3VtZW50cyxcIixcIiAgICBpc0ZhbHN5OiBpc0ZhbHN5LFwiLFwiICAgIGlzRW1wdHk6IGlzRW1wdHlcIixcIn07XCJdO1xuIiwiLyogYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgYnkgSlNDb3ZlcmFnZSAtIGRvIG5vdCBlZGl0ICovXG5pZiAodHlwZW9mIF8kanNjb3ZlcmFnZSA9PT0gJ3VuZGVmaW5lZCcpIF8kanNjb3ZlcmFnZSA9IHt9O1xuaWYgKCEgXyRqc2NvdmVyYWdlWydpZC5qcyddKSB7XG4gIF8kanNjb3ZlcmFnZVsnaWQuanMnXSA9IFtdO1xuICBfJGpzY292ZXJhZ2VbJ2lkLmpzJ11bMV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2lkLmpzJ11bMjJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydpZC5qcyddWzIzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnaWQuanMnXVsyNV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2lkLmpzJ11bMjZdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydpZC5qcyddWzI5XSA9IDA7XG59XG5fJGpzY292ZXJhZ2VbJ2lkLmpzJ11bMV0rKztcbnZhciBpZHMgPSB7fTtcbl8kanNjb3ZlcmFnZVsnaWQuanMnXVsyMl0rKztcbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uIChwKSB7XG4gIF8kanNjb3ZlcmFnZVsnaWQuanMnXVsyM10rKztcbiAgdmFyIHByZWZpeCA9IHAgPT09IHVuZGVmaW5lZD8gXCJsdWMtXCI6IHA7XG4gIF8kanNjb3ZlcmFnZVsnaWQuanMnXVsyNV0rKztcbiAgaWYgKGlkc1twcmVmaXhdID09PSB1bmRlZmluZWQpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ2lkLmpzJ11bMjZdKys7XG4gICAgaWRzW3ByZWZpeF0gPSAwO1xuICB9XG4gIF8kanNjb3ZlcmFnZVsnaWQuanMnXVsyOV0rKztcbiAgcmV0dXJuIHByZWZpeCArIGlkc1twcmVmaXhdKys7XG59KTtcbl8kanNjb3ZlcmFnZVsnaWQuanMnXS5zb3VyY2UgPSBbXCJ2YXIgaWRzID0ge307XCIsXCIvKipcIixcIiAqIEBtZW1iZXIgTHVjXCIsXCIgKiBAbWV0aG9kIGlkXCIsXCIgKiBcIixcIiAqIFJldHVybiBhIHVuaXF1ZSBpZC5cIixcIiAqIEBwYXJhbSB7U3RyaW5nfSBbcHJlZml4XSBPcHRpb25hbCBwcmVmaXggdG8gdXNlXCIsXCIgKlwiLFwiICpcIixcIiAgICAgICAgTHVjLmlkKClcIixcIiAgICAgICAgJmd0O1xcXCJsdWMtMFxcXCJcIixcIiAgICAgICAgTHVjLmlkKClcIixcIiAgICAgICAgJmd0O1xcXCJsdWMtMVxcXCJcIixcIiAgICAgICAgTHVjLmlkKCdteS1wcmVmaXgnKVwiLFwiICAgICAgICAmZ3Q7XFxcIm15LXByZWZpeDBcXFwiXCIsXCIgICAgICAgIEx1Yy5pZCgnJylcIixcIiAgICAgICAgJmd0O1xcXCIwXFxcIlwiLFwiICpcIixcIiAqIEByZXR1cm4ge1N0cmluZ31cIixcIiAqXCIsXCIgKi9cIixcIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocCkge1wiLFwiICAgIHZhciBwcmVmaXggPSBwID09PSB1bmRlZmluZWQgPyAnbHVjLScgOiBwO1wiLFwiXCIsXCIgICAgaWYoaWRzW3ByZWZpeF0gPT09IHVuZGVmaW5lZCkge1wiLFwiICAgICAgICBpZHNbcHJlZml4XSA9IDA7XCIsXCIgICAgfVwiLFwiXCIsXCIgICAgcmV0dXJuIHByZWZpeCArIGlkc1twcmVmaXhdKys7XCIsXCJ9O1wiXTtcbiIsIi8qIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGJ5IEpTQ292ZXJhZ2UgLSBkbyBub3QgZWRpdCAqL1xuaWYgKHR5cGVvZiBfJGpzY292ZXJhZ2UgPT09ICd1bmRlZmluZWQnKSBfJGpzY292ZXJhZ2UgPSB7fTtcbmlmICghIF8kanNjb3ZlcmFnZVsnZXZlbnRzL2V2ZW50RW1pdHRlci5qcyddKSB7XG4gIF8kanNjb3ZlcmFnZVsnZXZlbnRzL2V2ZW50RW1pdHRlci5qcyddID0gW107XG4gIF8kanNjb3ZlcmFnZVsnZXZlbnRzL2V2ZW50RW1pdHRlci5qcyddWzFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydldmVudHMvZXZlbnRFbWl0dGVyLmpzJ11bMTNdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydldmVudHMvZXZlbnRFbWl0dGVyLmpzJ11bMTVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydldmVudHMvZXZlbnRFbWl0dGVyLmpzJ11bMTddID0gMDtcbiAgXyRqc2NvdmVyYWdlWydldmVudHMvZXZlbnRFbWl0dGVyLmpzJ11bMThdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydldmVudHMvZXZlbnRFbWl0dGVyLmpzJ11bMjFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydldmVudHMvZXZlbnRFbWl0dGVyLmpzJ11bMjNdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydldmVudHMvZXZlbnRFbWl0dGVyLmpzJ11bMjZdID0gMDtcbn1cbl8kanNjb3ZlcmFnZVsnZXZlbnRzL2V2ZW50RW1pdHRlci5qcyddWzFdKys7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcImV2ZW50c1wiKS5FdmVudEVtaXR0ZXI7XG5fJGpzY292ZXJhZ2VbJ2V2ZW50cy9ldmVudEVtaXR0ZXIuanMnXVsxM10rKztcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IChmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIpIHtcbiAgXyRqc2NvdmVyYWdlWydldmVudHMvZXZlbnRFbWl0dGVyLmpzJ11bMTVdKys7XG4gIHZhciBzZWxmID0gdGhpcywgZyA9IChmdW5jdGlvbiAoKSB7XG4gIF8kanNjb3ZlcmFnZVsnZXZlbnRzL2V2ZW50RW1pdHRlci5qcyddWzE3XSsrO1xuICBzZWxmLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuICBfJGpzY292ZXJhZ2VbJ2V2ZW50cy9ldmVudEVtaXR0ZXIuanMnXVsxOF0rKztcbiAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn0pO1xuICBfJGpzY292ZXJhZ2VbJ2V2ZW50cy9ldmVudEVtaXR0ZXIuanMnXVsyMV0rKztcbiAgc2VsZi5vbih0eXBlLCBnKTtcbiAgXyRqc2NvdmVyYWdlWydldmVudHMvZXZlbnRFbWl0dGVyLmpzJ11bMjNdKys7XG4gIHJldHVybiB0aGlzO1xufSk7XG5fJGpzY292ZXJhZ2VbJ2V2ZW50cy9ldmVudEVtaXR0ZXIuanMnXVsyNl0rKztcbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXyRqc2NvdmVyYWdlWydldmVudHMvZXZlbnRFbWl0dGVyLmpzJ10uc291cmNlID0gW1widmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcIixcIi8qKlwiLFwiICogQGxpY2Vuc2UgaHR0cHM6Ly9yYXcuZ2l0aHViLmNvbS9qb3llbnQvbm9kZS92MC4xMC4xMS9MSUNFTlNFXCIsXCIgKiBOb2RlIGpzIGxpY2Vuc2UuIEV2ZW50RW1pdHRlciB3aWxsIGJlIGluIHRoZSBjbGllbnRcIixcIiAqIG9ubHkgY29kZS5cIixcIiAqL1wiLFwiLyoqXCIsXCIgKiBAY2xhc3MgTHVjLkV2ZW50RW1pdHRlclwiLFwiICogVGhlIHdvbmRlcmZ1bCBldmVudCBlbW1pdGVyIHRoYXQgY29tZXMgd2l0aCBub2RlLFwiLFwiICogdGhhdCB3b3JrcyBpbiB0aGUgc3VwcG9ydGVkIGJyb3dzZXJzLlwiLFwiICogW2h0dHA6Ly9ub2RlanMub3JnL2FwaS9ldmVudHMuaHRtbF0oaHR0cDovL25vZGVqcy5vcmcvYXBpL2V2ZW50cy5odG1sKVwiLFwiICovXCIsXCJFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1wiLFwiICAgIC8vcHV0IGluIGZpeCBmb3IgSUUgOSBhbmQgYmVsb3dcIixcIiAgICB2YXIgc2VsZiA9IHRoaXMsXCIsXCIgICAgICAgIGcgPSBmdW5jdGlvbigpIHtcIixcIiAgICAgICAgICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XCIsXCIgICAgICAgICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1wiLFwiICAgICAgICB9O1wiLFwiXCIsXCIgICAgc2VsZi5vbih0eXBlLCBnKTtcIixcIlwiLFwiICAgIHJldHVybiB0aGlzO1wiLFwifTtcIixcIlwiLFwibW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XCJdO1xuIiwiLyoqXG4gKiBAbGljZW5zZSBodHRwczovL3Jhdy5naXRodWIuY29tL2tyaXNrb3dhbC9lczUtc2hpbS9tYXN0ZXIvTElDRU5TRVxuICogZXM1LXNoaW0gbGljZW5zZVxuICovXG5cbmlmKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmVxdWlyZSgnZXM1LXNoaW0tc2hhbScpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbHVjJyk7IiwidmFyIEx1YyA9IHt9O1xuLyoqXG4gKiBAY2xhc3MgTHVjXG4gKiBBbGlhc2VzIGZvciBjb21tb24gTHVjIG1ldGhvZHMgYW5kIHBhY2thZ2VzLiAgQ2hlY2sgb3V0IEx1Yy5kZWZpbmVcbiAqIHRvIGxvb2sgYXQgdGhlIGNsYXNzIHN5c3RlbSBMdWMgcHJvdmlkZXMuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gTHVjO1xuXG52YXIgb2JqZWN0ID0gcmVxdWlyZSgnLi9vYmplY3QnKTtcbkx1Yy5PYmplY3QgPSBvYmplY3Q7XG4vKipcbiAqIEBtZW1iZXIgTHVjXG4gKiBAcHJvcGVydHkgTyBMdWMuT1xuICogQWxpYXMgZm9yIEx1Yy5PYmplY3RcbiAqL1xuTHVjLk8gPSBvYmplY3Q7XG5cblxuLyoqXG4gKiBAbWVtYmVyIEx1Y1xuICogQG1ldGhvZCBhcHBseVxuICogQGluaGVyaXRkb2MgTHVjLk9iamVjdCNhcHBseVxuICovXG5MdWMuYXBwbHkgPSBMdWMuT2JqZWN0LmFwcGx5O1xuXG4vKipcbiAqIEBtZW1iZXIgTHVjXG4gKiBAbWV0aG9kIG1peFxuICogQGluaGVyaXRkb2MgTHVjLk9iamVjdCNtaXhcbiAqL1xuTHVjLm1peCA9IEx1Yy5PYmplY3QubWl4O1xuXG5cbnZhciBmdW4gPSByZXF1aXJlKCcuL2Z1bmN0aW9uJyk7XG5MdWMuRnVuY3Rpb24gPSBmdW47XG5cbi8qKlxuICogQG1lbWJlciBMdWNcbiAqIEBwcm9wZXJ0eSBGIEx1Yy5GXG4gKiBBbGlhcyBmb3IgTHVjLkZ1bmN0aW9uXG4gKi9cbkx1Yy5GID0gZnVuO1xuXG4vKipcbiAqIEBtZW1iZXIgTHVjXG4gKiBAbWV0aG9kIGVtcHR5Rm5cbiAqIEBpbmhlcml0ZG9jIEx1Yy5GdW5jdGlvbiNlbXB0eUZuXG4gKi9cbkx1Yy5lbXB0eUZuID0gTHVjLkZ1bmN0aW9uLmVtcHR5Rm47XG5cbi8qKlxuICogQG1lbWJlciBMdWNcbiAqIEBtZXRob2QgYWJzdHJhY3RGblxuICogQGluaGVyaXRkb2MgTHVjLkZ1bmN0aW9uI2Fic3RyYWN0Rm5cbiAqL1xuTHVjLmFic3RyYWN0Rm4gPSBMdWMuRnVuY3Rpb24uYWJzdHJhY3RGbjtcblxudmFyIGFycmF5ID0gcmVxdWlyZSgnLi9hcnJheScpO1xuTHVjLkFycmF5ID0gYXJyYXk7XG5cbi8qKlxuICogQG1lbWJlciBMdWNcbiAqIEBwcm9wZXJ0eSBBIEx1Yy5BXG4gKiBBbGlhcyBmb3IgTHVjLkFycmF5XG4gKi9cbkx1Yy5BID0gYXJyYXk7XG5cbkx1Yy5BcnJheUZuR2VuZXJhdG9yID0gcmVxdWlyZSgnLi9hcnJheUZuR2VuZXJhdG9yJyk7XG5cbkx1Yy5hcHBseShMdWMsIHJlcXVpcmUoJy4vaXMnKSk7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCcuL2V2ZW50cy9ldmVudEVtaXR0ZXInKTtcblxuTHVjLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2NsYXNzL2Jhc2UnKTtcblxuTHVjLkJhc2UgPSBCYXNlO1xuXG52YXIgRGVmaW5lciA9IHJlcXVpcmUoJy4vY2xhc3MvZGVmaW5lcicpO1xuXG5MdWMuQ2xhc3NEZWZpbmVyID0gRGVmaW5lcjtcblxuLyoqXG4gKiBAbWVtYmVyIEx1Y1xuICogQG1ldGhvZCBkZWZpbmVcbiAqIEBpbmhlcml0ZG9jIEx1Yy5kZWZpbmUjZGVmaW5lXG4gKi9cbkx1Yy5kZWZpbmUgPSBEZWZpbmVyLmRlZmluZTtcblxuTHVjLlBsdWdpbiA9IHJlcXVpcmUoJy4vY2xhc3MvcGx1Z2luJyk7XG5cbkx1Yy5QbHVnaW5NYW5hZ2VyID0gcmVxdWlyZSgnLi9jbGFzcy9wbHVnaW5NYW5hZ2VyJyk7XG5cbkx1Yy5hcHBseShMdWMsIHtcbiAgICBjb21wb3NpdGlvbkVudW1zOiByZXF1aXJlKCcuL2NsYXNzL2NvbXBvc2l0aW9uRW51bXMnKVxufSk7XG5cbkx1Yy5jb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJykuY29tcGFyZTtcblxuTHVjLmlkID0gcmVxdWlyZSgnLi9pZCcpO1xuXG5cbmlmKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgd2luZG93Lkx1YyA9IEx1Yztcbn0iLCIvKiBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBieSBKU0NvdmVyYWdlIC0gZG8gbm90IGVkaXQgKi9cbmlmICh0eXBlb2YgXyRqc2NvdmVyYWdlID09PSAndW5kZWZpbmVkJykgXyRqc2NvdmVyYWdlID0ge307XG5pZiAoISBfJGpzY292ZXJhZ2VbJ2Z1bmN0aW9uLmpzJ10pIHtcbiAgXyRqc2NvdmVyYWdlWydmdW5jdGlvbi5qcyddID0gW107XG4gIF8kanNjb3ZlcmFnZVsnZnVuY3Rpb24uanMnXVsxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnZnVuY3Rpb24uanMnXVszXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnZnVuY3Rpb24uanMnXVsxMl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2Z1bmN0aW9uLmpzJ11bMTNdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydmdW5jdGlvbi5qcyddWzE3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnZnVuY3Rpb24uanMnXVsxOF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2Z1bmN0aW9uLmpzJ11bMjFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydmdW5jdGlvbi5qcyddWzIyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnZnVuY3Rpb24uanMnXVsyM10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2Z1bmN0aW9uLmpzJ11bMjVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydmdW5jdGlvbi5qcyddWzI4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnZnVuY3Rpb24uanMnXVszNV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2Z1bmN0aW9uLmpzJ11bNDJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydmdW5jdGlvbi5qcyddWzQzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnZnVuY3Rpb24uanMnXVsxMDhdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydmdW5jdGlvbi5qcyddWzEwOV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2Z1bmN0aW9uLmpzJ11bMTExXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnZnVuY3Rpb24uanMnXVsxMTJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydmdW5jdGlvbi5qcyddWzExNl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2Z1bmN0aW9uLmpzJ11bMTE3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnZnVuY3Rpb24uanMnXVsxMThdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydmdW5jdGlvbi5qcyddWzExOV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2Z1bmN0aW9uLmpzJ11bMTIxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnZnVuY3Rpb24uanMnXVsxMjJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydmdW5jdGlvbi5qcyddWzEyNV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2Z1bmN0aW9uLmpzJ11bMTI4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnZnVuY3Rpb24uanMnXVsxNjFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydmdW5jdGlvbi5qcyddWzE2Ml0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2Z1bmN0aW9uLmpzJ11bMTY0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnZnVuY3Rpb24uanMnXVsxNjVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydmdW5jdGlvbi5qcyddWzE2OF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2Z1bmN0aW9uLmpzJ11bMTY5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnZnVuY3Rpb24uanMnXVsxNzJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydmdW5jdGlvbi5qcyddWzIxNF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2Z1bmN0aW9uLmpzJ11bMjE1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnZnVuY3Rpb24uanMnXVsyMTddID0gMDtcbiAgXyRqc2NvdmVyYWdlWydmdW5jdGlvbi5qcyddWzIxOF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2Z1bmN0aW9uLmpzJ11bMjIxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnZnVuY3Rpb24uanMnXVsyMjJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydmdW5jdGlvbi5qcyddWzIyNF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2Z1bmN0aW9uLmpzJ11bMjI3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnZnVuY3Rpb24uanMnXVsyNThdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydmdW5jdGlvbi5qcyddWzI1OV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2Z1bmN0aW9uLmpzJ11bMjYxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnZnVuY3Rpb24uanMnXVsyNjJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydmdW5jdGlvbi5qcyddWzI2NV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2Z1bmN0aW9uLmpzJ11bMjY2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnZnVuY3Rpb24uanMnXVsyNjddID0gMDtcbiAgXyRqc2NvdmVyYWdlWydmdW5jdGlvbi5qcyddWzI2OV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2Z1bmN0aW9uLmpzJ11bMjczXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnZnVuY3Rpb24uanMnXVszMTFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydmdW5jdGlvbi5qcyddWzMxMl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2Z1bmN0aW9uLmpzJ11bMzE1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnZnVuY3Rpb24uanMnXVszMTZdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydmdW5jdGlvbi5qcyddWzMxOV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2Z1bmN0aW9uLmpzJ11bMzIwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnZnVuY3Rpb24uanMnXVszMjJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydmdW5jdGlvbi5qcyddWzMyM10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2Z1bmN0aW9uLmpzJ11bMzI2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnZnVuY3Rpb24uanMnXVszMjddID0gMDtcbiAgXyRqc2NvdmVyYWdlWydmdW5jdGlvbi5qcyddWzMyOF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2Z1bmN0aW9uLmpzJ11bMzQ2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnZnVuY3Rpb24uanMnXVszNDddID0gMDtcbiAgXyRqc2NvdmVyYWdlWydmdW5jdGlvbi5qcyddWzM0OV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2Z1bmN0aW9uLmpzJ11bMzUwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnZnVuY3Rpb24uanMnXVszNTNdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydmdW5jdGlvbi5qcyddWzM1NF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2Z1bmN0aW9uLmpzJ11bMzU2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnZnVuY3Rpb24uanMnXVszNTddID0gMDtcbn1cbl8kanNjb3ZlcmFnZVsnZnVuY3Rpb24uanMnXVsxXSsrO1xudmFyIGlzID0gcmVxdWlyZShcIi4vaXNcIiksIGFJbnNlcnQgPSByZXF1aXJlKFwiLi9hcnJheVwiKS5pbnNlcnQ7XG5fJGpzY292ZXJhZ2VbJ2Z1bmN0aW9uLmpzJ11bM10rKztcbmFFYWNoID0gcmVxdWlyZShcIi4vYXJyYXlcIikuZWFjaDtcbl8kanNjb3ZlcmFnZVsnZnVuY3Rpb24uanMnXVsxMl0rKztcbmZ1bmN0aW9uIF9hdWdtZW50QXJncyhjb25maWcsIGNhbGxBcmdzKSB7XG4gIF8kanNjb3ZlcmFnZVsnZnVuY3Rpb24uanMnXVsxM10rKztcbiAgdmFyIGNvbmZpZ0FyZ3MgPSBjb25maWcuYXJncywgaW5kZXggPSBjb25maWcuaW5kZXgsIGFyZ3NBcnJheTtcbiAgXyRqc2NvdmVyYWdlWydmdW5jdGlvbi5qcyddWzE3XSsrO1xuICBpZiAoISBjb25maWdBcmdzKSB7XG4gICAgXyRqc2NvdmVyYWdlWydmdW5jdGlvbi5qcyddWzE4XSsrO1xuICAgIHJldHVybiBjYWxsQXJncztcbiAgfVxuICBfJGpzY292ZXJhZ2VbJ2Z1bmN0aW9uLmpzJ11bMjFdKys7XG4gIGlmIChpbmRleCA9PT0gdHJ1ZSB8fCBpcy5pc051bWJlcihpbmRleCkpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ2Z1bmN0aW9uLmpzJ11bMjJdKys7XG4gICAgaWYgKGNvbmZpZy5hcmd1bWVudHNGaXJzdCA9PT0gZmFsc2UpIHtcbiAgICAgIF8kanNjb3ZlcmFnZVsnZnVuY3Rpb24uanMnXVsyM10rKztcbiAgICAgIHJldHVybiBhSW5zZXJ0KGNvbmZpZ0FyZ3MsIGNhbGxBcmdzLCBpbmRleCk7XG4gICAgfVxuICAgIF8kanNjb3ZlcmFnZVsnZnVuY3Rpb24uanMnXVsyNV0rKztcbiAgICByZXR1cm4gYUluc2VydChjYWxsQXJncywgY29uZmlnQXJncywgaW5kZXgpO1xuICB9XG4gIF8kanNjb3ZlcmFnZVsnZnVuY3Rpb24uanMnXVsyOF0rKztcbiAgcmV0dXJuIGNvbmZpZ0FyZ3M7XG59XG5fJGpzY292ZXJhZ2VbJ2Z1bmN0aW9uLmpzJ11bMzVdKys7XG5leHBvcnRzLmVtcHR5Rm4gPSAoZnVuY3Rpb24gKCkge1xufSk7XG5fJGpzY292ZXJhZ2VbJ2Z1bmN0aW9uLmpzJ11bNDJdKys7XG5leHBvcnRzLmFic3RyYWN0Rm4gPSAoZnVuY3Rpb24gKCkge1xuICBfJGpzY292ZXJhZ2VbJ2Z1bmN0aW9uLmpzJ11bNDNdKys7XG4gIHRocm93IG5ldyBFcnJvcihcImFic3RyYWN0Rm4gbXVzdCBiZSBpbXBsZW1lbnRlZFwiKTtcbn0pO1xuXyRqc2NvdmVyYWdlWydmdW5jdGlvbi5qcyddWzEwOF0rKztcbmV4cG9ydHMuY3JlYXRlQXVnbWVudGVyID0gKGZ1bmN0aW9uIChmbiwgY29uZmlnKSB7XG4gIF8kanNjb3ZlcmFnZVsnZnVuY3Rpb24uanMnXVsxMDldKys7XG4gIHZhciB0aGlzQXJnID0gY29uZmlnLnRoaXNBcmc7XG4gIF8kanNjb3ZlcmFnZVsnZnVuY3Rpb24uanMnXVsxMTFdKys7XG4gIHJldHVybiAoZnVuY3Rpb24gKCkge1xuICBfJGpzY292ZXJhZ2VbJ2Z1bmN0aW9uLmpzJ11bMTEyXSsrO1xuICByZXR1cm4gZm4uYXBwbHkodGhpc0FyZyB8fCB0aGlzLCBfYXVnbWVudEFyZ3MoY29uZmlnLCBhcmd1bWVudHMpKTtcbn0pO1xufSk7XG5fJGpzY292ZXJhZ2VbJ2Z1bmN0aW9uLmpzJ11bMTE2XSsrO1xuZnVuY3Rpb24gX2luaXRTZXF1ZW5jZUZ1bmN0aW9ucyhmbnMsIGNvbmZpZykge1xuICBfJGpzY292ZXJhZ2VbJ2Z1bmN0aW9uLmpzJ11bMTE3XSsrO1xuICB2YXIgdG9SdW4gPSBbXTtcbiAgXyRqc2NvdmVyYWdlWydmdW5jdGlvbi5qcyddWzExOF0rKztcbiAgYUVhY2goZm5zLCAoZnVuY3Rpb24gKGYpIHtcbiAgXyRqc2NvdmVyYWdlWydmdW5jdGlvbi5qcyddWzExOV0rKztcbiAgdmFyIGZuID0gZjtcbiAgXyRqc2NvdmVyYWdlWydmdW5jdGlvbi5qcyddWzEyMV0rKztcbiAgaWYgKGNvbmZpZykge1xuICAgIF8kanNjb3ZlcmFnZVsnZnVuY3Rpb24uanMnXVsxMjJdKys7XG4gICAgZm4gPSBleHBvcnRzLmNyZWF0ZUF1Z21lbnRlcihmLCBjb25maWcpO1xuICB9XG4gIF8kanNjb3ZlcmFnZVsnZnVuY3Rpb24uanMnXVsxMjVdKys7XG4gIHRvUnVuLnB1c2goZm4pO1xufSkpO1xuICBfJGpzY292ZXJhZ2VbJ2Z1bmN0aW9uLmpzJ11bMTI4XSsrO1xuICByZXR1cm4gdG9SdW47XG59XG5fJGpzY292ZXJhZ2VbJ2Z1bmN0aW9uLmpzJ11bMTYxXSsrO1xuZXhwb3J0cy5jcmVhdGVTZXF1ZW5jZSA9IChmdW5jdGlvbiAoZm5zLCBjb25maWcpIHtcbiAgXyRqc2NvdmVyYWdlWydmdW5jdGlvbi5qcyddWzE2Ml0rKztcbiAgdmFyIGZ1bmN0aW9ucyA9IF9pbml0U2VxdWVuY2VGdW5jdGlvbnMoZm5zLCBjb25maWcpO1xuICBfJGpzY292ZXJhZ2VbJ2Z1bmN0aW9uLmpzJ11bMTY0XSsrO1xuICByZXR1cm4gKGZ1bmN0aW9uICgpIHtcbiAgXyRqc2NvdmVyYWdlWydmdW5jdGlvbi5qcyddWzE2NV0rKztcbiAgdmFyIGkgPSAwLCBsZW4gPSBmdW5jdGlvbnMubGVuZ3RoO1xuICBfJGpzY292ZXJhZ2VbJ2Z1bmN0aW9uLmpzJ11bMTY4XSsrO1xuICBmb3IgKDsgaSA8IGxlbiAtIDE7ICsraSkge1xuICAgIF8kanNjb3ZlcmFnZVsnZnVuY3Rpb24uanMnXVsxNjldKys7XG4gICAgZnVuY3Rpb25zW2ldLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG4gIF8kanNjb3ZlcmFnZVsnZnVuY3Rpb24uanMnXVsxNzJdKys7XG4gIHJldHVybiBmdW5jdGlvbnNbbGVuIC0gMV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn0pO1xufSk7XG5fJGpzY292ZXJhZ2VbJ2Z1bmN0aW9uLmpzJ11bMjE0XSsrO1xuZXhwb3J0cy5jcmVhdGVTZXF1ZW5jZUlmID0gKGZ1bmN0aW9uIChmbnMsIGNvbmZpZykge1xuICBfJGpzY292ZXJhZ2VbJ2Z1bmN0aW9uLmpzJ11bMjE1XSsrO1xuICB2YXIgZnVuY3Rpb25zID0gX2luaXRTZXF1ZW5jZUZ1bmN0aW9ucyhmbnMsIGNvbmZpZyk7XG4gIF8kanNjb3ZlcmFnZVsnZnVuY3Rpb24uanMnXVsyMTddKys7XG4gIHJldHVybiAoZnVuY3Rpb24gKCkge1xuICBfJGpzY292ZXJhZ2VbJ2Z1bmN0aW9uLmpzJ11bMjE4XSsrO1xuICB2YXIgdmFsdWUsIGFyZ3MgPSBhcmd1bWVudHM7XG4gIF8kanNjb3ZlcmFnZVsnZnVuY3Rpb24uanMnXVsyMjFdKys7XG4gIGZ1bmN0aW9ucy5zb21lKChmdW5jdGlvbiAoZm4pIHtcbiAgXyRqc2NvdmVyYWdlWydmdW5jdGlvbi5qcyddWzIyMl0rKztcbiAgdmFsdWUgPSBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgXyRqc2NvdmVyYWdlWydmdW5jdGlvbi5qcyddWzIyNF0rKztcbiAgcmV0dXJuIHZhbHVlID09PSBmYWxzZTtcbn0pLCB0aGlzKTtcbiAgXyRqc2NvdmVyYWdlWydmdW5jdGlvbi5qcyddWzIyN10rKztcbiAgcmV0dXJuIHZhbHVlO1xufSk7XG59KTtcbl8kanNjb3ZlcmFnZVsnZnVuY3Rpb24uanMnXVsyNThdKys7XG5leHBvcnRzLmNyZWF0ZVJlbGF5ZXIgPSAoZnVuY3Rpb24gKGZucywgY29uZmlnKSB7XG4gIF8kanNjb3ZlcmFnZVsnZnVuY3Rpb24uanMnXVsyNTldKys7XG4gIHZhciBmdW5jdGlvbnMgPSBfaW5pdFNlcXVlbmNlRnVuY3Rpb25zKGZucywgY29uZmlnKTtcbiAgXyRqc2NvdmVyYWdlWydmdW5jdGlvbi5qcyddWzI2MV0rKztcbiAgcmV0dXJuIChmdW5jdGlvbiAoKSB7XG4gIF8kanNjb3ZlcmFnZVsnZnVuY3Rpb24uanMnXVsyNjJdKys7XG4gIHZhciB2YWx1ZSwgYXJncyA9IGFyZ3VtZW50cztcbiAgXyRqc2NvdmVyYWdlWydmdW5jdGlvbi5qcyddWzI2NV0rKztcbiAgZnVuY3Rpb25zLmZvckVhY2goKGZ1bmN0aW9uIChmbiwgaW5kZXgpIHtcbiAgXyRqc2NvdmVyYWdlWydmdW5jdGlvbi5qcyddWzI2Nl0rKztcbiAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgXyRqc2NvdmVyYWdlWydmdW5jdGlvbi5qcyddWzI2N10rKztcbiAgICB2YWx1ZSA9IGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG4gIGVsc2Uge1xuICAgIF8kanNjb3ZlcmFnZVsnZnVuY3Rpb24uanMnXVsyNjldKys7XG4gICAgdmFsdWUgPSBmbi5hcHBseSh0aGlzLCBbdmFsdWVdKTtcbiAgfVxufSksIHRoaXMpO1xuICBfJGpzY292ZXJhZ2VbJ2Z1bmN0aW9uLmpzJ11bMjczXSsrO1xuICByZXR1cm4gdmFsdWU7XG59KTtcbn0pO1xuXyRqc2NvdmVyYWdlWydmdW5jdGlvbi5qcyddWzMxMV0rKztcbmV4cG9ydHMuY3JlYXRlVGhyb3R0bGVkID0gKGZ1bmN0aW9uIChmLCBtaWxsaXMsIGNvbmZpZykge1xuICBfJGpzY292ZXJhZ2VbJ2Z1bmN0aW9uLmpzJ11bMzEyXSsrO1xuICB2YXIgZm4gPSBjb25maWc/IGV4cG9ydHMuY3JlYXRlQXVnbWVudGVyKGYsIGNvbmZpZyk6IGYsIHRpbWVPdXRJZCA9IGZhbHNlO1xuICBfJGpzY292ZXJhZ2VbJ2Z1bmN0aW9uLmpzJ11bMzE1XSsrO1xuICBpZiAoISBtaWxsaXMpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ2Z1bmN0aW9uLmpzJ11bMzE2XSsrO1xuICAgIHJldHVybiBmbjtcbiAgfVxuICBfJGpzY292ZXJhZ2VbJ2Z1bmN0aW9uLmpzJ11bMzE5XSsrO1xuICByZXR1cm4gKGZ1bmN0aW9uICgpIHtcbiAgXyRqc2NvdmVyYWdlWydmdW5jdGlvbi5qcyddWzMyMF0rKztcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIF8kanNjb3ZlcmFnZVsnZnVuY3Rpb24uanMnXVszMjJdKys7XG4gIGlmICh0aW1lT3V0SWQpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ2Z1bmN0aW9uLmpzJ11bMzIzXSsrO1xuICAgIGNsZWFyVGltZW91dCh0aW1lT3V0SWQpO1xuICB9XG4gIF8kanNjb3ZlcmFnZVsnZnVuY3Rpb24uanMnXVszMjZdKys7XG4gIHRpbWVPdXRJZCA9IHNldFRpbWVvdXQoKGZ1bmN0aW9uICgpIHtcbiAgXyRqc2NvdmVyYWdlWydmdW5jdGlvbi5qcyddWzMyN10rKztcbiAgdGltZU91dElkID0gZmFsc2U7XG4gIF8kanNjb3ZlcmFnZVsnZnVuY3Rpb24uanMnXVszMjhdKys7XG4gIGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xufSksIG1pbGxpcyk7XG59KTtcbn0pO1xuXyRqc2NvdmVyYWdlWydmdW5jdGlvbi5qcyddWzM0Nl0rKztcbmV4cG9ydHMuY3JlYXRlRGVmZXJyZWQgPSAoZnVuY3Rpb24gKGYsIG1pbGxpcywgY29uZmlnKSB7XG4gIF8kanNjb3ZlcmFnZVsnZnVuY3Rpb24uanMnXVszNDddKys7XG4gIHZhciBmbiA9IGNvbmZpZz8gZXhwb3J0cy5jcmVhdGVBdWdtZW50ZXIoZiwgY29uZmlnKTogZjtcbiAgXyRqc2NvdmVyYWdlWydmdW5jdGlvbi5qcyddWzM0OV0rKztcbiAgaWYgKCEgbWlsbGlzKSB7XG4gICAgXyRqc2NvdmVyYWdlWydmdW5jdGlvbi5qcyddWzM1MF0rKztcbiAgICByZXR1cm4gZm47XG4gIH1cbiAgXyRqc2NvdmVyYWdlWydmdW5jdGlvbi5qcyddWzM1M10rKztcbiAgcmV0dXJuIChmdW5jdGlvbiAoKSB7XG4gIF8kanNjb3ZlcmFnZVsnZnVuY3Rpb24uanMnXVszNTRdKys7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICBfJGpzY292ZXJhZ2VbJ2Z1bmN0aW9uLmpzJ11bMzU2XSsrO1xuICBzZXRUaW1lb3V0KChmdW5jdGlvbiAoKSB7XG4gIF8kanNjb3ZlcmFnZVsnZnVuY3Rpb24uanMnXVszNTddKys7XG4gIGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xufSksIG1pbGxpcyk7XG59KTtcbn0pO1xuXyRqc2NvdmVyYWdlWydmdW5jdGlvbi5qcyddLnNvdXJjZSA9IFtcInZhciBpcyA9IHJlcXVpcmUoJy4vaXMnKSxcIixcIiAgICBhSW5zZXJ0ID0gcmVxdWlyZSgnLi9hcnJheScpLmluc2VydDtcIixcIiAgICBhRWFjaCA9IHJlcXVpcmUoJy4vYXJyYXknKS5lYWNoO1wiLFwiXCIsXCIvKipcIixcIiAqIEBjbGFzcyBMdWMuRnVuY3Rpb25cIixcIiAqIFBhY2thZ2UgZm9yIGZ1bmN0aW9uIG1ldGhvZHMuICBNb3N0IG9mIHRoZW0gZm9sbG93IHRoZSBzYW1lIGFwaTpcIixcIiAqIGZ1bmN0aW9uIG9yIGZ1bmN0aW9uW10sIHJlbGV2YW50IGFyZ3MgLi4uIHdpdGggYW4gb3B0aW9uYWwgY29uZmlnXCIsXCIgKiB0byBMdWMuRnVuY3Rpb24uY3JlYXRlQXV0bWVudGVyIGFzIHRoZSBsYXN0IGFyZ3VtZW50LlwiLFwiICovXCIsXCJcIixcImZ1bmN0aW9uIF9hdWdtZW50QXJncyhjb25maWcsIGNhbGxBcmdzKSB7XCIsXCIgICAgdmFyIGNvbmZpZ0FyZ3MgPSBjb25maWcuYXJncyxcIixcIiAgICAgICAgaW5kZXggPSBjb25maWcuaW5kZXgsXCIsXCIgICAgICAgIGFyZ3NBcnJheTtcIixcIlwiLFwiICAgIGlmICghY29uZmlnQXJncykge1wiLFwiICAgICAgICByZXR1cm4gY2FsbEFyZ3M7XCIsXCIgICAgfVwiLFwiXCIsXCIgICAgaWYoaW5kZXggPT09IHRydWUgfHwgaXMuaXNOdW1iZXIoaW5kZXgpKSB7XCIsXCIgICAgICAgIGlmKGNvbmZpZy5hcmd1bWVudHNGaXJzdCA9PT0gZmFsc2UpIHtcIixcIiAgICAgICAgICAgIHJldHVybiBhSW5zZXJ0KGNvbmZpZ0FyZ3MsIGNhbGxBcmdzLCBpbmRleCk7XCIsXCIgICAgICAgIH1cIixcIiAgICAgICAgcmV0dXJuIGFJbnNlcnQoY2FsbEFyZ3MsIGNvbmZpZ0FyZ3MsIGluZGV4KTtcIixcIiAgICB9XCIsXCJcIixcIiAgICByZXR1cm4gY29uZmlnQXJncztcIixcIn1cIixcIlwiLFwiLyoqXCIsXCIgKiBBIHJldXNhYmxlIGVtcHR5IGZ1bmN0aW9uXCIsXCIgKiBAcmV0dXJuIHtGdW5jdGlvbn1cIixcIiAqL1wiLFwiZXhwb3J0cy5lbXB0eUZuID0gZnVuY3Rpb24oKSB7fTtcIixcIlwiLFwiLyoqXCIsXCIgKiBBIGZ1bmN0aW9uIHRoYXQgdGhyb3dzIGFuIGVycm9yIHdoZW4gY2FsbGVkLlwiLFwiICogVXNlZnVsIHdoZW4gZGVmaW5pbmcgYWJzdHJhY3QgbGlrZSBjbGFzc2VzXCIsXCIgKiBAcmV0dXJuIHtGdW5jdGlvbn1cIixcIiAqL1wiLFwiZXhwb3J0cy5hYnN0cmFjdEZuID0gZnVuY3Rpb24oKSB7XCIsXCIgICAgdGhyb3cgbmV3IEVycm9yKCdhYnN0cmFjdEZuIG11c3QgYmUgaW1wbGVtZW50ZWQnKTtcIixcIn07XCIsXCJcIixcIi8qKlwiLFwiICogQXVnbWVudCB0aGUgcGFzc2VkIGluIGZ1bmN0aW9uJ3MgdGhpc0FyZyBhbmQgb3IgYXJndW1lbnRzIG9iamVjdCBcIixcIiAqIGJhc2VkIG9uIHRoZSBwYXNzZWQgaW4gY29uZmlnLlwiLFwiICogXCIsXCIgKiBAcGFyYW0gIHtGdW5jdGlvbn0gZm4gdGhlIGZ1bmN0aW9uIHRvIGNhbGxcIixcIiAqIEBwYXJhbSAge09iamVjdH0gY29uZmlnXCIsXCIgKiBcIixcIiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnRoaXNBcmddIHRoZSB0aGlzQXJnIGZvciB0aGUgZnVuY3Rpb24gYmVpbmcgZXhlY3V0ZWQuXCIsXCIgKiBJZiB0aGlzIGlzIHRoZSBvbmx5IHByb3BlcnR5IG9uIHlvdXIgY29uZmlnIG9iamVjdCB0aGUgcHJlZmVycmVkIHdheSB3b3VsZFwiLFwiICogYmUganVzdCB0byB1c2UgRnVuY3Rpb24uYmluZFwiLFwiICogXCIsXCIgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmFyZ3NdIHRoZSBhcmd1bWVudHMgdXNlZCBmb3IgdGhlIGZ1bmN0aW9uIGJlaW5nIGV4ZWN1dGVkLlwiLFwiICogVGhpcyB3aWxsIHJlcGxhY2UgdGhlIGZ1bmN0aW9ucyBjYWxsIGFyZ3MgaWYgaW5kZXggaXMgbm90IGEgbnVtYmVyIG9yIFwiLFwiICogdHJ1ZS5cIixcIiAqIFwiLFwiICogQHBhcmFtIHtOdW1iZXIvVHJ1ZX0gW2NvbmZpZy5pbmRleF0gQnkgZGVmYXVsdCB0aGUgdGhlIGNvbmZpZ3VyZWQgYXJndW1lbnRzXCIsXCIgKiB3aWxsIGJlIGluc2VydGVkIGludG8gdGhlIGZ1bmN0aW9ucyBwYXNzZWQgaW4gY2FsbCBhcmd1bWVudHMuICBJZiBpbmRleCBpcyB0cnVlXCIsXCIgKiBhcHBlbmQgdGhlIGFyZ3MgdG9nZXRoZXIgaWYgaXQgaXMgYSBudW1iZXIgaW5zZXJ0IGl0IGF0IHRoZSBwYXNzZWQgaW4gaW5kZXguXCIsXCIgKiBcIixcIiAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuYXJndW1lbnRzRmlyc3RdIHBhc3MgaW4gZmFsc2UgdG8gXCIsXCIgKiBhdWdtZW50IHRoZSBjb25maWd1cmVkIGFyZ3MgZmlyc3Qgd2l0aCBMdWMuQXJyYXkuaW5zZXJ0LiAgRGVmYXVsdHNcIixcIiAqIHRvIHRydWVcIixcIiAgICAgXCIsXCIgICAgIGZ1bmN0aW9uIGZuKCkge1wiLFwiICAgICAgICBjb25zb2xlLmxvZyh0aGlzKVwiLFwiICAgICAgICBjb25zb2xlLmxvZyhhcmd1bWVudHMpXCIsXCIgICAgfVwiLFwiICAgIFwiLFwiICAgIC8vTHVjLkFycmF5Lmluc2VydChbNF0sIFsxLDIsM10sIDApXCIsXCIgICAgTHVjLkZ1bmN0aW9uLmNyZWF0ZUF1Z21lbnRlcihmbiwge1wiLFwiICAgICAgICB0aGlzQXJnOiB7Y29uZmlnZWRUaGlzQXJnOiB0cnVlfSxcIixcIiAgICAgICAgYXJnczogWzEsMiwzXSxcIixcIiAgICAgICAgaW5kZXg6MFwiLFwiICAgIH0pKDQpXCIsXCJcIixcIiAgICAmZ3Q7T2JqZWN0IHtjb25maWdlZFRoaXNBcmc6IHRydWV9XCIsXCIgICAgJmd0O1sxLCAyLCAzLCA0XVwiLFwiXCIsXCIgICAgLy9MdWMuQXJyYXkuaW5zZXJ0KFsxLDIsM10sIFs0XSwgMClcIixcIiAgICBMdWMuRnVuY3Rpb24uY3JlYXRlQXVnbWVudGVyKGZuLCB7XCIsXCIgICAgICAgIHRoaXNBcmc6IHtjb25maWdlZFRoaXNBcmc6IHRydWV9LFwiLFwiICAgICAgICBhcmdzOiBbMSwyLDNdLFwiLFwiICAgICAgICBpbmRleDowLFwiLFwiICAgICAgICBhcmd1bWVudHNGaXJzdDpmYWxzZVwiLFwiICAgIH0pKDQpXCIsXCJcIixcIiAgICAmZ3Q7T2JqZWN0IHtjb25maWdlZFRoaXNBcmc6IHRydWV9XCIsXCIgICAgJmd0O1s0LCAxLCAyLCAzXVwiLFwiXCIsXCIgICAgTHVjLkFycmF5Lmluc2VydChbNF0sIFsxLDIsM10sICB0cnVlKVwiLFwiICAgIHZhciBmID0gTHVjLkZ1bmN0aW9uLmNyZWF0ZUF1Z21lbnRlcihmbiwge1wiLFwiICAgICAgICBhcmdzOiBbMSwyLDNdLFwiLFwiICAgICAgICBpbmRleDogdHJ1ZVwiLFwiICAgIH0pO1wiLFwiXCIsXCIgICAgZi5hcHBseSh7Y29uZmlnOiBmYWxzZX0sIFs0XSlcIixcIlwiLFwiICAgICZndDtPYmplY3Qge2NvbmZpZzogZmFsc2V9XCIsXCIgICAgJmd0O1s0LCAxLCAyLCAzXVwiLFwiXCIsXCIgKiBAcmV0dXJuIHtGdW5jdGlvbn0gdGhlIGF1Z21lbnRlZCBmdW5jdGlvbi5cIixcIiAqL1wiLFwiZXhwb3J0cy5jcmVhdGVBdWdtZW50ZXIgPSBmdW5jdGlvbihmbiwgY29uZmlnKSB7XCIsXCIgICAgdmFyIHRoaXNBcmcgPSBjb25maWcudGhpc0FyZztcIixcIlwiLFwiICAgIHJldHVybiBmdW5jdGlvbigpIHtcIixcIiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcgfHwgdGhpcywgX2F1Z21lbnRBcmdzKGNvbmZpZywgYXJndW1lbnRzKSk7XCIsXCIgICAgfTtcIixcIn07XCIsXCJcIixcImZ1bmN0aW9uIF9pbml0U2VxdWVuY2VGdW5jdGlvbnMoZm5zLCBjb25maWcpIHtcIixcIiAgICB2YXIgdG9SdW4gPSBbXTtcIixcIiAgICBhRWFjaChmbnMsIGZ1bmN0aW9uKGYpIHtcIixcIiAgICAgICAgdmFyIGZuID0gZjtcIixcIlwiLFwiICAgICAgICBpZiAoY29uZmlnKSB7XCIsXCIgICAgICAgICAgICBmbiA9IGV4cG9ydHMuY3JlYXRlQXVnbWVudGVyKGYsIGNvbmZpZyk7XCIsXCIgICAgICAgIH1cIixcIlwiLFwiICAgICAgICB0b1J1bi5wdXNoKGZuKTtcIixcIiAgICB9KTtcIixcIlwiLFwiICAgIHJldHVybiB0b1J1bjtcIixcIn1cIixcIlwiLFwiLyoqXCIsXCIgKiBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHJ1bnMgdGhlIHBhc3NlZCBpbiBmdW5jdGlvbnNcIixcIiAqIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgZnVuY3Rpb24gY2FsbGVkLlwiLFwiICogXCIsXCIgKiBAcGFyYW0gIHtGdW5jdGlvbltdfSBmbnMgXCIsXCIgKiBAcGFyYW0gIHtPYmplY3R9IFtjb25maWddIENvbmZpZyBvYmplY3RcIixcIiAqIGZvciBMdWMuRnVuY3Rpb24uY3JlYXRlQXVnbWVudGVyLiAgSWYgZGVmaW5lZCBhbGwgb2YgdGhlIGZ1bmN0aW9uc1wiLFwiICogd2lsbCBnZXQgY3JlYXRlZCB3aXRoIHRoZSBwYXNzZWQgaW4gY29uZmlnO1wiLFwiICpcIixcIiAgICBMdWMuRnVuY3Rpb24uY3JlYXRlU2VxdWVuY2UoW1wiLFwiICAgICAgICBmdW5jdGlvbigpIHtcIixcIiAgICAgICAgICAgIGNvbnNvbGUubG9nKDEpXCIsXCIgICAgICAgIH0sXCIsXCIgICAgICAgIGZ1bmN0aW9uKCkge1wiLFwiICAgICAgICAgICAgY29uc29sZS5sb2coMilcIixcIiAgICAgICAgfSxcIixcIiAgICAgICAgZnVuY3Rpb24oKSB7XCIsXCIgICAgICAgICAgICBjb25zb2xlLmxvZygzKVwiLFwiICAgICAgICAgICAgY29uc29sZS5sb2coJ2ZpbmlzaGVkIGxvZ2dpbmcnKVwiLFwiICAgICAgICAgICAgcmV0dXJuIDQ7XCIsXCIgICAgICAgIH1cIixcIiAgICBdKSgpXCIsXCIgICAgJmd0OzFcIixcIiAgICAmZ3Q7MlwiLFwiICAgICZndDszXCIsXCIgICAgJmd0O2ZpbmlzaGVkIGxvZ2dpbmdcIixcIiAgICAmZ3Q7NFwiLFwiICogXCIsXCIgKiBAcmV0dXJuIHtGdW5jdGlvbn1cIixcIiAqL1wiLFwiZXhwb3J0cy5jcmVhdGVTZXF1ZW5jZSA9IGZ1bmN0aW9uKGZucywgY29uZmlnKSB7XCIsXCIgICAgdmFyIGZ1bmN0aW9ucyA9IF9pbml0U2VxdWVuY2VGdW5jdGlvbnMoZm5zLCBjb25maWcpO1wiLFwiXCIsXCIgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1wiLFwiICAgICAgICB2YXIgaSA9IDAsXCIsXCIgICAgICAgICAgICBsZW4gPSBmdW5jdGlvbnMubGVuZ3RoO1wiLFwiXCIsXCIgICAgICAgIGZvcig7aSAmbHQ7IGxlbiAtMTsgKytpKSB7XCIsXCIgICAgICAgICAgICBmdW5jdGlvbnNbaV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcIixcIiAgICAgICAgfVwiLFwiXCIsXCIgICAgICAgIHJldHVybiBmdW5jdGlvbnNbbGVuIC0xIF0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcIixcIiAgICB9O1wiLFwifTtcIixcIlwiLFwiLyoqXCIsXCIgKiBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHJ1bnMgdGhlIHBhc3NlZCBpbiBmdW5jdGlvbnNcIixcIiAqIGlmIG9uZSBvZiB0aGUgZnVuY3Rpb25zIHJlc3VsdHMgZmFsc2UgdGhlIHJlc3Qgb2YgdGhlIFwiLFwiICogZnVuY3Rpb25zIHdvbid0IHJ1biBhbmQgZmFsc2Ugd2lsbCBiZSByZXR1cm5lZC5cIixcIiAqXCIsXCIgKiBJZiBubyBmYWxzZSBpcyByZXR1cm5lZCB0aGUgdmFsdWUgb2YgdGhlIGxhc3QgZnVuY3Rpb24gcmV0dXJuIHdpbGwgYmUgcmV0dXJuZWRcIixcIiAqIFwiLFwiICAgIEx1Yy5GdW5jdGlvbi5jcmVhdGVTZXF1ZW5jZUlmKFtcIixcIiAgICAgICAgZnVuY3Rpb24oKSB7XCIsXCIgICAgICAgICAgICBjb25zb2xlLmxvZygxKVwiLFwiICAgICAgICB9LFwiLFwiICAgICAgICBmdW5jdGlvbigpIHtcIixcIiAgICAgICAgICAgIGNvbnNvbGUubG9nKDIpXCIsXCIgICAgICAgIH0sXCIsXCIgICAgICAgIGZ1bmN0aW9uKCkge1wiLFwiICAgICAgICAgICAgY29uc29sZS5sb2coMylcIixcIiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdmaW5pc2hlZCBsb2dnaW5nJylcIixcIiAgICAgICAgICAgIHJldHVybiA0O1wiLFwiICAgICAgICB9LCBmdW5jdGlvbigpIHtcIixcIiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcIixcIiAgICAgICAgfSwgZnVuY3Rpb24oKSB7XCIsXCIgICAgICAgICAgICBjb25zb2xlLmxvZygnaSBjYW50IGxvZycpXCIsXCIgICAgICAgIH1cIixcIiAgICBdKSgpXCIsXCJcIixcIiAgICAmZ3Q7MVwiLFwiICAgICZndDsyXCIsXCIgICAgJmd0OzNcIixcIiAgICAmZ3Q7ZmluaXNoZWQgbG9nZ2luZ1wiLFwiICAgICZndDtmYWxzZVwiLFwiICpcIixcIiAqIFwiLFwiICogQHBhcmFtICB7RnVuY3Rpb25bXX0gZm5zIFwiLFwiICogQHBhcmFtICB7T2JqZWN0fSBbY29uZmlnXSBDb25maWcgb2JqZWN0XCIsXCIgKiBmb3IgTHVjLkZ1bmN0aW9uLmNyZWF0ZUF1Z21lbnRlci4gIElmIGRlZmluZWQgYWxsIG9mIHRoZSBmdW5jdGlvbnNcIixcIiAqIHdpbGwgZ2V0IGNyZWF0ZWQgd2l0aCB0aGUgcGFzc2VkIGluIGNvbmZpZztcIixcIiAqIEByZXR1cm4ge0Z1bmN0aW9ufVwiLFwiICovXCIsXCJleHBvcnRzLmNyZWF0ZVNlcXVlbmNlSWYgPSBmdW5jdGlvbihmbnMsIGNvbmZpZykge1wiLFwiICAgIHZhciBmdW5jdGlvbnMgPSBfaW5pdFNlcXVlbmNlRnVuY3Rpb25zKGZucywgY29uZmlnKTtcIixcIlwiLFwiICAgIHJldHVybiBmdW5jdGlvbigpIHtcIixcIiAgICAgICAgdmFyIHZhbHVlLFwiLFwiICAgICAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcIixcIlwiLFwiICAgICAgICBmdW5jdGlvbnMuc29tZShmdW5jdGlvbihmbil7XCIsXCIgICAgICAgICAgICB2YWx1ZSA9IGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1wiLFwiXCIsXCIgICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IGZhbHNlO1wiLFwiICAgICAgICB9LCB0aGlzKTtcIixcIlwiLFwiICAgICAgICByZXR1cm4gdmFsdWU7XCIsXCIgICAgfTtcIixcIn07XCIsXCJcIixcIi8qKlwiLFwiICogUmV0dXJuIGEgZnVuY3Rpb25zIHRoYXQgcnVucyB0aGUgcGFzc2VkIGluIGZ1bmN0aW9uc1wiLFwiICogdGhlIHJlc3VsdCBvZiBlYWNoIGZ1bmN0aW9uIHdpbGwgYmUgdGhlIHRoZSBjYWxsIGFyZ3MgXCIsXCIgKiBmb3IgdGhlIG5leHQgZnVuY3Rpb24uICBUaGUgdmFsdWUgb2YgdGhlIGxhc3QgZnVuY3Rpb24gXCIsXCIgKiByZXR1cm4gd2lsbCBiZSByZXR1cm5lZC5cIixcIiAqIFwiLFwiICAgICBcIixcIiAgICAgTHVjLkZ1bmN0aW9uLmNyZWF0ZVJlbGF5ZXIoW1wiLFwiICAgICAgICBmdW5jdGlvbihzdHIpIHtcIixcIiAgICAgICAgICAgIHJldHVybiBzdHIgKyAnYidcIixcIiAgICAgICAgfSxcIixcIiAgICAgICAgZnVuY3Rpb24oc3RyKSB7XCIsXCIgICAgICAgICAgICByZXR1cm4gc3RyICsgJ2MnXCIsXCIgICAgICAgIH0sXCIsXCIgICAgICAgIGZ1bmN0aW9uKHN0cikge1wiLFwiICAgICAgICAgICAgcmV0dXJuIHN0ciArICdkJ1wiLFwiICAgICAgICB9XCIsXCIgICAgXSkoJ2EnKVwiLFwiXCIsXCIgICAgJmd0O1xcXCJhYmNkXFxcIlwiLFwiXCIsXCIgKiBAcGFyYW0gIHtGdW5jdGlvbltdfSBmbnMgXCIsXCIgKiBAcGFyYW0gIHtPYmplY3R9IFtjb25maWddIENvbmZpZyBvYmplY3RcIixcIiAqIGZvciBMdWMuRnVuY3Rpb24uY3JlYXRlQXVnbWVudGVyLiAgSWYgZGVmaW5lZCBhbGwgb2YgdGhlIGZ1bmN0aW9uc1wiLFwiICogd2lsbCBnZXQgY3JlYXRlZCB3aXRoIHRoZSBwYXNzZWQgaW4gY29uZmlnO1wiLFwiICogQHJldHVybiB7RnVuY3Rpb259XCIsXCIgKi9cIixcImV4cG9ydHMuY3JlYXRlUmVsYXllciA9IGZ1bmN0aW9uKGZucywgY29uZmlnKSB7XCIsXCIgICAgdmFyIGZ1bmN0aW9ucyA9IF9pbml0U2VxdWVuY2VGdW5jdGlvbnMoZm5zLCBjb25maWcpO1wiLFwiXCIsXCIgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1wiLFwiICAgICAgICB2YXIgdmFsdWUsXCIsXCIgICAgICAgICAgICBhcmdzID0gYXJndW1lbnRzO1wiLFwiXCIsXCIgICAgICAgIGZ1bmN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGZuLCBpbmRleCkge1wiLFwiICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XCIsXCIgICAgICAgICAgICAgICAgdmFsdWUgPSBmbi5hcHBseSh0aGlzLCBhcmdzKTtcIixcIiAgICAgICAgICAgIH0gZWxzZSB7XCIsXCIgICAgICAgICAgICAgICAgdmFsdWUgPSBmbi5hcHBseSh0aGlzLCBbdmFsdWVdKTtcIixcIiAgICAgICAgICAgIH1cIixcIiAgICAgICAgfSwgdGhpcyk7XCIsXCJcIixcIiAgICAgICAgcmV0dXJuIHZhbHVlO1wiLFwiICAgIH07XCIsXCJ9O1wiLFwiXCIsXCIvKipcIixcIiAqIENyZWF0ZSBhIHRocm90dGxlZCBmdW5jdGlvbiBmcm9tIHRoZSBwYXNzZWQgaW4gZnVuY3Rpb25cIixcIiAqIHRoYXQgd2lsbCBvbmx5IGdldCBjYWxsZWQgb25jZSB0aGUgcGFzc2VkIG51bWJlciBvZiBtaWxpc2Vjb25kc1wiLFwiICogaGF2ZSBiZWVuIGV4Y2VlZGVkLlwiLFwiICogXCIsXCIgICAgdmFyIGxvZ0FyZ3MgID0gZnVuY3Rpb24oKSB7XCIsXCIgICAgICAgIGNvbnNvbGUubG9nKGFyZ3VtZW50cylcIixcIiAgICB9O1wiLFwiXCIsXCIgICAgdmFyIGEgPSBMdWMuRnVuY3Rpb24uY3JlYXRlVGhyb3R0bGVkKGxvZ0FyZ3MsIDEpO1wiLFwiXCIsXCIgICAgZm9yKHZhciBpID0gMDsgaSAmbHQ7IDEwMDsgKytpKSB7XCIsXCIgICAgICAgIGEoMSwyLDMpO1wiLFwiICAgIH1cIixcIlwiLFwiICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XCIsXCIgICAgICAgIGEoMSlcIixcIiAgICB9LCAxMDApXCIsXCIgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcIixcIiAgICAgICAgYSgyKVwiLFwiICAgIH0sIDQwMClcIixcIlwiLFwiICAgICZndDtbMSwgMiwgM11cIixcIiAgICAmZ3Q7WzFdXCIsXCIgICAgJmd0O1syXVwiLFwiICogXCIsXCIgKiBAcGFyYW0gIHtGdW5jdGlvbn0gZm5cIixcIiAqIEBwYXJhbSAge051bWJlcn0gbWlsbGlzIE51bWJlciBvZiBtaWxsaXNlY29uZHMgdG9cIixcIiAqIHRocm90dGxlIHRoZSBmdW5jdGlvbi5cIixcIiAqIEBwYXJhbSAge09iamVjdH0gW2NvbmZpZ10gQ29uZmlnIG9iamVjdFwiLFwiICogZm9yIEx1Yy5GdW5jdGlvbi5jcmVhdGVBdWdtZW50ZXIuICBJZiBkZWZpbmVkIGFsbCBvZiB0aGUgZnVuY3Rpb25zXCIsXCIgKiB3aWxsIGdldCBjcmVhdGVkIHdpdGggdGhlIHBhc3NlZCBpbiBjb25maWc7XCIsXCIgKiBAcmV0dXJuIHtGdW5jdGlvbn1cIixcIiAqL1wiLFwiZXhwb3J0cy5jcmVhdGVUaHJvdHRsZWQgPSBmdW5jdGlvbihmLCBtaWxsaXMsIGNvbmZpZykge1wiLFwiICAgIHZhciBmbiA9IGNvbmZpZyA/IGV4cG9ydHMuY3JlYXRlQXVnbWVudGVyKGYsIGNvbmZpZykgOiBmLFwiLFwiICAgICAgICB0aW1lT3V0SWQgPSBmYWxzZTtcIixcIlwiLFwiICAgIGlmKCFtaWxsaXMpIHtcIixcIiAgICAgICAgcmV0dXJuIGZuO1wiLFwiICAgIH1cIixcIlwiLFwiICAgIHJldHVybiBmdW5jdGlvbigpIHtcIixcIiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XCIsXCJcIixcIiAgICAgICAgaWYodGltZU91dElkKSB7XCIsXCIgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZU91dElkKTtcIixcIiAgICAgICAgfVwiLFwiXCIsXCIgICAgICAgIHRpbWVPdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XCIsXCIgICAgICAgICAgICB0aW1lT3V0SWQgPSBmYWxzZTtcIixcIiAgICAgICAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1wiLFwiICAgICAgICB9LCBtaWxsaXMpO1wiLFwiICAgIH07XCIsXCJ9O1wiLFwiXCIsXCIvKipcIixcIiAqIERlZmVyIGEgZnVuY3Rpb24ncyBleGVjdXRpb24gZm9yIHRoZSBwYXNzZWQgaW5cIixcIiAqIG1pbGxpc2Vjb25kcy5cIixcIiAqIFwiLFwiICogQHBhcmFtICB7RnVuY3Rpb259IGZuXCIsXCIgKiBAcGFyYW0gIHtOdW1iZXJ9IG1pbGxpcyBOdW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvXCIsXCIgKiBkZWZlclwiLFwiICogQHBhcmFtICB7T2JqZWN0fSBbY29uZmlnXSBDb25maWcgb2JqZWN0XCIsXCIgKiBmb3IgTHVjLkZ1bmN0aW9uLmNyZWF0ZUF1Z21lbnRlci4gIElmIGRlZmluZWQgYWxsIG9mIHRoZSBmdW5jdGlvbnNcIixcIiAqIHdpbGwgZ2V0IGNyZWF0ZWQgd2l0aCB0aGUgcGFzc2VkIGluIGNvbmZpZztcIixcIiAqIFwiLFwiICogQHJldHVybiB7RnVuY3Rpb259XCIsXCIgKi9cIixcImV4cG9ydHMuY3JlYXRlRGVmZXJyZWQgPSBmdW5jdGlvbihmLCBtaWxsaXMsIGNvbmZpZykge1wiLFwiICAgIHZhciBmbiA9IGNvbmZpZyA/IGV4cG9ydHMuY3JlYXRlQXVnbWVudGVyKGYsIGNvbmZpZykgOiBmO1wiLFwiXCIsXCIgICAgaWYoIW1pbGxpcykge1wiLFwiICAgICAgICByZXR1cm4gZm47XCIsXCIgICAgfVwiLFwiXCIsXCIgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1wiLFwiICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcIixcIlwiLFwiICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1wiLFwiICAgICAgICAgICAgZm4uYXBwbHkodGhpcywgYXJncyk7XCIsXCIgICAgICAgIH0sIG1pbGxpcyk7XCIsXCIgICAgfTtcIixcIn07XCJdO1xuIiwiLyogYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgYnkgSlNDb3ZlcmFnZSAtIGRvIG5vdCBlZGl0ICovXG5pZiAodHlwZW9mIF8kanNjb3ZlcmFnZSA9PT0gJ3VuZGVmaW5lZCcpIF8kanNjb3ZlcmFnZSA9IHt9O1xuaWYgKCEgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddKSB7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXSA9IFtdO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bNl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bN10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bOV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMTBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzEzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVsxNF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMTddID0gMDtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzE4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVsyMl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMjNdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzI1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVsyNl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMTEzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVsxMTRdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzExNV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMTE3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVsxMzJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzEzM10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMTQ2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVsxNDddID0gMDtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzE0OF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMTY0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVsxNjVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzE2Nl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMTkzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVsxOTRdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzE5NV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMjE4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVsyMTldID0gMDtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzIyM10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMjI0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVsyMjddID0gMDtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzIyOF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMjI5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVsyNDZdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzI0N10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMjQ4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVsyNDldID0gMDtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzI1Ml0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMjUzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVsyNTVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzI1Nl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMjU3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVsyNThdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzI2Ml0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMjc0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVsyNzVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzI3Nl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMjg4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVsyODldID0gMDtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzI5MF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMjk0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVsyOTVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzI5OF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMjk5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVszMDBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzMwMV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMzA1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVszMDZdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzMwOV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMzIxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVszMjJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzMyM10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMzM1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVszMzZdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzMzN10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMzQwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVszNDFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzM0Ml0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMzQzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVszNDRdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzM0NV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMzQ5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVszNjFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzM2Ml0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMzYzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVszNzVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzM3Nl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMzc3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVszODBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzM4MV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMzgyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVszOTRdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzM5NV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMzk2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVs0MDhdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzQwOV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bNDEwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVs0MTRdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzQxNV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bNDE2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVs0MTddID0gMDtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzQxOF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bNDE5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVs0MjFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzQyMl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bNDIzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVs0MjRdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzQyNV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bNDI3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVs0MjhdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzQyOV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bNDMwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVs0MzJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzQzM10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bNDM0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVs0MzZdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzQzN10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bNDM5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVs0NDBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzQ0MV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bNDQzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVs0NDhdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzQ0OV0gPSAwO1xufVxuXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzFdKys7XG52YXIgYXJyYXlTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZSwgY29tcGFyZSA9IHJlcXVpcmUoXCIuL2NvbXBhcmVcIiksIGlzID0gcmVxdWlyZShcIi4vaXNcIiksIGNvbXBhcmUgPSBjb21wYXJlLmNvbXBhcmU7XG5fJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bNl0rKztcbmZ1bmN0aW9uIF9jcmVhdGVJdGVyYXRvckZuKGZuLCBjKSB7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVs3XSsrO1xuICB2YXIgY29uZmlnID0gYyB8fCB7fTtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzldKys7XG4gIGlmIChpcy5pc0Z1bmN0aW9uKGZuKSAmJiAoY29uZmlnLnR5cGUgIT09IFwic3RyaWN0XCIpKSB7XG4gICAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzEwXSsrO1xuICAgIHJldHVybiBjPyBmbi5iaW5kKGMpOiBmbjtcbiAgfVxuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMTNdKys7XG4gIGlmIChjb25maWcudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzE0XSsrO1xuICAgIGNvbmZpZy50eXBlID0gXCJsb29zZVwiO1xuICB9XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVsxN10rKztcbiAgcmV0dXJuIChmdW5jdGlvbiAodmFsdWUpIHtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzE4XSsrO1xuICByZXR1cm4gY29tcGFyZShmbiwgdmFsdWUsIGNvbmZpZyk7XG59KTtcbn1cbl8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVsyMl0rKztcbmZ1bmN0aW9uIF9jcmVhdGVJdGVyYXRvck5vdEZuKGZuLCBjb25maWcpIHtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzIzXSsrO1xuICB2YXIgZnVuY3Rpb25Ub05vdCA9IF9jcmVhdGVJdGVyYXRvckZuKGZuLCBjb25maWcpO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMjVdKys7XG4gIHJldHVybiAoZnVuY3Rpb24gKCkge1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMjZdKys7XG4gIHJldHVybiAhIGZ1bmN0aW9uVG9Ob3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn0pO1xufVxuXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzExM10rKztcbmZ1bmN0aW9uIHRvQXJyYXkoaXRlbSkge1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMTE0XSsrO1xuICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVsxMTVdKys7XG4gICAgcmV0dXJuIGl0ZW07XG4gIH1cbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzExN10rKztcbiAgcmV0dXJuIChpdGVtID09PSBudWxsIHx8IGl0ZW0gPT09IHVuZGVmaW5lZCk/IFtdOiBbaXRlbV07XG59XG5fJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMTMyXSsrO1xuZnVuY3Rpb24gbGFzdChhcnIpIHtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzEzM10rKztcbiAgcmV0dXJuIGFyclthcnIubGVuZ3RoIC0gMV07XG59XG5fJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMTQ2XSsrO1xuZnVuY3Rpb24gcGx1Y2soYXJyLCBrZXkpIHtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzE0N10rKztcbiAgcmV0dXJuIGFyci5tYXAoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMTQ4XSsrO1xuICByZXR1cm4gdmFsdWUgJiYgdmFsdWVba2V5XTtcbn0pKTtcbn1cbl8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVsxNjRdKys7XG5mdW5jdGlvbiBmcm9tSW5kZXgoYSwgaW5kZXgpIHtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzE2NV0rKztcbiAgdmFyIGFyciA9IGlzLmlzQXJndW1lbnRzKGEpPyBhcnJheVNsaWNlLmNhbGwoYSk6IGE7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVsxNjZdKys7XG4gIHJldHVybiBhcnJheVNsaWNlLmNhbGwoYXJyLCBpbmRleCwgYXJyLmxlbmd0aCk7XG59XG5fJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMTkzXSsrO1xuZnVuY3Rpb24gZWFjaChpdGVtLCBmbiwgdGhpc0FyZykge1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMTk0XSsrO1xuICB2YXIgYXJyID0gdG9BcnJheShpdGVtKTtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzE5NV0rKztcbiAgcmV0dXJuIGFyci5mb3JFYWNoLmNhbGwoYXJyLCBmbiwgdGhpc0FyZyk7XG59XG5fJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMjE4XSsrO1xuZnVuY3Rpb24gaW5zZXJ0KGZpcnN0QXJyYXlPckFyZ3MsIHNlY29uZEFycmF5T3JBcmdzLCBpbmRleE9yQXBwZW5kKSB7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVsyMTldKys7XG4gIHZhciBmaXJzdEFycmF5ID0gYXJyYXlTbGljZS5jYWxsKGZpcnN0QXJyYXlPckFyZ3MpLCBzZWNvbmRBcnJheSA9IGFycmF5U2xpY2UuY2FsbChzZWNvbmRBcnJheU9yQXJncyksIHNwbGljZUFyZ3M7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVsyMjNdKys7XG4gIGlmIChpbmRleE9yQXBwZW5kID09PSB0cnVlKSB7XG4gICAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzIyNF0rKztcbiAgICByZXR1cm4gZmlyc3RBcnJheS5jb25jYXQoc2Vjb25kQXJyYXkpO1xuICB9XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVsyMjddKys7XG4gIHNwbGljZUFyZ3MgPSBbaW5kZXhPckFwcGVuZCwgMF0uY29uY2F0KHNlY29uZEFycmF5KTtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzIyOF0rKztcbiAgZmlyc3RBcnJheS5zcGxpY2UuYXBwbHkoZmlyc3RBcnJheSwgc3BsaWNlQXJncyk7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVsyMjldKys7XG4gIHJldHVybiBmaXJzdEFycmF5O1xufVxuXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzI0Nl0rKztcbmZ1bmN0aW9uIHJlbW92ZUF0SW5kZXgoYXJyLCBpbmRleCkge1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMjQ3XSsrO1xuICB2YXIgaXRlbSA9IGFycltpbmRleF07XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVsyNDhdKys7XG4gIGFyci5zcGxpY2UoaW5kZXgsIDEpO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMjQ5XSsrO1xuICByZXR1cm4gaXRlbTtcbn1cbl8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVsyNTJdKys7XG5mdW5jdGlvbiBfcmVtb3ZlRmlyc3QoYXJyLCBmbikge1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMjUzXSsrO1xuICB2YXIgcmVtb3ZlZCA9IGZhbHNlO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMjU1XSsrO1xuICBhcnIuc29tZSgoZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMjU2XSsrO1xuICBpZiAoZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKSkge1xuICAgIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVsyNTddKys7XG4gICAgcmVtb3ZlZCA9IHJlbW92ZUF0SW5kZXgoYXJyLCBpbmRleCk7XG4gICAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzI1OF0rKztcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufSkpO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMjYyXSsrO1xuICByZXR1cm4gcmVtb3ZlZDtcbn1cbl8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVsyNzRdKys7XG5mdW5jdGlvbiByZW1vdmVGaXJzdChhcnIsIG9iaiwgY29uZmlnKSB7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVsyNzVdKys7XG4gIHZhciBmbiA9IF9jcmVhdGVJdGVyYXRvckZuKG9iaiwgY29uZmlnKTtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzI3Nl0rKztcbiAgcmV0dXJuIF9yZW1vdmVGaXJzdChhcnIsIGZuKTtcbn1cbl8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVsyODhdKys7XG5mdW5jdGlvbiByZW1vdmVGaXJzdE5vdChhcnIsIG9iaiwgY29uZmlnKSB7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVsyODldKys7XG4gIHZhciBmbiA9IF9jcmVhdGVJdGVyYXRvck5vdEZuKG9iaiwgY29uZmlnKTtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzI5MF0rKztcbiAgcmV0dXJuIF9yZW1vdmVGaXJzdChhcnIsIGZuKTtcbn1cbl8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVsyOTRdKys7XG5mdW5jdGlvbiBfcmVtb3ZlQWxsKGFyciwgZm4pIHtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzI5NV0rKztcbiAgdmFyIGluZGV4c1RvUmVtb3ZlID0gW10sIHJlbW92ZWQgPSBbXTtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzI5OF0rKztcbiAgYXJyLmZvckVhY2goKGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzI5OV0rKztcbiAgaWYgKGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMzAwXSsrO1xuICAgIGluZGV4c1RvUmVtb3ZlLnVuc2hpZnQoaW5kZXgpO1xuICAgIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVszMDFdKys7XG4gICAgcmVtb3ZlZC5wdXNoKHZhbHVlKTtcbiAgfVxufSkpO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMzA1XSsrO1xuICBpbmRleHNUb1JlbW92ZS5mb3JFYWNoKChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzMwNl0rKztcbiAgcmVtb3ZlQXRJbmRleChhcnIsIGluZGV4KTtcbn0pKTtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzMwOV0rKztcbiAgcmV0dXJuIHJlbW92ZWQ7XG59XG5fJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMzIxXSsrO1xuZnVuY3Rpb24gcmVtb3ZlQWxsTm90KGFyciwgb2JqLCBjb25maWcpIHtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzMyMl0rKztcbiAgdmFyIGZuID0gX2NyZWF0ZUl0ZXJhdG9yTm90Rm4ob2JqLCBjb25maWcpO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMzIzXSsrO1xuICByZXR1cm4gX3JlbW92ZUFsbChhcnIsIGZuKTtcbn1cbl8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVszMzVdKys7XG5mdW5jdGlvbiByZW1vdmVBbGwoYXJyLCBvYmosIGNvbmZpZykge1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMzM2XSsrO1xuICB2YXIgZm4gPSBfY3JlYXRlSXRlcmF0b3JGbihvYmosIGNvbmZpZyk7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVszMzddKys7XG4gIHJldHVybiBfcmVtb3ZlQWxsKGFyciwgZm4pO1xufVxuXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzM0MF0rKztcbmZ1bmN0aW9uIF9maW5kRmlyc3QoYXJyLCBmbikge1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMzQxXSsrO1xuICB2YXIgaXRlbSA9IGZhbHNlO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMzQyXSsrO1xuICBhcnIuc29tZSgoZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMzQzXSsrO1xuICBpZiAoZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKSkge1xuICAgIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVszNDRdKys7XG4gICAgaXRlbSA9IGFycltpbmRleF07XG4gICAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzM0NV0rKztcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufSkpO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMzQ5XSsrO1xuICByZXR1cm4gaXRlbTtcbn1cbl8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVszNjFdKys7XG5mdW5jdGlvbiBmaW5kRmlyc3QoYXJyLCBvYmosIGNvbmZpZykge1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMzYyXSsrO1xuICB2YXIgZm4gPSBfY3JlYXRlSXRlcmF0b3JGbihvYmosIGNvbmZpZyk7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVszNjNdKys7XG4gIHJldHVybiBfZmluZEZpcnN0KGFyciwgZm4pO1xufVxuXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzM3NV0rKztcbmZ1bmN0aW9uIGZpbmRGaXJzdE5vdChhcnIsIG9iaiwgY29uZmlnKSB7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVszNzZdKys7XG4gIHZhciBmbiA9IF9jcmVhdGVJdGVyYXRvck5vdEZuKG9iaiwgY29uZmlnKTtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzM3N10rKztcbiAgcmV0dXJuIF9maW5kRmlyc3QoYXJyLCBmbik7XG59XG5fJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMzgwXSsrO1xuZnVuY3Rpb24gX2ZpbmRBbGwoYXJyLCBmbikge1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMzgxXSsrO1xuICB2YXIgZm91bmQgPSBhcnIuZmlsdGVyKGZuKTtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzM4Ml0rKztcbiAgcmV0dXJuIGZvdW5kO1xufVxuXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzM5NF0rKztcbmZ1bmN0aW9uIGZpbmRBbGwoYXJyLCBvYmosIGNvbmZpZykge1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bMzk1XSsrO1xuICB2YXIgZm4gPSBfY3JlYXRlSXRlcmF0b3JGbihvYmosIGNvbmZpZyk7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVszOTZdKys7XG4gIHJldHVybiBfZmluZEFsbChhcnIsIGZuKTtcbn1cbl8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVs0MDhdKys7XG5mdW5jdGlvbiBmaW5kQWxsTm90KGFyciwgb2JqLCBjb25maWcpIHtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzQwOV0rKztcbiAgdmFyIGZuID0gX2NyZWF0ZUl0ZXJhdG9yTm90Rm4ob2JqLCBjb25maWcpO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bNDEwXSsrO1xuICByZXR1cm4gX2ZpbmRBbGwoYXJyLCBmbik7XG59XG5fJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bNDE0XSsrO1xuZXhwb3J0cy50b0FycmF5ID0gdG9BcnJheTtcbl8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVs0MTVdKys7XG5leHBvcnRzLmVhY2ggPSBlYWNoO1xuXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzQxNl0rKztcbmV4cG9ydHMuaW5zZXJ0ID0gaW5zZXJ0O1xuXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzQxN10rKztcbmV4cG9ydHMuZnJvbUluZGV4ID0gZnJvbUluZGV4O1xuXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzQxOF0rKztcbmV4cG9ydHMubGFzdCA9IGxhc3Q7XG5fJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bNDE5XSsrO1xuZXhwb3J0cy5wbHVjayA9IHBsdWNrO1xuXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzQyMV0rKztcbmV4cG9ydHMucmVtb3ZlQXRJbmRleCA9IHJlbW92ZUF0SW5kZXg7XG5fJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bNDIyXSsrO1xuZXhwb3J0cy5maW5kRmlyc3ROb3QgPSBmaW5kRmlyc3ROb3Q7XG5fJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bNDIzXSsrO1xuZXhwb3J0cy5maW5kQWxsTm90ID0gZmluZEFsbE5vdDtcbl8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVs0MjRdKys7XG5leHBvcnRzLmZpbmRGaXJzdCA9IGZpbmRGaXJzdDtcbl8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVs0MjVdKys7XG5leHBvcnRzLmZpbmRBbGwgPSBmaW5kQWxsO1xuXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzQyN10rKztcbmV4cG9ydHMucmVtb3ZlRmlyc3ROb3QgPSByZW1vdmVGaXJzdE5vdDtcbl8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVs0MjhdKys7XG5leHBvcnRzLnJlbW92ZUFsbE5vdCA9IHJlbW92ZUFsbE5vdDtcbl8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVs0MjldKys7XG5leHBvcnRzLnJlbW92ZUZpcnN0ID0gcmVtb3ZlRmlyc3Q7XG5fJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bNDMwXSsrO1xuZXhwb3J0cy5yZW1vdmVBbGwgPSByZW1vdmVBbGw7XG5fJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bNDMyXSsrO1xuKGZ1bmN0aW9uICgpIHtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzQzM10rKztcbiAgdmFyIF9jcmVhdGVMYXN0Rm4gPSAoZnVuY3Rpb24gKGZuTmFtZSkge1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bNDM0XSsrO1xuICB2YXIgbGFzdE5hbWUgPSBmbk5hbWUucmVwbGFjZShcIkZpcnN0XCIsIFwiTGFzdFwiKTtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzQzNl0rKztcbiAgZXhwb3J0c1tsYXN0TmFtZV0gPSAoZnVuY3Rpb24gKGFyciwgb2JqLCBjb25maWcpIHtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzQzN10rKztcbiAgdmFyIHJldDtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzQzOV0rKztcbiAgYXJyLnJldmVyc2UoKTtcbiAgXyRqc2NvdmVyYWdlWydhcnJheS5qcyddWzQ0MF0rKztcbiAgcmV0ID0gZXhwb3J0c1tmbk5hbWVdKGFyciwgb2JqLCBjb25maWcpO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bNDQxXSsrO1xuICBhcnIucmV2ZXJzZSgpO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bNDQzXSsrO1xuICByZXR1cm4gcmV0O1xufSk7XG59KSwgbmFtZXNUb0FkZExhc3QgPSBbXCJmaW5kRmlyc3ROb3RcIiwgXCJmaW5kRmlyc3RcIiwgXCJyZW1vdmVGaXJzdE5vdFwiLCBcInJlbW92ZUZpcnN0XCJdO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ11bNDQ4XSsrO1xuICBuYW1lc1RvQWRkTGFzdC5mb3JFYWNoKChmdW5jdGlvbiAoZm5OYW1lKSB7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXkuanMnXVs0NDldKys7XG4gIF9jcmVhdGVMYXN0Rm4oZm5OYW1lKTtcbn0pKTtcbn0pKCk7XG5fJGpzY292ZXJhZ2VbJ2FycmF5LmpzJ10uc291cmNlID0gW1widmFyIGFycmF5U2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UsXCIsXCIgICAgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpLFwiLFwiICAgIGlzID0gcmVxdWlyZSgnLi9pcycpLFwiLFwiICAgIGNvbXBhcmUgPSBjb21wYXJlLmNvbXBhcmU7XCIsXCJcIixcImZ1bmN0aW9uIF9jcmVhdGVJdGVyYXRvckZuKGZuLCBjKSB7XCIsXCIgICAgdmFyIGNvbmZpZyA9IGMgfHwge307XCIsXCJcIixcIiAgICBpZihpcy5pc0Z1bmN0aW9uKGZuKSAmYW1wOyZhbXA7IChjb25maWcudHlwZSAhPT0gJ3N0cmljdCcpKSB7XCIsXCIgICAgICAgIHJldHVybiBjID8gZm4uYmluZChjKSA6IGZuO1wiLFwiICAgIH1cIixcIlwiLFwiICAgIGlmKGNvbmZpZy50eXBlID09PSB1bmRlZmluZWQpIHtcIixcIiAgICAgICAgY29uZmlnLnR5cGUgPSAnbG9vc2UnO1wiLFwiICAgIH1cIixcIlwiLFwiICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1wiLFwiICAgICAgICByZXR1cm4gY29tcGFyZShmbiwgdmFsdWUsIGNvbmZpZyk7XCIsXCIgICAgfTtcIixcIn1cIixcIlwiLFwiZnVuY3Rpb24gX2NyZWF0ZUl0ZXJhdG9yTm90Rm4oZm4sIGNvbmZpZykge1wiLFwiICAgIHZhciBmdW5jdGlvblRvTm90ID0gX2NyZWF0ZUl0ZXJhdG9yRm4oZm4sIGNvbmZpZyk7XCIsXCIgICAgICAgIFwiLFwiICAgIHJldHVybiBmdW5jdGlvbigpIHtcIixcIiAgICAgICAgcmV0dXJuICFmdW5jdGlvblRvTm90LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XCIsXCIgICAgfTtcIixcIn1cIixcIlwiLFwiXCIsXCIvKipcIixcIiAqIEBjbGFzcyBMdWMuQXJyYXkgXCIsXCIgKiBQYWNrYWdlIGZvciBBcnJheSBtZXRob2RzLiAmbHQ7YnImZ3Q7XCIsXCIgKiBcIixcIiAqIEtlZXAgaW4gbWluZCB0aGF0IEx1YyBpcyBvcHRpb25hbGx5IHBhY2thZ2VkIHdpdGggZXM1IHNoaW0gc28geW91IGNhbiB3cml0ZSBlczUgY29kZSBpbiBub24gZXM1IGJyb3dzZXJzLlwiLFwiICogSXQgY29tZXMgd2l0aCB5b3VyIGZhdm9yaXRlIHtAbGluayBBcnJheSBBcnJheX0gbWV0aG9kcyBzdWNoIGFzIEFycmF5LmZvckVhY2gsIEFycmF5LmZpbHRlciwgQXJyYXkuc29tZSwgQXJyYXkuZXZlcnkgQXJyYXkucmVkdWNlUmlnaHQgLi5cIixcIiAqXCIsXCIgKiBBbHNvIGRvbid0IGZvcmdldCBhYm91dCBMdWMuQXJyYXkuZWFjaCBhbmQgTHVjLkFycmF5LnRvQXJyYXksIHRoZXkgYXJlIGdyZWF0IHV0aWxpdHkgbWV0aG9kc1wiLFwiICogdGhhdCBhcmUgdXNlZCBhbGwgb3ZlciB0aGUgZnJhbWV3b3JrLlwiLFwiICogXCIsXCIgKiBBbGwgcmVtb3ZlXFxcXCogLyBmaW5kXFxcXCogbWV0aG9kcyBmb2xsb3cgdGhlIHNhbWUgYXBpLiAgXFxcXCpBbGwgZnVuY3Rpb25zIHdpbGwgcmV0dXJuIGFuIGFycmF5IG9mIHJlbW92ZWQgb3IgZm91bmRcIixcIiAqIGl0ZW1zLiAgVGhlIGl0ZW1zIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGFycmF5IGluIHRoZSBvcmRlciB0aGV5IGFyZVwiLFwiICogZm91bmQuICBcXFxcKkZpcnN0IGZ1bmN0aW9ucyB3aWxsIHJldHVybiB0aGUgZmlyc3QgaXRlbSBhbmQgc3RvcCBpdGVyYXRpbmcgYWZ0ZXIgdGhhdCwgaWYgbm9uZVwiLFwiICogIGlzIGZvdW5kIGZhbHNlIGlzIHJldHVybmVkLiAgcmVtb3ZlXFxcXCogZnVuY3Rpb25zIHdpbGwgZGlyZWN0bHkgY2hhbmdlIHRoZSBwYXNzZWQgaW4gYXJyYXkuXCIsXCIgKiAgXFxcXCpOb3QgZnVuY3Rpb25zIG9ubHkgZG8gdGhlIGZvbGxvd2luZyBhY3Rpb25zIGlmIHRoZSBjb21wYXJpc29uIGlzIG5vdCB0cnVlLlwiLFwiICogIEFsbCByZW1vdmVcXFxcKiAvIGZpbmRcXFxcKiB0YWtlIHRoZSBmb2xsb3dpbmcgYXBpOiBhcnJheSwgb2JqZWN0VG9Db21wYXJlT3JJdGVyYXRvciwgY29tcGFyZUNvbmZpZ09yVGhpc0FyZyBmb3IgZXhhbXBsZTpcIixcIiAqXCIsXCIgICAgLy9tb3N0IGNvbW1vbiB1c2UgY2FzZVwiLFwiICAgIEx1Yy5BcnJheS5maW5kRmlyc3QoWzEsMiwzLCB7fV0sIHt9KTtcIixcIiAgICAmZ3Q7T2JqZWN0IHt9XCIsXCJcIixcIiAgICAvL3Bhc3MgaW4gb3B0aW9uIGNvbmZpZyBmb3IgYSBzdHJpY3QgPT09IGNvbXBhcmlzb25cIixcIiAgICBMdWMuQXJyYXkuZmluZEZpcnN0KFsxLDIsMyx7fV0sIHt9LCB7dHlwZTogJ3N0cmljdCd9KTtcIixcIiAgICAmZ3Q7ZmFsc2VcIixcIlwiLFwiICAgIC8vcGFzcyBpbiBhbiBpdGVyYXRvciBhbmQgdGhpc0FyZ1wiLFwiICAgIEx1Yy5BcnJheS5maW5kRmlyc3QoWzEsMiwzLHt9XSwgZnVuY3Rpb24odmFsLCBpbmRleCwgYXJyYXkpe1wiLFwiICAgICAgICByZXR1cm4gdmFsID09PSAzIHx8IHRoaXMubnVtID09PSB2YWw7XCIsXCIgICAgfSwge251bTogMX0pO1wiLFwiICAgICZndDsxXCIsXCIgICAgXCIsXCIgICAgLy95b3UgY2FuIHNlZSByZW1vdmUgbW9kaWZpZXMgdGhlIHBhc3NlZCBpbiBhcnJheS5cIixcIiAgICB2YXIgYXJyID0gWzEsMix7YToxfSwxLCB7YToxfV07XCIsXCIgICAgTHVjLkFycmF5LnJlbW92ZUZpcnN0KGFyciwge2E6MX0pXCIsXCIgICAgJmd0O3thOjF9XCIsXCIgICAgYXJyO1wiLFwiICAgICZndDtbMSwgMiwgMSwge2E6MX1dXCIsXCIgICAgTHVjLkFycmF5LnJlbW92ZUxhc3QoYXJyLCAxKVwiLFwiICAgICZndDsxXCIsXCIgICAgYXJyO1wiLFwiICAgICZndDtbMSwyLCB7YToxfV1cIixcIiAgICBcIixcIiAgICBcIixcIiAgICBMdWMuQXJyYXkuZmluZEFsbChbMSwyLDMsIHthOjEsYjoyfV0sIGZ1bmN0aW9uKCkge3JldHVybiB0cnVlO30pXCIsXCIgICAgJmd0OyBbMSwyLDMsIHthOjEsYjoyfV1cIixcIiAgICAvL3Nob3cgaG93IG5vdCB3b3JrcyB3aXRoIGFuIGl0ZXJhdG9yXCIsXCIgICAgTHVjLkFycmF5LmZpbmRBbGxOb3QoWzEsMiwzLCB7YToxLGI6Mn1dLCBmdW5jdGlvbigpIHtyZXR1cm4gdHJ1ZTt9KVwiLFwiICAgICZndDtbXVwiLFwiICpcIixcIiAqIEZvciBjb21tb25seSB1c2VkIGZpbmQvcmVtb3ZlIGZ1bmN0aW9ucyBjaGVjayBvdXQgTHVjLkFycmF5Rm5zIGZvciBleGFtcGxlIGFcIixcIiAqIFxcXCJjb21wYWN0XFxcIiBsaWtlIGZ1bmN0aW9uXCIsXCIgKiBcIixcIiAgICBMdWMuQXJyYXkuZmluZEFsbE5vdEZhbHN5KFtmYWxzZSwgJycsIHVuZGVmaW5lZCwgMCwge30sIFtdXSlcIixcIiAgICAmZ3Q7WzAsIHt9LCBbXV1cIixcIiAqXCIsXCIgKiBPciByZW1vdmUgYWxsIGVtcHR5IGl0ZW1zXCIsXCIgKiBcIixcIiAgICB2YXIgYXJyID0gWycnLCAwICwgW10sIHthOjF9LCB0cnVlLCB7fSwgWzFdXVwiLFwiICAgIEx1Yy5BcnJheS5yZW1vdmVBbGxFbXB0eShhcnIpXCIsXCIgICAgJmd0O1snJywgW10sIHt9XVwiLFwiICAgIGFyclwiLFwiICAgICZndDtbMCwge2E6MX0sIHRydWUsIFsxXV1cIixcIiAqL1wiLFwiXCIsXCIvKipcIixcIiAqIFR1cm4gdGhlIHBhc3NlZCBpbiBpdGVtIGludG8gYW4gYXJyYXkgaWYgaXRcIixcIiAqIGlzbid0IG9uZSBhbHJlYWR5LCBpZiB0aGUgaXRlbSBpcyBhbiBhcnJheSBqdXN0IHJldHVybiBpdC4gIFwiLFwiICogSXQgcmV0dXJucyBhbiBlbXB0eSBhcnJheSBpZiBpdGVtIGlzIG51bGwgb3IgdW5kZWZpbmVkLlwiLFwiICogSWYgaXQgaXMganVzdCBhIHNpbmdsZSBpdGVtIHJldHVybiBhbiBhcnJheSBjb250YWluaW5nIHRoZSBpdGVtLlwiLFwiICogXCIsXCIgICAgTHVjLkFycmF5LnRvQXJyYXkoKVwiLFwiICAgICZndDtbXVwiLFwiICAgIEx1Yy5BcnJheS50b0FycmF5KG51bGwpXCIsXCIgICAgJmd0O1tdXCIsXCIgICAgTHVjLkFycmF5LnRvQXJyYXkoMSlcIixcIiAgICAmZ3Q7WzFdXCIsXCIgICAgTHVjLkFycmF5LnRvQXJyYXkoWzEsMl0pXCIsXCIgICAgJmd0O1sxLCAyXVwiLFwiICpcIixcIiAqIEBwYXJhbSAge09iamVjdH0gaXRlbSBpdGVtIHRvIHR1cm4gaW50byBhbiBhcnJheS5cIixcIiAqIEByZXR1cm4gdGhlIGFycmF5XCIsXCIgKi9cIixcImZ1bmN0aW9uIHRvQXJyYXkoaXRlbSkge1wiLFwiICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XCIsXCIgICAgICAgIHJldHVybiBpdGVtO1wiLFwiICAgIH1cIixcIiAgICByZXR1cm4gKGl0ZW0gPT09IG51bGwgfHwgaXRlbSA9PT0gdW5kZWZpbmVkKSA/IFtdIDogW2l0ZW1dO1wiLFwifVwiLFwiXCIsXCIvKipcIixcIiAqIFJldHVybiB0aGUgbGFzdCBpdGVtIG9mIHRoZSBhcnJheVwiLFwiICogQHBhcmFtICB7QXJyYXl9IGFyclwiLFwiICogQHJldHVybiB7T2JqZWN0fSB0aGUgaXRlbVwiLFwiICAgIFwiLFwiICAgIHZhciBteUxvbmdBcnJheU5hbWVGb3JUaGluZ3NUaGF0SVdhbnRUb0tlZXBUcmFja09mID0gWzEsMiwzXVwiLFwiICAgIFwiLFwiICAgIEx1Yy5BcnJheS5sYXN0KG15TG9uZ0FycmF5TmFtZUZvclRoaW5nc1RoYXRJV2FudFRvS2VlcFRyYWNrT2YpO1wiLFwiICAgIHZzLlwiLFwiICAgIG15TG9uZ0FycmF5TmFtZUZvclRoaW5nc1RoYXRJV2FudFRvS2VlcFRyYWNrT2ZbbXlMb25nQXJyYXlOYW1lRm9yVGhpbmdzVGhhdElXYW50VG9LZWVwVHJhY2tPZi5sZW5ndGggLTFdXCIsXCIgKlwiLFwiICovXCIsXCJmdW5jdGlvbiBsYXN0KGFycikge1wiLFwiICAgIHJldHVybiBhcnJbYXJyLmxlbmd0aCAtMV07XCIsXCJ9XCIsXCJcIixcIi8qKlwiLFwiICogRmxhdHRlbiBvdXQgYW4gYXJyYXkgb2Ygb2JqZWN0cyBiYXNlZCBvZiB0aGVpciB2YWx1ZSBmb3IgdGhlIHBhc3NlZCBpbiBrZXkuXCIsXCIgKiBUaGlzIGFsc28gdGFrZXMgYWNjY291bnQgZm9yIG51bGwvdW5kZWZpbmVkIHZhbHVlcy5cIixcIiAqXCIsXCIgICAgTHVjLkFycmF5LnBsdWNrKFt1bmRlZmluZWQsIHthOicxJywgYjoyfSwge2I6M30sIHtiOjR9XSwgJ2InKVwiLFwiICAgICZndDtbdW5kZWZpbmVkLCAyLCAzLCA0XVwiLFwiICogQHBhcmFtICB7T2JqZWN0W119IGFyciBcIixcIiAqIEBwYXJhbSAge1N0cmluZ30ga2V5IFwiLFwiICogQHJldHVybiB7QXJyYXl9ICAgICBcIixcIiAqL1wiLFwiZnVuY3Rpb24gcGx1Y2soYXJyLCBrZXkpIHtcIixcIiAgICByZXR1cm4gYXJyLm1hcChmdW5jdGlvbih2YWx1ZSkge1wiLFwiICAgICAgICByZXR1cm4gdmFsdWUgJmFtcDsmYW1wOyB2YWx1ZVtrZXldO1wiLFwiICAgIH0pO1wiLFwifVwiLFwiXCIsXCIvKipcIixcIiAqIFJldHVybiB0aGUgaXRlbXMgaW5iZXR3ZWVuIHRoZSBwYXNzZWQgaW4gaW5kZXhcIixcIiAqIGFuZCB0aGUgZW5kIG9mIHRoZSBhcnJheS5cIixcIiAqXCIsXCIgICAgTHVjLkFycmF5LmZyb21JbmRleChbMSwyLDMsNCw1XSwgMSlcIixcIiAgICAmZ3Q7WzIsIDMsIDQsIDVdXCIsXCJcIixcIiAqIEBwYXJhbSAge0FycmF5L2FyZ3VtZW50c30gYXJyIFwiLFwiICogQHBhcmFtICB7TnVtYmVyfSBpbmRleCBcIixcIiAqIEByZXR1cm4ge0FycmF5fSB0aGUgbmV3IGFycmF5LlwiLFwiICogXCIsXCIgKi9cIixcImZ1bmN0aW9uIGZyb21JbmRleChhLCBpbmRleCkge1wiLFwiICAgIHZhciBhcnIgPSBpcy5pc0FyZ3VtZW50cyhhKSA/IGFycmF5U2xpY2UuY2FsbChhKSA6IGE7XCIsXCIgICAgcmV0dXJuIGFycmF5U2xpY2UuY2FsbChhcnIsIGluZGV4LCBhcnIubGVuZ3RoKTtcIixcIn1cIixcIlwiLFwiLyoqXCIsXCIgKiBSdW5zIGFuIEFycmF5LmZvckVhY2ggYWZ0ZXIgY2FsbGluZyBMdWMuQXJyYXkudG9BcnJheSBvbiB0aGUgaXRlbS5cIixcIiAgSXQgaXMgdmVyeSB1c2VmdWwgZm9yIHNldHRpbmcgdXAgZmxleGlibGUgYXBpJ3MgdGhhdCBjYW4gaGFuZGxlIG5vbmUgb25lIG9yIG1hbnkuXCIsXCJcIixcIiAgICBMdWMuQXJyYXkuZWFjaCh0aGlzLml0ZW1zLCBmdW5jdGlvbihpdGVtKSB7XCIsXCIgICAgICAgIHRoaXMuX2FkZEl0ZW0oaXRlbSk7XCIsXCIgICAgfSk7XCIsXCJcIixcIiAgICB2cy5cIixcIlwiLFwiICAgIGlmKEFycmF5LmlzQXJyYXkodGhpcy5pdGVtcykpe1wiLFwiICAgICAgICB0aGlzLml0ZW1zLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1wiLFwiICAgICAgICAgICAgdGhpcy5fYWRkSXRlbShpdGVtKTtcIixcIiAgICAgICAgfSlcIixcIiAgICB9XCIsXCIgICAgZWxzZSBpZih0aGlzLml0ZW1zICE9PSB1bmRlZmluZWQpIHtcIixcIiAgICAgICAgdGhpcy5fYWRkSXRlbSh0aGlzLml0ZW1zKTtcIixcIiAgICB9XCIsXCJcIixcIiAqIEBwYXJhbSAge09iamVjdH0gICBpdGVtXCIsXCIgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2tcIixcIiAqIEBwYXJhbSAge09iamVjdH0gICB0aGlzQXJnICAgXCIsXCIgKlwiLFwiICovXCIsXCJmdW5jdGlvbiBlYWNoKGl0ZW0sIGZuLCB0aGlzQXJnKSB7XCIsXCIgICAgdmFyIGFyciA9IHRvQXJyYXkoaXRlbSk7XCIsXCIgICAgcmV0dXJuIGFyci5mb3JFYWNoLmNhbGwoYXJyLCBmbiwgdGhpc0FyZyk7XCIsXCJ9XCIsXCJcIixcIi8qKlwiLFwiICogSW5zZXJ0IG9yIGFwcGVuZCB0aGUgc2Vjb25kIGFycmF5L2FyZ3VtZW50cyBpbnRvIHRoZVwiLFwiICogZmlyc3QgYXJyYXkvYXJndW1lbnRzLiAgVGhpcyBtZXRob2QgZG9lcyBub3QgYWx0ZXJcIixcIiAqIHRoZSBwYXNzZWQgaW4gYXJyYXkvYXJndW1lbnRzLlwiLFwiICogXCIsXCIgKiBAcGFyYW0gIHtBcnJheS9hcmd1bWVudHN9IGZpcnN0QXJyYXlPckFyZ3NcIixcIiAqIEBwYXJhbSAge0FycmF5L2FyZ3VtZW50c30gc2Vjb25kQXJyYXlPckFyZ3NcIixcIiAqIEBwYXJhbSAge051bWJlci90cnVlfSBpbmRleE9yQXBwZW5kIHRydWUgdG8gYXBwZW5kIFwiLFwiICogdGhlIHNlY29uZCBhcnJheSB0byB0aGUgZW5kIG9mIHRoZSBmaXJzdCBvbmUuICBJZiBpdCBpcyBhIG51bWJlclwiLFwiICogaW5zZXJ0IHRoZSBzZWNvbmRBcnJheSBpbnRvIHRoZSBmaXJzdCBvbmUgYXQgdGhlIHBhc3NlZCBpbiBpbmRleC5cIixcIiAqIEByZXR1cm4ge0FycmF5fSB0aGUgbmV3bHkgY3JlYXRlZCBhcnJheS5cIixcIiAqXCIsXCIgICAgTHVjLkFycmF5Lmluc2VydChbMCw0XSwgWzEsMiwzXSwgMSk7XCIsXCIgICAgJmd0O1swLCAxLCAyLCAzLCA0XVwiLFwiICAgIEx1Yy5BcnJheS5pbnNlcnQoWzAsNF0sIFsxLDIsM10sIHRydWUpO1wiLFwiICAgICZndDtbMCwgNCwgMSwgMiwgM11cIixcIiAgICBMdWMuQXJyYXkuaW5zZXJ0KFswLDRdLCBbMSwyLDNdLCAwKTtcIixcIiAgICAmZ3Q7WzEsIDIsIDMsIDAsIDRdXCIsXCIgKlwiLFwiICovXCIsXCJmdW5jdGlvbiBpbnNlcnQoZmlyc3RBcnJheU9yQXJncywgc2Vjb25kQXJyYXlPckFyZ3MsIGluZGV4T3JBcHBlbmQpIHtcIixcIiAgICB2YXIgZmlyc3RBcnJheSA9IGFycmF5U2xpY2UuY2FsbChmaXJzdEFycmF5T3JBcmdzKSxcIixcIiAgICAgICAgc2Vjb25kQXJyYXkgPSBhcnJheVNsaWNlLmNhbGwoc2Vjb25kQXJyYXlPckFyZ3MpLFwiLFwiICAgICAgICBzcGxpY2VBcmdzO1wiLFwiXCIsXCIgICAgaWYoaW5kZXhPckFwcGVuZCA9PT0gdHJ1ZSkge1wiLFwiICAgICAgICByZXR1cm4gZmlyc3RBcnJheS5jb25jYXQoc2Vjb25kQXJyYXkpO1wiLFwiICAgIH1cIixcIlwiLFwiICAgIHNwbGljZUFyZ3MgPSBbaW5kZXhPckFwcGVuZCwgMF0uY29uY2F0KHNlY29uZEFycmF5KTtcIixcIiAgICBmaXJzdEFycmF5LnNwbGljZS5hcHBseShmaXJzdEFycmF5LCBzcGxpY2VBcmdzKTtcIixcIiAgICByZXR1cm4gZmlyc3RBcnJheTtcIixcIn1cIixcIlwiLFwiLyoqXCIsXCIgKiBSZW1vdmUgYW4gaXRlbSBmcm9tIGFuIHRoZSBwYXNzZWQgaW4gYXJyXCIsXCIgKiBmcm9tIHRoZSBpbmRleC5cIixcIiAqIEBwYXJhbSAge0FycmF5fSBhcnJcIixcIiAqIEBwYXJhbSAge051bWJlcn0gaW5kZXhcIixcIiAqIEByZXR1cm4ge09iamVjdH0gdGhlIGl0ZW0gcmVtb3ZlZC5cIixcIiAqXCIsXCIgICAgdmFyIGFyciA9IFsxLDIsM107XCIsXCIgICAgTHVjLkFycmF5LnJlbW92ZUF0SW5kZXgoYXJyLCAxKTtcIixcIiAgICAmZ3Q7MlwiLFwiICAgIGFycjtcIixcIiAgICAmZ3Q7WzEsM11cIixcIlwiLFwiICovXCIsXCJmdW5jdGlvbiByZW1vdmVBdEluZGV4KGFyciwgaW5kZXgpIHtcIixcIiAgICB2YXIgaXRlbSA9IGFycltpbmRleF07XCIsXCIgICAgYXJyLnNwbGljZShpbmRleCwgMSk7XCIsXCIgICAgcmV0dXJuIGl0ZW07XCIsXCJ9XCIsXCJcIixcImZ1bmN0aW9uIF9yZW1vdmVGaXJzdChhcnIsIGZuKSB7XCIsXCIgICAgdmFyIHJlbW92ZWQgPSBmYWxzZTtcIixcIlwiLFwiICAgIGFyci5zb21lKGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1wiLFwiICAgICAgICBpZiAoZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKSkge1wiLFwiICAgICAgICAgICAgcmVtb3ZlZCA9IHJlbW92ZUF0SW5kZXgoYXJyLCBpbmRleCk7XCIsXCIgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcIixcIiAgICAgICAgfVwiLFwiICAgIH0pO1wiLFwiXCIsXCIgICAgcmV0dXJuIHJlbW92ZWQ7XCIsXCJ9XCIsXCJcIixcIi8qKlwiLFwiICogUmVtb3ZlIHRoZSBmaXJzdCBpdGVtIGZyb20gdGhlIHBhc3NlZCBpbiBhcnJheVwiLFwiICogdGhhdCB7QGxpbmsgTHVjI2NvbXBhcmUgbWF0Y2hlc30gdGhlIHBhc3NlZCBpbiBvYmplY3QuICBJbnN0ZWFkIG9mIFwiLFwiICogY29tcGFyaW5nIGFuIG9iamVjdCBhbiBpdGVyYXRvciBmdW5jdGlvbiBjYW4gYmVcIixcIiAqIHVzZWQuXCIsXCIgKiBcIixcIntjb3B5RG9jI2FyclBhcmFtc31cIixcIntjb3B5RG9jI2FyclJlbW92ZVNpbmdsZX1cIixcIiAqL1wiLFwiZnVuY3Rpb24gcmVtb3ZlRmlyc3QoYXJyLCBvYmosIGNvbmZpZykge1wiLFwiICAgIHZhciBmbiA9IF9jcmVhdGVJdGVyYXRvckZuKG9iaiwgY29uZmlnKTtcIixcIiAgICByZXR1cm4gX3JlbW92ZUZpcnN0KGFyciwgZm4pO1wiLFwifVwiLFwiXCIsXCIvKipcIixcIiAqIFJlbW92ZSB0aGUgZmlyc3QgaXRlbSBmcm9tIHRoZSBwYXNzZWQgaW4gYXJyYXlcIixcIiAqIHRoYXQgZG9lcyBub3Qge0BsaW5rIEx1YyNjb21wYXJlIG1hdGNofSB0aGUgcGFzc2VkIGluIG9iamVjdC4gIEluc3RlYWQgb2YgXCIsXCIgKiBjb21wYXJpbmcgYW4gb2JqZWN0IGFuIGl0ZXJhdG9yIGZ1bmN0aW9uIGNhbiBiZVwiLFwiICogdXNlZC5cIixcIiAqIFwiLFwie2NvcHlEb2MjYXJyUGFyYW1zfVwiLFwie2NvcHlEb2MjYXJyUmVtb3ZlU2luZ2xlfVwiLFwiICovXCIsXCJmdW5jdGlvbiByZW1vdmVGaXJzdE5vdChhcnIsIG9iaiwgY29uZmlnKSB7XCIsXCIgICAgdmFyIGZuID0gX2NyZWF0ZUl0ZXJhdG9yTm90Rm4ob2JqLCBjb25maWcpO1wiLFwiICAgIHJldHVybiBfcmVtb3ZlRmlyc3QoYXJyLCBmbik7XCIsXCJ9XCIsXCJcIixcIlwiLFwiZnVuY3Rpb24gX3JlbW92ZUFsbChhcnIsIGZuKSB7XCIsXCIgICAgdmFyIGluZGV4c1RvUmVtb3ZlID0gW10sXCIsXCIgICAgICAgIHJlbW92ZWQgPSBbXTtcIixcIlwiLFwiICAgIGFyci5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1wiLFwiICAgICAgICBpZiAoZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKSkge1wiLFwiICAgICAgICAgICAgaW5kZXhzVG9SZW1vdmUudW5zaGlmdChpbmRleCk7XCIsXCIgICAgICAgICAgICByZW1vdmVkLnB1c2godmFsdWUpO1wiLFwiICAgICAgICB9XCIsXCIgICAgfSk7XCIsXCJcIixcIiAgICBpbmRleHNUb1JlbW92ZS5mb3JFYWNoKGZ1bmN0aW9uKGluZGV4KXtcIixcIiAgICAgICAgcmVtb3ZlQXRJbmRleChhcnIsIGluZGV4KTtcIixcIiAgICB9KTtcIixcIlwiLFwiICAgIHJldHVybiByZW1vdmVkO1wiLFwifVwiLFwiXCIsXCIvKipcIixcIiAqIFJlbW92ZSB0aGUgYWxsIHRoZSBpdGVtcyBmcm9tIHRoZSBwYXNzZWQgaW4gYXJyYXlcIixcIiAqIHRoYXQgZG8gbm90IHtAbGluayBMdWMjY29tcGFyZSBtYXRjaH0gdGhlIHBhc3NlZCBpbiBvYmplY3QuICBJbnN0ZWFkIG9mIFwiLFwiICogY29tcGFyaW5nIGFuIG9iamVjdCBhbiBpdGVyYXRvciBmdW5jdGlvbiBjYW4gYmVcIixcIiAqIHVzZWQuXCIsXCIgKiBcIixcIntjb3B5RG9jI2FyclBhcmFtc31cIixcIntjb3B5RG9jI2FyclJlbW92ZUFsbH1cIixcIiAqL1wiLFwiZnVuY3Rpb24gcmVtb3ZlQWxsTm90KGFyciwgb2JqLCBjb25maWcpIHtcIixcIiAgICB2YXIgZm4gPSBfY3JlYXRlSXRlcmF0b3JOb3RGbihvYmosIGNvbmZpZyk7XCIsXCIgICAgcmV0dXJuIF9yZW1vdmVBbGwoYXJyLCBmbik7XCIsXCJ9XCIsXCJcIixcIi8qKlwiLFwiICogUmVtb3ZlIHRoZSBhbGwgdGhlIGl0ZW1zIGZyb20gdGhlIHBhc3NlZCBpbiBhcnJheVwiLFwiICogdGhhdCB7QGxpbmsgTHVjI2NvbXBhcmUgbWF0Y2hlc30gdGhlIHBhc3NlZCBpbiBvYmplY3QuICBJbnN0ZWFkIG9mIFwiLFwiICogY29tcGFyaW5nIGFuIG9iamVjdCBhbiBpdGVyYXRvciBmdW5jdGlvbiBjYW4gYmVcIixcIiAqIHVzZWQuXCIsXCIgKiBcIixcIntjb3B5RG9jI2FyclBhcmFtc31cIixcIntjb3B5RG9jI2FyclJlbW92ZUFsbH1cIixcIiAqL1wiLFwiZnVuY3Rpb24gcmVtb3ZlQWxsKGFyciwgb2JqLCBjb25maWcpIHtcIixcIiAgICB2YXIgZm4gPSBfY3JlYXRlSXRlcmF0b3JGbihvYmosIGNvbmZpZyk7XCIsXCIgICAgcmV0dXJuIF9yZW1vdmVBbGwoYXJyLCBmbik7XCIsXCJ9XCIsXCJcIixcImZ1bmN0aW9uIF9maW5kRmlyc3QoYXJyLCBmbikge1wiLFwiICAgIHZhciBpdGVtID0gZmFsc2U7XCIsXCIgICAgYXJyLnNvbWUoZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XCIsXCIgICAgICAgIGlmIChmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSB7XCIsXCIgICAgICAgICAgICBpdGVtID0gYXJyW2luZGV4XTtcIixcIiAgICAgICAgICAgIHJldHVybiB0cnVlO1wiLFwiICAgICAgICB9XCIsXCIgICAgfSk7XCIsXCJcIixcIiAgICByZXR1cm4gaXRlbTtcIixcIn1cIixcIlwiLFwiLyoqXCIsXCIgKiBGaW5kIHRoZSBmaXJzdCBpdGVtIGZyb20gdGhlIHBhc3NlZCBpbiBhcnJheVwiLFwiICogdGhhdCBkb2VzIHtAbGluayBMdWMjY29tcGFyZSBtYXRjaGVzfSB0aGUgcGFzc2VkIGluIG9iamVjdC4gIEluc3RlYWQgb2YgXCIsXCIgKiBjb21wYXJpbmcgYW4gb2JqZWN0IGFuIGl0ZXJhdG9yIGZ1bmN0aW9uIGNhbiBiZVwiLFwiICogdXNlZC5cIixcIiAqIFwiLFwie2NvcHlEb2MjYXJyUGFyYW1zfVwiLFwie2NvcHlEb2MjYXJyRmluZFNpbmdsZX1cIixcIiAqL1wiLFwiZnVuY3Rpb24gZmluZEZpcnN0KGFyciwgb2JqLCBjb25maWcpIHtcIixcIiAgICB2YXIgZm4gPSBfY3JlYXRlSXRlcmF0b3JGbihvYmosIGNvbmZpZyk7XCIsXCIgICAgcmV0dXJuIF9maW5kRmlyc3QoYXJyLCBmbik7XCIsXCJ9XCIsXCJcIixcIi8qKlwiLFwiICogRmluZCB0aGUgZmlyc3QgaXRlbSBmcm9tIHRoZSBwYXNzZWQgaW4gYXJyYXlcIixcIiAqIHRoYXQgZG9lcyBub3Qge0BsaW5rIEx1YyNjb21wYXJlIG1hdGNofSB0aGUgcGFzc2VkIGluIG9iamVjdC4gIEluc3RlYWQgb2YgXCIsXCIgKiBjb21wYXJpbmcgYW4gb2JqZWN0IGFuIGl0ZXJhdG9yIGZ1bmN0aW9uIGNhbiBiZVwiLFwiICogdXNlZC5cIixcIiAqIFwiLFwie2NvcHlEb2MjYXJyUGFyYW1zfVwiLFwie2NvcHlEb2MjYXJyRmluZFNpbmdsZX1cIixcIiAqL1wiLFwiZnVuY3Rpb24gZmluZEZpcnN0Tm90KGFyciwgb2JqLCBjb25maWcpIHtcIixcIiAgICB2YXIgZm4gPSBfY3JlYXRlSXRlcmF0b3JOb3RGbihvYmosIGNvbmZpZyk7XCIsXCIgICAgcmV0dXJuIF9maW5kRmlyc3QoYXJyLCBmbik7XCIsXCJ9XCIsXCJcIixcImZ1bmN0aW9uIF9maW5kQWxsKGFyciwgZm4pIHtcIixcIiAgICB2YXIgZm91bmQgPSBhcnIuZmlsdGVyKGZuKTtcIixcIiAgICByZXR1cm4gZm91bmQ7XCIsXCJ9XCIsXCJcIixcIi8qKlwiLFwiICogRmluZCBhbGwgb2YgdGhlIHRoZSBpdGVtcyBmcm9tIHRoZSBwYXNzZWQgaW4gYXJyYXlcIixcIiAqIHRoYXQge0BsaW5rIEx1YyNjb21wYXJlIG1hdGNoZXN9IHRoZSBwYXNzZWQgaW4gb2JqZWN0LiAgSW5zdGVhZCBvZiBcIixcIiAqIGNvbXBhcmluZyBhbiBvYmplY3QgYW4gaXRlcmF0b3IgZnVuY3Rpb24gY2FuIGJlXCIsXCIgKiB1c2VkLlwiLFwiICogXCIsXCJ7Y29weURvYyNhcnJQYXJhbXN9XCIsXCJ7Y29weURvYyNhcnJGaW5kQWxsfVwiLFwiICovXCIsXCJmdW5jdGlvbiBmaW5kQWxsKGFyciwgb2JqLCBjb25maWcpIHtcIixcIiAgICB2YXIgZm4gPSBfY3JlYXRlSXRlcmF0b3JGbihvYmosIGNvbmZpZyk7XCIsXCIgICAgcmV0dXJuIF9maW5kQWxsKGFyciwgZm4pO1wiLFwifVwiLFwiXCIsXCIvKipcIixcIiAqIEZpbmQgYWxsIG9mIHRoZSB0aGUgaXRlbXMgZnJvbSB0aGUgcGFzc2VkIGluIGFycmF5XCIsXCIgKiB0aGF0IGRvIG5vdCB7QGxpbmsgTHVjI2NvbXBhcmUgbWF0Y2h9IHRoZSBwYXNzZWQgaW4gb2JqZWN0LiAgSW5zdGVhZCBvZiBcIixcIiAqIGNvbXBhcmluZyBhbiBvYmplY3QgYW4gaXRlcmF0b3IgZnVuY3Rpb24gY2FuIGJlXCIsXCIgKiB1c2VkLlwiLFwiICogXCIsXCJ7Y29weURvYyNhcnJQYXJhbXN9XCIsXCJ7Y29weURvYyNhcnJGaW5kQWxsfVwiLFwiICovXCIsXCJmdW5jdGlvbiBmaW5kQWxsTm90KGFyciwgb2JqLCBjb25maWcpIHtcIixcIiAgICB2YXIgZm4gPSBfY3JlYXRlSXRlcmF0b3JOb3RGbihvYmosIGNvbmZpZyk7XCIsXCIgICAgcmV0dXJuIF9maW5kQWxsKGFyciwgZm4pO1wiLFwifVwiLFwiXCIsXCJcIixcImV4cG9ydHMudG9BcnJheSA9IHRvQXJyYXk7XCIsXCJleHBvcnRzLmVhY2ggPSBlYWNoO1wiLFwiZXhwb3J0cy5pbnNlcnQgPSBpbnNlcnQ7XCIsXCJleHBvcnRzLmZyb21JbmRleCA9IGZyb21JbmRleDtcIixcImV4cG9ydHMubGFzdCA9IGxhc3Q7XCIsXCJleHBvcnRzLnBsdWNrID0gcGx1Y2s7XCIsXCJcIixcImV4cG9ydHMucmVtb3ZlQXRJbmRleCA9IHJlbW92ZUF0SW5kZXg7XCIsXCJleHBvcnRzLmZpbmRGaXJzdE5vdCA9IGZpbmRGaXJzdE5vdDtcIixcImV4cG9ydHMuZmluZEFsbE5vdCA9IGZpbmRBbGxOb3Q7XCIsXCJleHBvcnRzLmZpbmRGaXJzdCA9IGZpbmRGaXJzdDtcIixcImV4cG9ydHMuZmluZEFsbCA9IGZpbmRBbGw7XCIsXCJcIixcImV4cG9ydHMucmVtb3ZlRmlyc3ROb3QgPSByZW1vdmVGaXJzdE5vdDtcIixcImV4cG9ydHMucmVtb3ZlQWxsTm90ID0gcmVtb3ZlQWxsTm90O1wiLFwiZXhwb3J0cy5yZW1vdmVGaXJzdCA9IHJlbW92ZUZpcnN0O1wiLFwiZXhwb3J0cy5yZW1vdmVBbGwgPSByZW1vdmVBbGw7XCIsXCJcIixcIihmdW5jdGlvbigpe1wiLFwiICAgIHZhciBfY3JlYXRlTGFzdEZuID0gZnVuY3Rpb24oZm5OYW1lKSB7XCIsXCIgICAgICAgIHZhciBsYXN0TmFtZSA9IGZuTmFtZS5yZXBsYWNlKCdGaXJzdCcsICdMYXN0Jyk7XCIsXCJcIixcIiAgICAgICAgZXhwb3J0c1tsYXN0TmFtZV0gPSBmdW5jdGlvbihhcnIsIG9iaiwgY29uZmlnKSB7XCIsXCIgICAgICAgICAgICB2YXIgcmV0O1wiLFwiXCIsXCIgICAgICAgICAgICBhcnIucmV2ZXJzZSgpO1wiLFwiICAgICAgICAgICAgcmV0ID0gZXhwb3J0c1tmbk5hbWVdKGFyciwgb2JqLCBjb25maWcpO1wiLFwiICAgICAgICAgICAgYXJyLnJldmVyc2UoKTtcIixcIlwiLFwiICAgICAgICAgICAgcmV0dXJuIHJldDtcIixcIiAgICAgICAgfTtcIixcIlwiLFwiICAgIH0sIG5hbWVzVG9BZGRMYXN0ID0gWydmaW5kRmlyc3ROb3QnLCAnZmluZEZpcnN0JywgJ3JlbW92ZUZpcnN0Tm90JywgJ3JlbW92ZUZpcnN0J107XCIsXCJcIixcIiAgICBuYW1lc1RvQWRkTGFzdC5mb3JFYWNoKGZ1bmN0aW9uKGZuTmFtZSkge1wiLFwiICAgICAgICBfY3JlYXRlTGFzdEZuKGZuTmFtZSk7XCIsXCIgICAgfSk7XCIsXCJcIixcIn0oKSk7XCIsXCJcIixcIi8qKlwiLFwiICogQG1lbWJlciBMdWMuQXJyYXkgXCIsXCIgKiBAbWV0aG9kIGZpbmRMYXN0Tm90IFwiLFwiICogU2FtZSBhcyBMdWMuQXJyYXkuZmluZEZpcnN0Tm90IGV4Y2VwdCBzdGFydCBhdCB0aGUgZW5kLlwiLFwiICovXCIsXCJcIixcIi8qKlwiLFwiICogQG1lbWJlciBMdWMuQXJyYXkgXCIsXCIgKiBAbWV0aG9kIGZpbmRMYXN0XCIsXCIgKiBTYW1lIGFzIEx1Yy5BcnJheS5maW5kRmlyc3QgZXhjZXB0IHN0YXJ0IGF0IHRoZSBlbmQuXCIsXCIgKi9cIixcIlwiLFwiLyoqXCIsXCIgKiBAbWVtYmVyIEx1Yy5BcnJheSBcIixcIiAqIEBtZXRob2QgcmVtb3ZlTGFzdE5vdCBcIixcIiAqIFNhbWUgYXMgTHVjLkFycmF5LnJlbW92ZUZpcnN0Tm90IGV4Y2VwdCBzdGFydCBhdCB0aGUgZW5kLlwiLFwiICovXCIsXCJcIixcIi8qKlwiLFwiICogQG1lbWJlciBMdWMuQXJyYXkgXCIsXCIgKiBAbWV0aG9kIHJlbW92ZUxhc3QgXCIsXCIgKiBTYW1lIGFzIEx1Yy5BcnJheS5yZW1vdmVGaXJzdCBleGNlcHQgc3RhcnQgYXQgdGhlIGVuZC5cIixcIiAqL1wiXTtcbiIsIi8qIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGJ5IEpTQ292ZXJhZ2UgLSBkbyBub3QgZWRpdCAqL1xuaWYgKHR5cGVvZiBfJGpzY292ZXJhZ2UgPT09ICd1bmRlZmluZWQnKSBfJGpzY292ZXJhZ2UgPSB7fTtcbmlmICghIF8kanNjb3ZlcmFnZVsnYXJyYXlGbkdlbmVyYXRvci5qcyddKSB7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXlGbkdlbmVyYXRvci5qcyddID0gW107XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXlGbkdlbmVyYXRvci5qcyddWzFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydhcnJheUZuR2VuZXJhdG9yLmpzJ11bNV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5Rm5HZW5lcmF0b3IuanMnXVsxMl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5Rm5HZW5lcmF0b3IuanMnXVsxM10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5Rm5HZW5lcmF0b3IuanMnXVsxOF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5Rm5HZW5lcmF0b3IuanMnXVsxOV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5Rm5HZW5lcmF0b3IuanMnXVsyMF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5Rm5HZW5lcmF0b3IuanMnXVsyNV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5Rm5HZW5lcmF0b3IuanMnXVs4M10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5Rm5HZW5lcmF0b3IuanMnXVs4NF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5Rm5HZW5lcmF0b3IuanMnXVs4Nl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5Rm5HZW5lcmF0b3IuanMnXVs4N10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5Rm5HZW5lcmF0b3IuanMnXVs4OF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5Rm5HZW5lcmF0b3IuanMnXVs4OV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5Rm5HZW5lcmF0b3IuanMnXVs5MF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5Rm5HZW5lcmF0b3IuanMnXVs5Nl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5Rm5HZW5lcmF0b3IuanMnXVs5N10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5Rm5HZW5lcmF0b3IuanMnXVsxMDBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydhcnJheUZuR2VuZXJhdG9yLmpzJ11bMTAyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXlGbkdlbmVyYXRvci5qcyddWzEwNV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5Rm5HZW5lcmF0b3IuanMnXVsxMDhdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydhcnJheUZuR2VuZXJhdG9yLmpzJ11bMTExXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXlGbkdlbmVyYXRvci5qcyddWzExNV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5Rm5HZW5lcmF0b3IuanMnXVsxMTZdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydhcnJheUZuR2VuZXJhdG9yLmpzJ11bMTE3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXlGbkdlbmVyYXRvci5qcyddWzEyMl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5Rm5HZW5lcmF0b3IuanMnXVsxMjNdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydhcnJheUZuR2VuZXJhdG9yLmpzJ11bMTI1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXlGbkdlbmVyYXRvci5qcyddWzEyNl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5Rm5HZW5lcmF0b3IuanMnXVsxMjldID0gMDtcbiAgXyRqc2NvdmVyYWdlWydhcnJheUZuR2VuZXJhdG9yLmpzJ11bMTMwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXlGbkdlbmVyYXRvci5qcyddWzEzMV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5Rm5HZW5lcmF0b3IuanMnXVsxMzJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydhcnJheUZuR2VuZXJhdG9yLmpzJ11bMTM1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXlGbkdlbmVyYXRvci5qcyddWzEzOF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5Rm5HZW5lcmF0b3IuanMnXVsxNDNdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydhcnJheUZuR2VuZXJhdG9yLmpzJ11bMTQ0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXlGbkdlbmVyYXRvci5qcyddWzE0NV0gPSAwO1xufVxuXyRqc2NvdmVyYWdlWydhcnJheUZuR2VuZXJhdG9yLmpzJ11bMV0rKztcbnZhciBhcnJheSA9IHJlcXVpcmUoXCIuL2FycmF5XCIpLCBpcyA9IHJlcXVpcmUoXCIuL2lzXCIpLCBHZW5lcmF0b3I7XG5fJGpzY292ZXJhZ2VbJ2FycmF5Rm5HZW5lcmF0b3IuanMnXVs1XSsrO1xuR2VuZXJhdG9yID0ge2FycmF5Rm5OYW1lczogW1wiZmluZEZpcnN0Tm90XCIsIFwiZmluZEFsbE5vdFwiLCBcImZpbmRGaXJzdFwiLCBcImZpbmRBbGxcIiwgXCJyZW1vdmVGaXJzdE5vdFwiLCBcInJlbW92ZUFsbE5vdFwiLCBcInJlbW92ZUZpcnN0XCIsIFwicmVtb3ZlQWxsXCIsIFwicmVtb3ZlTGFzdE5vdFwiLCBcInJlbW92ZUxhc3RcIiwgXCJmaW5kTGFzdFwiLCBcImZpbmRMYXN0Tm90XCJdLCBjcmVhdGVGbjogKGZ1bmN0aW9uIChhcnJheUZuTmFtZSwgZm4pIHtcbiAgXyRqc2NvdmVyYWdlWydhcnJheUZuR2VuZXJhdG9yLmpzJ11bMTJdKys7XG4gIHJldHVybiAoZnVuY3Rpb24gKGFycikge1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5Rm5HZW5lcmF0b3IuanMnXVsxM10rKztcbiAgcmV0dXJuIGFycmF5W2FycmF5Rm5OYW1lXShhcnIsIGZuKTtcbn0pO1xufSksIGNyZWF0ZUJvdW5kRm46IChmdW5jdGlvbiAoYXJyYXlGbk5hbWUsIGZuVG9CaW5kKSB7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXlGbkdlbmVyYXRvci5qcyddWzE4XSsrO1xuICByZXR1cm4gKGZ1bmN0aW9uIChhcnIsIHZhbHVlKSB7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXlGbkdlbmVyYXRvci5qcyddWzE5XSsrO1xuICB2YXIgZm4gPSBmblRvQmluZC5hcHBseSh0aGlzLCBhcnJheS5mcm9tSW5kZXgoYXJndW1lbnRzLCAxKSk7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXlGbkdlbmVyYXRvci5qcyddWzIwXSsrO1xuICByZXR1cm4gYXJyYXlbYXJyYXlGbk5hbWVdKGFyciwgZm4pO1xufSk7XG59KX07XG5fJGpzY292ZXJhZ2VbJ2FycmF5Rm5HZW5lcmF0b3IuanMnXVsyNV0rKztcbm1vZHVsZS5leHBvcnRzID0gR2VuZXJhdG9yO1xuXyRqc2NvdmVyYWdlWydhcnJheUZuR2VuZXJhdG9yLmpzJ11bODNdKys7XG4oZnVuY3Rpb24gX2NyZWF0ZUlzRm5zKCkge1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5Rm5HZW5lcmF0b3IuanMnXVs4NF0rKztcbiAgdmFyIGlzVG9JZ25vcmUgPSBbXCJpc1JlZ0V4cFwiLCBcImlzQXJndW1lbnRzXCJdO1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5Rm5HZW5lcmF0b3IuanMnXVs4Nl0rKztcbiAgT2JqZWN0LmtleXMoaXMpLmZvckVhY2goKGZ1bmN0aW9uIChrZXkpIHtcbiAgXyRqc2NvdmVyYWdlWydhcnJheUZuR2VuZXJhdG9yLmpzJ11bODddKys7XG4gIHZhciBuYW1lID0ga2V5LnNwbGl0KFwiaXNcIilbMV07XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXlGbkdlbmVyYXRvci5qcyddWzg4XSsrO1xuICBHZW5lcmF0b3IuYXJyYXlGbk5hbWVzLmZvckVhY2goKGZ1bmN0aW9uIChmbk5hbWUpIHtcbiAgXyRqc2NvdmVyYWdlWydhcnJheUZuR2VuZXJhdG9yLmpzJ11bODldKys7XG4gIGlmIChpc1RvSWdub3JlLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ2FycmF5Rm5HZW5lcmF0b3IuanMnXVs5MF0rKztcbiAgICBhcnJheVtmbk5hbWUgKyBuYW1lXSA9IEdlbmVyYXRvci5jcmVhdGVGbihmbk5hbWUsIGlzW2tleV0pO1xuICB9XG59KSk7XG59KSk7XG59KSgpO1xuXyRqc2NvdmVyYWdlWydhcnJheUZuR2VuZXJhdG9yLmpzJ11bOTZdKys7XG4oZnVuY3Rpb24gX2NyZWF0ZUZhbHN5Rm5zKCkge1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5Rm5HZW5lcmF0b3IuanMnXVs5N10rKztcbiAgdmFyIHVzZWZ1bGxGYWxzeUZucyA9IFtcImZpbmRGaXJzdE5vdFwiLCBcImZpbmRBbGxOb3RcIiwgXCJyZW1vdmVGaXJzdE5vdFwiLCBcInJlbW92ZUFsbE5vdFwiLCBcInJlbW92ZUZpcnN0XCIsIFwicmVtb3ZlQWxsXCIsIFwicmVtb3ZlTGFzdE5vdFwiLCBcInJlbW92ZUxhc3RcIiwgXCJmaW5kTGFzdE5vdFwiXTtcbiAgXyRqc2NvdmVyYWdlWydhcnJheUZuR2VuZXJhdG9yLmpzJ11bMTAwXSsrO1xuICB2YXIgZm5zID0ge1wiRmFsc2VcIjogKGZ1bmN0aW9uICh2YWwpIHtcbiAgXyRqc2NvdmVyYWdlWydhcnJheUZuR2VuZXJhdG9yLmpzJ11bMTAyXSsrO1xuICByZXR1cm4gdmFsID09PSBmYWxzZTtcbn0pLCBcIlRydWVcIjogKGZ1bmN0aW9uICh2YWwpIHtcbiAgXyRqc2NvdmVyYWdlWydhcnJheUZuR2VuZXJhdG9yLmpzJ11bMTA1XSsrO1xuICByZXR1cm4gdmFsID09PSB0cnVlO1xufSksIFwiTnVsbFwiOiAoZnVuY3Rpb24gKHZhbCkge1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5Rm5HZW5lcmF0b3IuanMnXVsxMDhdKys7XG4gIHJldHVybiB2YWwgPT09IG51bGw7XG59KSwgXCJVbmRlZmluZWRcIjogKGZ1bmN0aW9uICh2YWwpIHtcbiAgXyRqc2NvdmVyYWdlWydhcnJheUZuR2VuZXJhdG9yLmpzJ11bMTExXSsrO1xuICByZXR1cm4gdmFsID09PSB1bmRlZmluZWQ7XG59KX07XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXlGbkdlbmVyYXRvci5qcyddWzExNV0rKztcbiAgT2JqZWN0LmtleXMoZm5zKS5mb3JFYWNoKChmdW5jdGlvbiAoa2V5KSB7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXlGbkdlbmVyYXRvci5qcyddWzExNl0rKztcbiAgdXNlZnVsbEZhbHN5Rm5zLmZvckVhY2goKGZ1bmN0aW9uIChmbk5hbWUpIHtcbiAgXyRqc2NvdmVyYWdlWydhcnJheUZuR2VuZXJhdG9yLmpzJ11bMTE3XSsrO1xuICBhcnJheVtmbk5hbWUgKyBrZXldID0gR2VuZXJhdG9yLmNyZWF0ZUZuKGZuTmFtZSwgZm5zW2tleV0pO1xufSkpO1xufSkpO1xufSkoKTtcbl8kanNjb3ZlcmFnZVsnYXJyYXlGbkdlbmVyYXRvci5qcyddWzEyMl0rKztcbihmdW5jdGlvbiBfY3JlYXRlQm91bmRGbnMoKSB7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXlGbkdlbmVyYXRvci5qcyddWzEyM10rKztcbiAgdmFyIGZucyA9IHtcIkluc3RhbmNlT2ZcIjogKGZ1bmN0aW9uIChDb25zdHJ1Y3Rvcikge1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5Rm5HZW5lcmF0b3IuanMnXVsxMjVdKys7XG4gIHJldHVybiAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXlGbkdlbmVyYXRvci5qcyddWzEyNl0rKztcbiAgcmV0dXJuICh2YWx1ZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKTtcbn0pO1xufSksIFwiSW5cIjogKGZ1bmN0aW9uIChhcnIsIGMpIHtcbiAgXyRqc2NvdmVyYWdlWydhcnJheUZuR2VuZXJhdG9yLmpzJ11bMTI5XSsrO1xuICB2YXIgZGVmYXVsdEMgPSB7dHlwZTogXCJsb29zZVJpZ2h0XCJ9O1xuICBfJGpzY292ZXJhZ2VbJ2FycmF5Rm5HZW5lcmF0b3IuanMnXVsxMzBdKys7XG4gIHJldHVybiAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gIF8kanNjb3ZlcmFnZVsnYXJyYXlGbkdlbmVyYXRvci5qcyddWzEzMV0rKztcbiAgaWYgKHZhbHVlICE9PSBmYWxzZSkge1xuICAgIF8kanNjb3ZlcmFnZVsnYXJyYXlGbkdlbmVyYXRvci5qcyddWzEzMl0rKztcbiAgICB2YXIgY2ZnID0gYyB8fCBkZWZhdWx0QztcbiAgICBfJGpzY292ZXJhZ2VbJ2FycmF5Rm5HZW5lcmF0b3IuanMnXVsxMzVdKys7XG4gICAgcmV0dXJuIGFycmF5LmZpbmRGaXJzdChhcnIsIHZhbHVlLCBjZmcudHlwZSA9PT0gXCJsb29zZVwiPyBkZWZhdWx0QzogY2ZnKSAhPT0gZmFsc2U7XG4gIH1cbiAgXyRqc2NvdmVyYWdlWydhcnJheUZuR2VuZXJhdG9yLmpzJ11bMTM4XSsrO1xuICByZXR1cm4gYXJyLmluZGV4T2YoZmFsc2UpID4gLTE7XG59KTtcbn0pfTtcbiAgXyRqc2NvdmVyYWdlWydhcnJheUZuR2VuZXJhdG9yLmpzJ11bMTQzXSsrO1xuICBPYmplY3Qua2V5cyhmbnMpLmZvckVhY2goKGZ1bmN0aW9uIChrZXkpIHtcbiAgXyRqc2NvdmVyYWdlWydhcnJheUZuR2VuZXJhdG9yLmpzJ11bMTQ0XSsrO1xuICBHZW5lcmF0b3IuYXJyYXlGbk5hbWVzLmZvckVhY2goKGZ1bmN0aW9uIChmbk5hbWUpIHtcbiAgXyRqc2NvdmVyYWdlWydhcnJheUZuR2VuZXJhdG9yLmpzJ11bMTQ1XSsrO1xuICBhcnJheVtmbk5hbWUgKyBrZXldID0gR2VuZXJhdG9yLmNyZWF0ZUJvdW5kRm4oZm5OYW1lLCBmbnNba2V5XSk7XG59KSk7XG59KSk7XG59KSgpO1xuXyRqc2NvdmVyYWdlWydhcnJheUZuR2VuZXJhdG9yLmpzJ10uc291cmNlID0gW1widmFyIGFycmF5ID0gcmVxdWlyZSgnLi9hcnJheScpLFwiLFwiICAgIGlzID0gcmVxdWlyZSgnLi9pcycpLFwiLFwiICAgIEdlbmVyYXRvcjtcIixcIlwiLFwiR2VuZXJhdG9yID0ge1wiLFwiICAgIGFycmF5Rm5OYW1lczogWydmaW5kRmlyc3ROb3QnLCAnZmluZEFsbE5vdCcsICdmaW5kRmlyc3QnLCAnZmluZEFsbCcsXCIsXCIgICAgICAgICAgICAncmVtb3ZlRmlyc3ROb3QnLCAncmVtb3ZlQWxsTm90JywgJ3JlbW92ZUZpcnN0JywgJ3JlbW92ZUFsbCcsXCIsXCIgICAgICAgICAgICAncmVtb3ZlTGFzdE5vdCcsICdyZW1vdmVMYXN0JywgJ2ZpbmRMYXN0JywgJ2ZpbmRMYXN0Tm90J1wiLFwiICAgIF0sXCIsXCJcIixcIiAgICBjcmVhdGVGbjogZnVuY3Rpb24oYXJyYXlGbk5hbWUsIGZuKSB7XCIsXCIgICAgICAgIHJldHVybiBmdW5jdGlvbihhcnIpIHtcIixcIiAgICAgICAgICAgIHJldHVybiBhcnJheVthcnJheUZuTmFtZV0oYXJyLCBmbik7XCIsXCIgICAgICAgIH07XCIsXCIgICAgfSxcIixcIlwiLFwiICAgIGNyZWF0ZUJvdW5kRm46IGZ1bmN0aW9uKGFycmF5Rm5OYW1lLCBmblRvQmluZCkge1wiLFwiICAgICAgICByZXR1cm4gZnVuY3Rpb24oYXJyLCB2YWx1ZSkge1wiLFwiICAgICAgICAgICAgdmFyIGZuID0gZm5Ub0JpbmQuYXBwbHkodGhpcywgYXJyYXkuZnJvbUluZGV4KGFyZ3VtZW50cywgMSkpO1wiLFwiICAgICAgICAgICAgcmV0dXJuIGFycmF5W2FycmF5Rm5OYW1lXShhcnIsIGZuKTtcIixcIiAgICAgICAgfTtcIixcIiAgICB9XCIsXCJ9O1wiLFwiXCIsXCJtb2R1bGUuZXhwb3J0cyA9IEdlbmVyYXRvcjtcIixcIlwiLFwiLyoqXCIsXCIgKiBAY2xhc3MgTHVjLkFycmF5Rm5zXCIsXCIgKiBUaGlzIGlzIGRvY3VtZW50ZWQgYXMgYSBzZXBhcmF0ZSBwYWNrYWdlIGJ1dCBpdCBhY3R1YWxseSBleGlzdHMgdW5kZXIgdGhlIFwiLFwiICogTHVjLkFycmF5IG5hbWVzcGFjZS4gIENoZWNrIG91dCB0aGUgXFxcIkZpbHRlciBjbGFzcyBtZW1iZXJzXFxcIiBpbnB1dCBib3hcIixcIiAqIGp1c3QgdG8gdGhlIHJpZ2h0IHdoZW4gc2VhcmNoaW5nIGZvciBmdW5jdGlvbnMuXCIsXCIgKiZsdDticiZndDtcIixcIiAqIFwiLFwiICogVGhlcmUgYXJlIGEgbG90IG9mIGZ1bmN0aW9ucyBpbiB0aGlzIHBhY2thZ2UgYnV0IGFsbCBvZiB0aGVtIFwiLFwiICogZm9sbG93IHRoZSBzYW1lIGFwaS4gIFxcXFwqQWxsIGZ1bmN0aW9ucyB3aWxsIHJldHVybiBhbiBhcnJheSBvZiByZW1vdmVkIG9yIGZvdW5kXCIsXCIgKiBpdGVtcy4gIFRoZSBpdGVtcyB3aWxsIGJlIGFkZGVkIHRvIHRoZSBhcnJheSBpbiB0aGUgb3JkZXIgdGhleSBhcmVcIixcIiAqIGZvdW5kLiAgXFxcXCpGaXJzdCBmdW5jdGlvbnMgd2lsbCByZXR1cm4gdGhlIGZpcnN0IGl0ZW0gYW5kIHN0b3AgaXRlcmF0aW5nIGFmdGVyIHRoYXQsIGlmIG5vbmVcIixcIiAqICBpcyBmb3VuZCBmYWxzZSBpcyByZXR1cm5lZC4gIHJlbW92ZVxcXFwqIGZ1bmN0aW9ucyB3aWxsIGRpcmVjdGx5IGNoYW5nZSB0aGUgcGFzc2VkIGluIGFycmF5LlwiLFwiICogIFxcXFwqTm90IGZ1bmN0aW9ucyBvbmx5IGRvIHRoZSBmb2xsb3dpbmcgYWN0aW9ucyBpZiB0aGUgY29tcGFyaXNvbiBpcyBub3QgdHJ1ZS5cIixcIiAqICBcXFxcKkxhc3QgZnVuY3Rpb25zIGRvIHRoZSBzYW1lIGFzIHRoZWlyIFxcXFwqRmlyc3QgY291bnRlcnBhcnRzIGV4Y2VwdCB0aGF0IHRoZSBpdGVyYXRpbmdcIixcIiAqICBzdGFydHMgYXQgdGhlIGVuZCBvZiB0aGUgYXJyYXkuIEFsbW9zdCBldmVyeSBwdWJsaWMgbWV0aG9kIG9mIEx1Yy5pcyBpcyBhdmFpbGFibGUgaXRcIixcIiAqICB1c2VzIHRoZSBmb2xsb3dpbmcgZ3JhbW1hciBMdWMuQXJyYXlbXFxcIm1ldGhvZE5hbWVcXFwiXFxcImlzTWV0aG9kTmFtZVxcXCJdXCIsXCIgKlwiLFwiICAgICAgTHVjLkFycmF5LmZpbmRBbGxOb3RFbXB0eShbZmFsc2UsIHRydWUsIG51bGwsIHVuZGVmaW5lZCwgMCwgJycsIFtdLCBbMV1dKVwiLFwiICAgICAgJmd0OyBbdHJ1ZSwgMCwgWzFdXVwiLFwiXCIsXCIgICAgICBMdWMuQXJyYXkuZmluZEFsbE5vdEZhbHN5KFtmYWxzZSwgdHJ1ZSwgbnVsbCwgdW5kZWZpbmVkLCAwLCAnJywgW10sIFsxXV0pXCIsXCIgICAgICAmZ3Q7IFt0cnVlLCAwLCBbXSwgWzFdXVwiLFwiICAgICBcIixcIiAgICAgIEx1Yy5BcnJheS5maW5kRmlyc3ROb3RTdHJpbmcoWzEsMiwzLCc1J10pXCIsXCIgICAgICAmZ3Q7MVwiLFwiICAgICAgdmFyIGFyciA9IFsxLDIsMywnNSddO1wiLFwiICAgICAgTHVjLkFycmF5LnJlbW92ZUFsbE5vdFN0cmluZyhhcnIpO1wiLFwiICAgICAgJmd0O1sxLDIsM11cIixcIiAgICAgIGFyclwiLFwiICAgICAgJmd0O1tcXFwiNVxcXCJdXCIsXCIgKlwiLFwiICogQXMgb2YgcmlnaHQgbm93IHRoZXJlIGFyZSB0d28gZnVuY3Rpb24gc2V0cyB3aGljaCBkaWZmZXIgZnJvbSB0aGUgaXNcIixcIiAqIGFwaS5cIixcIiAqXCIsXCIgKiBJbnN0YW5jZU9mXCIsXCIgKiBcIixcIiAgICBMdWMuQXJyYXkuZmluZEFsbEluc3RhbmNlT2YoWzEsMiwgbmV3IERhdGUoKSwge30sIFtdXSwgT2JqZWN0KVwiLFwiICAgICZndDtbZGF0ZSwge30sIFtdXVwiLFwiICAgICZndDtMdWMuQXJyYXkuZmluZEFsbE5vdEluc3RhbmNlT2YoWzEsMiwgbmV3IERhdGUoKSwge30sIFtdXSwgT2JqZWN0KVwiLFwiICAgIFsxLCAyXVwiLFwiICpcIixcIiAqIEluXCIsXCIgKiBcIixcIiAgICBMdWMuQXJyYXkuZmluZEFsbEluKFsxLDIsM10sIFsxLDJdKVwiLFwiICAgICZndDtbMSwgMl1cIixcIiAgICBMdWMuQXJyYXkuZmluZEZpcnN0SW4oWzEsMiwzXSwgWzEsMl0pXCIsXCIgICAgJmd0OzFcIixcIlwiLFwiICAgIC8vZGVmYXVsdHMgdG8gbG9vc2UgY29tcGFyaXNvblwiLFwiICAgIEx1Yy5BcnJheS5maW5kQWxsSW4oWzEsMiwzLCB7YToxLCBiOjJ9XSwgWzEse2E6MX1dKVwiLFwiICAgICZndDsgWzEsIHthOjEsYjoyfV1cIixcIlwiLFwiICAgIEx1Yy5BcnJheS5maW5kQWxsSW4oWzEsMiwzLCB7YToxLCBiOjJ9XSwgWzEse2E6MX1dLCB7dHlwZTogJ2RlZXAnfSlcIixcIiAgICAmZ3Q7WzFdXCIsXCIgKi9cIixcIlwiLFwiKGZ1bmN0aW9uIF9jcmVhdGVJc0ZucygpIHtcIixcIiAgICB2YXIgaXNUb0lnbm9yZSA9IFsnaXNSZWdFeHAnLCAnaXNBcmd1bWVudHMnXTtcIixcIlwiLFwiICAgIE9iamVjdC5rZXlzKGlzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1wiLFwiICAgICAgICB2YXIgbmFtZSA9IGtleS5zcGxpdCgnaXMnKVsxXTtcIixcIiAgICAgICAgR2VuZXJhdG9yLmFycmF5Rm5OYW1lcy5mb3JFYWNoKGZ1bmN0aW9uKGZuTmFtZSkge1wiLFwiICAgICAgICAgICAgaWYoaXNUb0lnbm9yZS5pbmRleE9mKGtleSkgPT09IC0xKSB7XCIsXCIgICAgICAgICAgICAgICAgYXJyYXlbZm5OYW1lICsgbmFtZV0gPSBHZW5lcmF0b3IuY3JlYXRlRm4oZm5OYW1lLCBpc1trZXldKTtcIixcIiAgICAgICAgICAgIH1cIixcIiAgICAgICAgfSk7XCIsXCIgICAgfSk7XCIsXCJ9KCkpO1wiLFwiXCIsXCIoZnVuY3Rpb24gX2NyZWF0ZUZhbHN5Rm5zKCkge1wiLFwiICAgIHZhciB1c2VmdWxsRmFsc3lGbnMgPSBbJ2ZpbmRGaXJzdE5vdCcsICdmaW5kQWxsTm90JywgJ3JlbW92ZUZpcnN0Tm90JywgJ3JlbW92ZUFsbE5vdCcsXCIsXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JlbW92ZUZpcnN0JywgJ3JlbW92ZUFsbCcsICdyZW1vdmVMYXN0Tm90JywgJ3JlbW92ZUxhc3QnLCAgJ2ZpbmRMYXN0Tm90J107XCIsXCJcIixcIiAgICB2YXIgZm5zID0ge1wiLFwiICAgICAgICAnRmFsc2UnOiBmdW5jdGlvbih2YWwpIHtcIixcIiAgICAgICAgICAgIHJldHVybiB2YWwgPT09IGZhbHNlO1wiLFwiICAgICAgICB9LFwiLFwiICAgICAgICAnVHJ1ZSc6IGZ1bmN0aW9uKHZhbCkge1wiLFwiICAgICAgICAgICAgcmV0dXJuIHZhbCA9PT0gdHJ1ZTtcIixcIiAgICAgICAgfSxcIixcIiAgICAgICAgJ051bGwnOiBmdW5jdGlvbih2YWwpIHtcIixcIiAgICAgICAgICAgIHJldHVybiB2YWwgPT09IG51bGw7XCIsXCIgICAgICAgIH0sXCIsXCIgICAgICAgICdVbmRlZmluZWQnOiBmdW5jdGlvbih2YWwpIHtcIixcIiAgICAgICAgICAgIHJldHVybiB2YWwgPT09IHVuZGVmaW5lZDtcIixcIiAgICAgICAgfVwiLFwiICAgIH07XCIsXCJcIixcIiAgICBPYmplY3Qua2V5cyhmbnMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XCIsXCIgICAgICAgIHVzZWZ1bGxGYWxzeUZucy5mb3JFYWNoKGZ1bmN0aW9uKGZuTmFtZSkge1wiLFwiICAgICAgICAgICAgYXJyYXlbZm5OYW1lICsga2V5XSA9IEdlbmVyYXRvci5jcmVhdGVGbihmbk5hbWUsIGZuc1trZXldKTtcIixcIiAgICAgICAgfSk7XCIsXCIgICAgfSk7XCIsXCJ9KCkpO1wiLFwiXCIsXCIoZnVuY3Rpb24gX2NyZWF0ZUJvdW5kRm5zKCkge1wiLFwiICAgIHZhciBmbnMgPSB7XCIsXCIgICAgICAgICdJbnN0YW5jZU9mJzogZnVuY3Rpb24oQ29uc3RydWN0b3IpIHtcIixcIiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1wiLFwiICAgICAgICAgICAgICAgIHJldHVybiAodmFsdWUgaW5zdGFuY2VvZiBDb25zdHJ1Y3Rvcik7XCIsXCIgICAgICAgICAgICB9O1wiLFwiICAgICAgICB9LCdJbic6IGZ1bmN0aW9uKGFyciwgYykge1wiLFwiICAgICAgICAgICAgdmFyIGRlZmF1bHRDID0ge3R5cGU6J2xvb3NlUmlnaHQnfTtcIixcIiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1wiLFwiICAgICAgICAgICAgICAgIGlmKHZhbHVlICE9PSBmYWxzZSkge1wiLFwiICAgICAgICAgICAgICAgICAgICB2YXIgY2ZnID0gYyB8fCBkZWZhdWx0QztcIixcIiAgICAgICAgICAgICAgICAgICAgLy90aGlzIGlzIGEgcmlnaHQgdG8gbGVmdCBjb21wYXJpc29uIFwiLFwiICAgICAgICAgICAgICAgICAgICAvL2V4cGVjdGVkIGxvb3NlIGJlaGF2aW9yIHNob3VsZCBiZSBsb29zZVJpZ2h0XCIsXCIgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcnJheS5maW5kRmlyc3QoYXJyLCB2YWx1ZSwgY2ZnLnR5cGUgPT09ICdsb29zZScgPyBkZWZhdWx0QyA6IGNmZykgIT09IGZhbHNlO1wiLFwiICAgICAgICAgICAgICAgIH1cIixcIiAgICAgICAgICAgICAgICBcIixcIiAgICAgICAgICAgICAgICByZXR1cm4gYXJyLmluZGV4T2YoZmFsc2UpICZndDsgLTE7XCIsXCIgICAgICAgICAgICB9O1wiLFwiICAgICAgICB9XCIsXCIgICAgfTtcIixcIlwiLFwiICAgIE9iamVjdC5rZXlzKGZucykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcIixcIiAgICAgICAgR2VuZXJhdG9yLmFycmF5Rm5OYW1lcy5mb3JFYWNoKGZ1bmN0aW9uKGZuTmFtZSkge1wiLFwiICAgICAgICAgICAgYXJyYXlbZm5OYW1lICsga2V5XSA9IEdlbmVyYXRvci5jcmVhdGVCb3VuZEZuKGZuTmFtZSwgZm5zW2tleV0pO1wiLFwiICAgICAgICB9KTtcIixcIiAgICB9KTtcIixcIn0oKSk7XCJdO1xuIiwiLyogYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgYnkgSlNDb3ZlcmFnZSAtIGRvIG5vdCBlZGl0ICovXG5pZiAodHlwZW9mIF8kanNjb3ZlcmFnZSA9PT0gJ3VuZGVmaW5lZCcpIF8kanNjb3ZlcmFnZSA9IHt9O1xuaWYgKCEgXyRqc2NvdmVyYWdlWydjb21wYXJlLmpzJ10pIHtcbiAgXyRqc2NvdmVyYWdlWydjb21wYXJlLmpzJ10gPSBbXTtcbiAgXyRqc2NvdmVyYWdlWydjb21wYXJlLmpzJ11bMV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NvbXBhcmUuanMnXVszXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzRdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjb21wYXJlLmpzJ11bN10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NvbXBhcmUuanMnXVs4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzExXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzEyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzE1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzE2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzE5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzIwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzIxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzI1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzI4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzI5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzMyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzMzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzM2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzM3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzM4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzQyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzQ1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzQ2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzQ5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzUwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzUyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzUzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzU2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzU3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzU4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzU5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzYwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzY1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzY4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzY5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzcxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzcyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzc1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzc2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzc3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzc4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzc5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzg0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzg4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzg5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzkxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzkyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzk1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzk2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzk3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzk4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzk5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzEwMF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NvbXBhcmUuanMnXVsxMDZdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjb21wYXJlLmpzJ11bMTA3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzEwOF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NvbXBhcmUuanMnXVsxMDldID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjb21wYXJlLmpzJ11bMTEwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzExN10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NvbXBhcmUuanMnXVsxMjFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjb21wYXJlLmpzJ11bMTIyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzEyM10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NvbXBhcmUuanMnXVsxMjZdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjb21wYXJlLmpzJ11bMTI5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzEzMF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NvbXBhcmUuanMnXVsxMzFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjb21wYXJlLmpzJ11bMTM1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzEzNl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NvbXBhcmUuanMnXVsxNDBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjb21wYXJlLmpzJ11bMTQxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzE0Ml0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NvbXBhcmUuanMnXVsxNDNdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjb21wYXJlLmpzJ11bMTQ0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzE0NV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NvbXBhcmUuanMnXVsxNDZdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjb21wYXJlLmpzJ11bMTQ4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzE0OV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NvbXBhcmUuanMnXVsxNTBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjb21wYXJlLmpzJ11bMTUxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzE1Ml0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NvbXBhcmUuanMnXVsxNTNdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjb21wYXJlLmpzJ11bMTU0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzE1Nl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NvbXBhcmUuanMnXVsxNTldID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjb21wYXJlLmpzJ11bMTYyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzIxMl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NvbXBhcmUuanMnXVsyMTNdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjb21wYXJlLmpzJ11bMjE3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzIxOF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NvbXBhcmUuanMnXVsyMjBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjb21wYXJlLmpzJ11bMjIzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzIyNF0gPSAwO1xufVxuXyRqc2NvdmVyYWdlWydjb21wYXJlLmpzJ11bMV0rKztcbnZhciBpcyA9IHJlcXVpcmUoXCIuL2lzXCIpO1xuXyRqc2NvdmVyYWdlWydjb21wYXJlLmpzJ11bM10rKztcbmZ1bmN0aW9uIF9zdHJpY3QodmFsMSwgdmFsMikge1xuICBfJGpzY292ZXJhZ2VbJ2NvbXBhcmUuanMnXVs0XSsrO1xuICByZXR1cm4gdmFsMSA9PT0gdmFsMjtcbn1cbl8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzddKys7XG5mdW5jdGlvbiBfY29tcGFyZUFycmF5TGVuZ3RoKHZhbDEsIHZhbDIpIHtcbiAgXyRqc2NvdmVyYWdlWydjb21wYXJlLmpzJ11bOF0rKztcbiAgcmV0dXJuIChpcy5pc0FycmF5KHZhbDEpICYmIGlzLmlzQXJyYXkodmFsMikgJiYgdmFsMS5sZW5ndGggPT09IHZhbDIubGVuZ3RoKTtcbn1cbl8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzExXSsrO1xuZnVuY3Rpb24gX3NoYWxsb3dBcnJheSh2YWwxLCB2YWwyKSB7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzEyXSsrO1xuICB2YXIgaSA9IDAsIGxlbjtcbiAgXyRqc2NvdmVyYWdlWydjb21wYXJlLmpzJ11bMTVdKys7XG4gIGlmICghIF9jb21wYXJlQXJyYXlMZW5ndGgodmFsMSwgdmFsMikpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ2NvbXBhcmUuanMnXVsxNl0rKztcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgXyRqc2NvdmVyYWdlWydjb21wYXJlLmpzJ11bMTldKys7XG4gIGZvciAobGVuID0gdmFsMS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzIwXSsrO1xuICAgIGlmICh2YWwxW2ldICE9PSB2YWwyW2ldKSB7XG4gICAgICBfJGpzY292ZXJhZ2VbJ2NvbXBhcmUuanMnXVsyMV0rKztcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzI1XSsrO1xuICByZXR1cm4gdHJ1ZTtcbn1cbl8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzI4XSsrO1xuZnVuY3Rpb24gX2RlZXBBcnJheSh2YWwxLCB2YWwyLCBjb25maWcpIHtcbiAgXyRqc2NvdmVyYWdlWydjb21wYXJlLmpzJ11bMjldKys7XG4gIHZhciBpID0gMCwgbGVuO1xuICBfJGpzY292ZXJhZ2VbJ2NvbXBhcmUuanMnXVszMl0rKztcbiAgaWYgKCEgX2NvbXBhcmVBcnJheUxlbmd0aCh2YWwxLCB2YWwyKSkge1xuICAgIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzMzXSsrO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBfJGpzY292ZXJhZ2VbJ2NvbXBhcmUuanMnXVszNl0rKztcbiAgZm9yIChsZW4gPSB2YWwxLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgXyRqc2NvdmVyYWdlWydjb21wYXJlLmpzJ11bMzddKys7XG4gICAgaWYgKCEgY29tcGFyZSh2YWwxW2ldLCB2YWwyW2ldLCBjb25maWcpKSB7XG4gICAgICBfJGpzY292ZXJhZ2VbJ2NvbXBhcmUuanMnXVszOF0rKztcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzQyXSsrO1xuICByZXR1cm4gdHJ1ZTtcbn1cbl8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzQ1XSsrO1xuZnVuY3Rpb24gX2NvbXBhcmVPYmplY3RLZXlzTGVuZ3RoKHZhbDEsIHZhbDIpIHtcbiAgXyRqc2NvdmVyYWdlWydjb21wYXJlLmpzJ11bNDZdKys7XG4gIHJldHVybiAoaXMuaXNPYmplY3QodmFsMSkgJiYgaXMuaXNPYmplY3QodmFsMikgJiYgT2JqZWN0LmtleXModmFsMSkubGVuZ3RoID09PSBPYmplY3Qua2V5cyh2YWwyKS5sZW5ndGgpO1xufVxuXyRqc2NvdmVyYWdlWydjb21wYXJlLmpzJ11bNDldKys7XG5mdW5jdGlvbiBfc2hhbGxvd09iamVjdCh2YWwxLCB2YWwyKSB7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzUwXSsrO1xuICB2YXIga2V5LCB2YWw7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzUyXSsrO1xuICBpZiAoISBfY29tcGFyZU9iamVjdEtleXNMZW5ndGgodmFsMSwgdmFsMikpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ2NvbXBhcmUuanMnXVs1M10rKztcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgXyRqc2NvdmVyYWdlWydjb21wYXJlLmpzJ11bNTZdKys7XG4gIGZvciAoa2V5IGluIHZhbDEpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ2NvbXBhcmUuanMnXVs1N10rKztcbiAgICBpZiAodmFsMS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBfJGpzY292ZXJhZ2VbJ2NvbXBhcmUuanMnXVs1OF0rKztcbiAgICAgIHZhbHVlID0gdmFsMVtrZXldO1xuICAgICAgXyRqc2NvdmVyYWdlWydjb21wYXJlLmpzJ11bNTldKys7XG4gICAgICBpZiAoISB2YWwyLmhhc093blByb3BlcnR5KGtleSkgfHwgdmFsMltrZXldICE9PSB2YWx1ZSkge1xuICAgICAgICBfJGpzY292ZXJhZ2VbJ2NvbXBhcmUuanMnXVs2MF0rKztcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbn1cbiAgXyRqc2NvdmVyYWdlWydjb21wYXJlLmpzJ11bNjVdKys7XG4gIHJldHVybiB0cnVlO1xufVxuXyRqc2NvdmVyYWdlWydjb21wYXJlLmpzJ11bNjhdKys7XG5mdW5jdGlvbiBfZGVlcE9iamVjdCh2YWwxLCB2YWwyLCBjb25maWcpIHtcbiAgXyRqc2NvdmVyYWdlWydjb21wYXJlLmpzJ11bNjldKys7XG4gIHZhciBrZXksIHZhbDtcbiAgXyRqc2NvdmVyYWdlWydjb21wYXJlLmpzJ11bNzFdKys7XG4gIGlmICghIF9jb21wYXJlT2JqZWN0S2V5c0xlbmd0aCh2YWwxLCB2YWwyKSkge1xuICAgIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzcyXSsrO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBfJGpzY292ZXJhZ2VbJ2NvbXBhcmUuanMnXVs3NV0rKztcbiAgZm9yIChrZXkgaW4gdmFsMSkge1xuICAgIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzc2XSsrO1xuICAgIGlmICh2YWwxLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzc3XSsrO1xuICAgICAgdmFsdWUgPSB2YWwxW2tleV07XG4gICAgICBfJGpzY292ZXJhZ2VbJ2NvbXBhcmUuanMnXVs3OF0rKztcbiAgICAgIGlmICghIHZhbDIuaGFzT3duUHJvcGVydHkoa2V5KSB8fCBjb21wYXJlKHZhbHVlLCB2YWwyW2tleV0sIGNvbmZpZykgIT09IHRydWUpIHtcbiAgICAgICAgXyRqc2NvdmVyYWdlWydjb21wYXJlLmpzJ11bNzldKys7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG59XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzg0XSsrO1xuICByZXR1cm4gdHJ1ZTtcbn1cbl8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzg4XSsrO1xuZnVuY3Rpb24gX2xvb3NlT2JqZWN0KHZhbDEsIHZhbDIsIGNvbmZpZykge1xuICBfJGpzY292ZXJhZ2VbJ2NvbXBhcmUuanMnXVs4OV0rKztcbiAgdmFyIGtleSwgdmFsO1xuICBfJGpzY292ZXJhZ2VbJ2NvbXBhcmUuanMnXVs5MV0rKztcbiAgaWYgKCEgKGlzLmlzT2JqZWN0KHZhbDEpICYmIGlzLmlzT2JqZWN0KHZhbDIpKSkge1xuICAgIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzkyXSsrO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBfJGpzY292ZXJhZ2VbJ2NvbXBhcmUuanMnXVs5NV0rKztcbiAgaWYgKGNvbmZpZy50eXBlID09PSBcImxvb3NlUmlnaHRcIikge1xuICAgIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzk2XSsrO1xuICAgIGZvciAoa2V5IGluIHZhbDIpIHtcbiAgICAgIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzk3XSsrO1xuICAgICAgaWYgKHZhbDIuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBfJGpzY292ZXJhZ2VbJ2NvbXBhcmUuanMnXVs5OF0rKztcbiAgICAgICAgdmFsdWUgPSB2YWwyW2tleV07XG4gICAgICAgIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzk5XSsrO1xuICAgICAgICBpZiAoY29tcGFyZSh2YWx1ZSwgdmFsMVtrZXldLCBjb25maWcpICE9PSB0cnVlKSB7XG4gICAgICAgICAgXyRqc2NvdmVyYWdlWydjb21wYXJlLmpzJ11bMTAwXSsrO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxufVxuICB9XG4gIGVsc2Uge1xuICAgIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzEwNl0rKztcbiAgICBmb3IgKGtleSBpbiB2YWwxKSB7XG4gICAgICBfJGpzY292ZXJhZ2VbJ2NvbXBhcmUuanMnXVsxMDddKys7XG4gICAgICBpZiAodmFsMS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzEwOF0rKztcbiAgICAgICAgdmFsdWUgPSB2YWwxW2tleV07XG4gICAgICAgIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzEwOV0rKztcbiAgICAgICAgaWYgKGNvbXBhcmUodmFsdWUsIHZhbDJba2V5XSwgY29uZmlnKSAhPT0gdHJ1ZSkge1xuICAgICAgICAgIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzExMF0rKztcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbn1cbiAgfVxuICBfJGpzY292ZXJhZ2VbJ2NvbXBhcmUuanMnXVsxMTddKys7XG4gIHJldHVybiB0cnVlO1xufVxuXyRqc2NvdmVyYWdlWydjb21wYXJlLmpzJ11bMTIxXSsrO1xuZnVuY3Rpb24gX2RhdGUodmFsMSwgdmFsMikge1xuICBfJGpzY292ZXJhZ2VbJ2NvbXBhcmUuanMnXVsxMjJdKys7XG4gIGlmIChpcy5pc0RhdGUodmFsMSkgJiYgaXMuaXNEYXRlKHZhbDIpKSB7XG4gICAgXyRqc2NvdmVyYWdlWydjb21wYXJlLmpzJ11bMTIzXSsrO1xuICAgIHJldHVybiB2YWwxLmdldFRpbWUoKSA9PT0gdmFsMi5nZXRUaW1lKCk7XG4gIH1cbiAgXyRqc2NvdmVyYWdlWydjb21wYXJlLmpzJ11bMTI2XSsrO1xuICByZXR1cm4gZmFsc2U7XG59XG5fJGpzY292ZXJhZ2VbJ2NvbXBhcmUuanMnXVsxMjldKys7XG5mdW5jdGlvbiBfY3JlYXRlQm91bmRDb21wYXJlKG9iamVjdCwgZm4pIHtcbiAgXyRqc2NvdmVyYWdlWydjb21wYXJlLmpzJ11bMTMwXSsrO1xuICByZXR1cm4gKGZ1bmN0aW9uICh2YWx1ZSkge1xuICBfJGpzY292ZXJhZ2VbJ2NvbXBhcmUuanMnXVsxMzFdKys7XG4gIHJldHVybiBmbihvYmplY3QsIHZhbHVlKTtcbn0pO1xufVxuXyRqc2NvdmVyYWdlWydjb21wYXJlLmpzJ11bMTM1XSsrO1xuZnVuY3Rpb24gZ2V0Q29tcGFyZUZuKG9iamVjdCwgYykge1xuICBfJGpzY292ZXJhZ2VbJ2NvbXBhcmUuanMnXVsxMzZdKys7XG4gIHZhciBjb21wYXJlRm4gPSBfc3RyaWN0LCBjb25maWcgPSBjIHx8IHt9LCB0eXBlID0gY29uZmlnLnR5cGU7XG4gIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzE0MF0rKztcbiAgaWYgKHR5cGUgPT09IFwiZGVlcFwiIHx8IHR5cGUgPT09IFwibG9vc2VcIiB8fCB0eXBlID09PSBcImxvb3NlUmlnaHRcIiB8fCB0eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ2NvbXBhcmUuanMnXVsxNDFdKys7XG4gICAgaWYgKGlzLmlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzE0Ml0rKztcbiAgICAgIGNvbXBhcmVGbiA9IHR5cGUgPT09IFwibG9vc2VcIiB8fCB0eXBlID09PSBcImxvb3NlUmlnaHRcIj8gX2xvb3NlT2JqZWN0OiBfZGVlcE9iamVjdDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBfJGpzY292ZXJhZ2VbJ2NvbXBhcmUuanMnXVsxNDNdKys7XG4gICAgICBpZiAoaXMuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzE0NF0rKztcbiAgICAgICAgY29tcGFyZUZuID0gX2RlZXBBcnJheTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBfJGpzY292ZXJhZ2VbJ2NvbXBhcmUuanMnXVsxNDVdKys7XG4gICAgICAgIGlmIChpcy5pc0RhdGUob2JqZWN0KSkge1xuICAgICAgICAgIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzE0Nl0rKztcbiAgICAgICAgICBjb21wYXJlRm4gPSBfZGF0ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICBfJGpzY292ZXJhZ2VbJ2NvbXBhcmUuanMnXVsxNDhdKys7XG4gICAgaWYgKHR5cGUgPT09IFwic2hhbGxvd1wiKSB7XG4gICAgICBfJGpzY292ZXJhZ2VbJ2NvbXBhcmUuanMnXVsxNDldKys7XG4gICAgICBpZiAoaXMuaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICBfJGpzY292ZXJhZ2VbJ2NvbXBhcmUuanMnXVsxNTBdKys7XG4gICAgICAgIGNvbXBhcmVGbiA9IF9zaGFsbG93T2JqZWN0O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzE1MV0rKztcbiAgICAgICAgaWYgKGlzLmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgICAgIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzE1Ml0rKztcbiAgICAgICAgICBjb21wYXJlRm4gPSBfc2hhbGxvd0FycmF5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzE1M10rKztcbiAgICAgICAgICBpZiAoaXMuaXNEYXRlKG9iamVjdCkpIHtcbiAgICAgICAgICAgIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzE1NF0rKztcbiAgICAgICAgICAgIGNvbXBhcmVGbiA9IF9kYXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzE1Nl0rKztcbiAgICAgIGlmICh0eXBlICE9PSBcInN0cmljdFwiKSB7XG4gICAgICAgIF8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzE1OV0rKztcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IHBhc3NlZCBpbiBhbiBpbnZhbGlkIGNvbXBhcmlzb24gdHlwZVwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgXyRqc2NvdmVyYWdlWydjb21wYXJlLmpzJ11bMTYyXSsrO1xuICByZXR1cm4gY29tcGFyZUZuO1xufVxuXyRqc2NvdmVyYWdlWydjb21wYXJlLmpzJ11bMjEyXSsrO1xuZnVuY3Rpb24gY29tcGFyZSh2YWwxLCB2YWwyLCBjb25maWcpIHtcbiAgXyRqc2NvdmVyYWdlWydjb21wYXJlLmpzJ11bMjEzXSsrO1xuICByZXR1cm4gZ2V0Q29tcGFyZUZuKHZhbDEsIGNvbmZpZykodmFsMSwgdmFsMiwgY29uZmlnKTtcbn1cbl8kanNjb3ZlcmFnZVsnY29tcGFyZS5qcyddWzIxN10rKztcbmZ1bmN0aW9uIGNyZWF0ZUJvdW5kQ29tcGFyZUZuKG9iamVjdCwgYykge1xuICBfJGpzY292ZXJhZ2VbJ2NvbXBhcmUuanMnXVsyMThdKys7XG4gIHZhciBjb21wYXJlRm4gPSBnZXRDb21wYXJlRm4ob2JqZWN0LCBjKTtcbiAgXyRqc2NvdmVyYWdlWydjb21wYXJlLmpzJ11bMjIwXSsrO1xuICByZXR1cm4gX2NyZWF0ZUJvdW5kQ29tcGFyZShvYmplY3QsIGNvbXBhcmVGbik7XG59XG5fJGpzY292ZXJhZ2VbJ2NvbXBhcmUuanMnXVsyMjNdKys7XG5leHBvcnRzLmNvbXBhcmUgPSBjb21wYXJlO1xuXyRqc2NvdmVyYWdlWydjb21wYXJlLmpzJ11bMjI0XSsrO1xuZXhwb3J0cy5jcmVhdGVCb3VuZENvbXBhcmVGbiA9IGNyZWF0ZUJvdW5kQ29tcGFyZUZuO1xuXyRqc2NvdmVyYWdlWydjb21wYXJlLmpzJ10uc291cmNlID0gW1widmFyIGlzID0gcmVxdWlyZSgnLi9pcycpO1wiLFwiXCIsXCJmdW5jdGlvbiBfc3RyaWN0KHZhbDEsIHZhbDIpe1wiLFwiICAgIHJldHVybiB2YWwxID09PSB2YWwyO1wiLFwifVwiLFwiXCIsXCJmdW5jdGlvbiBfY29tcGFyZUFycmF5TGVuZ3RoKHZhbDEsIHZhbDIpIHtcIixcIiAgICByZXR1cm4oaXMuaXNBcnJheSh2YWwxKSAmYW1wOyZhbXA7IGlzLmlzQXJyYXkodmFsMikgICZhbXA7JmFtcDsgdmFsMS5sZW5ndGggPT09IHZhbDIubGVuZ3RoKTtcIixcIn1cIixcIlwiLFwiZnVuY3Rpb24gX3NoYWxsb3dBcnJheSh2YWwxLCB2YWwyKSB7XCIsXCIgICAgdmFyIGkgPSAwLFwiLFwiICAgICAgICBsZW47XCIsXCIgICAgXCIsXCIgICAgaWYoIV9jb21wYXJlQXJyYXlMZW5ndGgodmFsMSwgdmFsMikpIHtcIixcIiAgICAgICAgcmV0dXJuIGZhbHNlO1wiLFwiICAgIH1cIixcIlwiLFwiICAgIGZvcihsZW4gPSB2YWwxLmxlbmd0aDsgaSAmbHQ7IGxlbjsgKytpKSB7XCIsXCIgICAgICAgIGlmKHZhbDFbaV0gIT09IHZhbDJbaV0pIHtcIixcIiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcIixcIiAgICAgICAgfVwiLFwiICAgIH1cIixcIlwiLFwiICAgIHJldHVybiB0cnVlO1wiLFwifVwiLFwiXCIsXCJmdW5jdGlvbiBfZGVlcEFycmF5KHZhbDEsIHZhbDIsIGNvbmZpZykge1wiLFwiICAgIHZhciBpID0gMCxcIixcIiAgICAgICAgbGVuO1wiLFwiICAgIFwiLFwiICAgIGlmKCFfY29tcGFyZUFycmF5TGVuZ3RoKHZhbDEsIHZhbDIpKSB7XCIsXCIgICAgICAgIHJldHVybiBmYWxzZTtcIixcIiAgICB9XCIsXCJcIixcIiAgICBmb3IobGVuID0gdmFsMS5sZW5ndGg7IGkgJmx0OyBsZW47ICsraSkge1wiLFwiICAgICAgICBpZighY29tcGFyZSh2YWwxW2ldLHZhbDJbaV0sIGNvbmZpZykpIHtcIixcIiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcIixcIiAgICAgICAgfVwiLFwiICAgIH1cIixcIlwiLFwiICAgIHJldHVybiB0cnVlO1wiLFwifVwiLFwiXCIsXCJmdW5jdGlvbiBfY29tcGFyZU9iamVjdEtleXNMZW5ndGgodmFsMSwgdmFsMikge1wiLFwiICAgIHJldHVybiAoaXMuaXNPYmplY3QodmFsMSkgJmFtcDsmYW1wOyBpcy5pc09iamVjdCh2YWwyKSAmYW1wOyZhbXA7IE9iamVjdC5rZXlzKHZhbDEpLmxlbmd0aCA9PT0gT2JqZWN0LmtleXModmFsMikubGVuZ3RoKTtcIixcIn1cIixcIlwiLFwiZnVuY3Rpb24gX3NoYWxsb3dPYmplY3QodmFsMSwgdmFsMikge1wiLFwiICAgIHZhciBrZXksIHZhbDtcIixcIlwiLFwiICAgIGlmICghX2NvbXBhcmVPYmplY3RLZXlzTGVuZ3RoKHZhbDEsIHZhbDIpKSB7XCIsXCIgICAgICAgIHJldHVybiBmYWxzZTtcIixcIiAgICB9XCIsXCJcIixcIiAgICBmb3IgKGtleSBpbiB2YWwxKSB7XCIsXCIgICAgICAgIGlmICh2YWwxLmhhc093blByb3BlcnR5KGtleSkpIHtcIixcIiAgICAgICAgICAgIHZhbHVlID0gdmFsMVtrZXldO1wiLFwiICAgICAgICAgICAgaWYgKCF2YWwyLmhhc093blByb3BlcnR5KGtleSkgfHwgdmFsMltrZXldICE9PSB2YWx1ZSkge1wiLFwiICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcIixcIiAgICAgICAgICAgIH1cIixcIiAgICAgICAgfVwiLFwiICAgIH1cIixcIlwiLFwiICAgIHJldHVybiB0cnVlO1wiLFwifVwiLFwiXCIsXCJmdW5jdGlvbiBfZGVlcE9iamVjdCh2YWwxLCB2YWwyLCBjb25maWcpIHtcIixcIiAgICB2YXIga2V5LCB2YWw7XCIsXCJcIixcIiAgICBpZiAoIV9jb21wYXJlT2JqZWN0S2V5c0xlbmd0aCh2YWwxLCB2YWwyKSkge1wiLFwiICAgICAgICByZXR1cm4gZmFsc2U7XCIsXCIgICAgfVwiLFwiXCIsXCIgICAgZm9yIChrZXkgaW4gdmFsMSkge1wiLFwiICAgICAgICBpZiAodmFsMS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XCIsXCIgICAgICAgICAgICB2YWx1ZSA9IHZhbDFba2V5XTtcIixcIiAgICAgICAgICAgIGlmICghdmFsMi5oYXNPd25Qcm9wZXJ0eShrZXkpIHx8IGNvbXBhcmUodmFsdWUsIHZhbDJba2V5XSwgY29uZmlnKSAhPT0gdHJ1ZSkge1wiLFwiICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcIixcIiAgICAgICAgICAgIH1cIixcIiAgICAgICAgfVwiLFwiICAgIH1cIixcIlwiLFwiICAgIHJldHVybiB0cnVlO1wiLFwiXCIsXCJ9XCIsXCJcIixcImZ1bmN0aW9uIF9sb29zZU9iamVjdCh2YWwxLCB2YWwyLCBjb25maWcpIHtcIixcIiAgICB2YXIga2V5LCB2YWw7XCIsXCJcIixcIiAgICBpZighKGlzLmlzT2JqZWN0KHZhbDEpICZhbXA7JmFtcDsgaXMuaXNPYmplY3QodmFsMikpKSB7XCIsXCIgICAgICAgIHJldHVybiBmYWxzZTtcIixcIiAgICB9XCIsXCJcIixcIiAgICBpZihjb25maWcudHlwZSA9PT0gJ2xvb3NlUmlnaHQnKSB7XCIsXCIgICAgICAgIGZvciAoa2V5IGluIHZhbDIpIHtcIixcIiAgICAgICAgICAgIGlmICh2YWwyLmhhc093blByb3BlcnR5KGtleSkpIHtcIixcIiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbDJba2V5XTtcIixcIiAgICAgICAgICAgICAgICBpZiAoY29tcGFyZSh2YWx1ZSwgdmFsMVtrZXldLCBjb25maWcpICE9PSB0cnVlKSB7XCIsXCIgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcIixcIiAgICAgICAgICAgICAgICB9XCIsXCIgICAgICAgICAgICB9XCIsXCIgICAgICAgIH1cIixcIiAgICB9XCIsXCIgICAgZWxzZSB7XCIsXCIgICAgICAgIGZvciAoa2V5IGluIHZhbDEpIHtcIixcIiAgICAgICAgICAgIGlmICh2YWwxLmhhc093blByb3BlcnR5KGtleSkpIHtcIixcIiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbDFba2V5XTtcIixcIiAgICAgICAgICAgICAgICBpZiAoY29tcGFyZSh2YWx1ZSwgdmFsMltrZXldLCBjb25maWcpICE9PSB0cnVlKSB7XCIsXCIgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcIixcIiAgICAgICAgICAgICAgICB9XCIsXCIgICAgICAgICAgICB9XCIsXCIgICAgICAgIH1cIixcIiAgICB9XCIsXCJcIixcIlwiLFwiICAgIHJldHVybiB0cnVlO1wiLFwiXCIsXCJ9XCIsXCJcIixcImZ1bmN0aW9uIF9kYXRlKHZhbDEsIHZhbDIpIHtcIixcIiAgICBpZihpcy5pc0RhdGUodmFsMSkgJmFtcDsmYW1wOyBpcy5pc0RhdGUodmFsMikpIHtcIixcIiAgICAgICAgcmV0dXJuIHZhbDEuZ2V0VGltZSgpID09PSB2YWwyLmdldFRpbWUoKTtcIixcIiAgICB9XCIsXCJcIixcIiAgICByZXR1cm4gZmFsc2U7XCIsXCJ9XCIsXCJcIixcImZ1bmN0aW9uIF9jcmVhdGVCb3VuZENvbXBhcmUob2JqZWN0LCBmbikge1wiLFwiICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1wiLFwiICAgICAgICByZXR1cm4gZm4ob2JqZWN0LCB2YWx1ZSk7XCIsXCIgICAgfTtcIixcIn1cIixcIlwiLFwiZnVuY3Rpb24gZ2V0Q29tcGFyZUZuKG9iamVjdCwgYykge1wiLFwiICAgIHZhciBjb21wYXJlRm4gPSBfc3RyaWN0LFwiLFwiICAgICAgICBjb25maWcgPSBjIHx8IHt9LFwiLFwiICAgICAgICB0eXBlID0gY29uZmlnLnR5cGU7XCIsXCJcIixcIiAgICBpZiAodHlwZSA9PT0gJ2RlZXAnIHx8IHR5cGUgPT09ICdsb29zZScgfHwgdHlwZSA9PT0gJ2xvb3NlUmlnaHQnIHx8IHR5cGUgPT09IHVuZGVmaW5lZCkge1wiLFwiICAgICAgICBpZiAoaXMuaXNPYmplY3Qob2JqZWN0KSkge1wiLFwiICAgICAgICAgICAgY29tcGFyZUZuID0gdHlwZSA9PT0gJ2xvb3NlJyB8fCB0eXBlID09PSAnbG9vc2VSaWdodCcgPyBfbG9vc2VPYmplY3QgOiBfZGVlcE9iamVjdDtcIixcIiAgICAgICAgfSBlbHNlIGlmIChpcy5pc0FycmF5KG9iamVjdCkpIHtcIixcIiAgICAgICAgICAgIGNvbXBhcmVGbiA9IF9kZWVwQXJyYXk7XCIsXCIgICAgICAgIH0gZWxzZSBpZiAoaXMuaXNEYXRlKG9iamVjdCkpIHtcIixcIiAgICAgICAgICAgIGNvbXBhcmVGbiA9IF9kYXRlO1wiLFwiICAgICAgICB9XCIsXCIgICAgfSBlbHNlIGlmICh0eXBlID09PSAnc2hhbGxvdycpIHtcIixcIiAgICAgICAgaWYgKGlzLmlzT2JqZWN0KG9iamVjdCkpIHtcIixcIiAgICAgICAgICAgIGNvbXBhcmVGbiA9IF9zaGFsbG93T2JqZWN0O1wiLFwiICAgICAgICB9IGVsc2UgaWYgKGlzLmlzQXJyYXkob2JqZWN0KSkge1wiLFwiICAgICAgICAgICAgY29tcGFyZUZuID0gX3NoYWxsb3dBcnJheTtcIixcIiAgICAgICAgfSBlbHNlIGlmIChpcy5pc0RhdGUob2JqZWN0KSkge1wiLFwiICAgICAgICAgICAgY29tcGFyZUZuID0gX2RhdGU7XCIsXCIgICAgICAgIH1cIixcIiAgICB9IGVsc2UgaWYgKHR5cGUgIT09ICdzdHJpY3QnKSB7XCIsXCIgICAgICAgIC8vd2Ugd291bGQgYmUgZG9pbmcgYSBzdHJpY3QgY29tcGFyaXNvbiBvbiBhIHR5cGUtb1wiLFwiICAgICAgICAvL0kgdGhpbmsgYW4gZXJyb3IgaXMgZ29vZCBoZXJlLlwiLFwiICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBwYXNzZWQgaW4gYW4gaW52YWxpZCBjb21wYXJpc29uIHR5cGUnKTtcIixcIiAgICB9XCIsXCJcIixcIiAgICByZXR1cm4gY29tcGFyZUZuO1wiLFwifVwiLFwiXCIsXCIvKipcIixcIiAqIEBtZW1iZXIgTHVjXCIsXCIgKiBAbWV0aG9kIGNvbXBhcmVcIixcIiAqIFwiLFwiICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlcyBhcmUgZXF1YWwgdG8gZWFjaFwiLFwiICogb3RoZXIuICBCeSBkZWZhdWx0IGEgZGVlcCBjb21wYXJpc29uIGlzIFwiLFwiICogZG9uZSBvbiBhcnJheXMsIGRhdGVzIGFuZCBvYmplY3RzIGFuZCBhIHN0cmljdCBjb21wYXJpc29uXCIsXCIgKiBpcyBkb25lIG9uIG90aGVyIHR5cGVzLlwiLFwiICogXCIsXCIgKiBAcGFyYW0gIHtBbnl9IHZhbDEgIFwiLFwiICogQHBhcmFtICB7QW55fSB2YWwyICAgXCIsXCIgKiBAcGFyYW0gIHtPYmplY3R9IFtjb25maWddXCIsXCIgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLnR5cGUgcGFzcyBpbiAnc2hhbGxvdycgZm9yIGEgc2hhbGxvd1wiLFwiICogY29tcGFyaXNvbiwgJ2RlZXAnIChkZWZhdWx0KSBmb3IgYSBkZWVwIGNvbXBhcmlzb25cIixcIiAqICdzdHJpY3QnIGZvciBhIHN0cmljdCA9PT0gY29tcGFyaXNvbiBmb3IgYWxsIG9iamVjdHMgb3IgXCIsXCIgKiAnbG9vc2UnIGZvciBhIGxvb3NlIGNvbXBhcmlzb24gb24gb2JqZWN0cy4gIEEgbG9vc2UgY29tcGFyaXNvblwiLFwiICogIHdpbGwgY29tcGFyZSB0aGUga2V5cyBhbmQgdmFsdWVzIG9mIHZhbDEgdG8gdmFsMiBhbmQgZG9lcyBub3RcIixcIiAqICBjaGVjayBpZiBrZXlzIGZyb20gdmFsMiBkbyBub3QgZXhpc3QgaW4gdmFsMS5cIixcIiAqXCIsXCIgKlwiLFwiICAgIEx1Yy5jb21wYXJlKCcxJywgMSlcIixcIiAgICAmZ3Q7ZmFsc2VcIixcIiAgICBMdWMuY29tcGFyZSh7YTogMX0sIHthOiAxfSlcIixcIiAgICAmZ3Q7dHJ1ZVwiLFwiICAgIEx1Yy5jb21wYXJlKHthOiAxLCBiOiB7fX0sIHthOiAxLCBiOiB7fSB9LCB7dHlwZTonc2hhbGxvdyd9KVwiLFwiICAgICZndDtmYWxzZVwiLFwiICAgIEx1Yy5jb21wYXJlKHthOiAxLCBiOiB7fX0sIHthOiAxLCBiOiB7fSB9LCB7dHlwZTogJ2RlZXAnfSlcIixcIiAgICAmZ3Q7dHJ1ZVwiLFwiICAgIEx1Yy5jb21wYXJlKHthOiAxLCBiOiB7fX0sIHthOiAxLCBiOiB7fSB9LCB7dHlwZTogJ3N0cmljdCd9KVwiLFwiICAgICZndDtmYWxzZVwiLFwiICAgIEx1Yy5jb21wYXJlKHthOiAxfSwge2E6MSxiOjF9KVwiLFwiICAgICZndDtmYWxzZVwiLFwiICAgIEx1Yy5jb21wYXJlKHthOiAxfSwge2E6MSxiOjF9LCB7dHlwZTogJ2xvb3NlJ30pXCIsXCIgICAgJmd0O3RydWVcIixcIiAgICBMdWMuY29tcGFyZSh7YTogMX0sIHthOjEsYjoxfSwge3R5cGU6ICdsb29zZSd9KVwiLFwiICAgICZndDt0cnVlXCIsXCIgICAgTHVjLmNvbXBhcmUoW3thOiAxfV0sIFt7YToxLGI6MX1dLCB7dHlwZTogJ2xvb3NlJ30pXCIsXCIgICAgJmd0O3RydWVcIixcIiAgICBMdWMuY29tcGFyZShbe2E6IDF9LCB7fV0sIFt7YToxLGI6MX1dLCB7dHlwZTogJ2xvb3NlJ30pXCIsXCIgICAgJmd0O2ZhbHNlXCIsXCIgICAgTHVjLmNvbXBhcmUoW3thOiAxfSwge31dLCBbe2E6MSxiOjF9LCB7fV0sIHt0eXBlOiAnbG9vc2UnfSlcIixcIiAgICAmZ3Q7dHJ1ZVwiLFwiICAgIEx1Yy5jb21wYXJlKFt7YToxLGI6MX1dLCBbe2E6IDF9XSwge3R5cGU6ICdsb29zZSd9KVwiLFwiICAgICZndDtmYWxzZVwiLFwiXCIsXCIgKiBAcmV0dXJuIHtCb29sZWFufVwiLFwiICovXCIsXCJmdW5jdGlvbiBjb21wYXJlKHZhbDEsIHZhbDIsIGNvbmZpZykge1wiLFwiICAgIHJldHVybiBnZXRDb21wYXJlRm4odmFsMSwgY29uZmlnKSh2YWwxLCB2YWwyLCBjb25maWcpO1wiLFwifVwiLFwiXCIsXCJcIixcImZ1bmN0aW9uIGNyZWF0ZUJvdW5kQ29tcGFyZUZuKG9iamVjdCwgYykge1wiLFwiICAgIHZhciBjb21wYXJlRm4gPSBnZXRDb21wYXJlRm4ob2JqZWN0LCBjKTtcIixcIlwiLFwiICAgIHJldHVybiBfY3JlYXRlQm91bmRDb21wYXJlKG9iamVjdCwgY29tcGFyZUZuKTtcIixcIn1cIixcIlwiLFwiZXhwb3J0cy5jb21wYXJlID0gY29tcGFyZTtcIixcImV4cG9ydHMuY3JlYXRlQm91bmRDb21wYXJlRm4gPSBjcmVhdGVCb3VuZENvbXBhcmVGbjtcIl07XG4iLCIvKiBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBieSBKU0NvdmVyYWdlIC0gZG8gbm90IGVkaXQgKi9cbmlmICh0eXBlb2YgXyRqc2NvdmVyYWdlID09PSAndW5kZWZpbmVkJykgXyRqc2NvdmVyYWdlID0ge307XG5pZiAoISBfJGpzY292ZXJhZ2VbJ2NsYXNzL2Jhc2UuanMnXSkge1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2Jhc2UuanMnXSA9IFtdO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2Jhc2UuanMnXVsxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvYmFzZS5qcyddWzYxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvYmFzZS5qcyddWzYyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvYmFzZS5qcyddWzYzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvYmFzZS5qcyddWzY2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvYmFzZS5qcyddWzcyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvYmFzZS5qcyddWzgyXSA9IDA7XG59XG5fJGpzY292ZXJhZ2VbJ2NsYXNzL2Jhc2UuanMnXVsxXSsrO1xudmFyIGVtcHR5Rm4gPSByZXF1aXJlKFwiLi4vZnVuY3Rpb25cIikuZW1wdHlGbiwgYXBwbHkgPSByZXF1aXJlKFwiLi4vb2JqZWN0XCIpLmFwcGx5O1xuXyRqc2NvdmVyYWdlWydjbGFzcy9iYXNlLmpzJ11bNjFdKys7XG5mdW5jdGlvbiBCYXNlKCkge1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2Jhc2UuanMnXVs2Ml0rKztcbiAgdGhpcy5iZWZvcmVJbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvYmFzZS5qcyddWzYzXSsrO1xuICB0aGlzLmluaXQoKTtcbn1cbl8kanNjb3ZlcmFnZVsnY2xhc3MvYmFzZS5qcyddWzY2XSsrO1xuQmFzZS5wcm90b3R5cGUgPSB7YmVmb3JlSW5pdDogKGZ1bmN0aW9uIChjb25maWcpIHtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9iYXNlLmpzJ11bNzJdKys7XG4gIGFwcGx5KHRoaXMsIGNvbmZpZyk7XG59KSwgaW5pdDogZW1wdHlGbn07XG5fJGpzY292ZXJhZ2VbJ2NsYXNzL2Jhc2UuanMnXVs4Ml0rKztcbm1vZHVsZS5leHBvcnRzID0gQmFzZTtcbl8kanNjb3ZlcmFnZVsnY2xhc3MvYmFzZS5qcyddLnNvdXJjZSA9IFtcInZhciBlbXB0eUZuID0gcmVxdWlyZSgnLi4vZnVuY3Rpb24nKS5lbXB0eUZuLFwiLFwiICAgIGFwcGx5ID0gcmVxdWlyZSgnLi4vb2JqZWN0JykuYXBwbHk7XCIsXCJcIixcIi8qKlwiLFwiICogQGNsYXNzIEx1Yy5CYXNlXCIsXCIgKiBTaW1wbGUgY2xhc3MgdGhhdCBieSBkZWZhdWx0IHtAbGluayBMdWMjYXBwbHkgYXBwbGllc30gdGhlIFwiLFwiICogZmlyc3QgYXJndW1lbnQgdG8gdGhlIGluc3RhbmNlIGFuZCB0aGVuIGNhbGxzXCIsXCIgKiBMdWMuQmFzZS5pbml0LlwiLFwiICpcIixcIiAgICB2YXIgYiA9IG5ldyBMdWMuQmFzZSh7XCIsXCIgICAgICAgIGE6IDEsXCIsXCIgICAgICAgIGluaXQ6IGZ1bmN0aW9uKCkge1wiLFwiICAgICAgICAgICAgY29uc29sZS5sb2coJ2hleScpXCIsXCIgICAgICAgIH1cIixcIiAgICB9KVwiLFwiICAgIGIuYVwiLFwiICAgICZndDtoZXlcIixcIiAgICAmZ3Q7MVwiLFwiICpcIixcIiAqIFdlIGZvdW5kIHRoYXQgbW9zdCBvZiBvdXIgY2xhc3NlcyBkbyB0aGlzIHNvIHdlIG1hZGVcIixcIiAqIGl0IHRoZSBkZWZhdWx0LiAgSGF2aW5nIGEgY29uZmlnIG9iamVjdCBhcyB0aGUgZmlyc3QgYW5kIG9ubHkgXCIsXCIgKiBwYXJhbSBrZWVwcyBhIGNsZWFuIGFwaSBhcyB3ZWxsLlwiLFwiICpcIixcIiAgICB2YXIgQyA9IEx1Yy5kZWZpbmUoe1wiLFwiICAgICAgICBpbml0OiBmdW5jdGlvbigpIHtcIixcIiAgICAgICAgICAgIEx1Yy5BcnJheS5lYWNoKHRoaXMuaXRlbXMsIHRoaXMubG9nSXRlbXMpXCIsXCIgICAgICAgIH0sXCIsXCJcIixcIiAgICAgICAgbG9nSXRlbXM6IGZ1bmN0aW9uKGl0ZW0pIHtcIixcIiAgICAgICAgICAgIGNvbnNvbGUubG9nKGl0ZW0pO1wiLFwiICAgICAgICB9XCIsXCIgICAgfSk7XCIsXCJcIixcIiAgICB2YXIgYyA9IG5ldyBDKHtpdGVtczogWzEsMiwzXX0pO1wiLFwiICAgICZndDsxXCIsXCIgICAgJmd0OzJcIixcIiAgICAmZ3Q7M1wiLFwiICAgIHZhciBkID0gbmV3IEMoe2l0ZW1zOiAnQSd9KTtcIixcIiAgICAmZ3Q7J0EnXCIsXCIgICAgdmFyIGUgPSBuZXcgQygpO1wiLFwiICpcIixcIiAqIElmIHlvdSBkb24ndCBsaWtlIHRoZSBhcHBseWluZyBvZiB0aGUgY29uZmlnIHRvIHRoZSBpbnN0YW5jZSBpdCBcIixcIiAqIGNhbiBhbHdheXMgYmUgXFxcImRpc2FibGVkXFxcIlwiLFwiICpcIixcIiAgICB2YXIgTm9BcHBseSA9IEx1Yy5kZWZpbmUoe1wiLFwiICAgICAgICBiZWZvcmVJbml0OiBmdW5jdGlvbigpIHtcIixcIlwiLFwiICAgICAgICB9LFwiLFwiICAgICAgICBpbml0OiBmdW5jdGlvbigpIHtcIixcIiAgICAgICAgICAgIEx1Yy5BcnJheS5lYWNoKHRoaXMuaXRlbXMsIHRoaXMubG9nSXRlbXMpXCIsXCIgICAgICAgIH0sXCIsXCJcIixcIiAgICAgICAgbG9nSXRlbXM6IGZ1bmN0aW9uKGl0ZW0pIHtcIixcIiAgICAgICAgICAgIGNvbnNvbGUubG9nKGl0ZW0pO1wiLFwiICAgICAgICB9XCIsXCIgICAgfSk7XCIsXCJcIixcIiAgICB2YXIgYyA9IG5ldyBOb0FwcGx5KHtpdGVtczogWzEsMiwzXX0pO1wiLFwiICogXCIsXCIgKi9cIixcImZ1bmN0aW9uIEJhc2UoKSB7XCIsXCIgICAgdGhpcy5iZWZvcmVJbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XCIsXCIgICAgdGhpcy5pbml0KCk7XCIsXCJ9XCIsXCJcIixcIkJhc2UucHJvdG90eXBlID0ge1wiLFwiICAgIC8qKlwiLFwiICAgICAqIEJ5IGRlZmF1bHQgYXBwbHkgdGhlIGNvbmZpZyB0byB0aGUgXCIsXCIgICAgICogaW5zdGFuY2UuXCIsXCIgICAgICovXCIsXCIgICAgYmVmb3JlSW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XCIsXCIgICAgICAgIGFwcGx5KHRoaXMsIGNvbmZpZyk7XCIsXCIgICAgfSxcIixcIiAgICAvKipcIixcIiAgICAgKiBAbWV0aG9kXCIsXCIgICAgICogU2ltcGxlIGhvb2sgdG8gaW5pdGlhbGl6ZVwiLFwiICAgICAqIHRoZSBjbGFzcy4gIERlZmF1bHRzIHRvIEx1Yy5lbXB0eUZuXCIsXCIgICAgICovXCIsXCIgICAgaW5pdDogZW1wdHlGblwiLFwifTtcIixcIlwiLFwibW9kdWxlLmV4cG9ydHMgPSBCYXNlO1wiXTtcbiIsIi8qIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGJ5IEpTQ292ZXJhZ2UgLSBkbyBub3QgZWRpdCAqL1xuaWYgKHR5cGVvZiBfJGpzY292ZXJhZ2UgPT09ICd1bmRlZmluZWQnKSBfJGpzY292ZXJhZ2UgPSB7fTtcbmlmICghIF8kanNjb3ZlcmFnZVsnY2xhc3MvcGx1Z2luLmpzJ10pIHtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9wbHVnaW4uanMnXSA9IFtdO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL3BsdWdpbi5qcyddWzFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9wbHVnaW4uanMnXVsxMF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL3BsdWdpbi5qcyddWzExXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvcGx1Z2luLmpzJ11bMTRdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9wbHVnaW4uanMnXVsyOV0gPSAwO1xufVxuXyRqc2NvdmVyYWdlWydjbGFzcy9wbHVnaW4uanMnXVsxXSsrO1xudmFyIGFFYWNoID0gcmVxdWlyZShcIi4uL2FycmF5XCIpLmVhY2gsIG9iaiA9IHJlcXVpcmUoXCIuLi9vYmplY3RcIiksIGVtcHR5Rm4gPSByZXF1aXJlKFwiLi4vZnVuY3Rpb25cIikuZW1wdHlGbiwgYXBwbHkgPSBvYmouYXBwbHk7XG5fJGpzY292ZXJhZ2VbJ2NsYXNzL3BsdWdpbi5qcyddWzEwXSsrO1xuZnVuY3Rpb24gUGx1Z2luKGNvbmZpZykge1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL3BsdWdpbi5qcyddWzExXSsrO1xuICBhcHBseSh0aGlzLCBjb25maWcpO1xufVxuXyRqc2NvdmVyYWdlWydjbGFzcy9wbHVnaW4uanMnXVsxNF0rKztcblBsdWdpbi5wcm90b3R5cGUgPSB7aW5pdDogZW1wdHlGbiwgZGVzdHJveTogZW1wdHlGbn07XG5fJGpzY292ZXJhZ2VbJ2NsYXNzL3BsdWdpbi5qcyddWzI5XSsrO1xubW9kdWxlLmV4cG9ydHMgPSBQbHVnaW47XG5fJGpzY292ZXJhZ2VbJ2NsYXNzL3BsdWdpbi5qcyddLnNvdXJjZSA9IFtcInZhciBhRWFjaCA9IHJlcXVpcmUoJy4uL2FycmF5JykuZWFjaCxcIixcIiAgICBvYmogPSByZXF1aXJlKCcuLi9vYmplY3QnKSxcIixcIiAgICBlbXB0eUZuID0gcmVxdWlyZSgnLi4vZnVuY3Rpb24nKS5lbXB0eUZuLFwiLFwiICAgIGFwcGx5ID0gb2JqLmFwcGx5O1wiLFwiXCIsXCIvKipcIixcIiAqIEBjbGFzcyBMdWMuUGx1Z2luXCIsXCIgKiBTaW1wbGUgY2xhc3MgdGhhdCBpcyB0aGUgZGVmYXVsdCBwbHVnaW4gdHlwZSBmb3IgTHVjLlBsdWdpbk1hbmFnZXJcIixcIiAqL1wiLFwiZnVuY3Rpb24gUGx1Z2luKGNvbmZpZykge1wiLFwiICAgIGFwcGx5KHRoaXMsIGNvbmZpZyk7XCIsXCJ9XCIsXCJcIixcIlBsdWdpbi5wcm90b3R5cGUgPSB7XCIsXCIgICAgLyoqXCIsXCIgICAgICogQG1ldGhvZFwiLFwiICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvd25lciB0aGUgb3duZXIgaW5zdGFuY2VcIixcIiAgICAgKiBTaW1wbGUgaG9vayB0byBpbml0aWFsaXplIHRoZSBwbHVnaW5cIixcIiAgICAgKiBEZWZhdWx0cyB0byBMdWMuZW1wdHlGbi5cIixcIiAgICAgKi9cIixcIiAgICBpbml0OiBlbXB0eUZuLFwiLFwiICAgIC8qKlwiLFwiICAgICAqIEBtZXRob2QgRGVmYXVsdHMgdG8gTHVjLmVtcHR5Rm4uXCIsXCIgICAgICogQ2FsbGVkIHdoZW4gdGhlIHBsdWdpbiBpcyBiZWluZyB7QGxpbmsgTHVjLlBsdWdpbk1hbmFnZXIjZGVzdHJveVBsdWdpbiBkZXN0cm95ZWR9LlwiLFwiICAgICAqL1wiLFwiICAgIGRlc3Ryb3k6IGVtcHR5Rm5cIixcIn07XCIsXCJcIixcIm1vZHVsZS5leHBvcnRzID0gUGx1Z2luO1wiXTtcbiIsIi8qIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGJ5IEpTQ292ZXJhZ2UgLSBkbyBub3QgZWRpdCAqL1xuaWYgKHR5cGVvZiBfJGpzY292ZXJhZ2UgPT09ICd1bmRlZmluZWQnKSBfJGpzY292ZXJhZ2UgPSB7fTtcbmlmICghIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddKSB7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddID0gW107XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bMzZdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bNTBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bNTVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bNTddID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bNTldID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bNjFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bNjVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bNjhdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bNjldID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bNzJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bNzZdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bNzldID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bODBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bODJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bODNdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bODZdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bODddID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bOTFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bOTVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bOTldID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bMTA1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzEwNl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVsxMTBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bMTExXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzExMl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVsxMTZdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bMTIwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzEyNF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVsxMjVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bMTI3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzEyOF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVsxMjldID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bMTM0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzEzN10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVsxMzhdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bMTQxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzE0Ml0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVsxNDddID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bMTUwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzE1MV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVsxNTRdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bMTU1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzE1Nl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVsxNjBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bMTY0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzE2NV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVsxNjldID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bMTc2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzE3N10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVsxNzhdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bMTg0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzE4OF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVsxODldID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bMTkxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzE5Ml0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVsxOThdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bMTk5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzIwMV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVsyMDJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bMjA3XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzIwOV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVsyMTFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bMjEyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzIxN10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVsyMjBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bMjIxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzIyNV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVsyMjddID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bMjI5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzIzMF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVsyMzFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bMjM1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzIzNl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVsyNDNdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bMjQ1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzI0Nl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVsyNDddID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bMjQ4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzI1M10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVsyNTRdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bMjU1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzI2N10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVsyNjhdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bMjcxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzI3Ml0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVsyNzhdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bMjgwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzI4OF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVsyOTJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bMjk2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzI5OF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVsyOTldID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bMzAwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzMwMV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVszMDVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bMzEwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzMxMl0gPSAwO1xufVxuXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bMV0rKztcbnZhciBCYXNlID0gcmVxdWlyZShcIi4vYmFzZVwiKSwgQ29tcG9zaXRpb24gPSByZXF1aXJlKFwiLi9jb21wb3NpdGlvblwiKSwgb2JqID0gcmVxdWlyZShcIi4uL29iamVjdFwiKSwgYXJyYXlGbnMgPSByZXF1aXJlKFwiLi4vYXJyYXlcIiksIGVtcHR5Rm4gPSByZXF1aXJlKFwiLi4vZnVuY3Rpb25cIikuZW1wdHlGbiwgaXMgPSByZXF1aXJlKFwiLi4vaXNcIiksIGFFYWNoID0gYXJyYXlGbnMuZWFjaCwgYXBwbHkgPSBvYmouYXBwbHksIG9FYWNoID0gb2JqLmVhY2gsIG9GaWx0ZXIgPSBvYmouZmlsdGVyLCBtaXggPSBvYmoubWl4LCBhcnJheVNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLCBDbGFzc0RlZmluZXI7XG5fJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVszNl0rKztcbkNsYXNzRGVmaW5lciA9IHtDT01QT1NJVElPTlNfTkFNRTogXCIkY29tcG9zaXRpb25zXCIsIGRlZmF1bHRUeXBlOiBCYXNlLCBwcm9jZXNzb3JLZXlzOiB7JG1peGluczogXCJfYXBwbHlNaXhpbnNcIiwgJHN0YXRpY3M6IFwiX2FwcGx5U3RhdGljc1wiLCAkY29tcG9zaXRpb25zOiBcIl9hcHBseUNvbXBvc2VyTWV0aG9kc1wiLCAkc3VwZXI6IFwiX2FwcGx5U3VwZXJcIn0sIGRlZmluZTogKGZ1bmN0aW9uIChvcHRzKSB7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzUwXSsrO1xuICB2YXIgb3B0aW9ucyA9IG9wdHMgfHwge30sIFN1cGVyID0gb3B0aW9ucy4kc3VwZXIgfHwgKG9wdGlvbnMuJHN1cGVyID09PSB1bmRlZmluZWQ/IHRoaXMuZGVmYXVsdFR5cGU6IGZhbHNlKSwgQ29uc3RydWN0b3I7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzU1XSsrO1xuICBvcHRpb25zLiRzdXBlciA9IFN1cGVyO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVs1N10rKztcbiAgQ29uc3RydWN0b3IgPSB0aGlzLl9jcmVhdGVDb25zdHJ1Y3RvcihvcHRpb25zKTtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bNTldKys7XG4gIHRoaXMuX3Byb2Nlc3NBZnRlckNyZWF0ZShDb25zdHJ1Y3Rvciwgb3B0aW9ucyk7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzYxXSsrO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59KSwgX2NyZWF0ZUNvbnN0cnVjdG9yOiAoZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bNjVdKys7XG4gIHZhciBzdXBlcmNsYXNzID0gb3B0aW9ucy4kc3VwZXIsIENvbnN0cnVjdG9yID0gdGhpcy5fY3JlYXRlQ29uc3RydWN0b3JGbihvcHRpb25zKTtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bNjhdKys7XG4gIGlmIChzdXBlcmNsYXNzKSB7XG4gICAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bNjldKys7XG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlcmNsYXNzLnByb3RvdHlwZSk7XG4gIH1cbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bNzJdKys7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn0pLCBfY3JlYXRlQ29uc3RydWN0b3JGbjogKGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzc2XSsrO1xuICB2YXIgc3VwZXJjbGFzcyA9IG9wdGlvbnMuJHN1cGVyLCBDb25zdHJ1Y3RvcjtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bNzldKys7XG4gIGlmICh0aGlzLl9oYXNDb25zdHJ1Y3Rvck1vZGlmeWluZ09wdGlvbnMob3B0aW9ucykpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVs4MF0rKztcbiAgICBDb25zdHJ1Y3RvciA9IHRoaXMuX2NyZWF0ZUNvbnN0cnVjdG9yRnJvbU9wdGlvbnMob3B0aW9ucyk7XG4gIH1cbiAgZWxzZSB7XG4gICAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bODJdKys7XG4gICAgaWYgKCEgc3VwZXJjbGFzcykge1xuICAgICAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bODNdKys7XG4gICAgICBDb25zdHJ1Y3RvciA9IChmdW5jdGlvbiAoKSB7XG59KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVs4Nl0rKztcbiAgICAgIENvbnN0cnVjdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bODddKys7XG4gIHN1cGVyY2xhc3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn0pO1xuICAgIH1cbiAgfVxuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVs5MV0rKztcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufSksIF9oYXNDb25zdHJ1Y3Rvck1vZGlmeWluZ09wdGlvbnM6IChmdW5jdGlvbiAob3B0aW9ucykge1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVs5NV0rKztcbiAgcmV0dXJuIG9wdGlvbnMuJGNvbXBvc2l0aW9ucztcbn0pLCBfY3JlYXRlQ29uc3RydWN0b3JGcm9tT3B0aW9uczogKGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzk5XSsrO1xuICB2YXIgc3VwZXJjbGFzcyA9IG9wdGlvbnMuJHN1cGVyLCBtZSA9IHRoaXMsIGluaXRCZWZvcmVTdXBlcmNsYXNzLCBpbml0QWZ0ZXJTdXBlcmNsYXNzLCBpbml0O1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVsxMDVdKys7XG4gIGlmICghIHN1cGVyY2xhc3MpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVsxMDZdKys7XG4gICAgaW5pdCA9IHRoaXMuX2NyZWF0ZUluaXRDbGFzc0ZuKG9wdGlvbnMsIHthbGw6IHRydWV9KTtcbiAgICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVsxMTBdKys7XG4gICAgcmV0dXJuIChmdW5jdGlvbiAoKSB7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzExMV0rKztcbiAgdmFyIGFyZ3MgPSBhcnJheVNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bMTEyXSsrO1xuICBpbml0LmNhbGwodGhpcywgb3B0aW9ucywgYXJncyk7XG59KTtcbiAgfVxuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVsxMTZdKys7XG4gIGluaXRCZWZvcmVTdXBlcmNsYXNzID0gdGhpcy5fY3JlYXRlSW5pdENsYXNzRm4ob3B0aW9ucywge2JlZm9yZTogdHJ1ZX0pO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVsxMjBdKys7XG4gIGluaXRBZnRlclN1cGVyY2xhc3MgPSB0aGlzLl9jcmVhdGVJbml0Q2xhc3NGbihvcHRpb25zLCB7YmVmb3JlOiBmYWxzZX0pO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVsxMjRdKys7XG4gIHJldHVybiAoZnVuY3Rpb24gKCkge1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVsxMjVdKys7XG4gIHZhciBhcmdzID0gYXJyYXlTbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzEyN10rKztcbiAgaW5pdEJlZm9yZVN1cGVyY2xhc3MuY2FsbCh0aGlzLCBvcHRpb25zLCBhcmdzKTtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bMTI4XSsrO1xuICBzdXBlcmNsYXNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzEyOV0rKztcbiAgaW5pdEFmdGVyU3VwZXJjbGFzcy5jYWxsKHRoaXMsIG9wdGlvbnMsIGFyZ3MpO1xufSk7XG59KSwgX2NyZWF0ZUluaXRDbGFzc0ZuOiAoZnVuY3Rpb24gKG9wdGlvbnMsIGNvbmZpZykge1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVsxMzRdKys7XG4gIHZhciBtZSA9IHRoaXMsIGNvbXBvc2l0aW9ucyA9IHRoaXMuX2ZpbHRlckNvbXBvc2l0aW9ucyhjb25maWcsIG9wdGlvbnMuJGNvbXBvc2l0aW9ucyk7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzEzN10rKztcbiAgaWYgKGNvbXBvc2l0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVsxMzhdKys7XG4gICAgcmV0dXJuIGVtcHR5Rm47XG4gIH1cbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bMTQxXSsrO1xuICByZXR1cm4gKGZ1bmN0aW9uIChvcHRpb25zLCBpbnN0YW5jZUFyZ3MpIHtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bMTQyXSsrO1xuICBtZS5faW5pdENvbXBvc2l0aW9ucy5jYWxsKHRoaXMsIGNvbXBvc2l0aW9ucywgaW5zdGFuY2VBcmdzKTtcbn0pO1xufSksIF9maWx0ZXJDb21wb3NpdGlvbnM6IChmdW5jdGlvbiAoY29uZmlnLCBjb21wb3NpdGlvbnMpIHtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bMTQ3XSsrO1xuICB2YXIgYmVmb3JlID0gY29uZmlnLmJlZm9yZSwgZmlsdGVyZWQgPSBbXTtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bMTUwXSsrO1xuICBpZiAoY29uZmlnLmFsbCkge1xuICAgIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzE1MV0rKztcbiAgICByZXR1cm4gY29tcG9zaXRpb25zO1xuICB9XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzE1NF0rKztcbiAgYUVhY2goY29tcG9zaXRpb25zLCAoZnVuY3Rpb24gKGNvbXBvc2l0aW9uKSB7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzE1NV0rKztcbiAgaWYgKGJlZm9yZSAmJiBjb21wb3NpdGlvbi5pbml0QWZ0ZXIgIT09IHRydWUgfHwgKCEgYmVmb3JlICYmIGNvbXBvc2l0aW9uLmluaXRBZnRlciA9PT0gdHJ1ZSkpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVsxNTZdKys7XG4gICAgZmlsdGVyZWQucHVzaChjb21wb3NpdGlvbik7XG4gIH1cbn0pKTtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bMTYwXSsrO1xuICByZXR1cm4gZmlsdGVyZWQ7XG59KSwgX3Byb2Nlc3NBZnRlckNyZWF0ZTogKGZ1bmN0aW9uICgkY2xhc3MsIG9wdGlvbnMpIHtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bMTY0XSsrO1xuICB0aGlzLl9hcHBseVZhbHVlc1RvUHJvdG8oJGNsYXNzLCBvcHRpb25zKTtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bMTY1XSsrO1xuICB0aGlzLl9oYW5kbGVQb3N0UHJvY2Vzc29ycygkY2xhc3MsIG9wdGlvbnMpO1xufSksIF9hcHBseVZhbHVlc1RvUHJvdG86IChmdW5jdGlvbiAoJGNsYXNzLCBvcHRpb25zKSB7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzE2OV0rKztcbiAgdmFyIHByb3RvID0gJGNsYXNzLnByb3RvdHlwZSwgdmFsdWVzID0gYXBwbHkoeyRjbGFzczogJGNsYXNzfSwgb3B0aW9ucyk7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzE3Nl0rKztcbiAgb0VhY2godmFsdWVzLCAoZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bMTc3XSsrO1xuICBpZiAoISB0aGlzLl9nZXRQcm9jZXNzb3JLZXkoa2V5KSkge1xuICAgIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzE3OF0rKztcbiAgICBwcm90b1trZXldID0gdmFsdWU7XG4gIH1cbn0pLCB0aGlzKTtcbn0pLCBfZ2V0UHJvY2Vzc29yS2V5OiAoZnVuY3Rpb24gKGtleSkge1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVsxODRdKys7XG4gIHJldHVybiB0aGlzLnByb2Nlc3NvcktleXNba2V5XTtcbn0pLCBfaGFuZGxlUG9zdFByb2Nlc3NvcnM6IChmdW5jdGlvbiAoJGNsYXNzLCBvcHRpb25zKSB7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzE4OF0rKztcbiAgb0VhY2gob3B0aW9ucywgKGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzE4OV0rKztcbiAgdmFyIG1ldGhvZCA9IHRoaXMuX2dldFByb2Nlc3NvcktleShrZXkpO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVsxOTFdKys7XG4gIGlmIChpcy5pc0Z1bmN0aW9uKHRoaXNbbWV0aG9kXSkpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVsxOTJdKys7XG4gICAgdGhpc1ttZXRob2RdLmNhbGwodGhpcywgJGNsYXNzLCBvcHRpb25zW2tleV0pO1xuICB9XG59KSwgdGhpcyk7XG59KSwgX2FwcGx5TWl4aW5zOiAoZnVuY3Rpb24gKCRjbGFzcywgbWl4aW5zKSB7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzE5OF0rKztcbiAgdmFyIHByb3RvID0gJGNsYXNzLnByb3RvdHlwZTtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bMTk5XSsrO1xuICBhRWFjaChtaXhpbnMsIChmdW5jdGlvbiAobWl4aW4pIHtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bMjAxXSsrO1xuICB2YXIgdG9NaXggPSBtaXhpbi5wcm90b3R5cGUgfHwgbWl4aW47XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzIwMl0rKztcbiAgbWl4KHByb3RvLCB0b01peCk7XG59KSk7XG59KSwgX2FwcGx5U3RhdGljczogKGZ1bmN0aW9uICgkY2xhc3MsIHN0YXRpY3MpIHtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bMjA3XSsrO1xuICB2YXIgcHJvdG90eXBlID0gJGNsYXNzLnByb3RvdHlwZTtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bMjA5XSsrO1xuICBhcHBseSgkY2xhc3MsIHN0YXRpY3MpO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVsyMTFdKys7XG4gIGlmIChwcm90b3R5cGUuZ2V0U3RhdGljVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzIxMl0rKztcbiAgICBwcm90b3R5cGUuZ2V0U3RhdGljVmFsdWUgPSB0aGlzLmdldFN0YXRpY1ZhbHVlO1xuICB9XG59KSwgX2FwcGx5Q29tcG9zZXJNZXRob2RzOiAoZnVuY3Rpb24gKCRjbGFzcywgY29tcG9zaXRpb25zKSB7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzIxN10rKztcbiAgdmFyIHByb3RvdHlwZSA9ICRjbGFzcy5wcm90b3R5cGUsIG1ldGhvZHNUb0NvbXBvc2U7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzIyMF0rKztcbiAgYUVhY2goY29tcG9zaXRpb25zLCAoZnVuY3Rpb24gKGNvbXBvc2l0aW9uQ29uZmlnKSB7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzIyMV0rKztcbiAgdmFyIGNvbXBvc2l0aW9uID0gbmV3IENvbXBvc2l0aW9uKGNvbXBvc2l0aW9uQ29uZmlnKSwgbmFtZSA9IGNvbXBvc2l0aW9uLm5hbWUsIENvbnN0cnVjdG9yID0gY29tcG9zaXRpb24uQ29uc3RydWN0b3I7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzIyNV0rKztcbiAgY29tcG9zaXRpb24udmFsaWRhdGUoKTtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bMjI3XSsrO1xuICBtZXRob2RzVG9Db21wb3NlID0gY29tcG9zaXRpb24uZ2V0TWV0aG9kc1RvQ29tcG9zZSgpO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVsyMjldKys7XG4gIG1ldGhvZHNUb0NvbXBvc2UuZm9yRWFjaCgoZnVuY3Rpb24gKGtleSkge1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVsyMzBdKys7XG4gIGlmIChwcm90b3R5cGVba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bMjMxXSsrO1xuICAgIHByb3RvdHlwZVtrZXldID0gdGhpcy5fY3JlYXRlQ29tcG9zZXJQcm90b0ZuKGtleSwgbmFtZSk7XG4gIH1cbn0pLCB0aGlzKTtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bMjM1XSsrO1xuICBpZiAocHJvdG90eXBlLmdldENvbXBvc2l0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVsyMzZdKys7XG4gICAgcHJvdG90eXBlLmdldENvbXBvc2l0aW9uID0gdGhpcy5nZXRDb21wb3NpdGlvbjtcbiAgfVxufSksIHRoaXMpO1xufSksIF9hcHBseVN1cGVyOiAoZnVuY3Rpb24gKCRjbGFzcywgJHN1cGVyKSB7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzI0M10rKztcbiAgdmFyIHByb3RvO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVsyNDVdKys7XG4gIGlmICgkc3VwZXIpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVsyNDZdKys7XG4gICAgcHJvdG8gPSAkY2xhc3MucHJvdG90eXBlO1xuICAgIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzI0N10rKztcbiAgICBwcm90by4kc3VwZXIgPSAkc3VwZXI7XG4gICAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bMjQ4XSsrO1xuICAgIHByb3RvLiRzdXBlcmNsYXNzID0gJHN1cGVyLnByb3RvdHlwZTtcbiAgfVxufSksIF9jcmVhdGVDb21wb3NlclByb3RvRm46IChmdW5jdGlvbiAobWV0aG9kTmFtZSwgY29tcG9zaXRpb25OYW1lKSB7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzI1M10rKztcbiAgcmV0dXJuIChmdW5jdGlvbiAoKSB7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzI1NF0rKztcbiAgdmFyIGNvbXAgPSB0aGlzW0NsYXNzRGVmaW5lci5DT01QT1NJVElPTlNfTkFNRV1bY29tcG9zaXRpb25OYW1lXTtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bMjU1XSsrO1xuICByZXR1cm4gY29tcFttZXRob2ROYW1lXS5hcHBseShjb21wLCBhcmd1bWVudHMpO1xufSk7XG59KSwgX2luaXRDb21wb3NpdGlvbnM6IChmdW5jdGlvbiAoY29tcG9zaXRpb25zLCBpbnN0YW5jZUFyZ3MpIHtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bMjY3XSsrO1xuICBpZiAoISB0aGlzW0NsYXNzRGVmaW5lci5DT01QT1NJVElPTlNfTkFNRV0pIHtcbiAgICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVsyNjhdKys7XG4gICAgdGhpc1tDbGFzc0RlZmluZXIuQ09NUE9TSVRJT05TX05BTUVdID0ge307XG4gIH1cbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bMjcxXSsrO1xuICBhRWFjaChjb21wb3NpdGlvbnMsIChmdW5jdGlvbiAoY29tcG9zaXRpb25Db25maWcpIHtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bMjcyXSsrO1xuICB2YXIgY29uZmlnID0gYXBwbHkoe2luc3RhbmNlOiB0aGlzLCBpbnN0YW5jZUFyZ3M6IGluc3RhbmNlQXJnc30sIGNvbXBvc2l0aW9uQ29uZmlnKSwgY29tcG9zaXRpb247XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzI3OF0rKztcbiAgY29tcG9zaXRpb24gPSBuZXcgQ29tcG9zaXRpb24oY29uZmlnKTtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bMjgwXSsrO1xuICB0aGlzW0NsYXNzRGVmaW5lci5DT01QT1NJVElPTlNfTkFNRV1bY29tcG9zaXRpb24ubmFtZV0gPSBjb21wb3NpdGlvbi5nZXRJbnN0YW5jZSgpO1xufSksIHRoaXMpO1xufSksIGdldENvbXBvc2l0aW9uOiAoZnVuY3Rpb24gKGtleSkge1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVsyODhdKys7XG4gIHJldHVybiB0aGlzW0NsYXNzRGVmaW5lci5DT01QT1NJVElPTlNfTkFNRV1ba2V5XTtcbn0pLCBnZXRTdGF0aWNWYWx1ZTogKGZ1bmN0aW9uIChrZXksICRjbGFzcykge1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVsyOTJdKys7XG4gIHZhciBjbGFzc1RvRmluZFZhbHVlID0gJGNsYXNzIHx8IHRoaXMuJGNsYXNzLCAkc3VwZXIsIHZhbHVlO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVsyOTZdKys7XG4gIHZhbHVlID0gY2xhc3NUb0ZpbmRWYWx1ZVtrZXldO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVsyOThdKys7XG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bMjk5XSsrO1xuICAgICRzdXBlciA9IGNsYXNzVG9GaW5kVmFsdWUucHJvdG90eXBlLiRzdXBlcjtcbiAgICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVszMDBdKys7XG4gICAgaWYgKCRzdXBlcikge1xuICAgICAgXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ11bMzAxXSsrO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhdGljVmFsdWUoa2V5LCAkc3VwZXIpO1xuICAgIH1cbiAgfVxuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2RlZmluZXIuanMnXVszMDVdKys7XG4gIHJldHVybiB2YWx1ZTtcbn0pfTtcbl8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzMxMF0rKztcbkNsYXNzRGVmaW5lci5kZWZpbmUgPSBDbGFzc0RlZmluZXIuZGVmaW5lLmJpbmQoQ2xhc3NEZWZpbmVyKTtcbl8kanNjb3ZlcmFnZVsnY2xhc3MvZGVmaW5lci5qcyddWzMxMl0rKztcbm1vZHVsZS5leHBvcnRzID0gQ2xhc3NEZWZpbmVyO1xuXyRqc2NvdmVyYWdlWydjbGFzcy9kZWZpbmVyLmpzJ10uc291cmNlID0gW1widmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKSxcIixcIiAgICBDb21wb3NpdGlvbiA9IHJlcXVpcmUoJy4vY29tcG9zaXRpb24nKSxcIixcIiAgICBvYmogPSByZXF1aXJlKCcuLi9vYmplY3QnKSxcIixcIiAgICBhcnJheUZucyA9IHJlcXVpcmUoJy4uL2FycmF5JyksXCIsXCIgICAgZW1wdHlGbiA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9uJykuZW1wdHlGbixcIixcIiAgICBpcyA9IHJlcXVpcmUoJy4uL2lzJyksXCIsXCIgICAgYUVhY2ggPSBhcnJheUZucy5lYWNoLFwiLFwiICAgIGFwcGx5ID0gb2JqLmFwcGx5LFwiLFwiICAgIG9FYWNoID0gb2JqLmVhY2gsXCIsXCIgICAgb0ZpbHRlciA9IG9iai5maWx0ZXIsXCIsXCIgICAgbWl4ID0gb2JqLm1peCxcIixcIiAgICBhcnJheVNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLFwiLFwiICAgIENsYXNzRGVmaW5lcjtcIixcIlwiLFwiLyoqXCIsXCIgKiBAY2xhc3MgTHVjLkNsYXNzRGVmaW5lclwiLFwiICogQHNpbmdsZXRvblwiLFwiICpcIixcIiAqIFNpbmdsZXRvbiB0aGF0IHtAbGluayBMdWMuZGVmaW5lI2RlZmluZSBMdWMuZGVmaW5lfSB1c2VzIHRvIGRlZmluZSBjbGFzc2VzLiAgVGhlIGRlZnVhbHQgdHlwZSBjYW5cIixcIiAqIGJlIGNoYW5nZWQgdG8gYW55IENvbnN0cnVjdG9yXCIsXCIgKlwiLFwiICAgIGZ1bmN0aW9uIE15Q2xhc3MoKXt9O1wiLFwiICAgIEx1Yy5DbGFzc0RlZmluZXIuZGVmYXVsdFR5cGUgPSBNeUNsYXNzO1wiLFwiICAgIHZhciBDID0gTHVjLmRlZmluZSgpO1wiLFwiICAgIG5ldyBDKCkgaW5zdGFuY2VvZiBMdWMuQmFzZVwiLFwiICAgICZndDtmYWxzZVwiLFwiICAgIG5ldyBDKCkgaW5zdGFuY2VvZiBNeUNsYXNzXCIsXCIgICAgJmd0O3RydWVcIixcIiAqL1wiLFwiXCIsXCIvKipcIixcIiAqIEBjZmcge0Z1bmN0aW9ufSBkZWZhdWx0VHlwZSB0aGlzIGNhbiBiZSBjaGFuZ2VkIHRvIGFueSBDb25zdHJ1Y3Rvci4gIERlZmF1bHRzXCIsXCIgKiB0byBMdWMuQmFzZS5cIixcIiAqL1wiLFwiXCIsXCJDbGFzc0RlZmluZXIgPSB7XCIsXCJcIixcIiAgICBDT01QT1NJVElPTlNfTkFNRTogJyRjb21wb3NpdGlvbnMnLFwiLFwiXCIsXCIgICAgZGVmYXVsdFR5cGU6IEJhc2UsXCIsXCJcIixcIiAgICBwcm9jZXNzb3JLZXlzOiB7XCIsXCIgICAgICAgICRtaXhpbnM6ICdfYXBwbHlNaXhpbnMnLFwiLFwiICAgICAgICAkc3RhdGljczogJ19hcHBseVN0YXRpY3MnLFwiLFwiICAgICAgICAkY29tcG9zaXRpb25zOiAnX2FwcGx5Q29tcG9zZXJNZXRob2RzJyxcIixcIiAgICAgICAgJHN1cGVyOiAnX2FwcGx5U3VwZXInXCIsXCIgICAgfSxcIixcIlwiLFwiICAgIGRlZmluZTogZnVuY3Rpb24ob3B0cykge1wiLFwiICAgICAgICB2YXIgb3B0aW9ucyA9IG9wdHMgfHwge30sXCIsXCIgICAgICAgICAgICAvL2lmIHN1cGVyIGlzIGEgZmFsc3kgdmFsdWUgYmVzaWRlcyB1bmRlZmluZWQgdGhhdCBtZWFucyBubyBzdXBlcmNsYXNzXCIsXCIgICAgICAgICAgICBTdXBlciA9IG9wdGlvbnMuJHN1cGVyIHx8IChvcHRpb25zLiRzdXBlciA9PT0gdW5kZWZpbmVkID8gdGhpcy5kZWZhdWx0VHlwZSA6IGZhbHNlKSxcIixcIiAgICAgICAgICAgIENvbnN0cnVjdG9yO1wiLFwiXCIsXCIgICAgICAgIG9wdGlvbnMuJHN1cGVyID0gU3VwZXI7XCIsXCJcIixcIiAgICAgICAgQ29uc3RydWN0b3IgPSB0aGlzLl9jcmVhdGVDb25zdHJ1Y3RvcihvcHRpb25zKTtcIixcIlwiLFwiICAgICAgICB0aGlzLl9wcm9jZXNzQWZ0ZXJDcmVhdGUoQ29uc3RydWN0b3IsIG9wdGlvbnMpO1wiLFwiXCIsXCIgICAgICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcIixcIiAgICB9LFwiLFwiXCIsXCIgICAgX2NyZWF0ZUNvbnN0cnVjdG9yOiBmdW5jdGlvbihvcHRpb25zKSB7XCIsXCIgICAgICAgIHZhciBzdXBlcmNsYXNzID0gb3B0aW9ucy4kc3VwZXIsXCIsXCIgICAgICAgICAgICBDb25zdHJ1Y3RvciA9IHRoaXMuX2NyZWF0ZUNvbnN0cnVjdG9yRm4ob3B0aW9ucyk7XCIsXCJcIixcIiAgICAgICAgaWYoc3VwZXJjbGFzcykge1wiLFwiICAgICAgICAgICAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlcmNsYXNzLnByb3RvdHlwZSk7XCIsXCIgICAgICAgIH1cIixcIiAgICAgICAgXCIsXCIgICAgICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcIixcIiAgICB9LFwiLFwiXCIsXCIgICAgX2NyZWF0ZUNvbnN0cnVjdG9yRm46IGZ1bmN0aW9uKG9wdGlvbnMpIHtcIixcIiAgICAgICAgdmFyIHN1cGVyY2xhc3MgPSBvcHRpb25zLiRzdXBlcixcIixcIiAgICAgICAgICAgIENvbnN0cnVjdG9yO1wiLFwiXCIsXCIgICAgICAgIGlmICh0aGlzLl9oYXNDb25zdHJ1Y3Rvck1vZGlmeWluZ09wdGlvbnMob3B0aW9ucykpIHtcIixcIiAgICAgICAgICAgIENvbnN0cnVjdG9yID0gdGhpcy5fY3JlYXRlQ29uc3RydWN0b3JGcm9tT3B0aW9ucyhvcHRpb25zKTtcIixcIiAgICAgICAgfVwiLFwiICAgICAgICBlbHNlIGlmKCFzdXBlcmNsYXNzKSB7XCIsXCIgICAgICAgICAgICBDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKCkge307XCIsXCIgICAgICAgIH1cIixcIiAgICAgICAgZWxzZSB7XCIsXCIgICAgICAgICAgICBDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKCkge1wiLFwiICAgICAgICAgICAgICAgIHN1cGVyY2xhc3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcIixcIiAgICAgICAgICAgIH07XCIsXCIgICAgICAgIH1cIixcIlwiLFwiICAgICAgICByZXR1cm4gQ29uc3RydWN0b3I7XCIsXCIgICAgfSxcIixcIlwiLFwiICAgIF9oYXNDb25zdHJ1Y3Rvck1vZGlmeWluZ09wdGlvbnM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcIixcIiAgICAgICAgcmV0dXJuIG9wdGlvbnMuJGNvbXBvc2l0aW9ucztcIixcIiAgICB9LFwiLFwiXCIsXCIgICAgX2NyZWF0ZUNvbnN0cnVjdG9yRnJvbU9wdGlvbnM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcIixcIiAgICAgICAgdmFyIHN1cGVyY2xhc3MgPSBvcHRpb25zLiRzdXBlcixcIixcIiAgICAgICAgICAgIG1lID0gdGhpcyxcIixcIiAgICAgICAgICAgIGluaXRCZWZvcmVTdXBlcmNsYXNzLFwiLFwiICAgICAgICAgICAgaW5pdEFmdGVyU3VwZXJjbGFzcyxcIixcIiAgICAgICAgICAgIGluaXQ7XCIsXCJcIixcIiAgICAgICAgaWYgKCFzdXBlcmNsYXNzKSB7XCIsXCIgICAgICAgICAgICBpbml0ID0gdGhpcy5fY3JlYXRlSW5pdENsYXNzRm4ob3B0aW9ucywge1wiLFwiICAgICAgICAgICAgICAgIGFsbDogdHJ1ZVwiLFwiICAgICAgICAgICAgfSk7XCIsXCJcIixcIiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcIixcIiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGFycmF5U2xpY2UuY2FsbChhcmd1bWVudHMpO1wiLFwiICAgICAgICAgICAgICAgIGluaXQuY2FsbCh0aGlzLCBvcHRpb25zLCBhcmdzKTtcIixcIiAgICAgICAgICAgIH07XCIsXCIgICAgICAgIH1cIixcIlwiLFwiICAgICAgICBpbml0QmVmb3JlU3VwZXJjbGFzcyA9IHRoaXMuX2NyZWF0ZUluaXRDbGFzc0ZuKG9wdGlvbnMsIHtcIixcIiAgICAgICAgICAgIGJlZm9yZTogdHJ1ZVwiLFwiICAgICAgICB9KTtcIixcIlwiLFwiICAgICAgICBpbml0QWZ0ZXJTdXBlcmNsYXNzID0gdGhpcy5fY3JlYXRlSW5pdENsYXNzRm4ob3B0aW9ucywge1wiLFwiICAgICAgICAgICAgYmVmb3JlOiBmYWxzZVwiLFwiICAgICAgICB9KTtcIixcIlwiLFwiICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XCIsXCIgICAgICAgICAgICB2YXIgYXJncyA9IGFycmF5U2xpY2UuY2FsbChhcmd1bWVudHMpO1wiLFwiXCIsXCIgICAgICAgICAgICBpbml0QmVmb3JlU3VwZXJjbGFzcy5jYWxsKHRoaXMsIG9wdGlvbnMsIGFyZ3MpO1wiLFwiICAgICAgICAgICAgc3VwZXJjbGFzcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1wiLFwiICAgICAgICAgICAgaW5pdEFmdGVyU3VwZXJjbGFzcy5jYWxsKHRoaXMsIG9wdGlvbnMsIGFyZ3MpO1wiLFwiICAgICAgICB9O1wiLFwiICAgIH0sXCIsXCJcIixcIiAgICBfY3JlYXRlSW5pdENsYXNzRm46IGZ1bmN0aW9uKG9wdGlvbnMsIGNvbmZpZykge1wiLFwiICAgICAgICB2YXIgbWUgPSB0aGlzLFwiLFwiICAgICAgICAgICAgY29tcG9zaXRpb25zID0gdGhpcy5fZmlsdGVyQ29tcG9zaXRpb25zKGNvbmZpZywgb3B0aW9ucy4kY29tcG9zaXRpb25zKTtcIixcIlwiLFwiICAgICAgICBpZihjb21wb3NpdGlvbnMubGVuZ3RoID09PSAwKSB7XCIsXCIgICAgICAgICAgICByZXR1cm4gZW1wdHlGbjtcIixcIiAgICAgICAgfVwiLFwiICAgICAgICBcIixcIiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9wdGlvbnMsIGluc3RhbmNlQXJncykge1wiLFwiICAgICAgICAgICAgbWUuX2luaXRDb21wb3NpdGlvbnMuY2FsbCh0aGlzLCBjb21wb3NpdGlvbnMsIGluc3RhbmNlQXJncyk7XCIsXCIgICAgICAgIH07XCIsXCIgICAgfSxcIixcIlwiLFwiICAgIF9maWx0ZXJDb21wb3NpdGlvbnM6IGZ1bmN0aW9uKGNvbmZpZywgY29tcG9zaXRpb25zKSB7XCIsXCIgICAgICAgIHZhciBiZWZvcmUgPSBjb25maWcuYmVmb3JlLCBcIixcIiAgICAgICAgICAgIGZpbHRlcmVkID0gW107XCIsXCJcIixcIiAgICAgICAgaWYoY29uZmlnLmFsbCkge1wiLFwiICAgICAgICAgICAgcmV0dXJuIGNvbXBvc2l0aW9ucztcIixcIiAgICAgICAgfVwiLFwiXCIsXCIgICAgICAgIGFFYWNoKGNvbXBvc2l0aW9ucywgZnVuY3Rpb24oY29tcG9zaXRpb24pIHtcIixcIiAgICAgICAgICAgIGlmKGJlZm9yZSAmYW1wOyZhbXA7IGNvbXBvc2l0aW9uLmluaXRBZnRlciAhPT0gdHJ1ZSB8fCAoIWJlZm9yZSAmYW1wOyZhbXA7IGNvbXBvc2l0aW9uLmluaXRBZnRlciA9PT0gdHJ1ZSkpIHtcIixcIiAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWQucHVzaChjb21wb3NpdGlvbik7XCIsXCIgICAgICAgICAgICB9XCIsXCIgICAgICAgIH0pO1wiLFwiXCIsXCIgICAgICAgIHJldHVybiBmaWx0ZXJlZDtcIixcIiAgICB9LFwiLFwiXCIsXCIgICAgX3Byb2Nlc3NBZnRlckNyZWF0ZTogZnVuY3Rpb24oJGNsYXNzLCBvcHRpb25zKSB7XCIsXCIgICAgICAgIHRoaXMuX2FwcGx5VmFsdWVzVG9Qcm90bygkY2xhc3MsIG9wdGlvbnMpO1wiLFwiICAgICAgICB0aGlzLl9oYW5kbGVQb3N0UHJvY2Vzc29ycygkY2xhc3MsIG9wdGlvbnMpO1wiLFwiICAgIH0sXCIsXCJcIixcIiAgICBfYXBwbHlWYWx1ZXNUb1Byb3RvOiBmdW5jdGlvbigkY2xhc3MsIG9wdGlvbnMpIHtcIixcIiAgICAgICAgdmFyIHByb3RvID0gJGNsYXNzLnByb3RvdHlwZSxcIixcIiAgICAgICAgICAgIHZhbHVlcyA9IGFwcGx5KHtcIixcIiAgICAgICAgICAgICAgICAkY2xhc3M6ICRjbGFzc1wiLFwiICAgICAgICAgICAgfSwgb3B0aW9ucyk7XCIsXCJcIixcIiAgICAgICAgLy9Eb24ndCBwdXQgdGhlIGRlZmluZSBzcGVjaWZpYyBwcm9wZXJ0aWVzXCIsXCIgICAgICAgIC8vb24gdGhlIHByb3RvdHlwZVwiLFwiICAgICAgICBvRWFjaCh2YWx1ZXMsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcIixcIiAgICAgICAgICAgIGlmICghdGhpcy5fZ2V0UHJvY2Vzc29yS2V5KGtleSkpIHtcIixcIiAgICAgICAgICAgICAgICBwcm90b1trZXldID0gdmFsdWU7XCIsXCIgICAgICAgICAgICB9XCIsXCIgICAgICAgIH0sIHRoaXMpO1wiLFwiICAgIH0sXCIsXCJcIixcIiAgICBfZ2V0UHJvY2Vzc29yS2V5OiBmdW5jdGlvbihrZXkpIHtcIixcIiAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc29yS2V5c1trZXldO1wiLFwiICAgIH0sXCIsXCJcIixcIiAgICBfaGFuZGxlUG9zdFByb2Nlc3NvcnM6IGZ1bmN0aW9uKCRjbGFzcywgb3B0aW9ucykge1wiLFwiICAgICAgICBvRWFjaChvcHRpb25zLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XCIsXCIgICAgICAgICAgICB2YXIgbWV0aG9kID0gdGhpcy5fZ2V0UHJvY2Vzc29yS2V5KGtleSk7XCIsXCJcIixcIiAgICAgICAgICAgIGlmIChpcy5pc0Z1bmN0aW9uKHRoaXNbbWV0aG9kXSkpIHtcIixcIiAgICAgICAgICAgICAgICB0aGlzW21ldGhvZF0uY2FsbCh0aGlzLCAkY2xhc3MsIG9wdGlvbnNba2V5XSk7XCIsXCIgICAgICAgICAgICB9XCIsXCIgICAgICAgIH0sIHRoaXMpO1wiLFwiICAgIH0sXCIsXCJcIixcIiAgICBfYXBwbHlNaXhpbnM6IGZ1bmN0aW9uKCRjbGFzcywgbWl4aW5zKSB7XCIsXCIgICAgICAgIHZhciBwcm90byA9ICRjbGFzcy5wcm90b3R5cGU7XCIsXCIgICAgICAgIGFFYWNoKG1peGlucywgZnVuY3Rpb24obWl4aW4pIHtcIixcIiAgICAgICAgICAgIC8vYWNjZXB0IENvbnN0cnVjdG9ycyBvciBPYmplY3RzXCIsXCIgICAgICAgICAgICB2YXIgdG9NaXggPSBtaXhpbi5wcm90b3R5cGUgfHwgbWl4aW47XCIsXCIgICAgICAgICAgICBtaXgocHJvdG8sIHRvTWl4KTtcIixcIiAgICAgICAgfSk7XCIsXCIgICAgfSxcIixcIlwiLFwiICAgIF9hcHBseVN0YXRpY3M6IGZ1bmN0aW9uKCRjbGFzcywgc3RhdGljcykge1wiLFwiICAgICAgICB2YXIgcHJvdG90eXBlID0gJGNsYXNzLnByb3RvdHlwZTtcIixcIlwiLFwiICAgICAgICBhcHBseSgkY2xhc3MsIHN0YXRpY3MpO1wiLFwiXCIsXCIgICAgICAgIGlmKHByb3RvdHlwZS5nZXRTdGF0aWNWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XCIsXCIgICAgICAgICAgICBwcm90b3R5cGUuZ2V0U3RhdGljVmFsdWUgPSB0aGlzLmdldFN0YXRpY1ZhbHVlO1wiLFwiICAgICAgICB9XCIsXCIgICAgfSxcIixcIlwiLFwiICAgIF9hcHBseUNvbXBvc2VyTWV0aG9kczogZnVuY3Rpb24oJGNsYXNzLCBjb21wb3NpdGlvbnMpIHtcIixcIiAgICAgICAgdmFyIHByb3RvdHlwZSA9ICRjbGFzcy5wcm90b3R5cGUsXCIsXCIgICAgICAgICAgICBtZXRob2RzVG9Db21wb3NlO1wiLFwiXCIsXCIgICAgICAgIGFFYWNoKGNvbXBvc2l0aW9ucywgZnVuY3Rpb24oY29tcG9zaXRpb25Db25maWcpIHtcIixcIiAgICAgICAgICAgIHZhciBjb21wb3NpdGlvbiA9IG5ldyBDb21wb3NpdGlvbihjb21wb3NpdGlvbkNvbmZpZyksXCIsXCIgICAgICAgICAgICAgICAgbmFtZSA9IGNvbXBvc2l0aW9uLm5hbWUsXCIsXCIgICAgICAgICAgICAgICAgQ29uc3RydWN0b3IgPSBjb21wb3NpdGlvbi5Db25zdHJ1Y3RvcjtcIixcIlwiLFwiICAgICAgICAgICAgY29tcG9zaXRpb24udmFsaWRhdGUoKTtcIixcIlwiLFwiICAgICAgICAgICAgbWV0aG9kc1RvQ29tcG9zZSA9IGNvbXBvc2l0aW9uLmdldE1ldGhvZHNUb0NvbXBvc2UoKTtcIixcIlwiLFwiICAgICAgICAgICAgbWV0aG9kc1RvQ29tcG9zZS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1wiLFwiICAgICAgICAgICAgICAgIGlmIChwcm90b3R5cGVba2V5XSA9PT0gdW5kZWZpbmVkKSB7XCIsXCIgICAgICAgICAgICAgICAgICAgIHByb3RvdHlwZVtrZXldID0gdGhpcy5fY3JlYXRlQ29tcG9zZXJQcm90b0ZuKGtleSwgbmFtZSk7XCIsXCIgICAgICAgICAgICAgICAgfVwiLFwiICAgICAgICAgICAgfSwgdGhpcyk7XCIsXCJcIixcIiAgICAgICAgICAgIGlmKHByb3RvdHlwZS5nZXRDb21wb3NpdGlvbiA9PT0gdW5kZWZpbmVkKSB7XCIsXCIgICAgICAgICAgICAgICAgcHJvdG90eXBlLmdldENvbXBvc2l0aW9uID0gdGhpcy5nZXRDb21wb3NpdGlvbjtcIixcIiAgICAgICAgICAgIH1cIixcIlwiLFwiICAgICAgICB9LCB0aGlzKTtcIixcIiAgICB9LFwiLFwiXCIsXCIgICAgX2FwcGx5U3VwZXI6IGZ1bmN0aW9uKCRjbGFzcywgJHN1cGVyKSB7XCIsXCIgICAgICAgIHZhciBwcm90bztcIixcIiAgICAgICAgLy9zdXBlciBjYW4gYmUgZmFsc3kgdG8gc2lnbmlmeSBubyBzdXBlcmNsYXNzXCIsXCIgICAgICAgIGlmICgkc3VwZXIpIHtcIixcIiAgICAgICAgICAgIHByb3RvID0gJGNsYXNzLnByb3RvdHlwZTtcIixcIiAgICAgICAgICAgIHByb3RvLiRzdXBlciA9ICRzdXBlcjtcIixcIiAgICAgICAgICAgIHByb3RvLiRzdXBlcmNsYXNzID0gJHN1cGVyLnByb3RvdHlwZTtcIixcIiAgICAgICAgfVwiLFwiICAgIH0sXCIsXCJcIixcIiAgICBfY3JlYXRlQ29tcG9zZXJQcm90b0ZuOiBmdW5jdGlvbihtZXRob2ROYW1lLCBjb21wb3NpdGlvbk5hbWUpIHtcIixcIiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1wiLFwiICAgICAgICAgICAgdmFyIGNvbXAgPSB0aGlzW0NsYXNzRGVmaW5lci5DT01QT1NJVElPTlNfTkFNRV1bY29tcG9zaXRpb25OYW1lXTtcIixcIiAgICAgICAgICAgIHJldHVybiBjb21wW21ldGhvZE5hbWVdLmFwcGx5KGNvbXAsIGFyZ3VtZW50cyk7XCIsXCIgICAgICAgIH07XCIsXCIgICAgfSxcIixcIlwiLFwiICAgIC8qKlwiLFwiICAgICAqIEBwcml2YXRlXCIsXCIgICAgICogQGlnbm9yZVwiLFwiICAgICAqIG9wdGlvbnMge09iamVjdH0gdGhlIGNvbXBvc2l0aW9uIGNvbmZpZyBvYmplY3RcIixcIiAgICAgKiBpbnN0YW5jZUFyZ3Mge0FycmF5fSB0aGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgaW5zdGFuY2Unc1wiLFwiICAgICAqIGNvbnN0cnVjdG9yLlwiLFwiICAgICAqL1wiLFwiICAgIF9pbml0Q29tcG9zaXRpb25zOiBmdW5jdGlvbihjb21wb3NpdGlvbnMsIGluc3RhbmNlQXJncykge1wiLFwiICAgICAgICBpZighdGhpc1tDbGFzc0RlZmluZXIuQ09NUE9TSVRJT05TX05BTUVdKSB7XCIsXCIgICAgICAgICAgICB0aGlzW0NsYXNzRGVmaW5lci5DT01QT1NJVElPTlNfTkFNRV0gPSB7fTtcIixcIiAgICAgICAgfVwiLFwiXCIsXCIgICAgICAgIGFFYWNoKGNvbXBvc2l0aW9ucywgZnVuY3Rpb24oY29tcG9zaXRpb25Db25maWcpIHtcIixcIiAgICAgICAgICAgIHZhciBjb25maWcgPSBhcHBseSh7XCIsXCIgICAgICAgICAgICAgICAgaW5zdGFuY2U6IHRoaXMsXCIsXCIgICAgICAgICAgICAgICAgaW5zdGFuY2VBcmdzOiBpbnN0YW5jZUFyZ3NcIixcIiAgICAgICAgICAgIH0sIGNvbXBvc2l0aW9uQ29uZmlnKSwgXCIsXCIgICAgICAgICAgICBjb21wb3NpdGlvbjtcIixcIlwiLFwiICAgICAgICAgICAgY29tcG9zaXRpb24gPSBuZXcgQ29tcG9zaXRpb24oY29uZmlnKTtcIixcIlwiLFwiICAgICAgICAgICAgdGhpc1tDbGFzc0RlZmluZXIuQ09NUE9TSVRJT05TX05BTUVdW2NvbXBvc2l0aW9uLm5hbWVdID0gY29tcG9zaXRpb24uZ2V0SW5zdGFuY2UoKTtcIixcIiAgICAgICAgfSwgdGhpcyk7XCIsXCIgICAgfSxcIixcIlwiLFwiICAgIC8vTWV0aG9kcyB0aGF0IGNhbiBnZXQgYWRkZWQgdG8gdGhlIHByb3RvdHlwZVwiLFwiICAgIC8vdGhleSB3aWxsIGJlIGNhbGxlZCBpbiB0aGUgY29udGV4dCBvZiB0aGUgaW5zdGFuY2UuXCIsXCIgICAgLy9cIixcIiAgICBnZXRDb21wb3NpdGlvbjogZnVuY3Rpb24oa2V5KSB7XCIsXCIgICAgICAgIHJldHVybiB0aGlzW0NsYXNzRGVmaW5lci5DT01QT1NJVElPTlNfTkFNRV1ba2V5XTtcIixcIiAgICB9LFwiLFwiXCIsXCIgICAgZ2V0U3RhdGljVmFsdWU6IGZ1bmN0aW9uIChrZXksICRjbGFzcykge1wiLFwiICAgICAgICB2YXIgY2xhc3NUb0ZpbmRWYWx1ZSA9ICRjbGFzcyB8fCB0aGlzLiRjbGFzcyxcIixcIiAgICAgICAgICAgICRzdXBlcixcIixcIiAgICAgICAgICAgIHZhbHVlO1wiLFwiXCIsXCIgICAgICAgIHZhbHVlID0gY2xhc3NUb0ZpbmRWYWx1ZVtrZXldO1wiLFwiXCIsXCIgICAgICAgIGlmKHZhbHVlID09PSB1bmRlZmluZWQpIHtcIixcIiAgICAgICAgICAgICRzdXBlciA9IGNsYXNzVG9GaW5kVmFsdWUucHJvdG90eXBlLiRzdXBlcjtcIixcIiAgICAgICAgICAgIGlmKCRzdXBlcikge1wiLFwiICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFN0YXRpY1ZhbHVlKGtleSwgJHN1cGVyKTtcIixcIiAgICAgICAgICAgIH1cIixcIiAgICAgICAgfVwiLFwiXCIsXCIgICAgICAgIHJldHVybiB2YWx1ZTtcIixcIiAgICB9XCIsXCJcIixcIn07XCIsXCJcIixcIkNsYXNzRGVmaW5lci5kZWZpbmUgPSBDbGFzc0RlZmluZXIuZGVmaW5lLmJpbmQoQ2xhc3NEZWZpbmVyKTtcIixcIlwiLFwibW9kdWxlLmV4cG9ydHMgPSBDbGFzc0RlZmluZXI7XCIsXCJcIixcIi8qKlwiLFwiICogQGNsYXNzICBMdWMuZGVmaW5lXCIsXCIgKiBUaGlzIGlzIGFjdHVhbGx5IGEgZnVuY3Rpb24gYnV0IGhhcyBhIGRlY2VudCBhbW91bnQgb2YgaW1wb3J0YW50IG9wdGlvbnNcIixcIiAqIHNvIHdlIGFyZSBkb2N1bWVudGluZyBpdCBsaWtlIGl0IGlzIGEgY2xhc3MuICBQcm9wZXJ0aWVzIGFyZSB0aGluZ3MgdGhhdCB3aWxsIGdldFwiLFwiICogYXBwbGllZCB0byBpbnN0YW5jZXMgb2YgY2xhc3NlcyBkZWZpbmVkIHdpdGgge0BsaW5rIEx1Yy5kZWZpbmUjZGVmaW5lIGRlZmluZX0uICBOb25lXCIsXCIgKiBhcmUgbmVlZGVkIGZvciB7QGxpbmsgTHVjLmRlZmluZSNkZWZpbmUgZGVmaW5pbmd9IGEgY2xhc3MuICB7QGxpbmsgTHVjLmRlZmluZSNkZWZpbmUgZGVmaW5lfVwiLFwiICoganVzdCB0YWtlcyB0aGUgcGFzc2VkIGluIGNvbmZpZyBhbmQgcHV0cyB0aGUgcHJvcGVydGllcyBvbiB0aGUgcHJvdG90eXBlIGFuZCByZXR1cm5zXCIsXCIgKiBhIENvbnN0cnVjdG9yLlwiLFwiICpcIixcIlwiLFwiICAgIHZhciBDID0gTHVjLmRlZmluZSh7XCIsXCIgICAgICAgIGE6IDEsXCIsXCIgICAgICAgIGRvTG9nOiB0cnVlLFwiLFwiICAgICAgICBsb2dBOiBmdW5jdGlvbigpIHtcIixcIiAgICAgICAgICAgIGlmICh0aGlzLmRvTG9nKSB7XCIsXCIgICAgICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5hKTtcIixcIiAgICAgICAgICAgIH1cIixcIiAgICAgICAgfVwiLFwiICAgIH0pO1wiLFwiICAgIHZhciBjID0gbmV3IEMoKTtcIixcIiAgICBjLmxvZ0EoKTtcIixcIiAgICAmZ3Q7MVwiLFwiICAgIGMuYSA9IDQ1O1wiLFwiICAgIGMubG9nQSgpO1wiLFwiICAgICZndDs0NVwiLFwiICAgIGMuZG9Mb2cgPSBmYWxzZTtcIixcIiAgICBjLmxvZ0EoKTtcIixcIlwiLFwiICAgIG5ldyBDKCkubG9nQSgpXCIsXCIgICAgJmd0OzFcIixcIlwiLFwiICpcIixcIiAqIENoZWNrIG91dCB0aGUgZm9sbG93aW5nIGNvbmZpZ3MgdG8gYWRkIGZ1bmN0aW9uYWxpdHkgdG8gYSBjbGFzcyB3aXRob3V0IG1lc3NpbmdcIixcIiAqIHVwIHRoZSBpbmhlcml0YW5jZSBjaGFpbi4gIEFsbCB0aGUgY29uZmlncyBoYXZlIGV4YW1wbGVzIGFuZCBkb2N1bWVudGF0aW9uIG9uIFwiLFwiICogaG93IHRvIHVzZSB0aGVtLlwiLFwiICpcIixcIiAqIHtAbGluayBMdWMuZGVmaW5lIyRzdXBlciBzdXBlcn0gJmx0O2JyJmd0O1wiLFwiICoge0BsaW5rIEx1Yy5kZWZpbmUjJGNvbXBvc2l0aW9ucyBjb21wb3NpdGlvbnN9ICZsdDticiZndDtcIixcIiAqIHtAbGluayBMdWMuZGVmaW5lIyRtaXhpbnMgbWl4aW5zfSAmbHQ7YnImZ3Q7XCIsXCIgKiB7QGxpbmsgTHVjLmRlZmluZSMkc3RhdGljcyBzdGF0aWNzfSAmbHQ7YnImZ3Q7XCIsXCIgKiBcIixcIiAqIFwiLFwiICovXCIsXCJcIixcIi8qKlwiLFwiICogQG1ldGhvZCAgZGVmaW5lXCIsXCIgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIGNvbmZpZyBvYmplY3QgdXNlZCB3aGVuIGNyZWF0aW5nIHRoZSBjbGFzcy4gIEFueSBwcm9wZXJ0eSB0aGF0XCIsXCIgKiBpcyBub3QgYXBhcnQgb2YgdGhlIHNwZWNpYWwgY29uZmlncyB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHByb3RvdHlwZS4gIENoZWNrIG91dFwiLFwiICogTHVjLmRlZmluZSBmb3IgYWxsIHRoZSBjb25maWcgb3B0aW9ucy4gICBObyBjb25maWdzIGFyZSBuZWVkZWQgdG8gZGVmaW5lIGEgY2xhc3MuXCIsXCIgKiBcIixcIiAqIEByZXR1cm4ge0Z1bmN0aW9ufSB0aGUgZGVmaW5lZCBjbGFzc1wiLFwiICpcIixcIiAgICB2YXIgQyA9IEx1Yy5kZWZpbmUoe1wiLFwiICAgICAgICBsb2dBOiBmdW5jdGlvbigpIHtcIixcIiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMuYSlcIixcIiAgICAgICAgfSxcIixcIiAgICAgICAgYTogMVwiLFwiICAgIH0pO1wiLFwiICAgIHZhciBjID0gbmV3IEMoKTtcIixcIiAgICBjLmxvZ0EoKTtcIixcIiAgICAmZ3Q7MVwiLFwiXCIsXCIgICAgYy5hID0gNDtcIixcIiAgICBjLmxvZ0EoKTtcIixcIiAgICAmZ3Q7NFwiLFwiICpcIixcIiAqXCIsXCIgKi9cIixcIlwiLFwiLyoqXCIsXCIgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSAkY2xhc3MgcmVmZXJlbmNlIHRvIHRoZSBpbnN0YW5jZXMgb3duIGNvbnN0cnVjdG9yLiAgVGhpc1wiLFwiICogd2lsbCBnZXQgYWRkZWQgdG8gYW55IGNsYXNzIHRoYXQgaXMgZGVmaW5lZCB3aXRoIEx1Yy5kZWZpbmUuXCIsXCIgKiBcIixcIiAgICB2YXIgQyA9IEx1Yy5kZWZpbmUoKVwiLFwiICAgIHZhciBjID0gbmV3IEMoKVwiLFwiICAgIGMuJGNsYXNzID09PSBDXCIsXCIgICAgJmd0O3RydWVcIixcIiAqXCIsXCIgKiBUaGVyZSBhcmUgc29tZSByZWFsbHkgZ29vZCB1c2UgY2FzZXMgdG8gaGF2ZSBhIHJlZmVyZW5jZSB0byBpdCdzXCIsXCIgKiBvd24gY29uc3RydWN0b3IuICAmbHQ7YnImZ3Q7IEFkZCBmdW5jdGlvbmFsaXR5IHRvIGFuIGluc3RhbmNlIGluIGEgc2ltcGxlXCIsXCIgKiBhbmQgZ2VuZXJpYyB3YXkuXCIsXCIgKlwiLFwiICAgIHZhciBDID0gTHVjLmRlZmluZSh7XCIsXCIgICAgICAgIGFkZDogZnVuY3Rpb24oYSxiKSB7XCIsXCIgICAgICAgICAgICByZXR1cm4gYSArIGI7XCIsXCIgICAgICAgIH1cIixcIiAgICB9KTtcIixcIlwiLFwiICAgIC8vTHVjLkJhc2UgYXBwbGllcyBmaXJzdCBcIixcIiAgICAvL2FyZyB0byB0aGUgaW5zdGFuY2VcIixcIlwiLFwiICAgIHZhciBjID0gbmV3IEMoe1wiLFwiICAgICAgICBhZGQ6IGZ1bmN0aW9uKGEsYixjKSB7XCIsXCIgICAgICAgICAgICByZXR1cm4gdGhpcy4kY2xhc3MucHJvdG90eXBlLmFkZC5jYWxsKHRoaXMsIGEsYikgKyBjO1wiLFwiICAgICAgICB9XCIsXCIgICAgfSk7XCIsXCJcIixcIiAgICBjLmFkZCgxLDIsMylcIixcIiAgICAmZ3Q7NlwiLFwiICAgIG5ldyBDKCkuYWRkKDEsMiwzKVwiLFwiICAgICZndDszXCIsXCIgKlwiLFwiICogT3IgaGF2ZSBhIHNpbXBsZSBnZW5lcmljIGNsb25lIG1ldGhvZCA6XCIsXCIgKlwiLFwiICAgIHZhciBDID0gTHVjLmRlZmluZSh7XCIsXCIgICAgICAgIGNsb25lOiBmdW5jdGlvbigpIHtcIixcIiAgICAgICAgICAgIHZhciBteU93blByb3BzID0ge307XCIsXCIgICAgICAgICAgICBMdWMuT2JqZWN0LmVhY2godGhpcywgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1wiLFwiICAgICAgICAgICAgICAgIG15T3duUHJvcHNba2V5XSA9IHZhbHVlO1wiLFwiICAgICAgICAgICAgfSk7XCIsXCJcIixcIiAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcy4kY2xhc3MobXlPd25Qcm9wcyk7XCIsXCIgICAgICAgIH1cIixcIiAgICB9KTtcIixcIlwiLFwiICAgIHZhciBjID0gbmV3IEMoe2E6MSxiOjIsYzozfSk7XCIsXCIgICAgYy5kID0gNDtcIixcIiAgICB2YXIgY2xvbmUgPSBjLmNsb25lKCk7XCIsXCJcIixcIiAgICBjbG9uZSA9PT0gY1wiLFwiICAgICZndDtmYWxzZVwiLFwiXCIsXCIgICAgY2xvbmUuYVwiLFwiICAgICZndDsxXCIsXCIgICAgY2xvbmUuYlwiLFwiICAgICZndDsyXCIsXCIgICAgY2xvbmUuY1wiLFwiICAgICZndDszXCIsXCIgICAgY2xvbmUuZFwiLFwiICAgICZndDs0XCIsXCIgKi9cIixcIlwiLFwiLyoqXCIsXCIgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbJHN1cGVyXSBJZiAkc3VwZXIgaXMgbm90IGZhbHNlIG9yIG51bGwgXCIsXCIgKiB0aGUgJHN1cGVyIHByb3BlcnR5IHdpbGwgYmUgYWRkZWQgdG8gZXZlcnkgaW5zdGFuY2Ugb2YgdGhlIGRlZmluZWQgY2xhc3MsXCIsXCIgKiAkc3VwZXIgaXMgdGhlIENvbnN0cnVjdG9yIHBhc3NlZCBpbiB3aXRoIHRoZSAkc3VwZXIgY29uZmlnIG9yIHRoZSB7QGxpbmsgTHVjLkNsYXNzRGVmaW5lciNkZWZhdWx0VHlwZSBkZWZhdWx0fVwiLFwiICogXCIsXCIgICAgdmFyIEMgPSBMdWMuZGVmaW5lKClcIixcIiAgICB2YXIgYyA9IG5ldyBDKClcIixcIiAgICAvL0x1Yy5CYXNlIGlzIHRoZSBkZWZhdWx0IFwiLFwiICAgIGMuJHN1cGVyID09PSBMdWMuQmFzZVwiLFwiICAgICZndDt0cnVlXCIsXCIgKi9cIixcIlwiLFwiLyoqXCIsXCIgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbJHN1cGVyY2xhc3NdIElmICRzdXBlciBpcyBkZWZpbmVkIGl0XCIsXCIgKiB3aWxsIGJlIHRoZSBwcm90b3R5cGUgb2YgJHN1cGVyLiAgSXQgY2FuIGJlIHVzZWQgdG8gY2FsbCBhIHBhcmVudCdzXCIsXCIgKiBtZXRob2RcIixcIiAqIFwiLFwiICAgIGZ1bmN0aW9uIE15Q29vbENsYXNzKCkge31cIixcIiAgICBNeUNvb2xDbGFzcy5wcm90b3R5cGUuYWRkTnVtcyA9IGZ1bmN0aW9uKGEsYikge1wiLFwiICAgICAgICByZXR1cm4gYSArIGI7XCIsXCIgICAgfVwiLFwiXCIsXCIgICAgdmFyIE15T3RoZXJDb29sQ2xhc3MgPSBMdWMuZGVmaW5lKHtcIixcIiAgICAgICAgJHN1cGVyOiBNeUNvb2xDbGFzcyxcIixcIiAgICAgICAgYWRkTnVtczogZnVuY3Rpb24oYSwgYiwgYykge1wiLFwiICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHN1cGVyY2xhc3MuYWRkTnVtcy5jYWxsKHRoaXMsIGEsIGIpICsgYztcIixcIiAgICAgICAgfVwiLFwiICAgIH0pXCIsXCJcIixcIiAgICB2YXIgbSA9IG5ldyBNeU90aGVyQ29vbENsYXNzKCk7XCIsXCIgICAgbS5hZGROdW1zKDEsMiwzKTtcIixcIiAgICAmZ3Q7NlwiLFwiICovXCIsXCJcIixcIi8qKlwiLFwiICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZ2V0U3RhdGljVmFsdWUgdGhpcyBtZXRob2RcIixcIiAqIHdpbGwgYmUgYWRkZWQgdG8gaW5zdGFuY2VzIHRoYXQgdXNlIHRoZSAkc3RhdGljc1wiLFwiICogY29uZmlnLlwiLFwiICpcIixcIiAqIFwiLFwiICogVGhpcyBzaG91bGQgYmUgdXNlZCBvdmVyIHRoaXMuJGNsYXNzLnN0YXRpY05hbWUgdG9cIixcIiAqIGdldCB0aGUgdmFsdWUgb2Ygc3RhdGljLiAgSWYgdGhlIGNsYXNzIGdldHMgaW5oZXJpdGVkXCIsXCIgKiBmcm9tLCB0aGlzLiRjbGFzcyB3aWxsIG5vdCBiZSB0aGUgc2FtZS4gIGdldFN0YXRpYyB2YWx1ZVwiLFwiICogZGVhbHMgd2l0aCB0aGlzIGlzc3VlLlwiLFwiICogXCIsXCIgICAgdmFyIEEgPSBMdWMuZGVmaW5lKHtcIixcIiAgICAgICAgJHN0YXRpY3M6IHtcIixcIiAgICAgICAgICAgIGE6IDFcIixcIiAgICAgICAgICAgIH0sXCIsXCIgICAgICAgIGdldEFCZXR0ZXI6IGZ1bmN0aW9uKCkge1wiLFwiICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhdGljVmFsdWUoJ2EnKTtcIixcIiAgICAgICAgfSxcIixcIiAgICAgICAgZ2V0QTogZnVuY3Rpb24oKSB7XCIsXCIgICAgICAgICAgICByZXR1cm4gdGhpcy4kY2xhc3MuYTtcIixcIiAgICAgICAgfVwiLFwiICAgIH0pO1wiLFwiXCIsXCIgICAgdmFyIEIgPSBMdWMuZGVmaW5lKHtcIixcIiAgICAgICAgJHN1cGVyOiBBLFwiLFwiICAgICAgICAkc3RhdGljczoge1wiLFwiICAgICAgICAgICAgYjogMixcIixcIiAgICAgICAgICAgIGM6IDNcIixcIiAgICAgICAgfVwiLFwiICAgIH0pO1wiLFwiXCIsXCIgICAgXCIsXCIgICAgdmFyIGIgPSBuZXcgQigpO1wiLFwiICAgIGIuZ2V0QSgpO1wiLFwiICAgICZndDt1bmRlZmluZWRcIixcIiAgICBiLmdldEFCZXR0ZXIoKTtcIixcIiAgICAmZ3Q7MVwiLFwiXCIsXCIgKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBzdGF0aWMgdmFsdWUgb2YgdGhlIGtleVwiLFwiICovXCIsXCJcIixcIiAgICBcIixcIi8qKlwiLFwiICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZ2V0Q29tcG9zaXRpb24gdGhpcyBtZXRob2Qgd2lsbCBiZVwiLFwiICogdG8gaW5zdGFuY2VzIHRoYXQgdXNlIHRoZSAkY29tcG9zaXRpb25zIGNvbmZpZ1wiLFwiICpcIixcIiAqIEBwYXJhbSAge1N0cmluZ30gbmFtZSB0aGUgZ2FtZSBvZiB0aGUgY29tcG9zaXRpb24gdG9cIixcIiAqIGdldC5cIixcIiAqL1wiLFwiXCIsXCJcIixcIi8qKlwiLFwiICogQGNmZyB7T2JqZWN0fSAkc3RhdGljcyAob3B0aW9uYWwpIEFkZCBzdGF0aWMgcHJvcGVydGllcyBvciBtZXRob2RzXCIsXCIgKiB0byB0aGUgY2xhc3MuICBUaGVzZSBwcm9wZXJ0aWVzL21ldGhvZHMgd2lsbCBub3QgYmUgYWJsZSB0byBiZVwiLFwiICogZGlyZWN0bHkgbW9kaWZpZWQgYnkgdGhlIGluc3RhbmNlIHNvIHRoZXkgYXJlIGdvb2QgZm9yIGRlZmluaW5nIGRlZmF1bHRcIixcIiAqIGNvbmZpZ3MuICBcIixcIiAqXCIsXCIgICAgdmFyIEMgPSBMdWMuZGVmaW5lKHtcIixcIiAgICAgICAgJHN0YXRpY3M6IHtcIixcIiAgICAgICAgICAgIG51bWJlcjogMVwiLFwiICAgICAgICB9XCIsXCIgICAgfSk7XCIsXCJcIixcIiAgICB2YXIgYyA9IG5ldyBDKCk7XCIsXCIgICAgYy5udW1iZXJcIixcIiAgICAmZ3Q7dW5kZWZpbmVkXCIsXCIgICAgQy5udW1iZXJcIixcIiAgICAmZ3Q7MVwiLFwiICAgIFwiLFwiICpcIixcIiAqIEJhZCB0aGluZ3MgY2FuIGhhcHBlbiBpZiBub24gcHJpbWl0aXZlcyBhcmUgcGxhY2VkIG9uIHRoZSBcIixcIiAqIHByb3RvdHlwZSBhbmQgaW5zdGFuY2Ugc2hhcmluZyBpcyBub3Qgd2FudGVkLiAgVXNpbmcgc3RhdGljc1wiLFwiICogcHJldmVudCBzdWJjbGFzc2VzIGFuZCBpbnN0YW5jZXMgZnJvbSB1bmtub3dpbmdseSBtb2RpZnlpbmdcIixcIiAqIGFsbCBpbnN0YW5jZXMuXCIsXCIgKiBcIixcIiAgICB2YXIgQyA9IEx1Yy5kZWZpbmUoe1wiLFwiICAgICAgICBjZmc6IHtcIixcIiAgICAgICAgICAgIGE6IDFcIixcIiAgICAgICAgfVwiLFwiICAgIH0pO1wiLFwiXCIsXCIgICAgdmFyIGMgPSBuZXcgQygpO1wiLFwiICAgIGMuY2ZnLmFcIixcIiAgICAmZ3Q7MVwiLFwiICAgIGMuY2ZnLmEgPSA1XCIsXCIgICAgbmV3IEMoKS5jZmcuYVwiLFwiICAgICZndDs1XCIsXCIgKlwiLFwiICovXCIsXCJcIixcIi8qKlwiLFwiICogQHByb3BlcnR5IHtGdW5jdGlvbn0gWyRzdXBlcmNsYXNzXSBJZiAkc3VwZXIgaXMgZGVmaW5lZCBpdFwiLFwiICogd2lsbCB0aGUgcHJvdG90eXBlIG9mICRzdXBlci4gIEl0IGNhbiBiZSB1c2VkIHRvIGNhbGwgcGFyZW50J3NcIixcIiAqIG1ldGhvZFwiLFwiICogXCIsXCIgICAgZnVuY3Rpb24gTXlDb29sQ2xhc3MoKSB7fVwiLFwiICAgIE15Q29vbENsYXNzLnByb3RvdHlwZS5hZGROdW1zID0gZnVuY3Rpb24oYSxiKSB7XCIsXCIgICAgICAgIHJldHVybiBhICsgYjtcIixcIiAgICB9XCIsXCJcIixcIiAgICB2YXIgTXlPdGhlckNvb2xDbGFzcyA9IEx1Yy5kZWZpbmUoe1wiLFwiICAgICAgICAkc3VwZXI6IE15Q29vbENsYXNzLFwiLFwiICAgICAgICBhZGROdW1zOiBmdW5jdGlvbihhLCBiLCBjKSB7XCIsXCIgICAgICAgICAgICByZXR1cm4gdGhpcy4kc3VwZXJjbGFzcy5hZGROdW1zLmNhbGwodGhpcywgYSwgYikgKyBjO1wiLFwiICAgICAgICB9XCIsXCIgICAgfSlcIixcIlwiLFwiICAgIHZhciBtID0gbmV3IE15T3RoZXJDb29sQ2xhc3MoKTtcIixcIiAgICBtLmFkZE51bXMoMSwyLDMpO1wiLFwiICAgICZndDs2XCIsXCIgKi9cIixcIlwiLFwiLyoqXCIsXCIgKiBAY2ZnIHtPYmplY3QvQ29uc3RydWN0b3IvT2JqZWN0W10vQ29uc3RydWN0b3JbXX0gJG1peGlucyAob3B0aW9uYWwpICBNaXhpbnMgYXJlIGEgd2F5IHRvIGFkZCBmdW5jdGlvbmFsaXR5XCIsXCIgKiB0byBhIGNsYXNzIHRoYXQgc2hvdWxkIG5vdCBhZGQgc3RhdGUgdG8gdGhlIGluc3RhbmNlIHVua25vd2luZ2x5LiAgTWl4aW5zIGNhbiBiZSBlaXRoZXIgb2JqZWN0cyBvciBDb25zdHJ1Y3RvcnMuXCIsXCIgKlwiLFwiICAgIGZ1bmN0aW9uIExvZ2dlcigpIHt9XCIsXCIgICAgTG9nZ2VyLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbigpIHtcIixcIiAgICAgICAgY29uc29sZS5sb2coYXJndW1lbnRzKVwiLFwiICAgIH1cIixcIlwiLFwiICAgIHZhciBDID0gTHVjLmRlZmluZSh7XCIsXCIgICAgICAgICRtaXhpbnM6IFtMb2dnZXIsIHtcIixcIiAgICAgICAgICAgIHdhcm46IGZ1bmN0aW9uKCkge1wiLFwiICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybihhcmd1bWVudHMpXCIsXCIgICAgICAgICAgICB9XCIsXCIgICAgICAgIH1dXCIsXCIgICAgfSk7XCIsXCJcIixcIiAgICB2YXIgYyA9IG5ldyBDKCk7XCIsXCJcIixcIiAgICBjLmxvZygxLDIpXCIsXCIgICAgJmd0O1sxLDJdXCIsXCJcIixcIiAgICBjLndhcm4oMyw0KVwiLFwiICAgICZndDtbMyw0XVwiLFwiICpcIixcIiAqL1wiLFwiLyoqXCIsXCIgKiBAY2ZnIHtDb25zdHJ1Y3Rvcn0gJHN1cGVyIChvcHRpb25hbCkgIHN1cGVyIGZvciB0aGUgZGVmaW5pbmcgY2xhc3MuICBCeSBMdWMuQmFzZVwiLFwiICogaXMgdGhlIGRlZmF1bHQgaWYgc3VwZXIgaXMgbm90IHBhc3NlZCBpbi4gIFRvIGRlZmluZSBhIGNsYXNzIHdpdGhvdXQgYSBzdXBlcmNsYXNzXCIsXCIgKiB5b3UgY2FuIHBhc3MgaW4gZmFsc2Ugb3IgbnVsbC5cIixcIiAqXCIsXCIgICAgIGZ1bmN0aW9uIENvdW50ZXIoKSB7XCIsXCIgICAgICAgIHRoaXMuY291bnQgPSAwO1wiLFwiICAgICB9O1wiLFwiXCIsXCIgICAgIENvdW50ZXIucHJvdG90eXBlID0ge1wiLFwiICAgICAgICBnZXRDb3VudDogZnVuY3Rpb24oKSB7XCIsXCIgICAgICAgICAgICByZXR1cm4gdGhpcy5jb3VudDtcIixcIiAgICAgICAgfSxcIixcIiAgICAgICAgaW5jcmVhc2VDb3VudDogZnVuY3Rpb24oKSB7XCIsXCIgICAgICAgICAgICB0aGlzLmNvdW50Kys7XCIsXCIgICAgICAgIH1cIixcIiAgICAgfVwiLFwiXCIsXCIgICAgIHZhciBDID0gTHVjLmRlZmluZSh7XCIsXCIgICAgICAgICRzdXBlcjpDb3VudGVyXCIsXCIgICAgfSk7XCIsXCJcIixcIiAgICB2YXIgYyA9IG5ldyBDKClcIixcIlwiLFwiICAgIGMgaW5zdGFuY2VvZiBDb3VudGVyXCIsXCIgICAgJmd0O3RydWVcIixcIiAgICBjLmluY3JlYXNlQ291bnQoKTtcIixcIiAgICBjLmdldENvdW50KCk7XCIsXCIgICAgJmd0OzFcIixcIiAgICBjLmNvdW50XCIsXCIgICAgJmd0OzFcIixcIiAqXCIsXCIgKiBDaGVjayBvdXQgTHVjLkJhc2UgdG8gc2VlIHdoeSB3ZSBoYXZlIGl0IGFzIHRoZSBkZWZhdWx0LlwiLFwiICogXCIsXCIgICAgdmFyIEIgPSBMdWMuZGVmaW5lKHtcIixcIiAgICAgICAgYW1JQUx1Y0Jhc2U6IGZ1bmN0aW9uKCkge1wiLFwiICAgICAgICAgICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBMdWMuQmFzZVwiLFwiICAgICAgICB9XCIsXCIgICAgfSlcIixcIiAgICB2YXIgYiA9IG5ldyBCKCk7XCIsXCIgICAgYi5hbUlBTHVjQmFzZSgpO1wiLFwiICAgICZndDt0cnVlXCIsXCIgKlwiLFwiICogXCIsXCIgKi9cIixcIlwiLFwiXCIsXCJcIixcIi8qKlwiLFwiICogQGNmZyB7T2JqZWN0L09iamVjdFtdfSAkY29tcG9zaXRpb25zIChvcHRpb25hbCkgY29uZmlnIG9iamVjdHMgZm9yIFwiLFwiICogTHVjLkNvbXBvc2l0aW9uLiAgQ29tcG9zaXRpb25zIGFyZSBhIGdyZWF0IHdheSB0byBhZGQgYmVoYXZpb3IgdG8gYSBjbGFzc1wiLFwiICogd2l0aG91dCBleHRlbmRpbmcgaXQuICBBICRtaXhpbiBjYW4gb2ZmZXIgc2ltaWxhciBmdW5jdGlvbmFsaXR5IGJ1dCBzaG91bGRcIixcIiAqIGJlIHN0YXRlbGVzcy4gIEEgQ29uc3RydWN0b3IgYW5kIGEgbmFtZSBhcmUgbmVlZGVkIGZvciB0aGUgY29uZmlnIG9iamVjdFwiLFwiICogVGhlIG1ldGhvZHMgcHJvcGVydHkgaXMgb3B0aW9uYWwgaGVyZSBidXQgaXQgaXMgc2F5aW5nIHRha2UgYWxsIG9mIFwiLFwiICogTHVjLkV2ZW50RW1pdHRlcidzIGluc3RhbmNlIG1ldGhvZHMgYW5kIG1ha2UgdGhlbSBpbnN0YW5jZSBtZXRob2RzIGZvciBDLlwiLFwiICogWW91IGNhbiBjaGVjayBvdXQgYWxsIG9mIHRoZSBjb25maWcgb3B0aW9ucyBieSBsb29raW5nIGF0IEx1Yy5Db21wb3NpdGlvbi5cIixcIiAqIFwiLFwiICAgICAgICB2YXIgQyA9IEx1Yy5kZWZpbmUoe1wiLFwiICAgICAgICAgICAgJGNvbXBvc2l0aW9uczoge1wiLFwiICAgICAgICAgICAgICAgIENvbnN0cnVjdG9yOiBMdWMuRXZlbnRFbWl0dGVyLFwiLFwiICAgICAgICAgICAgICAgIG5hbWU6ICdlbWl0dGVyJyxcIixcIiAgICAgICAgICAgICAgICBtZXRob2RzOiAnYWxsTWV0aG9kcydcIixcIiAgICAgICAgICAgIH1cIixcIiAgICAgICAgfSk7XCIsXCJcIixcIiAgICAgICAgdmFyIGMgPSBuZXcgQygpO1wiLFwiXCIsXCIgICAgICAgIGMub24oJ2hleScsIGZ1bmN0aW9uKCkge1wiLFwiICAgICAgICAgICAgY29uc29sZS5sb2coYXJndW1lbnRzKTtcIixcIiAgICAgICAgfSk7XCIsXCJcIixcIiAgICAgICAgYy5lbWl0KCdoZXknLCAxLDIsMywgJ2EnKTtcIixcIiAgICAgICAgJmd0O1sxLCAyLCAzLCBcXFwiYVxcXCJdXCIsXCIgICAgICAgIGMgaW5zdGFuY2VvZiBMdWMuRXZlbnRFbWl0dGVyXCIsXCIgICAgICAgICZndDtmYWxzZVwiLFwiICAgICAgICBjLl9ldmVudHNcIixcIiAgICAgICAgJmd0O3VuZGVmaW5lZFwiLFwiICpcIixcIiAqIEx1Yy5FdmVudEVtaXR0ZXIgaXMgcHJlZmVycmVkIGFzIGEgY29tcG9zaXRpb24gb3ZlciBhIG1peGluIGJlY2F1c2VcIixcIiAqIGl0IGFkZHMgYSBzdGF0ZSBcXFwiX2V2ZW50c1xcXCIgdG8gdGhlIHRoaXMgaW5zdGFuY2Ugd2hlbiBvbiBpcyBjYWxsZWQuICBJdFwiLFwiICogYWxzbyBzaG91bGRuJ3QgaGF2ZSB0byBrbm93IHRoYXQgaXQgbWF5IGJlIGluc3RhbnRpYXRlZCBhbG9uZSBvciBtaXhlZCBpbnRvIGNsYXNzZXNcIixcIiAqIHNvIHRoZSBpbml0aW5nIG9mIHN0YXRlIGlzIG5vdCBkb25lIGluIHRoZSBjb25zdHJ1Y3RvciBsaWtlIGl0IHByb2JhYmx5IHNob3VsZC5cIixcIiAqIEl0IGlzIG5vdCB0ZXJyaWJsZSBwcmFjdGljZSBieSBhbnkgbWVhbnMgYnV0IGl0IGlzIG5vdCBnb29kIHRvIGhhdmUgYSBzdGFuZGFsb25lIGNsYXNzXCIsXCIgKiB0aGF0IGtub3dzIHRoYXQgaXQgbWF5IGJlIG1peGluLiAgRXZlbiB3b3JzZSB0aGFuIHRoYXQgd291bGQgYmUgYSBtaXhpbiB0aGF0IG5lZWRzXCIsXCIgKiB0byBiZSBpbml0ZWQgYnkgdGhlIGRlZmluaW5nIGNsYXNzLiAgRW5jYXBzdWxhdGluZyBsb2dpYyBpbiBhIGNsYXNzXCIsXCIgKiBhbmQgdXNpbmcgaXQgYW55d2hlcmUgc2VhbWxlc3NseSBpcyB3aGVyZSBjb21wb3NpdGlvbnMgc2hpbmUuIEx1YyBjb21lcyB3aXRoIHR3byBjb21tb24gXCIsXCIgKiB7QGxpbmsgTHVjI2NvbXBvc2l0aW9uRW51bXMgZW51bXN9IHRoYXQgd2UgZXhwZWN0IHdpbGwgYmUgdXNlZCBvZnRlbi5cIixcIiAqIFwiLFwiICogJmx0O2JyJmd0O1wiLFwiICogSGVyZSBpcyBhbiBleGFtcGxlIG9mIGEgc2ltcGxlIGNvbXBvc2l0aW9uIHNlZSBob3cgdGhlIGZ1bmN0aW9uYWxpdHkgXCIsXCIgKiBpcyBhZGRlZCBidXQgd2UgYXJlIG5vdCBpbmhlcml0aW5nIGFuZCB0aGlzLmNvdW50IGlzXCIsXCIgKiB1bmRlZmluZWQuXCIsXCIgKlwiLFwiICAgICAgICAgZnVuY3Rpb24gQ291bnRlcigpIHtcIixcIiAgICAgICAgICAgIHRoaXMuY291bnQgPSAwO1wiLFwiICAgICAgICAgfTtcIixcIlwiLFwiICAgICAgICAgQ291bnRlci5wcm90b3R5cGUgPSB7XCIsXCIgICAgICAgICAgICBnZXRDb3VudDogZnVuY3Rpb24oKSB7XCIsXCIgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY291bnQ7XCIsXCIgICAgICAgICAgICB9LFwiLFwiICAgICAgICAgICAgaW5jcmVhc2VDb3VudDogZnVuY3Rpb24oKSB7XCIsXCIgICAgICAgICAgICAgICAgdGhpcy5jb3VudCsrO1wiLFwiICAgICAgICAgICAgfVwiLFwiICAgICAgICAgfVwiLFwiXCIsXCIgICAgICAgICB2YXIgQyA9IEx1Yy5kZWZpbmUoe1wiLFwiICAgICAgICAgICAgICAgICRjb21wb3NpdGlvbnM6IHtcIixcIiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2NvdW50ZXInLFwiLFwiICAgICAgICAgICAgICAgICAgICBDb25zdHJ1Y3RvcjogQ291bnRlcixcIixcIiAgICAgICAgICAgICAgICAgICAgbWV0aG9kczogJ2FsbE1ldGhvZHMnXCIsXCIgICAgICAgICAgICAgICAgfVwiLFwiICAgICAgICB9KTtcIixcIlwiLFwiICAgICAgICB2YXIgYyA9IG5ldyBDKClcIixcIlwiLFwiICAgICAgICBjLmluY3JlYXNlQ291bnQoKTtcIixcIiAgICAgICAgYy5pbmNyZWFzZUNvdW50KCk7XCIsXCIgICAgICAgIGMuaW5jcmVhc2VDb3VudCgpO1wiLFwiICAgICAgICBjLmdldENvdW50KCk7XCIsXCIgICAgICAgICZndDszXCIsXCIgICAgICAgIGMuY291bnRcIixcIiAgICAgICAgJmd0O3VuZGVmaW5lZFwiLFwiICpcIixcIiAqIEx1YyBjb21lcyB3aXRoIHR3byBkZWZhdWx0IGNvbXBvc2l0aW9uIG9iamVjdHMgTHVjLmNvbXBvc2l0aW9uRW51bXMuUGx1Z2luTWFuYWdlclwiLFwiICogYW5kIEx1Yy5jb21wb3NpdGlvbkVudW1zLkV2ZW50RW1pdHRlci5cIixcIiAqIFwiLFwiICogSGVyZSBpcyB0aGUgcGx1Z2luIG1hbmFnZXIgZW51bSwga2VlcCBpbiBtaW5kIHRoYXQgdGhpc1wiLFwiICogZnVuY3Rpb25hbGl0eSBjYW4gYmUgYWRkZWQgdG8gYW55IGNsYXNzLCBub3QganVzdCBvbmVzIGRlZmluZWQgd2l0aCBcIixcIiAqIEx1Yy5kZWZpbmUuICBDaGVjayBvdXQgTHVjLlBsdWdpbk1hbmFnZXIgdG8gc2VlIGFsbCBvZiB0aGUgcHVibGljIFwiLFwiICogbWV0aG9kcyB0aGF0IGdldHMgYWRkZWQgdG8gdGhlIGRlZmluZWQgaW5zdGFuY2UuXCIsXCIgICBcIixcIiAgICBmdW5jdGlvbiBNeUNsYXNzKCkge307XCIsXCJcIixcIiAgICBmdW5jdGlvbiBNeVBsdWdpbigpIHtcIixcIiAgICAgICAgdGhpcy5teUNvb2xOYW1lID0gJ2Nvbyc7XCIsXCJcIixcIiAgICAgICAgdGhpcy5pbml0ID0gZnVuY3Rpb24oKSB7XCIsXCIgICAgICAgICAgICBjb25zb2xlLmxvZygnaW0gZ2V0dGluZyBpbml0dGVkJyk7XCIsXCIgICAgICAgIH1cIixcIiAgICAgICAgdGhpcy5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XCIsXCIgICAgICAgICAgICBjb25zb2xlLmxvZygnTXlQbHVnaW4gaW5zdGFuY2UgYmVpbmcgZGVzdHJveWVkJylcIixcIiAgICAgICAgfVwiLFwiICAgIH1cIixcIlwiLFwiICAgIHZhciBDID0gTHVjLmRlZmluZSh7XCIsXCIgICAgICAgICRzdXBlcjogTXlDbGFzcyxcIixcIiAgICAgICAgJGNvbXBvc2l0aW9uczogTHVjLmNvbXBvc2l0aW9uRW51bXMuUGx1Z2luTWFuYWdlclwiLFwiICAgIH0pO1wiLFwiXCIsXCIgICAgdmFyIGMgPSBuZXcgQyh7XCIsXCIgICAgICAgIHBsdWdpbnM6IFt7XCIsXCIgICAgICAgICAgICAgICAgQ29uc3RydWN0b3I6IE15UGx1Z2luLFwiLFwiICAgICAgICAgICAgICAgIG15Q29vbE5hbWU6ICdjb28nXCIsXCIgICAgICAgICAgICB9XCIsXCIgICAgICAgIF1cIixcIiAgICB9KTtcIixcIiAgICAmZ3Q7aW0gZ2V0dGluZyBpbml0dGVkXCIsXCIgICAgYyBpbnN0YW5jZW9mIE15Q2xhc3NcIixcIiAgICAmZ3Q7dHJ1ZVwiLFwiXCIsXCIgICAgYy5nZXRQbHVnaW4oe215Q29vbE5hbWU6ICdjb28nfSkgaW5zdGFuY2VvZiBNeVBsdWdpblwiLFwiICAgICZndDsgdHJ1ZVwiLFwiXCIsXCJcIixcIiAgICBjLmEgPSAxO1wiLFwiICAgIC8vVGhpcyB3aWxsIGJlIHRoZSBkZWZhdWx0IEx1Yy5QbHVnaW5cIixcIiAgICBjLmFkZFBsdWdpbih7XCIsXCIgICAgICAgIGluaXQ6IGZ1bmN0aW9uKG93bmVyKSB7XCIsXCIgICAgICAgICAgICBjb25zb2xlLmxvZyhvd25lci5hKVwiLFwiICAgICAgICB9LFwiLFwiICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcIixcIiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdJbSBnZXR0aW5nIGRlc3Ryb3llZCcpXCIsXCIgICAgICAgIH1cIixcIiAgICB9KTtcIixcIlwiLFwiICAgICZndDsxXCIsXCJcIixcIiAgICBjLmRlc3Ryb3lBbGxQbHVnaW5zKCk7XCIsXCIgICAgJmd0O015UGx1Z2luIGluc3RhbmNlIGJlaW5nIGRlc3Ryb3llZFwiLFwiICAgICZndDtJJ20gZ2V0dGluZyBkZXN0cm95ZWQuXCIsXCJcIixcIiAgICBjLmdldFBsdWdpbih7bXlDb29sTmFtZTogJ2Nvbyd9KVwiLFwiICAgICZndDtmYWxzZVwiLFwiICpcIixcIiAqIFlvdSBjYW4gc2VlIHRoYXQgaXQgY2FuIGFkZCBwbHVnaW4gbGlrZSBiZWhhdmlvciB0byBhbnkgZGVmaW5pbmdcIixcIiAqIGNsYXNzIHdpdGggTHVjLlBsdWdpbk1hbmdlciB3aGljaCBpcyBsZXNzIHRoYW4gNzUgU0xPQy5cIixcIiAqL1wiXTtcbiIsIi8qIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGJ5IEpTQ292ZXJhZ2UgLSBkbyBub3QgZWRpdCAqL1xuaWYgKHR5cGVvZiBfJGpzY292ZXJhZ2UgPT09ICd1bmRlZmluZWQnKSBfJGpzY292ZXJhZ2UgPSB7fTtcbmlmICghIF8kanNjb3ZlcmFnZVsnY2xhc3MvcGx1Z2luTWFuYWdlci5qcyddKSB7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvcGx1Z2luTWFuYWdlci5qcyddID0gW107XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvcGx1Z2luTWFuYWdlci5qcyddWzFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9wbHVnaW5NYW5hZ2VyLmpzJ11bOV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL3BsdWdpbk1hbmFnZXIuanMnXVsxMF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL3BsdWdpbk1hbmFnZXIuanMnXVs2OF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL3BsdWdpbk1hbmFnZXIuanMnXVs3OF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL3BsdWdpbk1hbmFnZXIuanMnXVs3OV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL3BsdWdpbk1hbmFnZXIuanMnXVs4MF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL3BsdWdpbk1hbmFnZXIuanMnXVs4N10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL3BsdWdpbk1hbmFnZXIuanMnXVs4OF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL3BsdWdpbk1hbmFnZXIuanMnXVs5Nl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL3BsdWdpbk1hbmFnZXIuanMnXVs5N10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL3BsdWdpbk1hbmFnZXIuanMnXVsxMDddID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9wbHVnaW5NYW5hZ2VyLmpzJ11bMTA5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvcGx1Z2luTWFuYWdlci5qcyddWzExMV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL3BsdWdpbk1hbmFnZXIuanMnXVsxMTNdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9wbHVnaW5NYW5hZ2VyLmpzJ11bMTIwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvcGx1Z2luTWFuYWdlci5qcyddWzEyMl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL3BsdWdpbk1hbmFnZXIuanMnXVsxMjldID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9wbHVnaW5NYW5hZ2VyLmpzJ11bMTM0XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvcGx1Z2luTWFuYWdlci5qcyddWzE0MV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL3BsdWdpbk1hbmFnZXIuanMnXVsxNDJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9wbHVnaW5NYW5hZ2VyLmpzJ11bMTUxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvcGx1Z2luTWFuYWdlci5qcyddWzE1Ml0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL3BsdWdpbk1hbmFnZXIuanMnXVsxNTVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9wbHVnaW5NYW5hZ2VyLmpzJ11bMTU5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvcGx1Z2luTWFuYWdlci5qcyddWzE2MF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL3BsdWdpbk1hbmFnZXIuanMnXVsxNzFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9wbHVnaW5NYW5hZ2VyLmpzJ11bMTczXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvcGx1Z2luTWFuYWdlci5qcyddWzE3NF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL3BsdWdpbk1hbmFnZXIuanMnXVsxNzVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9wbHVnaW5NYW5hZ2VyLmpzJ11bMTc4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvcGx1Z2luTWFuYWdlci5qcyddWzE5M10gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL3BsdWdpbk1hbmFnZXIuanMnXVsxOTRdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9wbHVnaW5NYW5hZ2VyLmpzJ11bMTk2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvcGx1Z2luTWFuYWdlci5qcyddWzIwMF0gPSAwO1xufVxuXyRqc2NvdmVyYWdlWydjbGFzcy9wbHVnaW5NYW5hZ2VyLmpzJ11bMV0rKztcbnZhciBQbHVnaW4gPSByZXF1aXJlKFwiLi9wbHVnaW5cIiksIGlzID0gcmVxdWlyZShcIi4uL2lzXCIpLCBvYmogPSByZXF1aXJlKFwiLi4vb2JqZWN0XCIpLCBhcnIgPSByZXF1aXJlKFwiLi4vYXJyYXlcIiksIGFFYWNoID0gYXJyLmVhY2gsIG1peCA9IG9iai5taXgsIGFwcGx5ID0gb2JqLmFwcGx5O1xuXyRqc2NvdmVyYWdlWydjbGFzcy9wbHVnaW5NYW5hZ2VyLmpzJ11bOV0rKztcbmZ1bmN0aW9uIFBsdWdpbk1hbmFnZXIoY29uZmlnKSB7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvcGx1Z2luTWFuYWdlci5qcyddWzEwXSsrO1xuICB0aGlzLl9pbml0KGNvbmZpZyk7XG59XG5fJGpzY292ZXJhZ2VbJ2NsYXNzL3BsdWdpbk1hbmFnZXIuanMnXVs2OF0rKztcblBsdWdpbk1hbmFnZXIucHJvdG90eXBlID0ge2RlZmF1bHRQbHVnaW46IFBsdWdpbiwgX2luaXQ6IChmdW5jdGlvbiAoaW5zdGFuY2VWYWx1ZXMpIHtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9wbHVnaW5NYW5hZ2VyLmpzJ11bNzhdKys7XG4gIGFwcGx5KHRoaXMsIGluc3RhbmNlVmFsdWVzKTtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9wbHVnaW5NYW5hZ2VyLmpzJ11bNzldKys7XG4gIHRoaXMucGx1Z2lucyA9IFtdO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL3BsdWdpbk1hbmFnZXIuanMnXVs4MF0rKztcbiAgdGhpcy5fY3JlYXRlUGx1Z2lucygpO1xufSksIF9jcmVhdGVQbHVnaW5zOiAoZnVuY3Rpb24gKCkge1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL3BsdWdpbk1hbmFnZXIuanMnXVs4N10rKztcbiAgYUVhY2godGhpcy5fZ2V0UGx1Z2luQ29uZmlnRnJvbUluc3RhbmNlKCksIChmdW5jdGlvbiAocGx1Z2luQ29uZmlnKSB7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvcGx1Z2luTWFuYWdlci5qcyddWzg4XSsrO1xuICB0aGlzLmFkZFBsdWdpbihwbHVnaW5Db25maWcpO1xufSksIHRoaXMpO1xufSksIF9nZXRQbHVnaW5Db25maWdGcm9tSW5zdGFuY2U6IChmdW5jdGlvbiAoKSB7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvcGx1Z2luTWFuYWdlci5qcyddWzk2XSsrO1xuICB2YXIgY29uZmlnID0gdGhpcy5pbnN0YW5jZUFyZ3NbMF0gfHwge307XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvcGx1Z2luTWFuYWdlci5qcyddWzk3XSsrO1xuICByZXR1cm4gY29uZmlnLnBsdWdpbnM7XG59KSwgYWRkUGx1Z2luOiAoZnVuY3Rpb24gKHBsdWdpbkNvbmZpZykge1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL3BsdWdpbk1hbmFnZXIuanMnXVsxMDddKys7XG4gIHZhciBwbHVnaW5JbnN0YW5jZSA9IHRoaXMuX2NyZWF0ZVBsdWdpbihwbHVnaW5Db25maWcpO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL3BsdWdpbk1hbmFnZXIuanMnXVsxMDldKys7XG4gIHRoaXMuX2luaXRQbHVnaW4ocGx1Z2luSW5zdGFuY2UpO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL3BsdWdpbk1hbmFnZXIuanMnXVsxMTFdKys7XG4gIHRoaXMucGx1Z2lucy5wdXNoKHBsdWdpbkluc3RhbmNlKTtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9wbHVnaW5NYW5hZ2VyLmpzJ11bMTEzXSsrO1xuICByZXR1cm4gcGx1Z2luSW5zdGFuY2U7XG59KSwgX2NyZWF0ZVBsdWdpbjogKGZ1bmN0aW9uIChjb25maWcpIHtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9wbHVnaW5NYW5hZ2VyLmpzJ11bMTIwXSsrO1xuICBjb25maWcub3duZXIgPSB0aGlzLmluc3RhbmNlO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL3BsdWdpbk1hbmFnZXIuanMnXVsxMjJdKys7XG4gIGlmIChjb25maWcuQ29uc3RydWN0b3IpIHtcbiAgICBfJGpzY292ZXJhZ2VbJ2NsYXNzL3BsdWdpbk1hbmFnZXIuanMnXVsxMjldKys7XG4gICAgcmV0dXJuIG5ldyBjb25maWcuQ29uc3RydWN0b3IoYXBwbHkoY29uZmlnLCB7Q29uc3RydWN0b3I6IHVuZGVmaW5lZH0pKTtcbiAgfVxuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL3BsdWdpbk1hbmFnZXIuanMnXVsxMzRdKys7XG4gIHJldHVybiBuZXcgdGhpcy5kZWZhdWx0UGx1Z2luKGNvbmZpZyk7XG59KSwgX2luaXRQbHVnaW46IChmdW5jdGlvbiAocGx1Z2luKSB7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvcGx1Z2luTWFuYWdlci5qcyddWzE0MV0rKztcbiAgaWYgKGlzLmlzRnVuY3Rpb24ocGx1Z2luLmluaXQpKSB7XG4gICAgXyRqc2NvdmVyYWdlWydjbGFzcy9wbHVnaW5NYW5hZ2VyLmpzJ11bMTQyXSsrO1xuICAgIHBsdWdpbi5pbml0KHRoaXMuaW5zdGFuY2UpO1xuICB9XG59KSwgZGVzdHJveUFsbFBsdWdpbnM6IChmdW5jdGlvbiAoKSB7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvcGx1Z2luTWFuYWdlci5qcyddWzE1MV0rKztcbiAgdGhpcy5wbHVnaW5zLmZvckVhY2goKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9wbHVnaW5NYW5hZ2VyLmpzJ11bMTUyXSsrO1xuICB0aGlzLl9kZXN0cm95UGx1Z2luKHBsdWdpbik7XG59KSwgdGhpcyk7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvcGx1Z2luTWFuYWdlci5qcyddWzE1NV0rKztcbiAgdGhpcy5wbHVnaW5zID0gW107XG59KSwgX2Rlc3Ryb3lQbHVnaW46IChmdW5jdGlvbiAocGx1Z2luKSB7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvcGx1Z2luTWFuYWdlci5qcyddWzE1OV0rKztcbiAgaWYgKGlzLmlzRnVuY3Rpb24ocGx1Z2luLmRlc3Ryb3kpKSB7XG4gICAgXyRqc2NvdmVyYWdlWydjbGFzcy9wbHVnaW5NYW5hZ2VyLmpzJ11bMTYwXSsrO1xuICAgIHBsdWdpbi5kZXN0cm95KHRoaXMuaW5zdGFuY2UpO1xuICB9XG59KSwgZGVzdHJveVBsdWdpbjogKGZ1bmN0aW9uIChvYmopIHtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9wbHVnaW5NYW5hZ2VyLmpzJ11bMTcxXSsrO1xuICB2YXIgcGx1Z2luID0gdGhpcy5nZXRQbHVnaW4ob2JqKTtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9wbHVnaW5NYW5hZ2VyLmpzJ11bMTczXSsrO1xuICBpZiAocGx1Z2luKSB7XG4gICAgXyRqc2NvdmVyYWdlWydjbGFzcy9wbHVnaW5NYW5hZ2VyLmpzJ11bMTc0XSsrO1xuICAgIHRoaXMuX2Rlc3Ryb3lQbHVnaW4ocGx1Z2luKTtcbiAgICBfJGpzY292ZXJhZ2VbJ2NsYXNzL3BsdWdpbk1hbmFnZXIuanMnXVsxNzVdKys7XG4gICAgYXJyLnJlbW92ZUZpcnN0KHRoaXMucGx1Z2lucywgcGx1Z2luLCB7dHlwZTogXCJzdHJpY3RcIn0pO1xuICB9XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvcGx1Z2luTWFuYWdlci5qcyddWzE3OF0rKztcbiAgcmV0dXJuIHBsdWdpbjtcbn0pLCBnZXRQbHVnaW46IChmdW5jdGlvbiAob2JqKSB7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvcGx1Z2luTWFuYWdlci5qcyddWzE5M10rKztcbiAgaWYgKGlzLmlzRnVuY3Rpb24ob2JqKSkge1xuICAgIF8kanNjb3ZlcmFnZVsnY2xhc3MvcGx1Z2luTWFuYWdlci5qcyddWzE5NF0rKztcbiAgICByZXR1cm4gYXJyLmZpbmRGaXJzdEluc3RhbmNlT2YodGhpcy5wbHVnaW5zLCBvYmopO1xuICB9XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvcGx1Z2luTWFuYWdlci5qcyddWzE5Nl0rKztcbiAgcmV0dXJuIGFyci5maW5kRmlyc3QodGhpcy5wbHVnaW5zLCBvYmosIHt0eXBlOiBcImxvb3NlXCJ9KTtcbn0pfTtcbl8kanNjb3ZlcmFnZVsnY2xhc3MvcGx1Z2luTWFuYWdlci5qcyddWzIwMF0rKztcbm1vZHVsZS5leHBvcnRzID0gUGx1Z2luTWFuYWdlcjtcbl8kanNjb3ZlcmFnZVsnY2xhc3MvcGx1Z2luTWFuYWdlci5qcyddLnNvdXJjZSA9IFtcInZhciBQbHVnaW4gPSByZXF1aXJlKCcuL3BsdWdpbicpLFwiLFwiICAgIGlzID0gcmVxdWlyZSgnLi4vaXMnKSxcIixcIiAgICBvYmogPSByZXF1aXJlKCcuLi9vYmplY3QnKSxcIixcIiAgICBhcnIgPSByZXF1aXJlKCcuLi9hcnJheScpLFwiLFwiICAgIGFFYWNoID0gYXJyLmVhY2gsXCIsXCIgICAgbWl4ID0gb2JqLm1peCxcIixcIiAgICBhcHBseSA9IG9iai5hcHBseTtcIixcIlwiLFwiZnVuY3Rpb24gUGx1Z2luTWFuYWdlcihjb25maWcpIHtcIixcIiAgICB0aGlzLl9pbml0KGNvbmZpZyk7XCIsXCJ9XCIsXCJcIixcIi8qKlwiLFwiICogQHByb3RlY3RlZFwiLFwiICogQGNsYXNzIEx1Yy5QbHVnaW5NYW5hZ2VyXCIsXCIgKiBUaGlzIGNsYXNzIGlzIHVzZWQgYnkgTHVjLmNvbXBvc2l0aW9uRW51bXMjUGx1Z2luTWFuYWdlciB0byBhZGQgaXRzIGZ1bmN0aW9uYWxpdHkgXCIsXCIgKiB0byBhbnkgY2xhc3MuICAgQnkge0BsaW5rIEx1Yy5jb21wb3NpdGlvbkVudW1zI1BsdWdpbk1hbmFnZXIgZGVmYXVsdH0gaXQgYWRkc1wiLFwiICogYWxsIG9mIHRoZXNlIHB1YmxpYyBtZXRob2RzIHRvIHRoZSBpbnN0YW5jZS5UaGlzIGNsYXNzIGlzIGRlc2lnbmVkIHRvIHdvcmsgYXMgYSBjb21wb3NpdGlvbiwgXCIsXCIgKiBpdCBpcyBleHBvc2VkIGFzIG5vdCBwcml2YXRlIHNvIGl0IGNhbiBiZSBleHRlbmRlZCBpZiBuZWVkZWQuICAgQ2hlY2sgXFxcInByb3RlY3RlZFxcXCIgd2hpY2hcIixcIiAqIGlzIGEgcGFydCBvZiB0aGUgU2hvdyB2IGRyb3Bkb3duIG9uIHRoZSByaWdodCB0byBzZWUgdGhlIHByb3RlY3RlZCBtZXRob2RzLlwiLFwiICpcIixcIiAgICBmdW5jdGlvbiBNeVBsdWdpbigpIHtcIixcIiAgICAgICAgdGhpcy5teUNvb2xOYW1lID0gJ2Nvbyc7XCIsXCJcIixcIiAgICAgICAgdGhpcy5pbml0ID0gZnVuY3Rpb24oKSB7XCIsXCIgICAgICAgICAgICBjb25zb2xlLmxvZygnaW0gZ2V0dGluZyBpbml0dGVkJyk7XCIsXCIgICAgICAgIH1cIixcIiAgICAgICAgdGhpcy5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XCIsXCIgICAgICAgICAgICBjb25zb2xlLmxvZygnTXlQbHVnaW4gaW5zdGFuY2UgYmVpbmcgZGVzdHJveWVkJylcIixcIiAgICAgICAgfVwiLFwiICAgIH1cIixcIlwiLFwiICAgIHZhciBDID0gTHVjLmRlZmluZSh7XCIsXCIgICAgICAgICRjb21wb3NpdGlvbnM6IEx1Yy5jb21wb3NpdGlvbkVudW1zLlBsdWdpbk1hbmFnZXJcIixcIiAgICB9KTtcIixcIlwiLFwiICAgIHZhciBjID0gbmV3IEMoe1wiLFwiICAgICAgICBwbHVnaW5zOiBbe1wiLFwiICAgICAgICAgICAgICAgIENvbnN0cnVjdG9yOiBNeVBsdWdpbixcIixcIiAgICAgICAgICAgICAgICBteUNvb2xOYW1lOiAnY29vJ1wiLFwiICAgICAgICAgICAgfVwiLFwiICAgICAgICBdXCIsXCIgICAgfSk7XCIsXCJcIixcIiAgICAmZ3Q7aW0gZ2V0dGluZyBpbml0dGVkXCIsXCJcIixcIiAgICB2YXIgcGx1Z0luc3RhbmNlID0gYy5hZGRQbHVnaW4oe1wiLFwiICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcIixcIiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdJbSBnZXR0aW5nIGRlc3Ryb3llZCcpXCIsXCIgICAgICAgIH1cIixcIiAgICB9KTtcIixcIlwiLFwiICAgIGMuZ2V0UGx1Z2luKEx1Yy5QbHVnaW4pXCIsXCIgICAgJmd0OyBQbHVnaW4ge2Rlc3Ryb3k6IGZ1bmN0aW9uLCBvd25lcjogTXlDbGFzcywgaW5pdDogZnVuY3Rpb24sIGRlc3Ryb3k6IGZ1bmN0aW9ufVwiLFwiXCIsXCIgICAgYy5nZXRQbHVnaW4oTXlQbHVnaW4pXCIsXCIgICAgJmd0OyBNeVBsdWdpbiB7bXlDb29sTmFtZTogXFxcImNvb1xcXCIsIGluaXQ6IGZ1bmN0aW9uLCBkZXN0cm95OiBmdW5jdGlvbn1cIixcIlwiLFwiICAgIGMuZGVzdHJveUFsbFBsdWdpbnMoKVwiLFwiXCIsXCIgICAgJmd0O015UGx1Z2luIGluc3RhbmNlIGJlaW5nIGRlc3Ryb3llZFwiLFwiICAgICZndDtJbSBnZXR0aW5nIGRlc3Ryb3llZFwiLFwiXCIsXCIgICAgYy5nZXRQbHVnaW4oTXlQbHVnaW4pXCIsXCIgICAgJmd0O2ZhbHNlXCIsXCJcIixcIiAqL1wiLFwiUGx1Z2luTWFuYWdlci5wcm90b3R5cGUgPSB7XCIsXCIgICAvKipcIixcIiAgICAqIEBjZmcge0NvbnN0cnVjdG9yfSBkZWZhdWx0UGx1Z2luXCIsXCIgICAgKi9cIixcIiAgICBkZWZhdWx0UGx1Z2luOiBQbHVnaW4sXCIsXCJcIixcIiAgICAvKipcIixcIiAgICAgKiBAcHJvdGVjdGVkXCIsXCIgICAgICovXCIsXCIgICAgX2luaXQ6IGZ1bmN0aW9uKGluc3RhbmNlVmFsdWVzKSB7XCIsXCIgICAgICAgIGFwcGx5KHRoaXMsIGluc3RhbmNlVmFsdWVzKTtcIixcIiAgICAgICAgdGhpcy5wbHVnaW5zID0gW107XCIsXCIgICAgICAgIHRoaXMuX2NyZWF0ZVBsdWdpbnMoKTtcIixcIiAgICB9LFwiLFwiXCIsXCIgICAgLyoqXCIsXCIgICAgICogQHByb3RlY3RlZFwiLFwiICAgICAqL1wiLFwiICAgIF9jcmVhdGVQbHVnaW5zOiBmdW5jdGlvbigpIHtcIixcIiAgICAgICAgYUVhY2godGhpcy5fZ2V0UGx1Z2luQ29uZmlnRnJvbUluc3RhbmNlKCksIGZ1bmN0aW9uKHBsdWdpbkNvbmZpZykge1wiLFwiICAgICAgICAgICAgdGhpcy5hZGRQbHVnaW4ocGx1Z2luQ29uZmlnKTtcIixcIiAgICAgICAgfSwgdGhpcyk7XCIsXCIgICAgfSxcIixcIlwiLFwiICAgIC8qKlwiLFwiICAgICAqIEBwcm90ZWN0ZWRcIixcIiAgICAgKi9cIixcIiAgICBfZ2V0UGx1Z2luQ29uZmlnRnJvbUluc3RhbmNlOiBmdW5jdGlvbigpIHtcIixcIiAgICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuaW5zdGFuY2VBcmdzWzBdIHx8IHt9O1wiLFwiICAgICAgICByZXR1cm4gY29uZmlnLnBsdWdpbnM7XCIsXCIgICAgfSxcIixcIlwiLFwiICAgIC8qKlwiLFwiICAgICAqIEFkZCBhIHBsdWdpbiB0byB0aGUgaW5zdGFuY2UgYW5kIGluaXQgdGhlIFwiLFwiICAgICAqIHBsdWdpbi5cIixcIiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHBsdWdpbkNvbmZpZ1wiLFwiICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIGNyZWF0ZWQgcGx1Z2luIGluc3RhbmNlXCIsXCIgICAgICovXCIsXCIgICAgYWRkUGx1Z2luOiBmdW5jdGlvbihwbHVnaW5Db25maWcpIHtcIixcIiAgICAgICAgdmFyIHBsdWdpbkluc3RhbmNlID0gdGhpcy5fY3JlYXRlUGx1Z2luKHBsdWdpbkNvbmZpZyk7XCIsXCJcIixcIiAgICAgICAgdGhpcy5faW5pdFBsdWdpbihwbHVnaW5JbnN0YW5jZSk7XCIsXCJcIixcIiAgICAgICAgdGhpcy5wbHVnaW5zLnB1c2gocGx1Z2luSW5zdGFuY2UpO1wiLFwiXCIsXCIgICAgICAgIHJldHVybiBwbHVnaW5JbnN0YW5jZTtcIixcIiAgICB9LFwiLFwiXCIsXCIgICAgLyoqXCIsXCIgICAgICogQHByb3RlY3RlZFwiLFwiICAgICAqL1wiLFwiICAgIF9jcmVhdGVQbHVnaW46IGZ1bmN0aW9uKGNvbmZpZykge1wiLFwiICAgICAgICBjb25maWcub3duZXIgPSB0aGlzLmluc3RhbmNlO1wiLFwiXCIsXCIgICAgICAgIGlmIChjb25maWcuQ29uc3RydWN0b3IpIHtcIixcIiAgICAgICAgICAgIC8vY2FsbCB0aGUgY29uZmlnZWQgQ29uc3RydWN0b3Igd2l0aCB0aGUgXCIsXCIgICAgICAgICAgICAvL3Bhc3NlZCBpbiBjb25maWcgYnV0IHRha2Ugb2ZmIHRoZSBDb25zdHJ1Y3RvclwiLFwiICAgICAgICAgICAgLy9jb25maWcuXCIsXCIgICAgICAgICAgICAgXCIsXCIgICAgICAgICAgICAvL1RoZSBwbHVnaW4gQ29uc3RydWN0b3IgXCIsXCIgICAgICAgICAgICAvL3Nob3VsZCBub3QgbmVlZCB0byBrbm93IGFib3V0IGl0c2VsZlwiLFwiICAgICAgICAgICAgcmV0dXJuIG5ldyBjb25maWcuQ29uc3RydWN0b3IoYXBwbHkoY29uZmlnLCB7XCIsXCIgICAgICAgICAgICAgICAgQ29uc3RydWN0b3I6IHVuZGVmaW5lZFwiLFwiICAgICAgICAgICAgfSkpO1wiLFwiICAgICAgICB9XCIsXCJcIixcIiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmRlZmF1bHRQbHVnaW4oY29uZmlnKTtcIixcIiAgICB9LFwiLFwiXCIsXCIgICAgLyoqXCIsXCIgICAgICogQHByb3RlY3RlZFwiLFwiICAgICAqL1wiLFwiICAgIF9pbml0UGx1Z2luOiBmdW5jdGlvbihwbHVnaW4pIHtcIixcIiAgICAgICAgaWYgKGlzLmlzRnVuY3Rpb24ocGx1Z2luLmluaXQpKSB7XCIsXCIgICAgICAgICAgICBwbHVnaW4uaW5pdCh0aGlzLmluc3RhbmNlKTtcIixcIiAgICAgICAgfVwiLFwiICAgIH0sXCIsXCJcIixcIiAgICAvKipcIixcIiAgICAgKiBDYWxsIGRlc3Ryb3kgb24gYWxsIG9mIHRoZSBwbHVnaW5zXCIsXCIgICAgICogYW5kIHJlbW92ZSB0aGVtLlwiLFwiICAgICAqL1wiLFwiICAgIGRlc3Ryb3lBbGxQbHVnaW5zOiBmdW5jdGlvbigpIHtcIixcIiAgICAgICAgdGhpcy5wbHVnaW5zLmZvckVhY2goZnVuY3Rpb24ocGx1Z2luKSB7XCIsXCIgICAgICAgICAgICB0aGlzLl9kZXN0cm95UGx1Z2luKHBsdWdpbik7XCIsXCIgICAgICAgIH0sIHRoaXMpO1wiLFwiXCIsXCIgICAgICAgIHRoaXMucGx1Z2lucyA9IFtdO1wiLFwiICAgIH0sXCIsXCJcIixcIiAgICBfZGVzdHJveVBsdWdpbjogZnVuY3Rpb24ocGx1Z2luKSB7XCIsXCIgICAgICAgIGlmIChpcy5pc0Z1bmN0aW9uKHBsdWdpbi5kZXN0cm95KSkge1wiLFwiICAgICAgICAgICAgcGx1Z2luLmRlc3Ryb3kodGhpcy5pbnN0YW5jZSk7XCIsXCIgICAgICAgIH1cIixcIiAgICB9LFwiLFwiXCIsXCIgICAgLyoqXCIsXCIgICAgICogUmVtb3ZlIHRoZSBwbHVnaW4gYW5kIGlmIGZvdW5kIGRlc3Ryb3kgaXQuXCIsXCIgICAgICogQHBhcmFtICB7T2JqZWN0L0NvbnN0cnVjdG9yfSBvYmplY3QgdG8gdXNlIHRvIG1hdGNoIFwiLFwiICAgICAqIHRoZSBwbHVnaW4gdG8gcmVtb3ZlLlwiLFwiICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIGRlc3Ryb3llZCBwbHVnaW4uXCIsXCIgICAgICovXCIsXCIgICAgZGVzdHJveVBsdWdpbjogZnVuY3Rpb24ob2JqKSB7XCIsXCIgICAgICAgIHZhciBwbHVnaW4gPSB0aGlzLmdldFBsdWdpbihvYmopO1wiLFwiXCIsXCIgICAgICAgIGlmKHBsdWdpbikge1wiLFwiICAgICAgICAgICAgdGhpcy5fZGVzdHJveVBsdWdpbihwbHVnaW4pO1wiLFwiICAgICAgICAgICAgYXJyLnJlbW92ZUZpcnN0KHRoaXMucGx1Z2lucywgcGx1Z2luLCB7dHlwZTogJ3N0cmljdCd9KTtcIixcIiAgICAgICAgfVwiLFwiXCIsXCIgICAgICAgIHJldHVybiBwbHVnaW47XCIsXCIgICAgfSxcIixcIlwiLFwiICAgIC8qKlwiLFwiICAgICAqIEdldCBhIHBsdWdpbiBpbnN0YW5jZS4gIEEgQ29uc3RydWN0b3Igb3IgYW4gb2JqZWN0IGNhbiBiZSB1c2VkXCIsXCIgICAgICogdG8gZmluZCBhIHBsdWdpbi5cIixcIiAgICAgKlwiLFwiICAgICAgICAgIGMuYWRkUGx1Z2luKHthOjF9KVwiLFwiICAgICAgICAgIGMuZ2V0UGx1Z2luKHthOjF9KVwiLFwiICAgICAgICAgICZndDtMdWMuUGx1Z2luKHthOjF9KVwiLFwiXCIsXCIgICAgICogQHBhcmFtICB7T2JqZWN0fSBvYmogXCIsXCIgICAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgcGx1Z2luIGluc3RhbmNlIGlmIGZvdW5kLlwiLFwiICAgICAqL1wiLFwiICAgIGdldFBsdWdpbjogZnVuY3Rpb24ob2JqKSB7XCIsXCIgICAgICAgIGlmIChpcy5pc0Z1bmN0aW9uKG9iaikpIHtcIixcIiAgICAgICAgICAgIHJldHVybiBhcnIuZmluZEZpcnN0SW5zdGFuY2VPZih0aGlzLnBsdWdpbnMsIG9iaik7XCIsXCIgICAgICAgIH1cIixcIiAgICAgICAgcmV0dXJuIGFyci5maW5kRmlyc3QodGhpcy5wbHVnaW5zLCBvYmosIHt0eXBlOiAnbG9vc2UnfSk7XCIsXCIgICAgfVwiLFwifTtcIixcIlwiLFwibW9kdWxlLmV4cG9ydHMgPSBQbHVnaW5NYW5hZ2VyO1wiXTtcbiIsIi8qIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGJ5IEpTQ292ZXJhZ2UgLSBkbyBub3QgZWRpdCAqL1xuaWYgKHR5cGVvZiBfJGpzY292ZXJhZ2UgPT09ICd1bmRlZmluZWQnKSBfJGpzY292ZXJhZ2UgPSB7fTtcbmlmICghIF8kanNjb3ZlcmFnZVsnY2xhc3MvY29tcG9zaXRpb25FbnVtcy5qcyddKSB7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvY29tcG9zaXRpb25FbnVtcy5qcyddID0gW107XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvY29tcG9zaXRpb25FbnVtcy5qcyddWzFdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9jb21wb3NpdGlvbkVudW1zLmpzJ11bMjldID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9jb21wb3NpdGlvbkVudW1zLmpzJ11bMzldID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9jb21wb3NpdGlvbkVudW1zLmpzJ11bNDRdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9jb21wb3NpdGlvbkVudW1zLmpzJ11bNDldID0gMDtcbn1cbl8kanNjb3ZlcmFnZVsnY2xhc3MvY29tcG9zaXRpb25FbnVtcy5qcyddWzFdKys7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcIi4uL2V2ZW50cy9ldmVudEVtaXR0ZXJcIiksIFBsdWdpbk1hbmFnZXIgPSByZXF1aXJlKFwiLi9wbHVnaW5NYW5hZ2VyXCIpO1xuXyRqc2NvdmVyYWdlWydjbGFzcy9jb21wb3NpdGlvbkVudW1zLmpzJ11bMjldKys7XG5tb2R1bGUuZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSB7Q29uc3RydWN0b3I6IEV2ZW50RW1pdHRlciwgbmFtZTogXCJlbWl0dGVyXCIsIG1ldGhvZHM6IFwiYWxsTWV0aG9kc1wifTtcbl8kanNjb3ZlcmFnZVsnY2xhc3MvY29tcG9zaXRpb25FbnVtcy5qcyddWzM5XSsrO1xubW9kdWxlLmV4cG9ydHMuUGx1Z2luTWFuYWdlciA9IHtuYW1lOiBcInBsdWdpbnNcIiwgaW5pdEFmdGVyOiB0cnVlLCBDb25zdHJ1Y3RvcjogUGx1Z2luTWFuYWdlciwgY3JlYXRlOiAoZnVuY3Rpb24gKCkge1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2NvbXBvc2l0aW9uRW51bXMuanMnXVs0NF0rKztcbiAgdmFyIG1hbmFnZXIgPSBuZXcgdGhpcy5Db25zdHJ1Y3Rvcih7aW5zdGFuY2U6IHRoaXMuaW5zdGFuY2UsIGluc3RhbmNlQXJnczogdGhpcy5pbnN0YW5jZUFyZ3N9KTtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9jb21wb3NpdGlvbkVudW1zLmpzJ11bNDldKys7XG4gIHJldHVybiBtYW5hZ2VyO1xufSksIGlnbm9yZU1ldGhvZHM6IFwiZGVmYXVsdFBsdWdpblwiLCBtZXRob2RzOiBcInB1YmxpY01ldGhvZHNcIn07XG5fJGpzY292ZXJhZ2VbJ2NsYXNzL2NvbXBvc2l0aW9uRW51bXMuanMnXS5zb3VyY2UgPSBbXCJ2YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi4vZXZlbnRzL2V2ZW50RW1pdHRlcicpLFwiLFwiICAgIFBsdWdpbk1hbmFnZXIgPSByZXF1aXJlKCcuL3BsdWdpbk1hbmFnZXInKTtcIixcIlwiLFwiLyoqXCIsXCIgKiBAY2xhc3MgTHVjLmNvbXBvc2l0aW9uRW51bXNcIixcIiAqIENvbXBvc2l0aW9uIGVudW1zIGFyZSBqdXN0IGNvbW1vbiBjb25maWcgb2JqZWN0cyBmb3IgTHVjLkNvbXBvc2l0aW9uLlwiLFwiICogSGVyZSBpcyBhbiBleGFtcGxlIG9mIGEgY29tcG9zaXRpb24gdGhhdCB1c2VzIEV2ZW50RW1pdHRlciBidXQgb25seVwiLFwiICogcHV0cyB0aGUgZW1pdCBtZXRob2Qgb24gdGhlIHByb3RvdHlwZS5cIixcIiAqXCIsXCIgICAgdmFyIEMgPSBMdWMuZGVmaW5lKHtcIixcIiAgICAgICAgJGNvbXBvc2l0aW9uczoge1wiLFwiICAgICAgICAgICAgZGVmYXVsdHM6IEx1Yy5jb21wb3NpdGlvbkVudW1zLkV2ZW50RW1pdHRlcixcIixcIiAgICAgICAgICAgIG1ldGhvZHM6IFsnZW1pdCddXCIsXCIgICAgICAgIH1cIixcIiAgICB9KTtcIixcIlwiLFwiICAgIHZhciBjID0gbmV3IEMoKTtcIixcIlwiLFwiICAgIHR5cGVvZiBjLmVtaXRcIixcIiAgICAmZ3Q7XFxcImZ1bmN0aW9uXFxcIlwiLFwiICAgIHR5cGVvZiBjLm9uXCIsXCIgICAgXFxcInVuZGVmaW5lZFxcXCJcIixcIiAqIFwiLFwiICovXCIsXCJcIixcIi8qKlwiLFwiICogQHByb3BlcnR5IHtPYmplY3R9IEV2ZW50RW1pdHRlclwiLFwiICovXCIsXCJtb2R1bGUuZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSB7XCIsXCIgICAgQ29uc3RydWN0b3I6IEV2ZW50RW1pdHRlcixcIixcIiAgICBuYW1lOiAnZW1pdHRlcicsXCIsXCIgICAgbWV0aG9kczogJ2FsbE1ldGhvZHMnXCIsXCJ9O1wiLFwiXCIsXCJcIixcIi8qKlwiLFwiICogQHByb3BlcnR5IHtPYmplY3R9IFBsdWdpbk1hbmFnZXJcIixcIiAqL1wiLFwibW9kdWxlLmV4cG9ydHMuUGx1Z2luTWFuYWdlciA9IHtcIixcIiAgICBuYW1lOiAncGx1Z2lucycsXCIsXCIgICAgaW5pdEFmdGVyOiB0cnVlLFwiLFwiICAgIENvbnN0cnVjdG9yOiBQbHVnaW5NYW5hZ2VyLFwiLFwiICAgIGNyZWF0ZTogZnVuY3Rpb24oKSB7XCIsXCIgICAgICAgIHZhciBtYW5hZ2VyID0gbmV3IHRoaXMuQ29uc3RydWN0b3Ioe1wiLFwiICAgICAgICAgICAgaW5zdGFuY2U6IHRoaXMuaW5zdGFuY2UsXCIsXCIgICAgICAgICAgICBpbnN0YW5jZUFyZ3M6IHRoaXMuaW5zdGFuY2VBcmdzXCIsXCIgICAgICAgIH0pO1wiLFwiXCIsXCIgICAgICAgIHJldHVybiBtYW5hZ2VyO1wiLFwiICAgIH0sXCIsXCIgICAgaWdub3JlTWV0aG9kczogJ2RlZmF1bHRQbHVnaW4nLFwiLFwiICAgIG1ldGhvZHM6ICdwdWJsaWNNZXRob2RzJ1wiLFwifTtcIl07XG4iLCIoZnVuY3Rpb24ocHJvY2Vzcyl7aWYgKCFwcm9jZXNzLkV2ZW50RW1pdHRlcikgcHJvY2Vzcy5FdmVudEVtaXR0ZXIgPSBmdW5jdGlvbiAoKSB7fTtcblxudmFyIEV2ZW50RW1pdHRlciA9IGV4cG9ydHMuRXZlbnRFbWl0dGVyID0gcHJvY2Vzcy5FdmVudEVtaXR0ZXI7XG52YXIgaXNBcnJheSA9IHR5cGVvZiBBcnJheS5pc0FycmF5ID09PSAnZnVuY3Rpb24nXG4gICAgPyBBcnJheS5pc0FycmF5XG4gICAgOiBmdW5jdGlvbiAoeHMpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSdcbiAgICB9XG47XG5mdW5jdGlvbiBpbmRleE9mICh4cywgeCkge1xuICAgIGlmICh4cy5pbmRleE9mKSByZXR1cm4geHMuaW5kZXhPZih4KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh4ID09PSB4c1tpXSkgcmV0dXJuIGk7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhblxuLy8gMTAgbGlzdGVuZXJzIGFyZSBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoXG4vLyBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbi8vXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIXRoaXMuX2V2ZW50cykgdGhpcy5fZXZlbnRzID0ge307XG4gIHRoaXMuX2V2ZW50cy5tYXhMaXN0ZW5lcnMgPSBuO1xufTtcblxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzLmVycm9yIHx8XG4gICAgICAgIChpc0FycmF5KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKVxuICAgIHtcbiAgICAgIGlmIChhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBhcmd1bWVudHNbMV07IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmNhdWdodCwgdW5zcGVjaWZpZWQgJ2Vycm9yJyBldmVudC5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpIHJldHVybiBmYWxzZTtcbiAgdmFyIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGlmICghaGFuZGxlcikgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PSAnZnVuY3Rpb24nKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG5cbiAgfSBlbHNlIGlmIChpc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gICAgdmFyIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8vIEV2ZW50RW1pdHRlciBpcyBkZWZpbmVkIGluIHNyYy9ub2RlX2V2ZW50cy5jY1xuLy8gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0KCkgaXMgYWxzbyBkZWZpbmVkIHRoZXJlLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICgnZnVuY3Rpb24nICE9PSB0eXBlb2YgbGlzdGVuZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2FkZExpc3RlbmVyIG9ubHkgdGFrZXMgaW5zdGFuY2VzIG9mIEZ1bmN0aW9uJyk7XG4gIH1cblxuICBpZiAoIXRoaXMuX2V2ZW50cykgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PSBcIm5ld0xpc3RlbmVyc1wiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lcnNcIi5cbiAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSkge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkodGhpcy5fZXZlbnRzW3R5cGVdKSkge1xuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICAgIHZhciBtO1xuICAgICAgaWYgKHRoaXMuX2V2ZW50cy5tYXhMaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtID0gdGhpcy5fZXZlbnRzLm1heExpc3RlbmVycztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG0gPSBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgICAgfVxuXG4gICAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICB9IGVsc2Uge1xuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5vbih0eXBlLCBmdW5jdGlvbiBnKCkge1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG4gICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCdmdW5jdGlvbicgIT09IHR5cGVvZiBsaXN0ZW5lcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncmVtb3ZlTGlzdGVuZXIgb25seSB0YWtlcyBpbnN0YW5jZXMgb2YgRnVuY3Rpb24nKTtcbiAgfVxuXG4gIC8vIGRvZXMgbm90IHVzZSBsaXN0ZW5lcnMoKSwgc28gbm8gc2lkZSBlZmZlY3Qgb2YgY3JlYXRpbmcgX2V2ZW50c1t0eXBlXVxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKSByZXR1cm4gdGhpcztcblxuICB2YXIgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNBcnJheShsaXN0KSkge1xuICAgIHZhciBpID0gaW5kZXhPZihsaXN0LCBsaXN0ZW5lcik7XG4gICAgaWYgKGkgPCAwKSByZXR1cm4gdGhpcztcbiAgICBsaXN0LnNwbGljZShpLCAxKTtcbiAgICBpZiAobGlzdC5sZW5ndGggPT0gMClcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIH0gZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdID09PSBsaXN0ZW5lcikge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZG9lcyBub3QgdXNlIGxpc3RlbmVycygpLCBzbyBubyBzaWRlIGVmZmVjdCBvZiBjcmVhdGluZyBfZXZlbnRzW3R5cGVdXG4gIGlmICh0eXBlICYmIHRoaXMuX2V2ZW50cyAmJiB0aGlzLl9ldmVudHNbdHlwZV0pIHRoaXMuX2V2ZW50c1t0eXBlXSA9IG51bGw7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmICghdGhpcy5fZXZlbnRzKSB0aGlzLl9ldmVudHMgPSB7fTtcbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFtdO1xuICBpZiAoIWlzQXJyYXkodGhpcy5fZXZlbnRzW3R5cGVdKSkge1xuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICB9XG4gIHJldHVybiB0aGlzLl9ldmVudHNbdHlwZV07XG59O1xuXG59KShyZXF1aXJlKFwiX19icm93c2VyaWZ5X3Byb2Nlc3NcIikpIiwiLyoqXG4gKiBAY2xhc3MgTHVjLk9iamVjdFxuICogUGFja2FnZSBmb3IgT2JqZWN0IG1ldGhvZHMuICBMdWMuT2JqZWN0LmFwcGx5IGFuZCBMdWMuT2JqZWN0LmVhY2hcbiAqIGFyZSB1c2VkIHZlcnkgb2Z0ZW4uICBtaXggYW5kIGFwcGx5IGFyZSBhbGlhc2VkIHRvIEx1Yy5hcHBseSBhbmQgTHVjLm1peC5cbiAqL1xuXG4vKipcbiAqIEFwcGx5IHRoZSBwcm9wZXJ0aWVzIGZyb20gZnJvbU9iamVjdCB0byB0aGUgdG9PYmplY3QuICBmcm9tT2JqZWN0IHdpbGxcbiAqIG92ZXJ3cml0ZSBhbnkgc2hhcmVkIGtleXMuICBJdCBjYW4gYWxzbyBiZSB1c2VkIGFzIGEgc2ltcGxlIHNoYWxsb3cgY2xvbmUuXG4gKiBcbiAgICB2YXIgdG8gPSB7YToxLCBjOjF9LCBmcm9tID0ge2E6MiwgYjoyfVxuICAgIEx1Yy5PYmplY3QuYXBwbHkodG8sIGZyb20pXG4gICAgPk9iamVjdCB7YTogMiwgYzogMSwgYjogMn1cbiAgICB0byA9PT0gdG9cbiAgICA+dHJ1ZVxuICAgIHZhciBjbG9uZSA9IEx1Yy5PYmplY3QuYXBwbHkoe30sIGZyb20pXG4gICAgPnVuZGVmaW5lZFxuICAgIGNsb25lXG4gICAgPk9iamVjdCB7YTogMiwgYjogMn1cbiAgICBjbG9uZSA9PT0gZnJvbVxuICAgID5mYWxzZVxuICpcbiAqIE5vIG51bGwgY2hlY2tzIGFyZSBuZWVkZWQuXG4gICAgXG4gICAgTHVjLmFwcGx5KHVuZGVmaW5lZCwge2E6MX0pXG4gICAgPnthOjF9XG4gICAgTHVjLmFwcGx5KHthOiAxfSlcbiAgICA+e2E6MX1cblxuICpcbiAqIFxuICogQHBhcmFtICB7T2JqZWN0fSBbdG9PYmplY3RdIE9iamVjdCB0byBwdXQgdGhlIHByb3BlcnRpZXMgZnJvbU9iamVjdCBvbi5cbiAqIEBwYXJhbSAge09iamVjdH0gW2Zyb21PYmplY3RdIE9iamVjdCB0byBwdXQgdGhlIHByb3BlcnRpZXMgb24gdGhlIHRvT2JqZWN0XG4gKiBAcmV0dXJuIHtPYmplY3R9IHRoZSB0b09iamVjdFxuICovXG5leHBvcnRzLmFwcGx5ID0gZnVuY3Rpb24odG9PYmplY3QsIGZyb21PYmplY3QpIHtcbiAgICB2YXIgdG8gPSB0b09iamVjdCB8fCB7fSxcbiAgICAgICAgZnJvbSA9IGZyb21PYmplY3QgfHwge30sXG4gICAgICAgIHByb3A7XG5cbiAgICBmb3IgKHByb3AgaW4gZnJvbSkge1xuICAgICAgICBpZiAoZnJvbS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgdG9bcHJvcF0gPSBmcm9tW3Byb3BdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRvO1xufTtcblxuLyoqXG4gKiBTaW1pbGFyIHRvIEx1Yy5PYmplY3QuYXBwbHkgZXhjZXB0IHRoYXQgdGhlIGZyb21PYmplY3Qgd2lsbCBcbiAqIE5PVCBvdmVyd3JpdGUgdGhlIGtleXMgb2YgdGhlIHRvT2JqZWN0IGlmIHRoZXkgYXJlIGRlZmluZWQuXG4gKlxuICAgIEx1Yy5taXgoe2E6MSxiOjJ9LCB7YTozLGI6NCxjOjV9KVxuICAgID57YTogMSwgYjogMiwgYzogNX1cblxuICogTm8gbnVsbCBjaGVja3MgYXJlIG5lZWRlZC5cbiAgICBcbiAgICBMdWMubWl4KHVuZGVmaW5lZCwge2E6MX0pXG4gICAgPnthOjF9XG4gICAgTHVjLm1peCh7YTogMX0pXG4gICAgPnthOjF9XG4gICAgXG4gKlxuXG4gKiBAcGFyYW0gIHtPYmplY3R9IFt0b09iamVjdF0gT2JqZWN0IHRvIHB1dCB0aGUgcHJvcGVydGllcyBmcm9tT2JqZWN0IG9uLlxuICogQHBhcmFtICB7T2JqZWN0fSBbZnJvbU9iamVjdF0gZnJvbU9iamVjdCBPYmplY3QgdG8gcHV0IHRoZSBwcm9wZXJ0aWVzIG9uIHRoZSB0b09iamVjdFxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgdG9PYmplY3RcbiAqL1xuZXhwb3J0cy5taXggPSBmdW5jdGlvbih0b09iamVjdCwgZnJvbU9iamVjdCkge1xuICAgIHZhciB0byA9IHRvT2JqZWN0IHx8IHt9LFxuICAgICAgICBmcm9tID0gZnJvbU9iamVjdCB8fCB7fSxcbiAgICAgICAgcHJvcDtcblxuICAgIGZvciAocHJvcCBpbiBmcm9tKSB7XG4gICAgICAgIGlmIChmcm9tLmhhc093blByb3BlcnR5KHByb3ApICYmIHRvW3Byb3BdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRvW3Byb3BdID0gZnJvbVtwcm9wXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0bztcbn07XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGFuIG9iamVjdHMgcHJvcGVydGllc1xuICogYXMga2V5IHZhbHVlIFwicGFpcnNcIiB3aXRoIHRoZSBwYXNzZWQgaW4gZnVuY3Rpb24uXG4gKiBcbiAgICB2YXIgdGhpc0FyZyA9IHt2YWw6J2MnfTtcbiAgICBMdWMuT2JqZWN0LmVhY2goe1xuICAgICAgICB1OiAnTCdcbiAgICB9LCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKHZhbHVlICsga2V5ICsgdGhpcy52YWwpXG4gICAgfSwgdGhpc0FyZylcbiAgICBcbiAgICA+THVjIFxuIFxuICogQHBhcmFtICB7T2JqZWN0fSAgIG9iaiAgdGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXJcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmbiAgIHRoZSBmdW5jdGlvbiB0byBjYWxsXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGZuLmtleSAgIHRoZSBvYmplY3Qga2V5XG4gKiBAcGFyYW0gIHtPYmplY3R9IGZuLnZhbHVlICAgdGhlIG9iamVjdCB2YWx1ZVxuICogQHBhcmFtICB7T2JqZWN0fSAgIFt0aGlzQXJnXSBcbiAqIEBwYXJhbSB7T2JqZWN0fSAgW2NvbmZpZ11cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gIGNvbmZpZy5vd25Qcm9wZXJ0aWVzIHNldCB0byBmYWxzZVxuICogdG8gaXRlcmF0ZSBvdmVyIGFsbCBvZiB0aGUgb2JqZWN0cyBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gKi9cbmV4cG9ydHMuZWFjaCA9IGZ1bmN0aW9uKG9iaiwgZm4sIHRoaXNBcmcsIGNvbmZpZykge1xuICAgIHZhciBrZXksIHZhbHVlLFxuICAgICAgICBhbGxQcm9wZXJ0aWVzID0gY29uZmlnICYmIGNvbmZpZy5vd25Qcm9wZXJ0aWVzID09PSBmYWxzZTtcblxuICAgIGlmIChhbGxQcm9wZXJ0aWVzKSB7XG4gICAgICAgIGZvciAoa2V5IGluIG9iaikge1xuICAgICAgICAgICAgZm4uY2FsbCh0aGlzQXJnLCBrZXksIG9ialtrZXldKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoa2V5IGluIG9iaikge1xuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgZm4uY2FsbCh0aGlzQXJnLCBrZXksIG9ialtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogVGFrZSBhbiBhcnJheSBvZiBzdHJpbmdzIGFuZCBhbiBhcnJheS9hcmd1bWVudHMgb2ZcbiAqIHZhbHVlcyBhbmQgcmV0dXJuIGFuIG9iamVjdCBvZiBrZXkgdmFsdWUgcGFpcnNcbiAqIGJhc2VkIG9mZiBlYWNoIGFycmF5cyBpbmRleC4gIEl0IGlzIHVzZWZ1bCBmb3IgdGFraW5nXG4gKiBhIGxvbmcgbGlzdCBvZiBhcmd1bWVudHMgYW5kIGNyZWF0aW5nIGFuIG9iamVjdCB0aGF0IGNhblxuICogYmUgcGFzc2VkIHRvIG90aGVyIG1ldGhvZHMuXG4gKiBcbiAgICBmdW5jdGlvbiBsb25nQXJncyhhLGIsYyxkLGUsZikge1xuICAgICAgICByZXR1cm4gTHVjLk9iamVjdC50b09iamVjdChbJ2EnLCdiJywgJ2MnLCAnZCcsICdlJywgJ2YnXSwgYXJndW1lbnRzKVxuICAgIH1cblxuICAgIGxvbmdBcmdzKDEsMiwzLDQsNSw2LDcsOCw5KVxuXG4gICAgPk9iamVjdCB7YTogMSwgYjogMiwgYzogMywgZDogNCwgZTogNeKApn1cbiAgICBhOiAxXG4gICAgYjogMlxuICAgIGM6IDNcbiAgICBkOiA0XG4gICAgZTogNVxuICAgIGY6IDZcblxuICAgIGxvbmdBcmdzKDEsMiwzKVxuXG4gICAgPk9iamVjdCB7YTogMSwgYjogMiwgYzogMywgZDogdW5kZWZpbmVkLCBlOiB1bmRlZmluZWTigKZ9XG4gICAgYTogMVxuICAgIGI6IDJcbiAgICBjOiAzXG4gICAgZDogdW5kZWZpbmVkXG4gICAgZTogdW5kZWZpbmVkXG4gICAgZjogdW5kZWZpbmVkXG5cbiAqIEBwYXJhbSAge1N0cmluZ1tdfSBzdHJpbmdzXG4gKiBAcGFyYW0gIHtBcnJheS9hcmd1bWVudHN9IHZhbHVlc1xuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5leHBvcnRzLnRvT2JqZWN0ID0gZnVuY3Rpb24oc3RyaW5ncywgdmFsdWVzKSB7XG4gICAgdmFyIG9iaiA9IHt9LFxuICAgICAgICBpID0gMCxcbiAgICAgICAgbGVuID0gc3RyaW5ncy5sZW5ndGg7XG4gICAgZm9yICg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBvYmpbc3RyaW5nc1tpXV0gPSB2YWx1ZXNbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbn07XG5cbi8qKlxuICogUmV0dXJuIGtleSB2YWx1ZSBwYWlycyBmcm9tIHRoZSBvYmplY3QgaWYgdGhlXG4gKiBmaWx0ZXJGbiByZXR1cm5zIGEgdHJ1dGh5IHZhbHVlLlxuICpcbiAgICBMdWMuT2JqZWN0LmZpbHRlcih7XG4gICAgICAgIGE6IGZhbHNlLFxuICAgICAgICBiOiB0cnVlLFxuICAgICAgICBjOiBmYWxzZVxuICAgIH0sIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGtleSA9PT0gJ2EnIHx8IHZhbHVlXG4gICAgfSlcbiAgICA+W3trZXk6ICdhJywgdmFsdWU6IGZhbHNlfSwge2tleTogJ2InLCB2YWx1ZTogdHJ1ZX1dXG5cbiAgICBMdWMuT2JqZWN0LmZpbHRlcih7XG4gICAgICAgIGE6IGZhbHNlLFxuICAgICAgICBiOiB0cnVlLFxuICAgICAgICBjOiBmYWxzZVxuICAgIH0sIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGtleSA9PT0gJ2EnIHx8IHZhbHVlXG4gICAgfSwgdW5kZWZpbmVkLCB7XG4gICAgICAgIGtleXM6IHRydWVcbiAgICB9KVxuICAgID5bJ2EnLCAnYiddXG4gKiBcbiAqIEBwYXJhbSAge09iamVjdH0gICBvYmogIHRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gZmlsdGVyRm4gICB0aGUgZnVuY3Rpb24gdG8gY2FsbCwgcmV0dXJuIGEgdHJ1dGh5IHZhbHVlXG4gKiB0byBhZGQgdGhlIGtleSB2YWx1ZSBwYWlyXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGZpbHRlckZuLmtleSAgIHRoZSBvYmplY3Qga2V5XG4gKiBAcGFyYW0gIHtPYmplY3R9IGZpbHRlckZuLnZhbHVlICAgdGhlIG9iamVjdCB2YWx1ZVxuICogQHBhcmFtICB7T2JqZWN0fSAgIFt0aGlzQXJnXSBcbiAqIEBwYXJhbSB7T2JqZWN0fSAgW2NvbmZpZ11cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gIGNvbmZpZy5vd25Qcm9wZXJ0aWVzIHNldCB0byBmYWxzZVxuICogdG8gaXRlcmF0ZSBvdmVyIGFsbCBvZiB0aGUgb2JqZWN0cyBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gKiBcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gIGNvbmZpZy5rZXlzIHNldCB0byB0cnVlIHRvIHJldHVyblxuICoganVzdCB0aGUga2V5cy5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59ICBjb25maWcudmFsdWVzIHNldCB0byB0cnVlIHRvIHJldHVyblxuICoganVzdCB0aGUgdmFsdWVzLlxuICogXG4gKiBAcmV0dXJuIHtPYmplY3RbXS9TdHJpbmdbXX0gQXJyYXkgb2Yga2V5IHZhbHVlIHBhaXJzIGluIHRoZSBmb3JtXG4gKiBvZiB7a2V5OiAna2V5JywgdmFsdWU6IHZhbHVlfS4gIElmIGtleXMgb3IgdmFsdWVzIGlzIHRydWUgb24gdGhlIGNvbmZpZ1xuICoganVzdCB0aGUga2V5cyBvciB2YWx1ZXMgYXJlIHJldHVybmVkLlxuICpcbiAqL1xuZXhwb3J0cy5maWx0ZXIgPSBmdW5jdGlvbihvYmosIGZpbHRlckZuLCB0aGlzQXJnLCBjKSB7XG4gICAgdmFyIHZhbHVlcyA9IFtdLFxuICAgICAgICBjb25maWcgPSBjIHx8IHt9O1xuXG4gICAgZXhwb3J0cy5lYWNoKG9iaiwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoZmlsdGVyRm4uY2FsbCh0aGlzQXJnLCBrZXksIHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5rZXlzID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goa2V5KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29uZmlnLnZhbHVlcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGtleToga2V5XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB0aGlzQXJnLCBjb25maWcpO1xuXG4gICAgcmV0dXJuIHZhbHVlcztcbn07IiwidmFyIG9Ub1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XHJcblxyXG5cclxuLyoqXHJcbiAqIEBtZW1iZXIgTHVjXHJcbiAqIFJldHVybiB0cnVlIGlmIHRoZSBwYXNzZWQgaW4gb2JqZWN0IGlzIG9mXHJcbiAqIHRoZSB0eXBlIHtAbGluayBBcnJheSBBcnJheX1cclxuICogQHBhcmFtICB7T2JqZWN0fSAgb2JqIFxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKi9cclxuZnVuY3Rpb24gaXNBcnJheShvYmopIHtcclxuICAgIHJldHVybiBBcnJheS5pc0FycmF5KG9iaik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAbWVtYmVyIEx1Y1xyXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgcGFzc2VkIGluIG9iamVjdCBpcyBvZlxyXG4gKiB0aGUgdHlwZSB7QGxpbmsgT2JqZWN0IE9iamVjdH1cclxuICogQHBhcmFtICB7T2JqZWN0fSAgb2JqIFxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKi9cclxuZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XHJcbiAgICByZXR1cm4gb2JqICYmIG9Ub1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xyXG59XHJcblxyXG4vKipcclxuICogQG1lbWJlciBMdWNcclxuICogUmV0dXJuIHRydWUgaWYgdGhlIHBhc3NlZCBpbiBvYmplY3QgaXMgb2ZcclxuICogdGhlIHR5cGUge0BsaW5rIEZ1bmN0aW9uIEZ1bmN0aW9ufVxyXG4gKiBAcGFyYW0gIHtPYmplY3R9ICBvYmogXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAqL1xyXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKG9iaikge1xyXG4gICAgcmV0dXJuIG9Ub1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAbWVtYmVyIEx1Y1xyXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgcGFzc2VkIGluIG9iamVjdCBpcyBvZlxyXG4gKiB0aGUgdHlwZSB7QGxpbmsgRGF0ZSBEYXRlfVxyXG4gKiBAcGFyYW0gIHtPYmplY3R9ICBvYmogXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAqL1xyXG5mdW5jdGlvbiBpc0RhdGUob2JqKSB7XHJcbiAgICByZXR1cm4gb1RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xyXG59XHJcblxyXG4vKipcclxuICogQG1lbWJlciBMdWNcclxuICogUmV0dXJuIHRydWUgaWYgdGhlIHBhc3NlZCBpbiBvYmplY3QgaXMgb2ZcclxuICogdGhlIHR5cGUge0BsaW5rIFJlZ0V4cCBSZWdFeHB9XHJcbiAqIEBwYXJhbSAge09iamVjdH0gIG9iaiBcclxuICogQHJldHVybiB7Qm9vbGVhbn1cclxuICovXHJcbmZ1bmN0aW9uIGlzUmVnRXhwKG9iaikge1xyXG4gICAgcmV0dXJuIG9Ub1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xyXG59XHJcblxyXG4vKipcclxuICogQG1lbWJlciBMdWNcclxuICogUmV0dXJuIHRydWUgaWYgdGhlIHBhc3NlZCBpbiBvYmplY3QgaXMgb2ZcclxuICogdGhlIHR5cGUge0BsaW5rIE51bWJlciBOdW1iZXJ9XHJcbiAqIEBwYXJhbSAge09iamVjdH0gIG9iaiBcclxuICogQHJldHVybiB7Qm9vbGVhbn1cclxuICovXHJcbmZ1bmN0aW9uIGlzTnVtYmVyKG9iaikge1xyXG4gICAgcmV0dXJuIG9Ub1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE51bWJlcl0nO1xyXG59XHJcblxyXG4vKipcclxuICogQG1lbWJlciBMdWNcclxuICogUmV0dXJuIHRydWUgaWYgdGhlIHBhc3NlZCBpbiBvYmplY3QgaXMgb2ZcclxuICogdGhlIHR5cGUge0BsaW5rIFN0cmluZyBTdHJpbmd9XHJcbiAqIEBwYXJhbSAge09iamVjdH0gIG9iaiBcclxuICogQHJldHVybiB7Qm9vbGVhbn1cclxuICovXHJcbmZ1bmN0aW9uIGlzU3RyaW5nKG9iaikge1xyXG4gICAgcmV0dXJuIG9Ub1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xyXG59XHJcblxyXG4vKipcclxuICogQG1lbWJlciBMdWNcclxuICogUmV0dXJuIHRydWUgaWYgdGhlIHBhc3NlZCBpbiBvYmplY3QgaXMgb2ZcclxuICogdGhlIHR5cGUgYXJndW1lbnRzLlxyXG4gKiBcclxuICogQHBhcmFtICB7T2JqZWN0fSAgb2JqIFxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKi9cclxuZnVuY3Rpb24gaXNBcmd1bWVudHMob2JqKSB7XHJcbiAgICByZXR1cm4gb1RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXScgfHwgb2JqICYmICEhb2JqLmNhbGxlZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBtZW1iZXIgTHVjXHJcbiAqIFJldHVybiB0cnVlIGlmIHRoZSBvYmplY3QgaXMgZmFsc3kgYnV0IG5vdCB6ZXJvLiAgSWZcclxuICogeW91IHdhbnQgZmFsc3kgY2hlY2sgdGhhdCBpbmNsdWRlcyB6ZXJvIHVzZSBhIGdvcmFtIFxyXG4gKiBpZiBzdGF0ZW1lbnQgOilcclxuICogQHBhcmFtICB7T2JqZWN0fSAgb2JqXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICBcclxuICovXHJcbmZ1bmN0aW9uIGlzRmFsc3kob2JqKSB7XHJcbiAgICByZXR1cm4gKCFvYmogJiYgb2JqICE9PSAwKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBtZW1iZXIgTHVjXHJcbiAqIFJldHVybiB0cnVlIGlmIHRoZSBvYmplY3QgaXMgZW1wdHkuXHJcbiAqIHt9LCBbXSwgJycsZmFsc2UsIG51bGwsIHVuZGVmaW5lZCwgTmFOIFxyXG4gKiBBcmUgYWxsIHRyZWF0ZWQgYXMgZW1wdHkuXHJcbiAqIEBwYXJhbSAge09iamVjdH0gIG9ialxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKi9cclxuZnVuY3Rpb24gaXNFbXB0eShvYmopIHtcclxuICAgIHZhciBlbXB0eSA9IGZhbHNlO1xyXG5cclxuICAgIGlmIChpc0ZhbHN5KG9iaikpIHtcclxuICAgICAgICBlbXB0eSA9IHRydWU7XHJcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqKSkge1xyXG4gICAgICAgIGVtcHR5ID0gb2JqLmxlbmd0aCA9PT0gMDtcclxuICAgIH0gZWxzZSBpZiAoaXNPYmplY3Qob2JqKSkge1xyXG4gICAgICAgIGVtcHR5ID0gT2JqZWN0LmtleXMob2JqKS5sZW5ndGggPT09IDA7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGVtcHR5O1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIGlzQXJyYXk6IGlzQXJyYXksXHJcbiAgICBpc09iamVjdDogaXNPYmplY3QsXHJcbiAgICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxyXG4gICAgaXNEYXRlOiBpc0RhdGUsXHJcbiAgICBpc1N0cmluZzogaXNTdHJpbmcsXHJcbiAgICBpc051bWJlcjogaXNOdW1iZXIsXHJcbiAgICBpc1JlZ0V4cDogaXNSZWdFeHAsXHJcbiAgICBpc0FyZ3VtZW50czogaXNBcmd1bWVudHMsXHJcbiAgICBpc0ZhbHN5OiBpc0ZhbHN5LFxyXG4gICAgaXNFbXB0eTogaXNFbXB0eVxyXG59OyIsInZhciBpZHMgPSB7fTtcbi8qKlxuICogQG1lbWJlciBMdWNcbiAqIEBtZXRob2QgaWRcbiAqIFxuICogUmV0dXJuIGEgdW5pcXVlIGlkLlxuICogQHBhcmFtIHtTdHJpbmd9IFtwcmVmaXhdIE9wdGlvbmFsIHByZWZpeCB0byB1c2VcbiAqXG4gKlxuICAgICAgICBMdWMuaWQoKVxuICAgICAgICA+XCJsdWMtMFwiXG4gICAgICAgIEx1Yy5pZCgpXG4gICAgICAgID5cImx1Yy0xXCJcbiAgICAgICAgTHVjLmlkKCdteS1wcmVmaXgnKVxuICAgICAgICA+XCJteS1wcmVmaXgwXCJcbiAgICAgICAgTHVjLmlkKCcnKVxuICAgICAgICA+XCIwXCJcbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHApIHtcbiAgICB2YXIgcHJlZml4ID0gcCA9PT0gdW5kZWZpbmVkID8gJ2x1Yy0nIDogcDtcblxuICAgIGlmKGlkc1twcmVmaXhdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWRzW3ByZWZpeF0gPSAwO1xuICAgIH1cblxuICAgIHJldHVybiBwcmVmaXggKyBpZHNbcHJlZml4XSsrO1xufTsiLCJ2YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuLyoqXG4gKiBAbGljZW5zZSBodHRwczovL3Jhdy5naXRodWIuY29tL2pveWVudC9ub2RlL3YwLjEwLjExL0xJQ0VOU0VcbiAqIE5vZGUganMgbGljZW5zZS4gRXZlbnRFbWl0dGVyIHdpbGwgYmUgaW4gdGhlIGNsaWVudFxuICogb25seSBjb2RlLlxuICovXG4vKipcbiAqIEBjbGFzcyBMdWMuRXZlbnRFbWl0dGVyXG4gKiBUaGUgd29uZGVyZnVsIGV2ZW50IGVtbWl0ZXIgdGhhdCBjb21lcyB3aXRoIG5vZGUsXG4gKiB0aGF0IHdvcmtzIGluIHRoZSBzdXBwb3J0ZWQgYnJvd3NlcnMuXG4gKiBbaHR0cDovL25vZGVqcy5vcmcvYXBpL2V2ZW50cy5odG1sXShodHRwOi8vbm9kZWpzLm9yZy9hcGkvZXZlbnRzLmh0bWwpXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgLy9wdXQgaW4gZml4IGZvciBJRSA5IGFuZCBiZWxvd1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcbiAgICAgICAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG5cbiAgICBzZWxmLm9uKHR5cGUsIGcpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjsiLCJyZXF1aXJlKCcuL25vZGVfbW9kdWxlcy9lczUtc2hpbS9lczUtc2hpbScpO1xucmVxdWlyZSgnLi9ub2RlX21vZHVsZXMvZXM1LXNoaW0vZXM1LXNoYW0nKTsiLCJ2YXIgYXJyYXlTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZSxcbiAgICBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJyksXG4gICAgaXMgPSByZXF1aXJlKCcuL2lzJyksXG4gICAgY29tcGFyZSA9IGNvbXBhcmUuY29tcGFyZTtcblxuZnVuY3Rpb24gX2NyZWF0ZUl0ZXJhdG9yRm4oZm4sIGMpIHtcbiAgICB2YXIgY29uZmlnID0gYyB8fCB7fTtcblxuICAgIGlmKGlzLmlzRnVuY3Rpb24oZm4pICYmIChjb25maWcudHlwZSAhPT0gJ3N0cmljdCcpKSB7XG4gICAgICAgIHJldHVybiBjID8gZm4uYmluZChjKSA6IGZuO1xuICAgIH1cblxuICAgIGlmKGNvbmZpZy50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uZmlnLnR5cGUgPSAnbG9vc2UnO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gY29tcGFyZShmbiwgdmFsdWUsIGNvbmZpZyk7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUl0ZXJhdG9yTm90Rm4oZm4sIGNvbmZpZykge1xuICAgIHZhciBmdW5jdGlvblRvTm90ID0gX2NyZWF0ZUl0ZXJhdG9yRm4oZm4sIGNvbmZpZyk7XG4gICAgICAgIFxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICFmdW5jdGlvblRvTm90LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cblxuXG4vKipcbiAqIEBjbGFzcyBMdWMuQXJyYXkgXG4gKiBQYWNrYWdlIGZvciBBcnJheSBtZXRob2RzLiA8YnI+XG4gKiBcbiAqIEtlZXAgaW4gbWluZCB0aGF0IEx1YyBpcyBvcHRpb25hbGx5IHBhY2thZ2VkIHdpdGggZXM1IHNoaW0gc28geW91IGNhbiB3cml0ZSBlczUgY29kZSBpbiBub24gZXM1IGJyb3dzZXJzLlxuICogSXQgY29tZXMgd2l0aCB5b3VyIGZhdm9yaXRlIHtAbGluayBBcnJheSBBcnJheX0gbWV0aG9kcyBzdWNoIGFzIEFycmF5LmZvckVhY2gsIEFycmF5LmZpbHRlciwgQXJyYXkuc29tZSwgQXJyYXkuZXZlcnkgQXJyYXkucmVkdWNlUmlnaHQgLi5cbiAqXG4gKiBBbHNvIGRvbid0IGZvcmdldCBhYm91dCBMdWMuQXJyYXkuZWFjaCBhbmQgTHVjLkFycmF5LnRvQXJyYXksIHRoZXkgYXJlIGdyZWF0IHV0aWxpdHkgbWV0aG9kc1xuICogdGhhdCBhcmUgdXNlZCBhbGwgb3ZlciB0aGUgZnJhbWV3b3JrLlxuICogXG4gKiBBbGwgcmVtb3ZlXFwqIC8gZmluZFxcKiBtZXRob2RzIGZvbGxvdyB0aGUgc2FtZSBhcGkuICBcXCpBbGwgZnVuY3Rpb25zIHdpbGwgcmV0dXJuIGFuIGFycmF5IG9mIHJlbW92ZWQgb3IgZm91bmRcbiAqIGl0ZW1zLiAgVGhlIGl0ZW1zIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGFycmF5IGluIHRoZSBvcmRlciB0aGV5IGFyZVxuICogZm91bmQuICBcXCpGaXJzdCBmdW5jdGlvbnMgd2lsbCByZXR1cm4gdGhlIGZpcnN0IGl0ZW0gYW5kIHN0b3AgaXRlcmF0aW5nIGFmdGVyIHRoYXQsIGlmIG5vbmVcbiAqICBpcyBmb3VuZCBmYWxzZSBpcyByZXR1cm5lZC4gIHJlbW92ZVxcKiBmdW5jdGlvbnMgd2lsbCBkaXJlY3RseSBjaGFuZ2UgdGhlIHBhc3NlZCBpbiBhcnJheS5cbiAqICBcXCpOb3QgZnVuY3Rpb25zIG9ubHkgZG8gdGhlIGZvbGxvd2luZyBhY3Rpb25zIGlmIHRoZSBjb21wYXJpc29uIGlzIG5vdCB0cnVlLlxuICogIEFsbCByZW1vdmVcXCogLyBmaW5kXFwqIHRha2UgdGhlIGZvbGxvd2luZyBhcGk6IGFycmF5LCBvYmplY3RUb0NvbXBhcmVPckl0ZXJhdG9yLCBjb21wYXJlQ29uZmlnT3JUaGlzQXJnIGZvciBleGFtcGxlOlxuICpcbiAgICAvL21vc3QgY29tbW9uIHVzZSBjYXNlXG4gICAgTHVjLkFycmF5LmZpbmRGaXJzdChbMSwyLDMsIHt9XSwge30pO1xuICAgID5PYmplY3Qge31cblxuICAgIC8vcGFzcyBpbiBvcHRpb24gY29uZmlnIGZvciBhIHN0cmljdCA9PT0gY29tcGFyaXNvblxuICAgIEx1Yy5BcnJheS5maW5kRmlyc3QoWzEsMiwzLHt9XSwge30sIHt0eXBlOiAnc3RyaWN0J30pO1xuICAgID5mYWxzZVxuXG4gICAgLy9wYXNzIGluIGFuIGl0ZXJhdG9yIGFuZCB0aGlzQXJnXG4gICAgTHVjLkFycmF5LmZpbmRGaXJzdChbMSwyLDMse31dLCBmdW5jdGlvbih2YWwsIGluZGV4LCBhcnJheSl7XG4gICAgICAgIHJldHVybiB2YWwgPT09IDMgfHwgdGhpcy5udW0gPT09IHZhbDtcbiAgICB9LCB7bnVtOiAxfSk7XG4gICAgPjFcbiAgICBcbiAgICAvL3lvdSBjYW4gc2VlIHJlbW92ZSBtb2RpZmllcyB0aGUgcGFzc2VkIGluIGFycmF5LlxuICAgIHZhciBhcnIgPSBbMSwyLHthOjF9LDEsIHthOjF9XTtcbiAgICBMdWMuQXJyYXkucmVtb3ZlRmlyc3QoYXJyLCB7YToxfSlcbiAgICA+e2E6MX1cbiAgICBhcnI7XG4gICAgPlsxLCAyLCAxLCB7YToxfV1cbiAgICBMdWMuQXJyYXkucmVtb3ZlTGFzdChhcnIsIDEpXG4gICAgPjFcbiAgICBhcnI7XG4gICAgPlsxLDIsIHthOjF9XVxuICAgIFxuICAgIFxuICAgIEx1Yy5BcnJheS5maW5kQWxsKFsxLDIsMywge2E6MSxiOjJ9XSwgZnVuY3Rpb24oKSB7cmV0dXJuIHRydWU7fSlcbiAgICA+IFsxLDIsMywge2E6MSxiOjJ9XVxuICAgIC8vc2hvdyBob3cgbm90IHdvcmtzIHdpdGggYW4gaXRlcmF0b3JcbiAgICBMdWMuQXJyYXkuZmluZEFsbE5vdChbMSwyLDMsIHthOjEsYjoyfV0sIGZ1bmN0aW9uKCkge3JldHVybiB0cnVlO30pXG4gICAgPltdXG4gKlxuICogRm9yIGNvbW1vbmx5IHVzZWQgZmluZC9yZW1vdmUgZnVuY3Rpb25zIGNoZWNrIG91dCBMdWMuQXJyYXlGbnMgZm9yIGV4YW1wbGUgYVxuICogXCJjb21wYWN0XCIgbGlrZSBmdW5jdGlvblxuICogXG4gICAgTHVjLkFycmF5LmZpbmRBbGxOb3RGYWxzeShbZmFsc2UsICcnLCB1bmRlZmluZWQsIDAsIHt9LCBbXV0pXG4gICAgPlswLCB7fSwgW11dXG4gKlxuICogT3IgcmVtb3ZlIGFsbCBlbXB0eSBpdGVtc1xuICogXG4gICAgdmFyIGFyciA9IFsnJywgMCAsIFtdLCB7YToxfSwgdHJ1ZSwge30sIFsxXV1cbiAgICBMdWMuQXJyYXkucmVtb3ZlQWxsRW1wdHkoYXJyKVxuICAgID5bJycsIFtdLCB7fV1cbiAgICBhcnJcbiAgICA+WzAsIHthOjF9LCB0cnVlLCBbMV1dXG4gKi9cblxuLyoqXG4gKiBUdXJuIHRoZSBwYXNzZWQgaW4gaXRlbSBpbnRvIGFuIGFycmF5IGlmIGl0XG4gKiBpc24ndCBvbmUgYWxyZWFkeSwgaWYgdGhlIGl0ZW0gaXMgYW4gYXJyYXkganVzdCByZXR1cm4gaXQuICBcbiAqIEl0IHJldHVybnMgYW4gZW1wdHkgYXJyYXkgaWYgaXRlbSBpcyBudWxsIG9yIHVuZGVmaW5lZC5cbiAqIElmIGl0IGlzIGp1c3QgYSBzaW5nbGUgaXRlbSByZXR1cm4gYW4gYXJyYXkgY29udGFpbmluZyB0aGUgaXRlbS5cbiAqIFxuICAgIEx1Yy5BcnJheS50b0FycmF5KClcbiAgICA+W11cbiAgICBMdWMuQXJyYXkudG9BcnJheShudWxsKVxuICAgID5bXVxuICAgIEx1Yy5BcnJheS50b0FycmF5KDEpXG4gICAgPlsxXVxuICAgIEx1Yy5BcnJheS50b0FycmF5KFsxLDJdKVxuICAgID5bMSwgMl1cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IGl0ZW0gaXRlbSB0byB0dXJuIGludG8gYW4gYXJyYXkuXG4gKiBAcmV0dXJuIHRoZSBhcnJheVxuICovXG5mdW5jdGlvbiB0b0FycmF5KGl0ZW0pIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG4gICAgcmV0dXJuIChpdGVtID09PSBudWxsIHx8IGl0ZW0gPT09IHVuZGVmaW5lZCkgPyBbXSA6IFtpdGVtXTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGxhc3QgaXRlbSBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSAge0FycmF5fSBhcnJcbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIGl0ZW1cbiAgICBcbiAgICB2YXIgbXlMb25nQXJyYXlOYW1lRm9yVGhpbmdzVGhhdElXYW50VG9LZWVwVHJhY2tPZiA9IFsxLDIsM11cbiAgICBcbiAgICBMdWMuQXJyYXkubGFzdChteUxvbmdBcnJheU5hbWVGb3JUaGluZ3NUaGF0SVdhbnRUb0tlZXBUcmFja09mKTtcbiAgICB2cy5cbiAgICBteUxvbmdBcnJheU5hbWVGb3JUaGluZ3NUaGF0SVdhbnRUb0tlZXBUcmFja09mW215TG9uZ0FycmF5TmFtZUZvclRoaW5nc1RoYXRJV2FudFRvS2VlcFRyYWNrT2YubGVuZ3RoIC0xXVxuICpcbiAqL1xuZnVuY3Rpb24gbGFzdChhcnIpIHtcbiAgICByZXR1cm4gYXJyW2Fyci5sZW5ndGggLTFdO1xufVxuXG4vKipcbiAqIEZsYXR0ZW4gb3V0IGFuIGFycmF5IG9mIG9iamVjdHMgYmFzZWQgb2YgdGhlaXIgdmFsdWUgZm9yIHRoZSBwYXNzZWQgaW4ga2V5LlxuICogVGhpcyBhbHNvIHRha2VzIGFjY2NvdW50IGZvciBudWxsL3VuZGVmaW5lZCB2YWx1ZXMuXG4gKlxuICAgIEx1Yy5BcnJheS5wbHVjayhbdW5kZWZpbmVkLCB7YTonMScsIGI6Mn0sIHtiOjN9LCB7Yjo0fV0sICdiJylcbiAgICA+W3VuZGVmaW5lZCwgMiwgMywgNF1cbiAqIEBwYXJhbSAge09iamVjdFtdfSBhcnIgXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGtleSBcbiAqIEByZXR1cm4ge0FycmF5fSAgICAgXG4gKi9cbmZ1bmN0aW9uIHBsdWNrKGFyciwga2V5KSB7XG4gICAgcmV0dXJuIGFyci5tYXAoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICYmIHZhbHVlW2tleV07XG4gICAgfSk7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBpdGVtcyBpbmJldHdlZW4gdGhlIHBhc3NlZCBpbiBpbmRleFxuICogYW5kIHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICpcbiAgICBMdWMuQXJyYXkuZnJvbUluZGV4KFsxLDIsMyw0LDVdLCAxKVxuICAgID5bMiwgMywgNCwgNV1cblxuICogQHBhcmFtICB7QXJyYXkvYXJndW1lbnRzfSBhcnIgXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGluZGV4IFxuICogQHJldHVybiB7QXJyYXl9IHRoZSBuZXcgYXJyYXkuXG4gKiBcbiAqL1xuZnVuY3Rpb24gZnJvbUluZGV4KGEsIGluZGV4KSB7XG4gICAgdmFyIGFyciA9IGlzLmlzQXJndW1lbnRzKGEpID8gYXJyYXlTbGljZS5jYWxsKGEpIDogYTtcbiAgICByZXR1cm4gYXJyYXlTbGljZS5jYWxsKGFyciwgaW5kZXgsIGFyci5sZW5ndGgpO1xufVxuXG4vKipcbiAqIFJ1bnMgYW4gQXJyYXkuZm9yRWFjaCBhZnRlciBjYWxsaW5nIEx1Yy5BcnJheS50b0FycmF5IG9uIHRoZSBpdGVtLlxuICBJdCBpcyB2ZXJ5IHVzZWZ1bCBmb3Igc2V0dGluZyB1cCBmbGV4aWJsZSBhcGkncyB0aGF0IGNhbiBoYW5kbGUgbm9uZSBvbmUgb3IgbWFueS5cblxuICAgIEx1Yy5BcnJheS5lYWNoKHRoaXMuaXRlbXMsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgdGhpcy5fYWRkSXRlbShpdGVtKTtcbiAgICB9KTtcblxuICAgIHZzLlxuXG4gICAgaWYoQXJyYXkuaXNBcnJheSh0aGlzLml0ZW1zKSl7XG4gICAgICAgIHRoaXMuaXRlbXMuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICB0aGlzLl9hZGRJdGVtKGl0ZW0pO1xuICAgICAgICB9KVxuICAgIH1cbiAgICBlbHNlIGlmKHRoaXMuaXRlbXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9hZGRJdGVtKHRoaXMuaXRlbXMpO1xuICAgIH1cblxuICogQHBhcmFtICB7T2JqZWN0fSAgIGl0ZW1cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHBhcmFtICB7T2JqZWN0fSAgIHRoaXNBcmcgICBcbiAqXG4gKi9cbmZ1bmN0aW9uIGVhY2goaXRlbSwgZm4sIHRoaXNBcmcpIHtcbiAgICB2YXIgYXJyID0gdG9BcnJheShpdGVtKTtcbiAgICByZXR1cm4gYXJyLmZvckVhY2guY2FsbChhcnIsIGZuLCB0aGlzQXJnKTtcbn1cblxuLyoqXG4gKiBJbnNlcnQgb3IgYXBwZW5kIHRoZSBzZWNvbmQgYXJyYXkvYXJndW1lbnRzIGludG8gdGhlXG4gKiBmaXJzdCBhcnJheS9hcmd1bWVudHMuICBUaGlzIG1ldGhvZCBkb2VzIG5vdCBhbHRlclxuICogdGhlIHBhc3NlZCBpbiBhcnJheS9hcmd1bWVudHMuXG4gKiBcbiAqIEBwYXJhbSAge0FycmF5L2FyZ3VtZW50c30gZmlyc3RBcnJheU9yQXJnc1xuICogQHBhcmFtICB7QXJyYXkvYXJndW1lbnRzfSBzZWNvbmRBcnJheU9yQXJnc1xuICogQHBhcmFtICB7TnVtYmVyL3RydWV9IGluZGV4T3JBcHBlbmQgdHJ1ZSB0byBhcHBlbmQgXG4gKiB0aGUgc2Vjb25kIGFycmF5IHRvIHRoZSBlbmQgb2YgdGhlIGZpcnN0IG9uZS4gIElmIGl0IGlzIGEgbnVtYmVyXG4gKiBpbnNlcnQgdGhlIHNlY29uZEFycmF5IGludG8gdGhlIGZpcnN0IG9uZSBhdCB0aGUgcGFzc2VkIGluIGluZGV4LlxuICogQHJldHVybiB7QXJyYXl9IHRoZSBuZXdseSBjcmVhdGVkIGFycmF5LlxuICpcbiAgICBMdWMuQXJyYXkuaW5zZXJ0KFswLDRdLCBbMSwyLDNdLCAxKTtcbiAgICA+WzAsIDEsIDIsIDMsIDRdXG4gICAgTHVjLkFycmF5Lmluc2VydChbMCw0XSwgWzEsMiwzXSwgdHJ1ZSk7XG4gICAgPlswLCA0LCAxLCAyLCAzXVxuICAgIEx1Yy5BcnJheS5pbnNlcnQoWzAsNF0sIFsxLDIsM10sIDApO1xuICAgID5bMSwgMiwgMywgMCwgNF1cbiAqXG4gKi9cbmZ1bmN0aW9uIGluc2VydChmaXJzdEFycmF5T3JBcmdzLCBzZWNvbmRBcnJheU9yQXJncywgaW5kZXhPckFwcGVuZCkge1xuICAgIHZhciBmaXJzdEFycmF5ID0gYXJyYXlTbGljZS5jYWxsKGZpcnN0QXJyYXlPckFyZ3MpLFxuICAgICAgICBzZWNvbmRBcnJheSA9IGFycmF5U2xpY2UuY2FsbChzZWNvbmRBcnJheU9yQXJncyksXG4gICAgICAgIHNwbGljZUFyZ3M7XG5cbiAgICBpZihpbmRleE9yQXBwZW5kID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBmaXJzdEFycmF5LmNvbmNhdChzZWNvbmRBcnJheSk7XG4gICAgfVxuXG4gICAgc3BsaWNlQXJncyA9IFtpbmRleE9yQXBwZW5kLCAwXS5jb25jYXQoc2Vjb25kQXJyYXkpO1xuICAgIGZpcnN0QXJyYXkuc3BsaWNlLmFwcGx5KGZpcnN0QXJyYXksIHNwbGljZUFyZ3MpO1xuICAgIHJldHVybiBmaXJzdEFycmF5O1xufVxuXG4vKipcbiAqIFJlbW92ZSBhbiBpdGVtIGZyb20gYW4gdGhlIHBhc3NlZCBpbiBhcnJcbiAqIGZyb20gdGhlIGluZGV4LlxuICogQHBhcmFtICB7QXJyYXl9IGFyclxuICogQHBhcmFtICB7TnVtYmVyfSBpbmRleFxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgaXRlbSByZW1vdmVkLlxuICpcbiAgICB2YXIgYXJyID0gWzEsMiwzXTtcbiAgICBMdWMuQXJyYXkucmVtb3ZlQXRJbmRleChhcnIsIDEpO1xuICAgID4yXG4gICAgYXJyO1xuICAgID5bMSwzXVxuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUF0SW5kZXgoYXJyLCBpbmRleCkge1xuICAgIHZhciBpdGVtID0gYXJyW2luZGV4XTtcbiAgICBhcnIuc3BsaWNlKGluZGV4LCAxKTtcbiAgICByZXR1cm4gaXRlbTtcbn1cblxuZnVuY3Rpb24gX3JlbW92ZUZpcnN0KGFyciwgZm4pIHtcbiAgICB2YXIgcmVtb3ZlZCA9IGZhbHNlO1xuXG4gICAgYXJyLnNvbWUoZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XG4gICAgICAgIGlmIChmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSB7XG4gICAgICAgICAgICByZW1vdmVkID0gcmVtb3ZlQXRJbmRleChhcnIsIGluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVtb3ZlZDtcbn1cblxuLyoqXG4gKiBSZW1vdmUgdGhlIGZpcnN0IGl0ZW0gZnJvbSB0aGUgcGFzc2VkIGluIGFycmF5XG4gKiB0aGF0IHtAbGluayBMdWMjY29tcGFyZSBtYXRjaGVzfSB0aGUgcGFzc2VkIGluIG9iamVjdC4gIEluc3RlYWQgb2YgXG4gKiBjb21wYXJpbmcgYW4gb2JqZWN0IGFuIGl0ZXJhdG9yIGZ1bmN0aW9uIGNhbiBiZVxuICogdXNlZC5cbiAqIFxue2NvcHlEb2MjYXJyUGFyYW1zfVxue2NvcHlEb2MjYXJyUmVtb3ZlU2luZ2xlfVxuICovXG5mdW5jdGlvbiByZW1vdmVGaXJzdChhcnIsIG9iaiwgY29uZmlnKSB7XG4gICAgdmFyIGZuID0gX2NyZWF0ZUl0ZXJhdG9yRm4ob2JqLCBjb25maWcpO1xuICAgIHJldHVybiBfcmVtb3ZlRmlyc3QoYXJyLCBmbik7XG59XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBmaXJzdCBpdGVtIGZyb20gdGhlIHBhc3NlZCBpbiBhcnJheVxuICogdGhhdCBkb2VzIG5vdCB7QGxpbmsgTHVjI2NvbXBhcmUgbWF0Y2h9IHRoZSBwYXNzZWQgaW4gb2JqZWN0LiAgSW5zdGVhZCBvZiBcbiAqIGNvbXBhcmluZyBhbiBvYmplY3QgYW4gaXRlcmF0b3IgZnVuY3Rpb24gY2FuIGJlXG4gKiB1c2VkLlxuICogXG57Y29weURvYyNhcnJQYXJhbXN9XG57Y29weURvYyNhcnJSZW1vdmVTaW5nbGV9XG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUZpcnN0Tm90KGFyciwgb2JqLCBjb25maWcpIHtcbiAgICB2YXIgZm4gPSBfY3JlYXRlSXRlcmF0b3JOb3RGbihvYmosIGNvbmZpZyk7XG4gICAgcmV0dXJuIF9yZW1vdmVGaXJzdChhcnIsIGZuKTtcbn1cblxuXG5mdW5jdGlvbiBfcmVtb3ZlQWxsKGFyciwgZm4pIHtcbiAgICB2YXIgaW5kZXhzVG9SZW1vdmUgPSBbXSxcbiAgICAgICAgcmVtb3ZlZCA9IFtdO1xuXG4gICAgYXJyLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XG4gICAgICAgIGlmIChmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSB7XG4gICAgICAgICAgICBpbmRleHNUb1JlbW92ZS51bnNoaWZ0KGluZGV4KTtcbiAgICAgICAgICAgIHJlbW92ZWQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGluZGV4c1RvUmVtb3ZlLmZvckVhY2goZnVuY3Rpb24oaW5kZXgpe1xuICAgICAgICByZW1vdmVBdEluZGV4KGFyciwgaW5kZXgpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlbW92ZWQ7XG59XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBhbGwgdGhlIGl0ZW1zIGZyb20gdGhlIHBhc3NlZCBpbiBhcnJheVxuICogdGhhdCBkbyBub3Qge0BsaW5rIEx1YyNjb21wYXJlIG1hdGNofSB0aGUgcGFzc2VkIGluIG9iamVjdC4gIEluc3RlYWQgb2YgXG4gKiBjb21wYXJpbmcgYW4gb2JqZWN0IGFuIGl0ZXJhdG9yIGZ1bmN0aW9uIGNhbiBiZVxuICogdXNlZC5cbiAqIFxue2NvcHlEb2MjYXJyUGFyYW1zfVxue2NvcHlEb2MjYXJyUmVtb3ZlQWxsfVxuICovXG5mdW5jdGlvbiByZW1vdmVBbGxOb3QoYXJyLCBvYmosIGNvbmZpZykge1xuICAgIHZhciBmbiA9IF9jcmVhdGVJdGVyYXRvck5vdEZuKG9iaiwgY29uZmlnKTtcbiAgICByZXR1cm4gX3JlbW92ZUFsbChhcnIsIGZuKTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgdGhlIGFsbCB0aGUgaXRlbXMgZnJvbSB0aGUgcGFzc2VkIGluIGFycmF5XG4gKiB0aGF0IHtAbGluayBMdWMjY29tcGFyZSBtYXRjaGVzfSB0aGUgcGFzc2VkIGluIG9iamVjdC4gIEluc3RlYWQgb2YgXG4gKiBjb21wYXJpbmcgYW4gb2JqZWN0IGFuIGl0ZXJhdG9yIGZ1bmN0aW9uIGNhbiBiZVxuICogdXNlZC5cbiAqIFxue2NvcHlEb2MjYXJyUGFyYW1zfVxue2NvcHlEb2MjYXJyUmVtb3ZlQWxsfVxuICovXG5mdW5jdGlvbiByZW1vdmVBbGwoYXJyLCBvYmosIGNvbmZpZykge1xuICAgIHZhciBmbiA9IF9jcmVhdGVJdGVyYXRvckZuKG9iaiwgY29uZmlnKTtcbiAgICByZXR1cm4gX3JlbW92ZUFsbChhcnIsIGZuKTtcbn1cblxuZnVuY3Rpb24gX2ZpbmRGaXJzdChhcnIsIGZuKSB7XG4gICAgdmFyIGl0ZW0gPSBmYWxzZTtcbiAgICBhcnIuc29tZShmdW5jdGlvbih2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgaWYgKGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHtcbiAgICAgICAgICAgIGl0ZW0gPSBhcnJbaW5kZXhdO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBpdGVtO1xufVxuXG4vKipcbiAqIEZpbmQgdGhlIGZpcnN0IGl0ZW0gZnJvbSB0aGUgcGFzc2VkIGluIGFycmF5XG4gKiB0aGF0IGRvZXMge0BsaW5rIEx1YyNjb21wYXJlIG1hdGNoZXN9IHRoZSBwYXNzZWQgaW4gb2JqZWN0LiAgSW5zdGVhZCBvZiBcbiAqIGNvbXBhcmluZyBhbiBvYmplY3QgYW4gaXRlcmF0b3IgZnVuY3Rpb24gY2FuIGJlXG4gKiB1c2VkLlxuICogXG57Y29weURvYyNhcnJQYXJhbXN9XG57Y29weURvYyNhcnJGaW5kU2luZ2xlfVxuICovXG5mdW5jdGlvbiBmaW5kRmlyc3QoYXJyLCBvYmosIGNvbmZpZykge1xuICAgIHZhciBmbiA9IF9jcmVhdGVJdGVyYXRvckZuKG9iaiwgY29uZmlnKTtcbiAgICByZXR1cm4gX2ZpbmRGaXJzdChhcnIsIGZuKTtcbn1cblxuLyoqXG4gKiBGaW5kIHRoZSBmaXJzdCBpdGVtIGZyb20gdGhlIHBhc3NlZCBpbiBhcnJheVxuICogdGhhdCBkb2VzIG5vdCB7QGxpbmsgTHVjI2NvbXBhcmUgbWF0Y2h9IHRoZSBwYXNzZWQgaW4gb2JqZWN0LiAgSW5zdGVhZCBvZiBcbiAqIGNvbXBhcmluZyBhbiBvYmplY3QgYW4gaXRlcmF0b3IgZnVuY3Rpb24gY2FuIGJlXG4gKiB1c2VkLlxuICogXG57Y29weURvYyNhcnJQYXJhbXN9XG57Y29weURvYyNhcnJGaW5kU2luZ2xlfVxuICovXG5mdW5jdGlvbiBmaW5kRmlyc3ROb3QoYXJyLCBvYmosIGNvbmZpZykge1xuICAgIHZhciBmbiA9IF9jcmVhdGVJdGVyYXRvck5vdEZuKG9iaiwgY29uZmlnKTtcbiAgICByZXR1cm4gX2ZpbmRGaXJzdChhcnIsIGZuKTtcbn1cblxuZnVuY3Rpb24gX2ZpbmRBbGwoYXJyLCBmbikge1xuICAgIHZhciBmb3VuZCA9IGFyci5maWx0ZXIoZm4pO1xuICAgIHJldHVybiBmb3VuZDtcbn1cblxuLyoqXG4gKiBGaW5kIGFsbCBvZiB0aGUgdGhlIGl0ZW1zIGZyb20gdGhlIHBhc3NlZCBpbiBhcnJheVxuICogdGhhdCB7QGxpbmsgTHVjI2NvbXBhcmUgbWF0Y2hlc30gdGhlIHBhc3NlZCBpbiBvYmplY3QuICBJbnN0ZWFkIG9mIFxuICogY29tcGFyaW5nIGFuIG9iamVjdCBhbiBpdGVyYXRvciBmdW5jdGlvbiBjYW4gYmVcbiAqIHVzZWQuXG4gKiBcbntjb3B5RG9jI2FyclBhcmFtc31cbntjb3B5RG9jI2FyckZpbmRBbGx9XG4gKi9cbmZ1bmN0aW9uIGZpbmRBbGwoYXJyLCBvYmosIGNvbmZpZykge1xuICAgIHZhciBmbiA9IF9jcmVhdGVJdGVyYXRvckZuKG9iaiwgY29uZmlnKTtcbiAgICByZXR1cm4gX2ZpbmRBbGwoYXJyLCBmbik7XG59XG5cbi8qKlxuICogRmluZCBhbGwgb2YgdGhlIHRoZSBpdGVtcyBmcm9tIHRoZSBwYXNzZWQgaW4gYXJyYXlcbiAqIHRoYXQgZG8gbm90IHtAbGluayBMdWMjY29tcGFyZSBtYXRjaH0gdGhlIHBhc3NlZCBpbiBvYmplY3QuICBJbnN0ZWFkIG9mIFxuICogY29tcGFyaW5nIGFuIG9iamVjdCBhbiBpdGVyYXRvciBmdW5jdGlvbiBjYW4gYmVcbiAqIHVzZWQuXG4gKiBcbntjb3B5RG9jI2FyclBhcmFtc31cbntjb3B5RG9jI2FyckZpbmRBbGx9XG4gKi9cbmZ1bmN0aW9uIGZpbmRBbGxOb3QoYXJyLCBvYmosIGNvbmZpZykge1xuICAgIHZhciBmbiA9IF9jcmVhdGVJdGVyYXRvck5vdEZuKG9iaiwgY29uZmlnKTtcbiAgICByZXR1cm4gX2ZpbmRBbGwoYXJyLCBmbik7XG59XG5cblxuZXhwb3J0cy50b0FycmF5ID0gdG9BcnJheTtcbmV4cG9ydHMuZWFjaCA9IGVhY2g7XG5leHBvcnRzLmluc2VydCA9IGluc2VydDtcbmV4cG9ydHMuZnJvbUluZGV4ID0gZnJvbUluZGV4O1xuZXhwb3J0cy5sYXN0ID0gbGFzdDtcbmV4cG9ydHMucGx1Y2sgPSBwbHVjaztcblxuZXhwb3J0cy5yZW1vdmVBdEluZGV4ID0gcmVtb3ZlQXRJbmRleDtcbmV4cG9ydHMuZmluZEZpcnN0Tm90ID0gZmluZEZpcnN0Tm90O1xuZXhwb3J0cy5maW5kQWxsTm90ID0gZmluZEFsbE5vdDtcbmV4cG9ydHMuZmluZEZpcnN0ID0gZmluZEZpcnN0O1xuZXhwb3J0cy5maW5kQWxsID0gZmluZEFsbDtcblxuZXhwb3J0cy5yZW1vdmVGaXJzdE5vdCA9IHJlbW92ZUZpcnN0Tm90O1xuZXhwb3J0cy5yZW1vdmVBbGxOb3QgPSByZW1vdmVBbGxOb3Q7XG5leHBvcnRzLnJlbW92ZUZpcnN0ID0gcmVtb3ZlRmlyc3Q7XG5leHBvcnRzLnJlbW92ZUFsbCA9IHJlbW92ZUFsbDtcblxuKGZ1bmN0aW9uKCl7XG4gICAgdmFyIF9jcmVhdGVMYXN0Rm4gPSBmdW5jdGlvbihmbk5hbWUpIHtcbiAgICAgICAgdmFyIGxhc3ROYW1lID0gZm5OYW1lLnJlcGxhY2UoJ0ZpcnN0JywgJ0xhc3QnKTtcblxuICAgICAgICBleHBvcnRzW2xhc3ROYW1lXSA9IGZ1bmN0aW9uKGFyciwgb2JqLCBjb25maWcpIHtcbiAgICAgICAgICAgIHZhciByZXQ7XG5cbiAgICAgICAgICAgIGFyci5yZXZlcnNlKCk7XG4gICAgICAgICAgICByZXQgPSBleHBvcnRzW2ZuTmFtZV0oYXJyLCBvYmosIGNvbmZpZyk7XG4gICAgICAgICAgICBhcnIucmV2ZXJzZSgpO1xuXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9O1xuXG4gICAgfSwgbmFtZXNUb0FkZExhc3QgPSBbJ2ZpbmRGaXJzdE5vdCcsICdmaW5kRmlyc3QnLCAncmVtb3ZlRmlyc3ROb3QnLCAncmVtb3ZlRmlyc3QnXTtcblxuICAgIG5hbWVzVG9BZGRMYXN0LmZvckVhY2goZnVuY3Rpb24oZm5OYW1lKSB7XG4gICAgICAgIF9jcmVhdGVMYXN0Rm4oZm5OYW1lKTtcbiAgICB9KTtcblxufSgpKTtcblxuLyoqXG4gKiBAbWVtYmVyIEx1Yy5BcnJheSBcbiAqIEBtZXRob2QgZmluZExhc3ROb3QgXG4gKiBTYW1lIGFzIEx1Yy5BcnJheS5maW5kRmlyc3ROb3QgZXhjZXB0IHN0YXJ0IGF0IHRoZSBlbmQuXG4gKi9cblxuLyoqXG4gKiBAbWVtYmVyIEx1Yy5BcnJheSBcbiAqIEBtZXRob2QgZmluZExhc3RcbiAqIFNhbWUgYXMgTHVjLkFycmF5LmZpbmRGaXJzdCBleGNlcHQgc3RhcnQgYXQgdGhlIGVuZC5cbiAqL1xuXG4vKipcbiAqIEBtZW1iZXIgTHVjLkFycmF5IFxuICogQG1ldGhvZCByZW1vdmVMYXN0Tm90IFxuICogU2FtZSBhcyBMdWMuQXJyYXkucmVtb3ZlRmlyc3ROb3QgZXhjZXB0IHN0YXJ0IGF0IHRoZSBlbmQuXG4gKi9cblxuLyoqXG4gKiBAbWVtYmVyIEx1Yy5BcnJheSBcbiAqIEBtZXRob2QgcmVtb3ZlTGFzdCBcbiAqIFNhbWUgYXMgTHVjLkFycmF5LnJlbW92ZUZpcnN0IGV4Y2VwdCBzdGFydCBhdCB0aGUgZW5kLlxuICovXG4iLCJ2YXIgaXMgPSByZXF1aXJlKCcuL2lzJyksXG4gICAgYUluc2VydCA9IHJlcXVpcmUoJy4vYXJyYXknKS5pbnNlcnQ7XG4gICAgYUVhY2ggPSByZXF1aXJlKCcuL2FycmF5JykuZWFjaDtcblxuLyoqXG4gKiBAY2xhc3MgTHVjLkZ1bmN0aW9uXG4gKiBQYWNrYWdlIGZvciBmdW5jdGlvbiBtZXRob2RzLiAgTW9zdCBvZiB0aGVtIGZvbGxvdyB0aGUgc2FtZSBhcGk6XG4gKiBmdW5jdGlvbiBvciBmdW5jdGlvbltdLCByZWxldmFudCBhcmdzIC4uLiB3aXRoIGFuIG9wdGlvbmFsIGNvbmZpZ1xuICogdG8gTHVjLkZ1bmN0aW9uLmNyZWF0ZUF1dG1lbnRlciBhcyB0aGUgbGFzdCBhcmd1bWVudC5cbiAqL1xuXG5mdW5jdGlvbiBfYXVnbWVudEFyZ3MoY29uZmlnLCBjYWxsQXJncykge1xuICAgIHZhciBjb25maWdBcmdzID0gY29uZmlnLmFyZ3MsXG4gICAgICAgIGluZGV4ID0gY29uZmlnLmluZGV4LFxuICAgICAgICBhcmdzQXJyYXk7XG5cbiAgICBpZiAoIWNvbmZpZ0FyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxBcmdzO1xuICAgIH1cblxuICAgIGlmKGluZGV4ID09PSB0cnVlIHx8IGlzLmlzTnVtYmVyKGluZGV4KSkge1xuICAgICAgICBpZihjb25maWcuYXJndW1lbnRzRmlyc3QgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gYUluc2VydChjb25maWdBcmdzLCBjYWxsQXJncywgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhSW5zZXJ0KGNhbGxBcmdzLCBjb25maWdBcmdzLCBpbmRleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbmZpZ0FyZ3M7XG59XG5cbi8qKlxuICogQSByZXVzYWJsZSBlbXB0eSBmdW5jdGlvblxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cbmV4cG9ydHMuZW1wdHlGbiA9IGZ1bmN0aW9uKCkge307XG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IHRocm93cyBhbiBlcnJvciB3aGVuIGNhbGxlZC5cbiAqIFVzZWZ1bCB3aGVuIGRlZmluaW5nIGFic3RyYWN0IGxpa2UgY2xhc3Nlc1xuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cbmV4cG9ydHMuYWJzdHJhY3RGbiA9IGZ1bmN0aW9uKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignYWJzdHJhY3RGbiBtdXN0IGJlIGltcGxlbWVudGVkJyk7XG59O1xuXG4vKipcbiAqIEF1Z21lbnQgdGhlIHBhc3NlZCBpbiBmdW5jdGlvbidzIHRoaXNBcmcgYW5kIG9yIGFyZ3VtZW50cyBvYmplY3QgXG4gKiBiYXNlZCBvbiB0aGUgcGFzc2VkIGluIGNvbmZpZy5cbiAqIFxuICogQHBhcmFtICB7RnVuY3Rpb259IGZuIHRoZSBmdW5jdGlvbiB0byBjYWxsXG4gKiBAcGFyYW0gIHtPYmplY3R9IGNvbmZpZ1xuICogXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy50aGlzQXJnXSB0aGUgdGhpc0FyZyBmb3IgdGhlIGZ1bmN0aW9uIGJlaW5nIGV4ZWN1dGVkLlxuICogSWYgdGhpcyBpcyB0aGUgb25seSBwcm9wZXJ0eSBvbiB5b3VyIGNvbmZpZyBvYmplY3QgdGhlIHByZWZlcnJlZCB3YXkgd291bGRcbiAqIGJlIGp1c3QgdG8gdXNlIEZ1bmN0aW9uLmJpbmRcbiAqIFxuICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5hcmdzXSB0aGUgYXJndW1lbnRzIHVzZWQgZm9yIHRoZSBmdW5jdGlvbiBiZWluZyBleGVjdXRlZC5cbiAqIFRoaXMgd2lsbCByZXBsYWNlIHRoZSBmdW5jdGlvbnMgY2FsbCBhcmdzIGlmIGluZGV4IGlzIG5vdCBhIG51bWJlciBvciBcbiAqIHRydWUuXG4gKiBcbiAqIEBwYXJhbSB7TnVtYmVyL1RydWV9IFtjb25maWcuaW5kZXhdIEJ5IGRlZmF1bHQgdGhlIHRoZSBjb25maWd1cmVkIGFyZ3VtZW50c1xuICogd2lsbCBiZSBpbnNlcnRlZCBpbnRvIHRoZSBmdW5jdGlvbnMgcGFzc2VkIGluIGNhbGwgYXJndW1lbnRzLiAgSWYgaW5kZXggaXMgdHJ1ZVxuICogYXBwZW5kIHRoZSBhcmdzIHRvZ2V0aGVyIGlmIGl0IGlzIGEgbnVtYmVyIGluc2VydCBpdCBhdCB0aGUgcGFzc2VkIGluIGluZGV4LlxuICogXG4gKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmFyZ3VtZW50c0ZpcnN0XSBwYXNzIGluIGZhbHNlIHRvIFxuICogYXVnbWVudCB0aGUgY29uZmlndXJlZCBhcmdzIGZpcnN0IHdpdGggTHVjLkFycmF5Lmluc2VydC4gIERlZmF1bHRzXG4gKiB0byB0cnVlXG4gICAgIFxuICAgICBmdW5jdGlvbiBmbigpIHtcbiAgICAgICAgY29uc29sZS5sb2codGhpcylcbiAgICAgICAgY29uc29sZS5sb2coYXJndW1lbnRzKVxuICAgIH1cbiAgICBcbiAgICAvL0x1Yy5BcnJheS5pbnNlcnQoWzRdLCBbMSwyLDNdLCAwKVxuICAgIEx1Yy5GdW5jdGlvbi5jcmVhdGVBdWdtZW50ZXIoZm4sIHtcbiAgICAgICAgdGhpc0FyZzoge2NvbmZpZ2VkVGhpc0FyZzogdHJ1ZX0sXG4gICAgICAgIGFyZ3M6IFsxLDIsM10sXG4gICAgICAgIGluZGV4OjBcbiAgICB9KSg0KVxuXG4gICAgPk9iamVjdCB7Y29uZmlnZWRUaGlzQXJnOiB0cnVlfVxuICAgID5bMSwgMiwgMywgNF1cblxuICAgIC8vTHVjLkFycmF5Lmluc2VydChbMSwyLDNdLCBbNF0sIDApXG4gICAgTHVjLkZ1bmN0aW9uLmNyZWF0ZUF1Z21lbnRlcihmbiwge1xuICAgICAgICB0aGlzQXJnOiB7Y29uZmlnZWRUaGlzQXJnOiB0cnVlfSxcbiAgICAgICAgYXJnczogWzEsMiwzXSxcbiAgICAgICAgaW5kZXg6MCxcbiAgICAgICAgYXJndW1lbnRzRmlyc3Q6ZmFsc2VcbiAgICB9KSg0KVxuXG4gICAgPk9iamVjdCB7Y29uZmlnZWRUaGlzQXJnOiB0cnVlfVxuICAgID5bNCwgMSwgMiwgM11cblxuICAgIEx1Yy5BcnJheS5pbnNlcnQoWzRdLCBbMSwyLDNdLCAgdHJ1ZSlcbiAgICB2YXIgZiA9IEx1Yy5GdW5jdGlvbi5jcmVhdGVBdWdtZW50ZXIoZm4sIHtcbiAgICAgICAgYXJnczogWzEsMiwzXSxcbiAgICAgICAgaW5kZXg6IHRydWVcbiAgICB9KTtcblxuICAgIGYuYXBwbHkoe2NvbmZpZzogZmFsc2V9LCBbNF0pXG5cbiAgICA+T2JqZWN0IHtjb25maWc6IGZhbHNlfVxuICAgID5bNCwgMSwgMiwgM11cblxuICogQHJldHVybiB7RnVuY3Rpb259IHRoZSBhdWdtZW50ZWQgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydHMuY3JlYXRlQXVnbWVudGVyID0gZnVuY3Rpb24oZm4sIGNvbmZpZykge1xuICAgIHZhciB0aGlzQXJnID0gY29uZmlnLnRoaXNBcmc7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzQXJnIHx8IHRoaXMsIF9hdWdtZW50QXJncyhjb25maWcsIGFyZ3VtZW50cykpO1xuICAgIH07XG59O1xuXG5mdW5jdGlvbiBfaW5pdFNlcXVlbmNlRnVuY3Rpb25zKGZucywgY29uZmlnKSB7XG4gICAgdmFyIHRvUnVuID0gW107XG4gICAgYUVhY2goZm5zLCBmdW5jdGlvbihmKSB7XG4gICAgICAgIHZhciBmbiA9IGY7XG5cbiAgICAgICAgaWYgKGNvbmZpZykge1xuICAgICAgICAgICAgZm4gPSBleHBvcnRzLmNyZWF0ZUF1Z21lbnRlcihmLCBjb25maWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdG9SdW4ucHVzaChmbik7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdG9SdW47XG59XG5cbi8qKlxuICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBydW5zIHRoZSBwYXNzZWQgaW4gZnVuY3Rpb25zXG4gKiBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGZ1bmN0aW9uIGNhbGxlZC5cbiAqIFxuICogQHBhcmFtICB7RnVuY3Rpb25bXX0gZm5zIFxuICogQHBhcmFtICB7T2JqZWN0fSBbY29uZmlnXSBDb25maWcgb2JqZWN0XG4gKiBmb3IgTHVjLkZ1bmN0aW9uLmNyZWF0ZUF1Z21lbnRlci4gIElmIGRlZmluZWQgYWxsIG9mIHRoZSBmdW5jdGlvbnNcbiAqIHdpbGwgZ2V0IGNyZWF0ZWQgd2l0aCB0aGUgcGFzc2VkIGluIGNvbmZpZztcbiAqXG4gICAgTHVjLkZ1bmN0aW9uLmNyZWF0ZVNlcXVlbmNlKFtcbiAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygxKVxuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKDIpXG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coMylcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdmaW5pc2hlZCBsb2dnaW5nJylcbiAgICAgICAgICAgIHJldHVybiA0O1xuICAgICAgICB9XG4gICAgXSkoKVxuICAgID4xXG4gICAgPjJcbiAgICA+M1xuICAgID5maW5pc2hlZCBsb2dnaW5nXG4gICAgPjRcbiAqIFxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cbmV4cG9ydHMuY3JlYXRlU2VxdWVuY2UgPSBmdW5jdGlvbihmbnMsIGNvbmZpZykge1xuICAgIHZhciBmdW5jdGlvbnMgPSBfaW5pdFNlcXVlbmNlRnVuY3Rpb25zKGZucywgY29uZmlnKTtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgICAgbGVuID0gZnVuY3Rpb25zLmxlbmd0aDtcblxuICAgICAgICBmb3IoO2kgPCBsZW4gLTE7ICsraSkge1xuICAgICAgICAgICAgZnVuY3Rpb25zW2ldLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb25zW2xlbiAtMSBdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBydW5zIHRoZSBwYXNzZWQgaW4gZnVuY3Rpb25zXG4gKiBpZiBvbmUgb2YgdGhlIGZ1bmN0aW9ucyByZXN1bHRzIGZhbHNlIHRoZSByZXN0IG9mIHRoZSBcbiAqIGZ1bmN0aW9ucyB3b24ndCBydW4gYW5kIGZhbHNlIHdpbGwgYmUgcmV0dXJuZWQuXG4gKlxuICogSWYgbm8gZmFsc2UgaXMgcmV0dXJuZWQgdGhlIHZhbHVlIG9mIHRoZSBsYXN0IGZ1bmN0aW9uIHJldHVybiB3aWxsIGJlIHJldHVybmVkXG4gKiBcbiAgICBMdWMuRnVuY3Rpb24uY3JlYXRlU2VxdWVuY2VJZihbXG4gICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coMSlcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygyKVxuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKDMpXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnZmluaXNoZWQgbG9nZ2luZycpXG4gICAgICAgICAgICByZXR1cm4gNDtcbiAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2kgY2FudCBsb2cnKVxuICAgICAgICB9XG4gICAgXSkoKVxuXG4gICAgPjFcbiAgICA+MlxuICAgID4zXG4gICAgPmZpbmlzaGVkIGxvZ2dpbmdcbiAgICA+ZmFsc2VcbiAqXG4gKiBcbiAqIEBwYXJhbSAge0Z1bmN0aW9uW119IGZucyBcbiAqIEBwYXJhbSAge09iamVjdH0gW2NvbmZpZ10gQ29uZmlnIG9iamVjdFxuICogZm9yIEx1Yy5GdW5jdGlvbi5jcmVhdGVBdWdtZW50ZXIuICBJZiBkZWZpbmVkIGFsbCBvZiB0aGUgZnVuY3Rpb25zXG4gKiB3aWxsIGdldCBjcmVhdGVkIHdpdGggdGhlIHBhc3NlZCBpbiBjb25maWc7XG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuZXhwb3J0cy5jcmVhdGVTZXF1ZW5jZUlmID0gZnVuY3Rpb24oZm5zLCBjb25maWcpIHtcbiAgICB2YXIgZnVuY3Rpb25zID0gX2luaXRTZXF1ZW5jZUZ1bmN0aW9ucyhmbnMsIGNvbmZpZyk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZSxcbiAgICAgICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG5cbiAgICAgICAgZnVuY3Rpb25zLnNvbWUoZnVuY3Rpb24oZm4pe1xuICAgICAgICAgICAgdmFsdWUgPSBmbi5hcHBseSh0aGlzLCBhcmdzKTtcblxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID09PSBmYWxzZTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG59O1xuXG4vKipcbiAqIFJldHVybiBhIGZ1bmN0aW9ucyB0aGF0IHJ1bnMgdGhlIHBhc3NlZCBpbiBmdW5jdGlvbnNcbiAqIHRoZSByZXN1bHQgb2YgZWFjaCBmdW5jdGlvbiB3aWxsIGJlIHRoZSB0aGUgY2FsbCBhcmdzIFxuICogZm9yIHRoZSBuZXh0IGZ1bmN0aW9uLiAgVGhlIHZhbHVlIG9mIHRoZSBsYXN0IGZ1bmN0aW9uIFxuICogcmV0dXJuIHdpbGwgYmUgcmV0dXJuZWQuXG4gKiBcbiAgICAgXG4gICAgIEx1Yy5GdW5jdGlvbi5jcmVhdGVSZWxheWVyKFtcbiAgICAgICAgZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyICsgJ2InXG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgcmV0dXJuIHN0ciArICdjJ1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHIgKyAnZCdcbiAgICAgICAgfVxuICAgIF0pKCdhJylcblxuICAgID5cImFiY2RcIlxuXG4gKiBAcGFyYW0gIHtGdW5jdGlvbltdfSBmbnMgXG4gKiBAcGFyYW0gIHtPYmplY3R9IFtjb25maWddIENvbmZpZyBvYmplY3RcbiAqIGZvciBMdWMuRnVuY3Rpb24uY3JlYXRlQXVnbWVudGVyLiAgSWYgZGVmaW5lZCBhbGwgb2YgdGhlIGZ1bmN0aW9uc1xuICogd2lsbCBnZXQgY3JlYXRlZCB3aXRoIHRoZSBwYXNzZWQgaW4gY29uZmlnO1xuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cbmV4cG9ydHMuY3JlYXRlUmVsYXllciA9IGZ1bmN0aW9uKGZucywgY29uZmlnKSB7XG4gICAgdmFyIGZ1bmN0aW9ucyA9IF9pbml0U2VxdWVuY2VGdW5jdGlvbnMoZm5zLCBjb25maWcpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsdWUsXG4gICAgICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuXG4gICAgICAgIGZ1bmN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGZuLCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBmbi5hcHBseSh0aGlzLCBbdmFsdWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIHRocm90dGxlZCBmdW5jdGlvbiBmcm9tIHRoZSBwYXNzZWQgaW4gZnVuY3Rpb25cbiAqIHRoYXQgd2lsbCBvbmx5IGdldCBjYWxsZWQgb25jZSB0aGUgcGFzc2VkIG51bWJlciBvZiBtaWxpc2Vjb25kc1xuICogaGF2ZSBiZWVuIGV4Y2VlZGVkLlxuICogXG4gICAgdmFyIGxvZ0FyZ3MgID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGFyZ3VtZW50cylcbiAgICB9O1xuXG4gICAgdmFyIGEgPSBMdWMuRnVuY3Rpb24uY3JlYXRlVGhyb3R0bGVkKGxvZ0FyZ3MsIDEpO1xuXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IDEwMDsgKytpKSB7XG4gICAgICAgIGEoMSwyLDMpO1xuICAgIH1cblxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGEoMSlcbiAgICB9LCAxMDApXG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgYSgyKVxuICAgIH0sIDQwMClcblxuICAgID5bMSwgMiwgM11cbiAgICA+WzFdXG4gICAgPlsyXVxuICogXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSAge051bWJlcn0gbWlsbGlzIE51bWJlciBvZiBtaWxsaXNlY29uZHMgdG9cbiAqIHRocm90dGxlIHRoZSBmdW5jdGlvbi5cbiAqIEBwYXJhbSAge09iamVjdH0gW2NvbmZpZ10gQ29uZmlnIG9iamVjdFxuICogZm9yIEx1Yy5GdW5jdGlvbi5jcmVhdGVBdWdtZW50ZXIuICBJZiBkZWZpbmVkIGFsbCBvZiB0aGUgZnVuY3Rpb25zXG4gKiB3aWxsIGdldCBjcmVhdGVkIHdpdGggdGhlIHBhc3NlZCBpbiBjb25maWc7XG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuZXhwb3J0cy5jcmVhdGVUaHJvdHRsZWQgPSBmdW5jdGlvbihmLCBtaWxsaXMsIGNvbmZpZykge1xuICAgIHZhciBmbiA9IGNvbmZpZyA/IGV4cG9ydHMuY3JlYXRlQXVnbWVudGVyKGYsIGNvbmZpZykgOiBmLFxuICAgICAgICB0aW1lT3V0SWQgPSBmYWxzZTtcblxuICAgIGlmKCFtaWxsaXMpIHtcbiAgICAgICAgcmV0dXJuIGZuO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG5cbiAgICAgICAgaWYodGltZU91dElkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZU91dElkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRpbWVPdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aW1lT3V0SWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9LCBtaWxsaXMpO1xuICAgIH07XG59O1xuXG4vKipcbiAqIERlZmVyIGEgZnVuY3Rpb24ncyBleGVjdXRpb24gZm9yIHRoZSBwYXNzZWQgaW5cbiAqIG1pbGxpc2Vjb25kcy5cbiAqIFxuICogQHBhcmFtICB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG1pbGxpcyBOdW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvXG4gKiBkZWZlclxuICogQHBhcmFtICB7T2JqZWN0fSBbY29uZmlnXSBDb25maWcgb2JqZWN0XG4gKiBmb3IgTHVjLkZ1bmN0aW9uLmNyZWF0ZUF1Z21lbnRlci4gIElmIGRlZmluZWQgYWxsIG9mIHRoZSBmdW5jdGlvbnNcbiAqIHdpbGwgZ2V0IGNyZWF0ZWQgd2l0aCB0aGUgcGFzc2VkIGluIGNvbmZpZztcbiAqIFxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cbmV4cG9ydHMuY3JlYXRlRGVmZXJyZWQgPSBmdW5jdGlvbihmLCBtaWxsaXMsIGNvbmZpZykge1xuICAgIHZhciBmbiA9IGNvbmZpZyA/IGV4cG9ydHMuY3JlYXRlQXVnbWVudGVyKGYsIGNvbmZpZykgOiBmO1xuXG4gICAgaWYoIW1pbGxpcykge1xuICAgICAgICByZXR1cm4gZm47XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcblxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH0sIG1pbGxpcyk7XG4gICAgfTtcbn07IiwidmFyIGFycmF5ID0gcmVxdWlyZSgnLi9hcnJheScpLFxuICAgIGlzID0gcmVxdWlyZSgnLi9pcycpLFxuICAgIEdlbmVyYXRvcjtcblxuR2VuZXJhdG9yID0ge1xuICAgIGFycmF5Rm5OYW1lczogWydmaW5kRmlyc3ROb3QnLCAnZmluZEFsbE5vdCcsICdmaW5kRmlyc3QnLCAnZmluZEFsbCcsXG4gICAgICAgICAgICAncmVtb3ZlRmlyc3ROb3QnLCAncmVtb3ZlQWxsTm90JywgJ3JlbW92ZUZpcnN0JywgJ3JlbW92ZUFsbCcsXG4gICAgICAgICAgICAncmVtb3ZlTGFzdE5vdCcsICdyZW1vdmVMYXN0JywgJ2ZpbmRMYXN0JywgJ2ZpbmRMYXN0Tm90J1xuICAgIF0sXG5cbiAgICBjcmVhdGVGbjogZnVuY3Rpb24oYXJyYXlGbk5hbWUsIGZuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihhcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnJheVthcnJheUZuTmFtZV0oYXJyLCBmbik7XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGNyZWF0ZUJvdW5kRm46IGZ1bmN0aW9uKGFycmF5Rm5OYW1lLCBmblRvQmluZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oYXJyLCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGZuID0gZm5Ub0JpbmQuYXBwbHkodGhpcywgYXJyYXkuZnJvbUluZGV4KGFyZ3VtZW50cywgMSkpO1xuICAgICAgICAgICAgcmV0dXJuIGFycmF5W2FycmF5Rm5OYW1lXShhcnIsIGZuKTtcbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdlbmVyYXRvcjtcblxuLyoqXG4gKiBAY2xhc3MgTHVjLkFycmF5Rm5zXG4gKiBUaGlzIGlzIGRvY3VtZW50ZWQgYXMgYSBzZXBhcmF0ZSBwYWNrYWdlIGJ1dCBpdCBhY3R1YWxseSBleGlzdHMgdW5kZXIgdGhlIFxuICogTHVjLkFycmF5IG5hbWVzcGFjZS4gIENoZWNrIG91dCB0aGUgXCJGaWx0ZXIgY2xhc3MgbWVtYmVyc1wiIGlucHV0IGJveFxuICoganVzdCB0byB0aGUgcmlnaHQgd2hlbiBzZWFyY2hpbmcgZm9yIGZ1bmN0aW9ucy5cbiAqPGJyPlxuICogXG4gKiBUaGVyZSBhcmUgYSBsb3Qgb2YgZnVuY3Rpb25zIGluIHRoaXMgcGFja2FnZSBidXQgYWxsIG9mIHRoZW0gXG4gKiBmb2xsb3cgdGhlIHNhbWUgYXBpLiAgXFwqQWxsIGZ1bmN0aW9ucyB3aWxsIHJldHVybiBhbiBhcnJheSBvZiByZW1vdmVkIG9yIGZvdW5kXG4gKiBpdGVtcy4gIFRoZSBpdGVtcyB3aWxsIGJlIGFkZGVkIHRvIHRoZSBhcnJheSBpbiB0aGUgb3JkZXIgdGhleSBhcmVcbiAqIGZvdW5kLiAgXFwqRmlyc3QgZnVuY3Rpb25zIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBpdGVtIGFuZCBzdG9wIGl0ZXJhdGluZyBhZnRlciB0aGF0LCBpZiBub25lXG4gKiAgaXMgZm91bmQgZmFsc2UgaXMgcmV0dXJuZWQuICByZW1vdmVcXCogZnVuY3Rpb25zIHdpbGwgZGlyZWN0bHkgY2hhbmdlIHRoZSBwYXNzZWQgaW4gYXJyYXkuXG4gKiAgXFwqTm90IGZ1bmN0aW9ucyBvbmx5IGRvIHRoZSBmb2xsb3dpbmcgYWN0aW9ucyBpZiB0aGUgY29tcGFyaXNvbiBpcyBub3QgdHJ1ZS5cbiAqICBcXCpMYXN0IGZ1bmN0aW9ucyBkbyB0aGUgc2FtZSBhcyB0aGVpciBcXCpGaXJzdCBjb3VudGVycGFydHMgZXhjZXB0IHRoYXQgdGhlIGl0ZXJhdGluZ1xuICogIHN0YXJ0cyBhdCB0aGUgZW5kIG9mIHRoZSBhcnJheS4gQWxtb3N0IGV2ZXJ5IHB1YmxpYyBtZXRob2Qgb2YgTHVjLmlzIGlzIGF2YWlsYWJsZSBpdFxuICogIHVzZXMgdGhlIGZvbGxvd2luZyBncmFtbWFyIEx1Yy5BcnJheVtcIm1ldGhvZE5hbWVcIlwiaXNNZXRob2ROYW1lXCJdXG4gKlxuICAgICAgTHVjLkFycmF5LmZpbmRBbGxOb3RFbXB0eShbZmFsc2UsIHRydWUsIG51bGwsIHVuZGVmaW5lZCwgMCwgJycsIFtdLCBbMV1dKVxuICAgICAgPiBbdHJ1ZSwgMCwgWzFdXVxuXG4gICAgICBMdWMuQXJyYXkuZmluZEFsbE5vdEZhbHN5KFtmYWxzZSwgdHJ1ZSwgbnVsbCwgdW5kZWZpbmVkLCAwLCAnJywgW10sIFsxXV0pXG4gICAgICA+IFt0cnVlLCAwLCBbXSwgWzFdXVxuICAgICBcbiAgICAgIEx1Yy5BcnJheS5maW5kRmlyc3ROb3RTdHJpbmcoWzEsMiwzLCc1J10pXG4gICAgICA+MVxuICAgICAgdmFyIGFyciA9IFsxLDIsMywnNSddO1xuICAgICAgTHVjLkFycmF5LnJlbW92ZUFsbE5vdFN0cmluZyhhcnIpO1xuICAgICAgPlsxLDIsM11cbiAgICAgIGFyclxuICAgICAgPltcIjVcIl1cbiAqXG4gKiBBcyBvZiByaWdodCBub3cgdGhlcmUgYXJlIHR3byBmdW5jdGlvbiBzZXRzIHdoaWNoIGRpZmZlciBmcm9tIHRoZSBpc1xuICogYXBpLlxuICpcbiAqIEluc3RhbmNlT2ZcbiAqIFxuICAgIEx1Yy5BcnJheS5maW5kQWxsSW5zdGFuY2VPZihbMSwyLCBuZXcgRGF0ZSgpLCB7fSwgW11dLCBPYmplY3QpXG4gICAgPltkYXRlLCB7fSwgW11dXG4gICAgPkx1Yy5BcnJheS5maW5kQWxsTm90SW5zdGFuY2VPZihbMSwyLCBuZXcgRGF0ZSgpLCB7fSwgW11dLCBPYmplY3QpXG4gICAgWzEsIDJdXG4gKlxuICogSW5cbiAqIFxuICAgIEx1Yy5BcnJheS5maW5kQWxsSW4oWzEsMiwzXSwgWzEsMl0pXG4gICAgPlsxLCAyXVxuICAgIEx1Yy5BcnJheS5maW5kRmlyc3RJbihbMSwyLDNdLCBbMSwyXSlcbiAgICA+MVxuXG4gICAgLy9kZWZhdWx0cyB0byBsb29zZSBjb21wYXJpc29uXG4gICAgTHVjLkFycmF5LmZpbmRBbGxJbihbMSwyLDMsIHthOjEsIGI6Mn1dLCBbMSx7YToxfV0pXG4gICAgPiBbMSwge2E6MSxiOjJ9XVxuXG4gICAgTHVjLkFycmF5LmZpbmRBbGxJbihbMSwyLDMsIHthOjEsIGI6Mn1dLCBbMSx7YToxfV0sIHt0eXBlOiAnZGVlcCd9KVxuICAgID5bMV1cbiAqL1xuXG4oZnVuY3Rpb24gX2NyZWF0ZUlzRm5zKCkge1xuICAgIHZhciBpc1RvSWdub3JlID0gWydpc1JlZ0V4cCcsICdpc0FyZ3VtZW50cyddO1xuXG4gICAgT2JqZWN0LmtleXMoaXMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHZhciBuYW1lID0ga2V5LnNwbGl0KCdpcycpWzFdO1xuICAgICAgICBHZW5lcmF0b3IuYXJyYXlGbk5hbWVzLmZvckVhY2goZnVuY3Rpb24oZm5OYW1lKSB7XG4gICAgICAgICAgICBpZihpc1RvSWdub3JlLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBhcnJheVtmbk5hbWUgKyBuYW1lXSA9IEdlbmVyYXRvci5jcmVhdGVGbihmbk5hbWUsIGlzW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn0oKSk7XG5cbihmdW5jdGlvbiBfY3JlYXRlRmFsc3lGbnMoKSB7XG4gICAgdmFyIHVzZWZ1bGxGYWxzeUZucyA9IFsnZmluZEZpcnN0Tm90JywgJ2ZpbmRBbGxOb3QnLCAncmVtb3ZlRmlyc3ROb3QnLCAncmVtb3ZlQWxsTm90JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAncmVtb3ZlRmlyc3QnLCAncmVtb3ZlQWxsJywgJ3JlbW92ZUxhc3ROb3QnLCAncmVtb3ZlTGFzdCcsICAnZmluZExhc3ROb3QnXTtcblxuICAgIHZhciBmbnMgPSB7XG4gICAgICAgICdGYWxzZSc6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbCA9PT0gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgICdUcnVlJzogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsID09PSB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICAnTnVsbCc6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbCA9PT0gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgJ1VuZGVmaW5lZCc6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbCA9PT0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIE9iamVjdC5rZXlzKGZucykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdXNlZnVsbEZhbHN5Rm5zLmZvckVhY2goZnVuY3Rpb24oZm5OYW1lKSB7XG4gICAgICAgICAgICBhcnJheVtmbk5hbWUgKyBrZXldID0gR2VuZXJhdG9yLmNyZWF0ZUZuKGZuTmFtZSwgZm5zW2tleV0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn0oKSk7XG5cbihmdW5jdGlvbiBfY3JlYXRlQm91bmRGbnMoKSB7XG4gICAgdmFyIGZucyA9IHtcbiAgICAgICAgJ0luc3RhbmNlT2YnOiBmdW5jdGlvbihDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sJ0luJzogZnVuY3Rpb24oYXJyLCBjKSB7XG4gICAgICAgICAgICB2YXIgZGVmYXVsdEMgPSB7dHlwZTonbG9vc2VSaWdodCd9O1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYodmFsdWUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjZmcgPSBjIHx8IGRlZmF1bHRDO1xuICAgICAgICAgICAgICAgICAgICAvL3RoaXMgaXMgYSByaWdodCB0byBsZWZ0IGNvbXBhcmlzb24gXG4gICAgICAgICAgICAgICAgICAgIC8vZXhwZWN0ZWQgbG9vc2UgYmVoYXZpb3Igc2hvdWxkIGJlIGxvb3NlUmlnaHRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5LmZpbmRGaXJzdChhcnIsIHZhbHVlLCBjZmcudHlwZSA9PT0gJ2xvb3NlJyA/IGRlZmF1bHRDIDogY2ZnKSAhPT0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiBhcnIuaW5kZXhPZihmYWxzZSkgPiAtMTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgT2JqZWN0LmtleXMoZm5zKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICBHZW5lcmF0b3IuYXJyYXlGbk5hbWVzLmZvckVhY2goZnVuY3Rpb24oZm5OYW1lKSB7XG4gICAgICAgICAgICBhcnJheVtmbk5hbWUgKyBrZXldID0gR2VuZXJhdG9yLmNyZWF0ZUJvdW5kRm4oZm5OYW1lLCBmbnNba2V5XSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufSgpKTsiLCJ2YXIgaXMgPSByZXF1aXJlKCcuL2lzJyk7XG5cbmZ1bmN0aW9uIF9zdHJpY3QodmFsMSwgdmFsMil7XG4gICAgcmV0dXJuIHZhbDEgPT09IHZhbDI7XG59XG5cbmZ1bmN0aW9uIF9jb21wYXJlQXJyYXlMZW5ndGgodmFsMSwgdmFsMikge1xuICAgIHJldHVybihpcy5pc0FycmF5KHZhbDEpICYmIGlzLmlzQXJyYXkodmFsMikgICYmIHZhbDEubGVuZ3RoID09PSB2YWwyLmxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIF9zaGFsbG93QXJyYXkodmFsMSwgdmFsMikge1xuICAgIHZhciBpID0gMCxcbiAgICAgICAgbGVuO1xuICAgIFxuICAgIGlmKCFfY29tcGFyZUFycmF5TGVuZ3RoKHZhbDEsIHZhbDIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IobGVuID0gdmFsMS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBpZih2YWwxW2ldICE9PSB2YWwyW2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gX2RlZXBBcnJheSh2YWwxLCB2YWwyLCBjb25maWcpIHtcbiAgICB2YXIgaSA9IDAsXG4gICAgICAgIGxlbjtcbiAgICBcbiAgICBpZighX2NvbXBhcmVBcnJheUxlbmd0aCh2YWwxLCB2YWwyKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yKGxlbiA9IHZhbDEubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgaWYoIWNvbXBhcmUodmFsMVtpXSx2YWwyW2ldLCBjb25maWcpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gX2NvbXBhcmVPYmplY3RLZXlzTGVuZ3RoKHZhbDEsIHZhbDIpIHtcbiAgICByZXR1cm4gKGlzLmlzT2JqZWN0KHZhbDEpICYmIGlzLmlzT2JqZWN0KHZhbDIpICYmIE9iamVjdC5rZXlzKHZhbDEpLmxlbmd0aCA9PT0gT2JqZWN0LmtleXModmFsMikubGVuZ3RoKTtcbn1cblxuZnVuY3Rpb24gX3NoYWxsb3dPYmplY3QodmFsMSwgdmFsMikge1xuICAgIHZhciBrZXksIHZhbDtcblxuICAgIGlmICghX2NvbXBhcmVPYmplY3RLZXlzTGVuZ3RoKHZhbDEsIHZhbDIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKGtleSBpbiB2YWwxKSB7XG4gICAgICAgIGlmICh2YWwxLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsMVtrZXldO1xuICAgICAgICAgICAgaWYgKCF2YWwyLmhhc093blByb3BlcnR5KGtleSkgfHwgdmFsMltrZXldICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBfZGVlcE9iamVjdCh2YWwxLCB2YWwyLCBjb25maWcpIHtcbiAgICB2YXIga2V5LCB2YWw7XG5cbiAgICBpZiAoIV9jb21wYXJlT2JqZWN0S2V5c0xlbmd0aCh2YWwxLCB2YWwyKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yIChrZXkgaW4gdmFsMSkge1xuICAgICAgICBpZiAodmFsMS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbDFba2V5XTtcbiAgICAgICAgICAgIGlmICghdmFsMi5oYXNPd25Qcm9wZXJ0eShrZXkpIHx8IGNvbXBhcmUodmFsdWUsIHZhbDJba2V5XSwgY29uZmlnKSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuXG59XG5cbmZ1bmN0aW9uIF9sb29zZU9iamVjdCh2YWwxLCB2YWwyLCBjb25maWcpIHtcbiAgICB2YXIga2V5LCB2YWw7XG5cbiAgICBpZighKGlzLmlzT2JqZWN0KHZhbDEpICYmIGlzLmlzT2JqZWN0KHZhbDIpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYoY29uZmlnLnR5cGUgPT09ICdsb29zZVJpZ2h0Jykge1xuICAgICAgICBmb3IgKGtleSBpbiB2YWwyKSB7XG4gICAgICAgICAgICBpZiAodmFsMi5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWwyW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBhcmUodmFsdWUsIHZhbDFba2V5XSwgY29uZmlnKSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmb3IgKGtleSBpbiB2YWwxKSB7XG4gICAgICAgICAgICBpZiAodmFsMS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWwxW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBhcmUodmFsdWUsIHZhbDJba2V5XSwgY29uZmlnKSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICByZXR1cm4gdHJ1ZTtcblxufVxuXG5mdW5jdGlvbiBfZGF0ZSh2YWwxLCB2YWwyKSB7XG4gICAgaWYoaXMuaXNEYXRlKHZhbDEpICYmIGlzLmlzRGF0ZSh2YWwyKSkge1xuICAgICAgICByZXR1cm4gdmFsMS5nZXRUaW1lKCkgPT09IHZhbDIuZ2V0VGltZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUJvdW5kQ29tcGFyZShvYmplY3QsIGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBmbihvYmplY3QsIHZhbHVlKTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBnZXRDb21wYXJlRm4ob2JqZWN0LCBjKSB7XG4gICAgdmFyIGNvbXBhcmVGbiA9IF9zdHJpY3QsXG4gICAgICAgIGNvbmZpZyA9IGMgfHwge30sXG4gICAgICAgIHR5cGUgPSBjb25maWcudHlwZTtcblxuICAgIGlmICh0eXBlID09PSAnZGVlcCcgfHwgdHlwZSA9PT0gJ2xvb3NlJyB8fCB0eXBlID09PSAnbG9vc2VSaWdodCcgfHwgdHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChpcy5pc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgICAgICBjb21wYXJlRm4gPSB0eXBlID09PSAnbG9vc2UnIHx8IHR5cGUgPT09ICdsb29zZVJpZ2h0JyA/IF9sb29zZU9iamVjdCA6IF9kZWVwT2JqZWN0O1xuICAgICAgICB9IGVsc2UgaWYgKGlzLmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgICAgICAgY29tcGFyZUZuID0gX2RlZXBBcnJheTtcbiAgICAgICAgfSBlbHNlIGlmIChpcy5pc0RhdGUob2JqZWN0KSkge1xuICAgICAgICAgICAgY29tcGFyZUZuID0gX2RhdGU7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzaGFsbG93Jykge1xuICAgICAgICBpZiAoaXMuaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICAgICAgY29tcGFyZUZuID0gX3NoYWxsb3dPYmplY3Q7XG4gICAgICAgIH0gZWxzZSBpZiAoaXMuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgICAgICBjb21wYXJlRm4gPSBfc2hhbGxvd0FycmF5O1xuICAgICAgICB9IGVsc2UgaWYgKGlzLmlzRGF0ZShvYmplY3QpKSB7XG4gICAgICAgICAgICBjb21wYXJlRm4gPSBfZGF0ZTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gJ3N0cmljdCcpIHtcbiAgICAgICAgLy93ZSB3b3VsZCBiZSBkb2luZyBhIHN0cmljdCBjb21wYXJpc29uIG9uIGEgdHlwZS1vXG4gICAgICAgIC8vSSB0aGluayBhbiBlcnJvciBpcyBnb29kIGhlcmUuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IHBhc3NlZCBpbiBhbiBpbnZhbGlkIGNvbXBhcmlzb24gdHlwZScpO1xuICAgIH1cblxuICAgIHJldHVybiBjb21wYXJlRm47XG59XG5cbi8qKlxuICogQG1lbWJlciBMdWNcbiAqIEBtZXRob2QgY29tcGFyZVxuICogXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWVzIGFyZSBlcXVhbCB0byBlYWNoXG4gKiBvdGhlci4gIEJ5IGRlZmF1bHQgYSBkZWVwIGNvbXBhcmlzb24gaXMgXG4gKiBkb25lIG9uIGFycmF5cywgZGF0ZXMgYW5kIG9iamVjdHMgYW5kIGEgc3RyaWN0IGNvbXBhcmlzb25cbiAqIGlzIGRvbmUgb24gb3RoZXIgdHlwZXMuXG4gKiBcbiAqIEBwYXJhbSAge0FueX0gdmFsMSAgXG4gKiBAcGFyYW0gIHtBbnl9IHZhbDIgICBcbiAqIEBwYXJhbSAge09iamVjdH0gW2NvbmZpZ11cbiAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcudHlwZSBwYXNzIGluICdzaGFsbG93JyBmb3IgYSBzaGFsbG93XG4gKiBjb21wYXJpc29uLCAnZGVlcCcgKGRlZmF1bHQpIGZvciBhIGRlZXAgY29tcGFyaXNvblxuICogJ3N0cmljdCcgZm9yIGEgc3RyaWN0ID09PSBjb21wYXJpc29uIGZvciBhbGwgb2JqZWN0cyBvciBcbiAqICdsb29zZScgZm9yIGEgbG9vc2UgY29tcGFyaXNvbiBvbiBvYmplY3RzLiAgQSBsb29zZSBjb21wYXJpc29uXG4gKiAgd2lsbCBjb21wYXJlIHRoZSBrZXlzIGFuZCB2YWx1ZXMgb2YgdmFsMSB0byB2YWwyIGFuZCBkb2VzIG5vdFxuICogIGNoZWNrIGlmIGtleXMgZnJvbSB2YWwyIGRvIG5vdCBleGlzdCBpbiB2YWwxLlxuICpcbiAqXG4gICAgTHVjLmNvbXBhcmUoJzEnLCAxKVxuICAgID5mYWxzZVxuICAgIEx1Yy5jb21wYXJlKHthOiAxfSwge2E6IDF9KVxuICAgID50cnVlXG4gICAgTHVjLmNvbXBhcmUoe2E6IDEsIGI6IHt9fSwge2E6IDEsIGI6IHt9IH0sIHt0eXBlOidzaGFsbG93J30pXG4gICAgPmZhbHNlXG4gICAgTHVjLmNvbXBhcmUoe2E6IDEsIGI6IHt9fSwge2E6IDEsIGI6IHt9IH0sIHt0eXBlOiAnZGVlcCd9KVxuICAgID50cnVlXG4gICAgTHVjLmNvbXBhcmUoe2E6IDEsIGI6IHt9fSwge2E6IDEsIGI6IHt9IH0sIHt0eXBlOiAnc3RyaWN0J30pXG4gICAgPmZhbHNlXG4gICAgTHVjLmNvbXBhcmUoe2E6IDF9LCB7YToxLGI6MX0pXG4gICAgPmZhbHNlXG4gICAgTHVjLmNvbXBhcmUoe2E6IDF9LCB7YToxLGI6MX0sIHt0eXBlOiAnbG9vc2UnfSlcbiAgICA+dHJ1ZVxuICAgIEx1Yy5jb21wYXJlKHthOiAxfSwge2E6MSxiOjF9LCB7dHlwZTogJ2xvb3NlJ30pXG4gICAgPnRydWVcbiAgICBMdWMuY29tcGFyZShbe2E6IDF9XSwgW3thOjEsYjoxfV0sIHt0eXBlOiAnbG9vc2UnfSlcbiAgICA+dHJ1ZVxuICAgIEx1Yy5jb21wYXJlKFt7YTogMX0sIHt9XSwgW3thOjEsYjoxfV0sIHt0eXBlOiAnbG9vc2UnfSlcbiAgICA+ZmFsc2VcbiAgICBMdWMuY29tcGFyZShbe2E6IDF9LCB7fV0sIFt7YToxLGI6MX0sIHt9XSwge3R5cGU6ICdsb29zZSd9KVxuICAgID50cnVlXG4gICAgTHVjLmNvbXBhcmUoW3thOjEsYjoxfV0sIFt7YTogMX1dLCB7dHlwZTogJ2xvb3NlJ30pXG4gICAgPmZhbHNlXG5cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmUodmFsMSwgdmFsMiwgY29uZmlnKSB7XG4gICAgcmV0dXJuIGdldENvbXBhcmVGbih2YWwxLCBjb25maWcpKHZhbDEsIHZhbDIsIGNvbmZpZyk7XG59XG5cblxuZnVuY3Rpb24gY3JlYXRlQm91bmRDb21wYXJlRm4ob2JqZWN0LCBjKSB7XG4gICAgdmFyIGNvbXBhcmVGbiA9IGdldENvbXBhcmVGbihvYmplY3QsIGMpO1xuXG4gICAgcmV0dXJuIF9jcmVhdGVCb3VuZENvbXBhcmUob2JqZWN0LCBjb21wYXJlRm4pO1xufVxuXG5leHBvcnRzLmNvbXBhcmUgPSBjb21wYXJlO1xuZXhwb3J0cy5jcmVhdGVCb3VuZENvbXBhcmVGbiA9IGNyZWF0ZUJvdW5kQ29tcGFyZUZuOyIsInZhciBlbXB0eUZuID0gcmVxdWlyZSgnLi4vZnVuY3Rpb24nKS5lbXB0eUZuLFxuICAgIGFwcGx5ID0gcmVxdWlyZSgnLi4vb2JqZWN0JykuYXBwbHk7XG5cbi8qKlxuICogQGNsYXNzIEx1Yy5CYXNlXG4gKiBTaW1wbGUgY2xhc3MgdGhhdCBieSBkZWZhdWx0IHtAbGluayBMdWMjYXBwbHkgYXBwbGllc30gdGhlIFxuICogZmlyc3QgYXJndW1lbnQgdG8gdGhlIGluc3RhbmNlIGFuZCB0aGVuIGNhbGxzXG4gKiBMdWMuQmFzZS5pbml0LlxuICpcbiAgICB2YXIgYiA9IG5ldyBMdWMuQmFzZSh7XG4gICAgICAgIGE6IDEsXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2hleScpXG4gICAgICAgIH1cbiAgICB9KVxuICAgIGIuYVxuICAgID5oZXlcbiAgICA+MVxuICpcbiAqIFdlIGZvdW5kIHRoYXQgbW9zdCBvZiBvdXIgY2xhc3NlcyBkbyB0aGlzIHNvIHdlIG1hZGVcbiAqIGl0IHRoZSBkZWZhdWx0LiAgSGF2aW5nIGEgY29uZmlnIG9iamVjdCBhcyB0aGUgZmlyc3QgYW5kIG9ubHkgXG4gKiBwYXJhbSBrZWVwcyBhIGNsZWFuIGFwaSBhcyB3ZWxsLlxuICpcbiAgICB2YXIgQyA9IEx1Yy5kZWZpbmUoe1xuICAgICAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIEx1Yy5BcnJheS5lYWNoKHRoaXMuaXRlbXMsIHRoaXMubG9nSXRlbXMpXG4gICAgICAgIH0sXG5cbiAgICAgICAgbG9nSXRlbXM6IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgYyA9IG5ldyBDKHtpdGVtczogWzEsMiwzXX0pO1xuICAgID4xXG4gICAgPjJcbiAgICA+M1xuICAgIHZhciBkID0gbmV3IEMoe2l0ZW1zOiAnQSd9KTtcbiAgICA+J0EnXG4gICAgdmFyIGUgPSBuZXcgQygpO1xuICpcbiAqIElmIHlvdSBkb24ndCBsaWtlIHRoZSBhcHBseWluZyBvZiB0aGUgY29uZmlnIHRvIHRoZSBpbnN0YW5jZSBpdCBcbiAqIGNhbiBhbHdheXMgYmUgXCJkaXNhYmxlZFwiXG4gKlxuICAgIHZhciBOb0FwcGx5ID0gTHVjLmRlZmluZSh7XG4gICAgICAgIGJlZm9yZUluaXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIH0sXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgTHVjLkFycmF5LmVhY2godGhpcy5pdGVtcywgdGhpcy5sb2dJdGVtcylcbiAgICAgICAgfSxcblxuICAgICAgICBsb2dJdGVtczogZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coaXRlbSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBjID0gbmV3IE5vQXBwbHkoe2l0ZW1zOiBbMSwyLDNdfSk7XG4gKiBcbiAqL1xuZnVuY3Rpb24gQmFzZSgpIHtcbiAgICB0aGlzLmJlZm9yZUluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0aGlzLmluaXQoKTtcbn1cblxuQmFzZS5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQnkgZGVmYXVsdCBhcHBseSB0aGUgY29uZmlnIHRvIHRoZSBcbiAgICAgKiBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBiZWZvcmVJbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgYXBwbHkodGhpcywgY29uZmlnKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBtZXRob2RcbiAgICAgKiBTaW1wbGUgaG9vayB0byBpbml0aWFsaXplXG4gICAgICogdGhlIGNsYXNzLiAgRGVmYXVsdHMgdG8gTHVjLmVtcHR5Rm5cbiAgICAgKi9cbiAgICBpbml0OiBlbXB0eUZuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2U7IiwidmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKSxcbiAgICBDb21wb3NpdGlvbiA9IHJlcXVpcmUoJy4vY29tcG9zaXRpb24nKSxcbiAgICBvYmogPSByZXF1aXJlKCcuLi9vYmplY3QnKSxcbiAgICBhcnJheUZucyA9IHJlcXVpcmUoJy4uL2FycmF5JyksXG4gICAgZW1wdHlGbiA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9uJykuZW1wdHlGbixcbiAgICBpcyA9IHJlcXVpcmUoJy4uL2lzJyksXG4gICAgYUVhY2ggPSBhcnJheUZucy5lYWNoLFxuICAgIGFwcGx5ID0gb2JqLmFwcGx5LFxuICAgIG9FYWNoID0gb2JqLmVhY2gsXG4gICAgb0ZpbHRlciA9IG9iai5maWx0ZXIsXG4gICAgbWl4ID0gb2JqLm1peCxcbiAgICBhcnJheVNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLFxuICAgIENsYXNzRGVmaW5lcjtcblxuLyoqXG4gKiBAY2xhc3MgTHVjLkNsYXNzRGVmaW5lclxuICogQHNpbmdsZXRvblxuICpcbiAqIFNpbmdsZXRvbiB0aGF0IHtAbGluayBMdWMuZGVmaW5lI2RlZmluZSBMdWMuZGVmaW5lfSB1c2VzIHRvIGRlZmluZSBjbGFzc2VzLiAgVGhlIGRlZnVhbHQgdHlwZSBjYW5cbiAqIGJlIGNoYW5nZWQgdG8gYW55IENvbnN0cnVjdG9yXG4gKlxuICAgIGZ1bmN0aW9uIE15Q2xhc3MoKXt9O1xuICAgIEx1Yy5DbGFzc0RlZmluZXIuZGVmYXVsdFR5cGUgPSBNeUNsYXNzO1xuICAgIHZhciBDID0gTHVjLmRlZmluZSgpO1xuICAgIG5ldyBDKCkgaW5zdGFuY2VvZiBMdWMuQmFzZVxuICAgID5mYWxzZVxuICAgIG5ldyBDKCkgaW5zdGFuY2VvZiBNeUNsYXNzXG4gICAgPnRydWVcbiAqL1xuXG4vKipcbiAqIEBjZmcge0Z1bmN0aW9ufSBkZWZhdWx0VHlwZSB0aGlzIGNhbiBiZSBjaGFuZ2VkIHRvIGFueSBDb25zdHJ1Y3Rvci4gIERlZmF1bHRzXG4gKiB0byBMdWMuQmFzZS5cbiAqL1xuXG5DbGFzc0RlZmluZXIgPSB7XG5cbiAgICBDT01QT1NJVElPTlNfTkFNRTogJyRjb21wb3NpdGlvbnMnLFxuXG4gICAgZGVmYXVsdFR5cGU6IEJhc2UsXG5cbiAgICBwcm9jZXNzb3JLZXlzOiB7XG4gICAgICAgICRtaXhpbnM6ICdfYXBwbHlNaXhpbnMnLFxuICAgICAgICAkc3RhdGljczogJ19hcHBseVN0YXRpY3MnLFxuICAgICAgICAkY29tcG9zaXRpb25zOiAnX2FwcGx5Q29tcG9zZXJNZXRob2RzJyxcbiAgICAgICAgJHN1cGVyOiAnX2FwcGx5U3VwZXInXG4gICAgfSxcblxuICAgIGRlZmluZTogZnVuY3Rpb24ob3B0cykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IG9wdHMgfHwge30sXG4gICAgICAgICAgICAvL2lmIHN1cGVyIGlzIGEgZmFsc3kgdmFsdWUgYmVzaWRlcyB1bmRlZmluZWQgdGhhdCBtZWFucyBubyBzdXBlcmNsYXNzXG4gICAgICAgICAgICBTdXBlciA9IG9wdGlvbnMuJHN1cGVyIHx8IChvcHRpb25zLiRzdXBlciA9PT0gdW5kZWZpbmVkID8gdGhpcy5kZWZhdWx0VHlwZSA6IGZhbHNlKSxcbiAgICAgICAgICAgIENvbnN0cnVjdG9yO1xuXG4gICAgICAgIG9wdGlvbnMuJHN1cGVyID0gU3VwZXI7XG5cbiAgICAgICAgQ29uc3RydWN0b3IgPSB0aGlzLl9jcmVhdGVDb25zdHJ1Y3RvcihvcHRpb25zKTtcblxuICAgICAgICB0aGlzLl9wcm9jZXNzQWZ0ZXJDcmVhdGUoQ29uc3RydWN0b3IsIG9wdGlvbnMpO1xuXG4gICAgICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgICB9LFxuXG4gICAgX2NyZWF0ZUNvbnN0cnVjdG9yOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBzdXBlcmNsYXNzID0gb3B0aW9ucy4kc3VwZXIsXG4gICAgICAgICAgICBDb25zdHJ1Y3RvciA9IHRoaXMuX2NyZWF0ZUNvbnN0cnVjdG9yRm4ob3B0aW9ucyk7XG5cbiAgICAgICAgaWYoc3VwZXJjbGFzcykge1xuICAgICAgICAgICAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlcmNsYXNzLnByb3RvdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgICB9LFxuXG4gICAgX2NyZWF0ZUNvbnN0cnVjdG9yRm46IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHN1cGVyY2xhc3MgPSBvcHRpb25zLiRzdXBlcixcbiAgICAgICAgICAgIENvbnN0cnVjdG9yO1xuXG4gICAgICAgIGlmICh0aGlzLl9oYXNDb25zdHJ1Y3Rvck1vZGlmeWluZ09wdGlvbnMob3B0aW9ucykpIHtcbiAgICAgICAgICAgIENvbnN0cnVjdG9yID0gdGhpcy5fY3JlYXRlQ29uc3RydWN0b3JGcm9tT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKCFzdXBlcmNsYXNzKSB7XG4gICAgICAgICAgICBDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKCkge307XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHN1cGVyY2xhc3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gICAgfSxcblxuICAgIF9oYXNDb25zdHJ1Y3Rvck1vZGlmeWluZ09wdGlvbnM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuJGNvbXBvc2l0aW9ucztcbiAgICB9LFxuXG4gICAgX2NyZWF0ZUNvbnN0cnVjdG9yRnJvbU9wdGlvbnM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHN1cGVyY2xhc3MgPSBvcHRpb25zLiRzdXBlcixcbiAgICAgICAgICAgIG1lID0gdGhpcyxcbiAgICAgICAgICAgIGluaXRCZWZvcmVTdXBlcmNsYXNzLFxuICAgICAgICAgICAgaW5pdEFmdGVyU3VwZXJjbGFzcyxcbiAgICAgICAgICAgIGluaXQ7XG5cbiAgICAgICAgaWYgKCFzdXBlcmNsYXNzKSB7XG4gICAgICAgICAgICBpbml0ID0gdGhpcy5fY3JlYXRlSW5pdENsYXNzRm4ob3B0aW9ucywge1xuICAgICAgICAgICAgICAgIGFsbDogdHJ1ZVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGFycmF5U2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIGluaXQuY2FsbCh0aGlzLCBvcHRpb25zLCBhcmdzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpbml0QmVmb3JlU3VwZXJjbGFzcyA9IHRoaXMuX2NyZWF0ZUluaXRDbGFzc0ZuKG9wdGlvbnMsIHtcbiAgICAgICAgICAgIGJlZm9yZTogdHJ1ZVxuICAgICAgICB9KTtcblxuICAgICAgICBpbml0QWZ0ZXJTdXBlcmNsYXNzID0gdGhpcy5fY3JlYXRlSW5pdENsYXNzRm4ob3B0aW9ucywge1xuICAgICAgICAgICAgYmVmb3JlOiBmYWxzZVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IGFycmF5U2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICBpbml0QmVmb3JlU3VwZXJjbGFzcy5jYWxsKHRoaXMsIG9wdGlvbnMsIGFyZ3MpO1xuICAgICAgICAgICAgc3VwZXJjbGFzcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgaW5pdEFmdGVyU3VwZXJjbGFzcy5jYWxsKHRoaXMsIG9wdGlvbnMsIGFyZ3MpO1xuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBfY3JlYXRlSW5pdENsYXNzRm46IGZ1bmN0aW9uKG9wdGlvbnMsIGNvbmZpZykge1xuICAgICAgICB2YXIgbWUgPSB0aGlzLFxuICAgICAgICAgICAgY29tcG9zaXRpb25zID0gdGhpcy5fZmlsdGVyQ29tcG9zaXRpb25zKGNvbmZpZywgb3B0aW9ucy4kY29tcG9zaXRpb25zKTtcblxuICAgICAgICBpZihjb21wb3NpdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZW1wdHlGbjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9wdGlvbnMsIGluc3RhbmNlQXJncykge1xuICAgICAgICAgICAgbWUuX2luaXRDb21wb3NpdGlvbnMuY2FsbCh0aGlzLCBjb21wb3NpdGlvbnMsIGluc3RhbmNlQXJncyk7XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIF9maWx0ZXJDb21wb3NpdGlvbnM6IGZ1bmN0aW9uKGNvbmZpZywgY29tcG9zaXRpb25zKSB7XG4gICAgICAgIHZhciBiZWZvcmUgPSBjb25maWcuYmVmb3JlLCBcbiAgICAgICAgICAgIGZpbHRlcmVkID0gW107XG5cbiAgICAgICAgaWYoY29uZmlnLmFsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBvc2l0aW9ucztcbiAgICAgICAgfVxuXG4gICAgICAgIGFFYWNoKGNvbXBvc2l0aW9ucywgZnVuY3Rpb24oY29tcG9zaXRpb24pIHtcbiAgICAgICAgICAgIGlmKGJlZm9yZSAmJiBjb21wb3NpdGlvbi5pbml0QWZ0ZXIgIT09IHRydWUgfHwgKCFiZWZvcmUgJiYgY29tcG9zaXRpb24uaW5pdEFmdGVyID09PSB0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZC5wdXNoKGNvbXBvc2l0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGZpbHRlcmVkO1xuICAgIH0sXG5cbiAgICBfcHJvY2Vzc0FmdGVyQ3JlYXRlOiBmdW5jdGlvbigkY2xhc3MsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fYXBwbHlWYWx1ZXNUb1Byb3RvKCRjbGFzcywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX2hhbmRsZVBvc3RQcm9jZXNzb3JzKCRjbGFzcywgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIF9hcHBseVZhbHVlc1RvUHJvdG86IGZ1bmN0aW9uKCRjbGFzcywgb3B0aW9ucykge1xuICAgICAgICB2YXIgcHJvdG8gPSAkY2xhc3MucHJvdG90eXBlLFxuICAgICAgICAgICAgdmFsdWVzID0gYXBwbHkoe1xuICAgICAgICAgICAgICAgICRjbGFzczogJGNsYXNzXG4gICAgICAgICAgICB9LCBvcHRpb25zKTtcblxuICAgICAgICAvL0Rvbid0IHB1dCB0aGUgZGVmaW5lIHNwZWNpZmljIHByb3BlcnRpZXNcbiAgICAgICAgLy9vbiB0aGUgcHJvdG90eXBlXG4gICAgICAgIG9FYWNoKHZhbHVlcywgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9nZXRQcm9jZXNzb3JLZXkoa2V5KSkge1xuICAgICAgICAgICAgICAgIHByb3RvW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfSxcblxuICAgIF9nZXRQcm9jZXNzb3JLZXk6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzb3JLZXlzW2tleV07XG4gICAgfSxcblxuICAgIF9oYW5kbGVQb3N0UHJvY2Vzc29yczogZnVuY3Rpb24oJGNsYXNzLCBvcHRpb25zKSB7XG4gICAgICAgIG9FYWNoKG9wdGlvbnMsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBtZXRob2QgPSB0aGlzLl9nZXRQcm9jZXNzb3JLZXkoa2V5KTtcblxuICAgICAgICAgICAgaWYgKGlzLmlzRnVuY3Rpb24odGhpc1ttZXRob2RdKSkge1xuICAgICAgICAgICAgICAgIHRoaXNbbWV0aG9kXS5jYWxsKHRoaXMsICRjbGFzcywgb3B0aW9uc1trZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfSxcblxuICAgIF9hcHBseU1peGluczogZnVuY3Rpb24oJGNsYXNzLCBtaXhpbnMpIHtcbiAgICAgICAgdmFyIHByb3RvID0gJGNsYXNzLnByb3RvdHlwZTtcbiAgICAgICAgYUVhY2gobWl4aW5zLCBmdW5jdGlvbihtaXhpbikge1xuICAgICAgICAgICAgLy9hY2NlcHQgQ29uc3RydWN0b3JzIG9yIE9iamVjdHNcbiAgICAgICAgICAgIHZhciB0b01peCA9IG1peGluLnByb3RvdHlwZSB8fCBtaXhpbjtcbiAgICAgICAgICAgIG1peChwcm90bywgdG9NaXgpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgX2FwcGx5U3RhdGljczogZnVuY3Rpb24oJGNsYXNzLCBzdGF0aWNzKSB7XG4gICAgICAgIHZhciBwcm90b3R5cGUgPSAkY2xhc3MucHJvdG90eXBlO1xuXG4gICAgICAgIGFwcGx5KCRjbGFzcywgc3RhdGljcyk7XG5cbiAgICAgICAgaWYocHJvdG90eXBlLmdldFN0YXRpY1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHByb3RvdHlwZS5nZXRTdGF0aWNWYWx1ZSA9IHRoaXMuZ2V0U3RhdGljVmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2FwcGx5Q29tcG9zZXJNZXRob2RzOiBmdW5jdGlvbigkY2xhc3MsIGNvbXBvc2l0aW9ucykge1xuICAgICAgICB2YXIgcHJvdG90eXBlID0gJGNsYXNzLnByb3RvdHlwZSxcbiAgICAgICAgICAgIG1ldGhvZHNUb0NvbXBvc2U7XG5cbiAgICAgICAgYUVhY2goY29tcG9zaXRpb25zLCBmdW5jdGlvbihjb21wb3NpdGlvbkNvbmZpZykge1xuICAgICAgICAgICAgdmFyIGNvbXBvc2l0aW9uID0gbmV3IENvbXBvc2l0aW9uKGNvbXBvc2l0aW9uQ29uZmlnKSxcbiAgICAgICAgICAgICAgICBuYW1lID0gY29tcG9zaXRpb24ubmFtZSxcbiAgICAgICAgICAgICAgICBDb25zdHJ1Y3RvciA9IGNvbXBvc2l0aW9uLkNvbnN0cnVjdG9yO1xuXG4gICAgICAgICAgICBjb21wb3NpdGlvbi52YWxpZGF0ZSgpO1xuXG4gICAgICAgICAgICBtZXRob2RzVG9Db21wb3NlID0gY29tcG9zaXRpb24uZ2V0TWV0aG9kc1RvQ29tcG9zZSgpO1xuXG4gICAgICAgICAgICBtZXRob2RzVG9Db21wb3NlLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3RvdHlwZVtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdG90eXBlW2tleV0gPSB0aGlzLl9jcmVhdGVDb21wb3NlclByb3RvRm4oa2V5LCBuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgaWYocHJvdG90eXBlLmdldENvbXBvc2l0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwcm90b3R5cGUuZ2V0Q29tcG9zaXRpb24gPSB0aGlzLmdldENvbXBvc2l0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG5cbiAgICBfYXBwbHlTdXBlcjogZnVuY3Rpb24oJGNsYXNzLCAkc3VwZXIpIHtcbiAgICAgICAgdmFyIHByb3RvO1xuICAgICAgICAvL3N1cGVyIGNhbiBiZSBmYWxzeSB0byBzaWduaWZ5IG5vIHN1cGVyY2xhc3NcbiAgICAgICAgaWYgKCRzdXBlcikge1xuICAgICAgICAgICAgcHJvdG8gPSAkY2xhc3MucHJvdG90eXBlO1xuICAgICAgICAgICAgcHJvdG8uJHN1cGVyID0gJHN1cGVyO1xuICAgICAgICAgICAgcHJvdG8uJHN1cGVyY2xhc3MgPSAkc3VwZXIucHJvdG90eXBlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9jcmVhdGVDb21wb3NlclByb3RvRm46IGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGNvbXBvc2l0aW9uTmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgY29tcCA9IHRoaXNbQ2xhc3NEZWZpbmVyLkNPTVBPU0lUSU9OU19OQU1FXVtjb21wb3NpdGlvbk5hbWVdO1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBbbWV0aG9kTmFtZV0uYXBwbHkoY29tcCwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaWdub3JlXG4gICAgICogb3B0aW9ucyB7T2JqZWN0fSB0aGUgY29tcG9zaXRpb24gY29uZmlnIG9iamVjdFxuICAgICAqIGluc3RhbmNlQXJncyB7QXJyYXl9IHRoZSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBpbnN0YW5jZSdzXG4gICAgICogY29uc3RydWN0b3IuXG4gICAgICovXG4gICAgX2luaXRDb21wb3NpdGlvbnM6IGZ1bmN0aW9uKGNvbXBvc2l0aW9ucywgaW5zdGFuY2VBcmdzKSB7XG4gICAgICAgIGlmKCF0aGlzW0NsYXNzRGVmaW5lci5DT01QT1NJVElPTlNfTkFNRV0pIHtcbiAgICAgICAgICAgIHRoaXNbQ2xhc3NEZWZpbmVyLkNPTVBPU0lUSU9OU19OQU1FXSA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgYUVhY2goY29tcG9zaXRpb25zLCBmdW5jdGlvbihjb21wb3NpdGlvbkNvbmZpZykge1xuICAgICAgICAgICAgdmFyIGNvbmZpZyA9IGFwcGx5KHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZTogdGhpcyxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZUFyZ3M6IGluc3RhbmNlQXJnc1xuICAgICAgICAgICAgfSwgY29tcG9zaXRpb25Db25maWcpLCBcbiAgICAgICAgICAgIGNvbXBvc2l0aW9uO1xuXG4gICAgICAgICAgICBjb21wb3NpdGlvbiA9IG5ldyBDb21wb3NpdGlvbihjb25maWcpO1xuXG4gICAgICAgICAgICB0aGlzW0NsYXNzRGVmaW5lci5DT01QT1NJVElPTlNfTkFNRV1bY29tcG9zaXRpb24ubmFtZV0gPSBjb21wb3NpdGlvbi5nZXRJbnN0YW5jZSgpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgLy9NZXRob2RzIHRoYXQgY2FuIGdldCBhZGRlZCB0byB0aGUgcHJvdG90eXBlXG4gICAgLy90aGV5IHdpbGwgYmUgY2FsbGVkIGluIHRoZSBjb250ZXh0IG9mIHRoZSBpbnN0YW5jZS5cbiAgICAvL1xuICAgIGdldENvbXBvc2l0aW9uOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbQ2xhc3NEZWZpbmVyLkNPTVBPU0lUSU9OU19OQU1FXVtrZXldO1xuICAgIH0sXG5cbiAgICBnZXRTdGF0aWNWYWx1ZTogZnVuY3Rpb24gKGtleSwgJGNsYXNzKSB7XG4gICAgICAgIHZhciBjbGFzc1RvRmluZFZhbHVlID0gJGNsYXNzIHx8IHRoaXMuJGNsYXNzLFxuICAgICAgICAgICAgJHN1cGVyLFxuICAgICAgICAgICAgdmFsdWU7XG5cbiAgICAgICAgdmFsdWUgPSBjbGFzc1RvRmluZFZhbHVlW2tleV07XG5cbiAgICAgICAgaWYodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgJHN1cGVyID0gY2xhc3NUb0ZpbmRWYWx1ZS5wcm90b3R5cGUuJHN1cGVyO1xuICAgICAgICAgICAgaWYoJHN1cGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhdGljVmFsdWUoa2V5LCAkc3VwZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxufTtcblxuQ2xhc3NEZWZpbmVyLmRlZmluZSA9IENsYXNzRGVmaW5lci5kZWZpbmUuYmluZChDbGFzc0RlZmluZXIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENsYXNzRGVmaW5lcjtcblxuLyoqXG4gKiBAY2xhc3MgIEx1Yy5kZWZpbmVcbiAqIFRoaXMgaXMgYWN0dWFsbHkgYSBmdW5jdGlvbiBidXQgaGFzIGEgZGVjZW50IGFtb3VudCBvZiBpbXBvcnRhbnQgb3B0aW9uc1xuICogc28gd2UgYXJlIGRvY3VtZW50aW5nIGl0IGxpa2UgaXQgaXMgYSBjbGFzcy4gIFByb3BlcnRpZXMgYXJlIHRoaW5ncyB0aGF0IHdpbGwgZ2V0XG4gKiBhcHBsaWVkIHRvIGluc3RhbmNlcyBvZiBjbGFzc2VzIGRlZmluZWQgd2l0aCB7QGxpbmsgTHVjLmRlZmluZSNkZWZpbmUgZGVmaW5lfS4gIE5vbmVcbiAqIGFyZSBuZWVkZWQgZm9yIHtAbGluayBMdWMuZGVmaW5lI2RlZmluZSBkZWZpbmluZ30gYSBjbGFzcy4gIHtAbGluayBMdWMuZGVmaW5lI2RlZmluZSBkZWZpbmV9XG4gKiBqdXN0IHRha2VzIHRoZSBwYXNzZWQgaW4gY29uZmlnIGFuZCBwdXRzIHRoZSBwcm9wZXJ0aWVzIG9uIHRoZSBwcm90b3R5cGUgYW5kIHJldHVybnNcbiAqIGEgQ29uc3RydWN0b3IuXG4gKlxuXG4gICAgdmFyIEMgPSBMdWMuZGVmaW5lKHtcbiAgICAgICAgYTogMSxcbiAgICAgICAgZG9Mb2c6IHRydWUsXG4gICAgICAgIGxvZ0E6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZG9Mb2cpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLmEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgdmFyIGMgPSBuZXcgQygpO1xuICAgIGMubG9nQSgpO1xuICAgID4xXG4gICAgYy5hID0gNDU7XG4gICAgYy5sb2dBKCk7XG4gICAgPjQ1XG4gICAgYy5kb0xvZyA9IGZhbHNlO1xuICAgIGMubG9nQSgpO1xuXG4gICAgbmV3IEMoKS5sb2dBKClcbiAgICA+MVxuXG4gKlxuICogQ2hlY2sgb3V0IHRoZSBmb2xsb3dpbmcgY29uZmlncyB0byBhZGQgZnVuY3Rpb25hbGl0eSB0byBhIGNsYXNzIHdpdGhvdXQgbWVzc2luZ1xuICogdXAgdGhlIGluaGVyaXRhbmNlIGNoYWluLiAgQWxsIHRoZSBjb25maWdzIGhhdmUgZXhhbXBsZXMgYW5kIGRvY3VtZW50YXRpb24gb24gXG4gKiBob3cgdG8gdXNlIHRoZW0uXG4gKlxuICoge0BsaW5rIEx1Yy5kZWZpbmUjJHN1cGVyIHN1cGVyfSA8YnI+XG4gKiB7QGxpbmsgTHVjLmRlZmluZSMkY29tcG9zaXRpb25zIGNvbXBvc2l0aW9uc30gPGJyPlxuICoge0BsaW5rIEx1Yy5kZWZpbmUjJG1peGlucyBtaXhpbnN9IDxicj5cbiAqIHtAbGluayBMdWMuZGVmaW5lIyRzdGF0aWNzIHN0YXRpY3N9IDxicj5cbiAqIFxuICogXG4gKi9cblxuLyoqXG4gKiBAbWV0aG9kICBkZWZpbmVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgY29uZmlnIG9iamVjdCB1c2VkIHdoZW4gY3JlYXRpbmcgdGhlIGNsYXNzLiAgQW55IHByb3BlcnR5IHRoYXRcbiAqIGlzIG5vdCBhcGFydCBvZiB0aGUgc3BlY2lhbCBjb25maWdzIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcHJvdG90eXBlLiAgQ2hlY2sgb3V0XG4gKiBMdWMuZGVmaW5lIGZvciBhbGwgdGhlIGNvbmZpZyBvcHRpb25zLiAgIE5vIGNvbmZpZ3MgYXJlIG5lZWRlZCB0byBkZWZpbmUgYSBjbGFzcy5cbiAqIFxuICogQHJldHVybiB7RnVuY3Rpb259IHRoZSBkZWZpbmVkIGNsYXNzXG4gKlxuICAgIHZhciBDID0gTHVjLmRlZmluZSh7XG4gICAgICAgIGxvZ0E6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5hKVxuICAgICAgICB9LFxuICAgICAgICBhOiAxXG4gICAgfSk7XG4gICAgdmFyIGMgPSBuZXcgQygpO1xuICAgIGMubG9nQSgpO1xuICAgID4xXG5cbiAgICBjLmEgPSA0O1xuICAgIGMubG9nQSgpO1xuICAgID40XG4gKlxuICpcbiAqL1xuXG4vKipcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259ICRjbGFzcyByZWZlcmVuY2UgdG8gdGhlIGluc3RhbmNlcyBvd24gY29uc3RydWN0b3IuICBUaGlzXG4gKiB3aWxsIGdldCBhZGRlZCB0byBhbnkgY2xhc3MgdGhhdCBpcyBkZWZpbmVkIHdpdGggTHVjLmRlZmluZS5cbiAqIFxuICAgIHZhciBDID0gTHVjLmRlZmluZSgpXG4gICAgdmFyIGMgPSBuZXcgQygpXG4gICAgYy4kY2xhc3MgPT09IENcbiAgICA+dHJ1ZVxuICpcbiAqIFRoZXJlIGFyZSBzb21lIHJlYWxseSBnb29kIHVzZSBjYXNlcyB0byBoYXZlIGEgcmVmZXJlbmNlIHRvIGl0J3NcbiAqIG93biBjb25zdHJ1Y3Rvci4gIDxicj4gQWRkIGZ1bmN0aW9uYWxpdHkgdG8gYW4gaW5zdGFuY2UgaW4gYSBzaW1wbGVcbiAqIGFuZCBnZW5lcmljIHdheS5cbiAqXG4gICAgdmFyIEMgPSBMdWMuZGVmaW5lKHtcbiAgICAgICAgYWRkOiBmdW5jdGlvbihhLGIpIHtcbiAgICAgICAgICAgIHJldHVybiBhICsgYjtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy9MdWMuQmFzZSBhcHBsaWVzIGZpcnN0IFxuICAgIC8vYXJnIHRvIHRoZSBpbnN0YW5jZVxuXG4gICAgdmFyIGMgPSBuZXcgQyh7XG4gICAgICAgIGFkZDogZnVuY3Rpb24oYSxiLGMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRjbGFzcy5wcm90b3R5cGUuYWRkLmNhbGwodGhpcywgYSxiKSArIGM7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGMuYWRkKDEsMiwzKVxuICAgID42XG4gICAgbmV3IEMoKS5hZGQoMSwyLDMpXG4gICAgPjNcbiAqXG4gKiBPciBoYXZlIGEgc2ltcGxlIGdlbmVyaWMgY2xvbmUgbWV0aG9kIDpcbiAqXG4gICAgdmFyIEMgPSBMdWMuZGVmaW5lKHtcbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIG15T3duUHJvcHMgPSB7fTtcbiAgICAgICAgICAgIEx1Yy5PYmplY3QuZWFjaCh0aGlzLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgbXlPd25Qcm9wc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLiRjbGFzcyhteU93blByb3BzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIGMgPSBuZXcgQyh7YToxLGI6MixjOjN9KTtcbiAgICBjLmQgPSA0O1xuICAgIHZhciBjbG9uZSA9IGMuY2xvbmUoKTtcblxuICAgIGNsb25lID09PSBjXG4gICAgPmZhbHNlXG5cbiAgICBjbG9uZS5hXG4gICAgPjFcbiAgICBjbG9uZS5iXG4gICAgPjJcbiAgICBjbG9uZS5jXG4gICAgPjNcbiAgICBjbG9uZS5kXG4gICAgPjRcbiAqL1xuXG4vKipcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFskc3VwZXJdIElmICRzdXBlciBpcyBub3QgZmFsc2Ugb3IgbnVsbCBcbiAqIHRoZSAkc3VwZXIgcHJvcGVydHkgd2lsbCBiZSBhZGRlZCB0byBldmVyeSBpbnN0YW5jZSBvZiB0aGUgZGVmaW5lZCBjbGFzcyxcbiAqICRzdXBlciBpcyB0aGUgQ29uc3RydWN0b3IgcGFzc2VkIGluIHdpdGggdGhlICRzdXBlciBjb25maWcgb3IgdGhlIHtAbGluayBMdWMuQ2xhc3NEZWZpbmVyI2RlZmF1bHRUeXBlIGRlZmF1bHR9XG4gKiBcbiAgICB2YXIgQyA9IEx1Yy5kZWZpbmUoKVxuICAgIHZhciBjID0gbmV3IEMoKVxuICAgIC8vTHVjLkJhc2UgaXMgdGhlIGRlZmF1bHQgXG4gICAgYy4kc3VwZXIgPT09IEx1Yy5CYXNlXG4gICAgPnRydWVcbiAqL1xuXG4vKipcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFskc3VwZXJjbGFzc10gSWYgJHN1cGVyIGlzIGRlZmluZWQgaXRcbiAqIHdpbGwgYmUgdGhlIHByb3RvdHlwZSBvZiAkc3VwZXIuICBJdCBjYW4gYmUgdXNlZCB0byBjYWxsIGEgcGFyZW50J3NcbiAqIG1ldGhvZFxuICogXG4gICAgZnVuY3Rpb24gTXlDb29sQ2xhc3MoKSB7fVxuICAgIE15Q29vbENsYXNzLnByb3RvdHlwZS5hZGROdW1zID0gZnVuY3Rpb24oYSxiKSB7XG4gICAgICAgIHJldHVybiBhICsgYjtcbiAgICB9XG5cbiAgICB2YXIgTXlPdGhlckNvb2xDbGFzcyA9IEx1Yy5kZWZpbmUoe1xuICAgICAgICAkc3VwZXI6IE15Q29vbENsYXNzLFxuICAgICAgICBhZGROdW1zOiBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kc3VwZXJjbGFzcy5hZGROdW1zLmNhbGwodGhpcywgYSwgYikgKyBjO1xuICAgICAgICB9XG4gICAgfSlcblxuICAgIHZhciBtID0gbmV3IE15T3RoZXJDb29sQ2xhc3MoKTtcbiAgICBtLmFkZE51bXMoMSwyLDMpO1xuICAgID42XG4gKi9cblxuLyoqXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBnZXRTdGF0aWNWYWx1ZSB0aGlzIG1ldGhvZFxuICogd2lsbCBiZSBhZGRlZCB0byBpbnN0YW5jZXMgdGhhdCB1c2UgdGhlIHtAbGluayBMdWMuZGVmaW5lIyRzdGF0aWNzICRzdGF0aWNzfVxuICogY29uZmlnLlxuICpcbiAqIFxuICogVGhpcyBzaG91bGQgYmUgdXNlZCBvdmVyIHRoaXMuJGNsYXNzLnN0YXRpY05hbWUgdG9cbiAqIGdldCB0aGUgdmFsdWUgb2Ygc3RhdGljLiAgSWYgdGhlIGNsYXNzIGdldHMgaW5oZXJpdGVkXG4gKiBmcm9tLCB0aGlzLiRjbGFzcyB3aWxsIG5vdCBiZSB0aGUgc2FtZS4gIGdldFN0YXRpYyB2YWx1ZVxuICogZGVhbHMgd2l0aCB0aGlzIGlzc3VlLlxuICogXG4gICAgdmFyIEEgPSBMdWMuZGVmaW5lKHtcbiAgICAgICAgJHN0YXRpY3M6IHtcbiAgICAgICAgICAgIGE6IDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgIGdldEFCZXR0ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhdGljVmFsdWUoJ2EnKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0QTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kY2xhc3MuYTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIEIgPSBMdWMuZGVmaW5lKHtcbiAgICAgICAgJHN1cGVyOiBBLFxuICAgICAgICAkc3RhdGljczoge1xuICAgICAgICAgICAgYjogMixcbiAgICAgICAgICAgIGM6IDNcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgXG4gICAgdmFyIGIgPSBuZXcgQigpO1xuICAgIGIuZ2V0QSgpO1xuICAgID51bmRlZmluZWRcbiAgICBiLmdldEFCZXR0ZXIoKTtcbiAgICA+MVxuXG4gKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBzdGF0aWMgdmFsdWUgb2YgdGhlIGtleVxuICovXG5cbiAgICBcbi8qKlxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZ2V0Q29tcG9zaXRpb24gdGhpcyBtZXRob2Qgd2lsbCBiZVxuICogdG8gaW5zdGFuY2VzIHRoYXQgdXNlIHRoZSB7QGxpbmsgTHVjLmRlZmluZSMkY29tcG9zaXRpb25zICRjb21wb3NpdGlvbnN9ICBjb25maWdcbiAqXG4gKiAgVGhpcyB3aWxsIHJldHVybiB0aGUgY29tcG9zaXRpb24gaW5zdGFuY2UgYmFzZWQgb2ZmIHRoZSBjb21wb3NpdGlvbiB7QGxpbmsgTHVjLkNvbXBvc2l0aW9uI25hbWUgbmFtZX1cbiAgICBcbiAgICB0aGlzLmdldENvbXBvc2l0aW9uKFwibmFtZVwiKTtcbiAgICBcbiAqXG4gKi9cblxuXG4vKipcbiAqIEBjZmcge09iamVjdH0gJHN0YXRpY3MgKG9wdGlvbmFsKSBBZGQgc3RhdGljIHByb3BlcnRpZXMgb3IgbWV0aG9kc1xuICogdG8gdGhlIGNsYXNzLiAgVGhlc2UgcHJvcGVydGllcy9tZXRob2RzIHdpbGwgbm90IGJlIGFibGUgdG8gYmVcbiAqIGRpcmVjdGx5IG1vZGlmaWVkIGJ5IHRoZSBpbnN0YW5jZSBzbyB0aGV5IGFyZSBnb29kIGZvciBkZWZpbmluZyBkZWZhdWx0XG4gKiBjb25maWdzLiAgVXNpbmcgdGhpcyBjb25maWcgYWRkcyB0aGUge0BsaW5rIEx1Yy5kZWZpbmUjZ2V0U3RhdGljVmFsdWUgZ2V0U3RhdGljVmFsdWV9XG4gKiBtZXRob2QgdG8gaW5zdGFuY2VzLlxuICpcbiAgICB2YXIgQyA9IEx1Yy5kZWZpbmUoe1xuICAgICAgICAkc3RhdGljczoge1xuICAgICAgICAgICAgbnVtYmVyOiAxXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBjID0gbmV3IEMoKTtcbiAgICBjLm51bWJlclxuICAgID51bmRlZmluZWRcbiAgICBDLm51bWJlclxuICAgID4xXG4gICAgXG4gKlxuICogQmFkIHRoaW5ncyBjYW4gaGFwcGVuIGlmIG5vbiBwcmltaXRpdmVzIGFyZSBwbGFjZWQgb24gdGhlIFxuICogcHJvdG90eXBlIGFuZCBpbnN0YW5jZSBzaGFyaW5nIGlzIG5vdCB3YW50ZWQuICBVc2luZyBzdGF0aWNzXG4gKiBwcmV2ZW50IHN1YmNsYXNzZXMgYW5kIGluc3RhbmNlcyBmcm9tIHVua25vd2luZ2x5IG1vZGlmeWluZ1xuICogYWxsIGluc3RhbmNlcy5cbiAqIFxuICAgIHZhciBDID0gTHVjLmRlZmluZSh7XG4gICAgICAgIGNmZzoge1xuICAgICAgICAgICAgYTogMVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgYyA9IG5ldyBDKCk7XG4gICAgYy5jZmcuYVxuICAgID4xXG4gICAgYy5jZmcuYSA9IDVcbiAgICBuZXcgQygpLmNmZy5hXG4gICAgPjVcbiAqXG4gKi9cblxuLyoqXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbJHN1cGVyY2xhc3NdIElmICRzdXBlciBpcyBkZWZpbmVkIGl0XG4gKiB3aWxsIHRoZSBwcm90b3R5cGUgb2YgJHN1cGVyLiAgSXQgY2FuIGJlIHVzZWQgdG8gY2FsbCBwYXJlbnQnc1xuICogbWV0aG9kXG4gKiBcbiAgICBmdW5jdGlvbiBNeUNvb2xDbGFzcygpIHt9XG4gICAgTXlDb29sQ2xhc3MucHJvdG90eXBlLmFkZE51bXMgPSBmdW5jdGlvbihhLGIpIHtcbiAgICAgICAgcmV0dXJuIGEgKyBiO1xuICAgIH1cblxuICAgIHZhciBNeU90aGVyQ29vbENsYXNzID0gTHVjLmRlZmluZSh7XG4gICAgICAgICRzdXBlcjogTXlDb29sQ2xhc3MsXG4gICAgICAgIGFkZE51bXM6IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRzdXBlcmNsYXNzLmFkZE51bXMuY2FsbCh0aGlzLCBhLCBiKSArIGM7XG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgdmFyIG0gPSBuZXcgTXlPdGhlckNvb2xDbGFzcygpO1xuICAgIG0uYWRkTnVtcygxLDIsMyk7XG4gICAgPjZcbiAqL1xuXG4vKipcbiAqIEBjZmcge09iamVjdC9Db25zdHJ1Y3Rvci9PYmplY3RbXS9Db25zdHJ1Y3RvcltdfSAkbWl4aW5zIChvcHRpb25hbCkgIE1peGlucyBhcmUgYSB3YXkgdG8gYWRkIGZ1bmN0aW9uYWxpdHlcbiAqIHRvIGEgY2xhc3MgdGhhdCBzaG91bGQgbm90IGFkZCBzdGF0ZSB0byB0aGUgaW5zdGFuY2UgdW5rbm93aW5nbHkuICBNaXhpbnMgY2FuIGJlIGVpdGhlciBvYmplY3RzIG9yIENvbnN0cnVjdG9ycy5cbiAqXG4gICAgZnVuY3Rpb24gTG9nZ2VyKCkge31cbiAgICBMb2dnZXIucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zb2xlLmxvZyhhcmd1bWVudHMpXG4gICAgfVxuXG4gICAgdmFyIEMgPSBMdWMuZGVmaW5lKHtcbiAgICAgICAgJG1peGluczogW0xvZ2dlciwge1xuICAgICAgICAgICAgd2FybjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGFyZ3VtZW50cylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfV1cbiAgICB9KTtcblxuICAgIHZhciBjID0gbmV3IEMoKTtcblxuICAgIGMubG9nKDEsMilcbiAgICA+WzEsMl1cblxuICAgIGMud2FybigzLDQpXG4gICAgPlszLDRdXG4gKlxuICovXG4vKipcbiAqIEBjZmcge0NvbnN0cnVjdG9yfSAkc3VwZXIgKG9wdGlvbmFsKSAgc3VwZXIgZm9yIHRoZSBkZWZpbmluZyBjbGFzcy4gIEJ5IEx1Yy5CYXNlXG4gKiBpcyB0aGUgZGVmYXVsdCBpZiBzdXBlciBpcyBub3QgcGFzc2VkIGluLiAgVG8gZGVmaW5lIGEgY2xhc3Mgd2l0aG91dCBhIHN1cGVyY2xhc3NcbiAqIHlvdSBjYW4gcGFzcyBpbiBmYWxzZSBvciBudWxsLlxuICpcbiAgICAgZnVuY3Rpb24gQ291bnRlcigpIHtcbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgIH07XG5cbiAgICAgQ291bnRlci5wcm90b3R5cGUgPSB7XG4gICAgICAgIGdldENvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvdW50O1xuICAgICAgICB9LFxuICAgICAgICBpbmNyZWFzZUNvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuY291bnQrKztcbiAgICAgICAgfVxuICAgICB9XG5cbiAgICAgdmFyIEMgPSBMdWMuZGVmaW5lKHtcbiAgICAgICAgJHN1cGVyOkNvdW50ZXJcbiAgICB9KTtcblxuICAgIHZhciBjID0gbmV3IEMoKVxuXG4gICAgYyBpbnN0YW5jZW9mIENvdW50ZXJcbiAgICA+dHJ1ZVxuICAgIGMuaW5jcmVhc2VDb3VudCgpO1xuICAgIGMuZ2V0Q291bnQoKTtcbiAgICA+MVxuICAgIGMuY291bnRcbiAgICA+MVxuICpcbiAqIENoZWNrIG91dCBMdWMuQmFzZSB0byBzZWUgd2h5IHdlIGhhdmUgaXQgYXMgdGhlIGRlZmF1bHQuXG4gKiBcbiAgICB2YXIgQiA9IEx1Yy5kZWZpbmUoe1xuICAgICAgICBhbUlBTHVjQmFzZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIEx1Yy5CYXNlXG4gICAgICAgIH1cbiAgICB9KVxuICAgIHZhciBiID0gbmV3IEIoKTtcbiAgICBiLmFtSUFMdWNCYXNlKCk7XG4gICAgPnRydWVcbiAqXG4gKiBcbiAqL1xuXG5cblxuLyoqXG4gKiBAY2ZnIHtPYmplY3QvT2JqZWN0W119ICRjb21wb3NpdGlvbnMgKG9wdGlvbmFsKSBjb25maWcgb2JqZWN0cyBmb3IgXG4gKiBMdWMuQ29tcG9zaXRpb24uICBDb21wb3NpdGlvbnMgYXJlIGEgZ3JlYXQgd2F5IHRvIGFkZCBiZWhhdmlvciB0byBhIGNsYXNzXG4gKiB3aXRob3V0IGV4dGVuZGluZyBpdC4gIEEge0BsaW5rIEx1Yy5kZWZpbmUjJG1peGlucyBtaXhpbn0gY2FuIG9mZmVyIHNpbWlsYXIgZnVuY3Rpb25hbGl0eSBidXQgc2hvdWxkXG4gKiBub3QgYmUgYWRkaW5nIGFuIHVubmVlZGVkIHN0YXRlLiAgQSBDb25zdHJ1Y3RvciBhbmQgYSBuYW1lIGFyZSBuZWVkZWQgZm9yIHRoZSBjb25maWcgb2JqZWN0LlxuICogIFVzaW5nIHRoaXMgY29uZmlnIGFkZHMgdGhlIHtAbGluayBMdWMuZGVmaW5lI2dldENvbXBvc2l0aW9uIGdldENvbXBvc2l0aW9ufVxuICogbWV0aG9kIHRvIGluc3RhbmNlcy5cbiAqIDxicj5cbiAqIFRoZSBtZXRob2RzIHByb3BlcnR5IGlzIG9wdGlvbmFsIGhlcmUgYnV0IGl0IGlzIHNheWluZyB0YWtlIGFsbCBvZiBcbiAqIEx1Yy5FdmVudEVtaXR0ZXIncyBpbnN0YW5jZSBtZXRob2RzIGFuZCBtYWtlIHRoZW0gaW5zdGFuY2UgbWV0aG9kcyBmb3IgQy5cbiAqIFlvdSBjYW4gY2hlY2sgb3V0IGFsbCBvZiB0aGUgY29uZmlnIG9wdGlvbnMgYnkgbG9va2luZyBhdCBMdWMuQ29tcG9zaXRpb24uXG4gKiBcbiAgICAgICAgdmFyIEMgPSBMdWMuZGVmaW5lKHtcbiAgICAgICAgICAgICRjb21wb3NpdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBDb25zdHJ1Y3RvcjogTHVjLkV2ZW50RW1pdHRlcixcbiAgICAgICAgICAgICAgICBuYW1lOiAnZW1pdHRlcicsXG4gICAgICAgICAgICAgICAgbWV0aG9kczogJ2FsbE1ldGhvZHMnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBjID0gbmV3IEMoKTtcblxuICAgICAgICBjLm9uKCdoZXknLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGFyZ3VtZW50cyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGMuZW1pdCgnaGV5JywgMSwyLDMsICdhJyk7XG4gICAgICAgID5bMSwgMiwgMywgXCJhXCJdXG4gICAgICAgIGMgaW5zdGFuY2VvZiBMdWMuRXZlbnRFbWl0dGVyXG4gICAgICAgID5mYWxzZVxuICAgICAgICBjLl9ldmVudHNcbiAgICAgICAgPnVuZGVmaW5lZFxuICpcbiAqIEx1Yy5FdmVudEVtaXR0ZXIgaXMgcHJlZmVycmVkIGFzIGEgY29tcG9zaXRpb24gb3ZlciBhIG1peGluIGJlY2F1c2VcbiAqIGl0IGFkZHMgYSBzdGF0ZSBcIl9ldmVudHNcIiB0byB0aGUgdGhpcyBpbnN0YW5jZSB3aGVuIG9uIGlzIGNhbGxlZC4gIEl0XG4gKiBhbHNvIHNob3VsZG4ndCBoYXZlIHRvIGtub3cgdGhhdCBpdCBtYXkgYmUgaW5zdGFudGlhdGVkIGFsb25lIG9yIG1peGVkIGludG8gY2xhc3Nlc1xuICogc28gdGhlIGluaXRpbmcgb2Ygc3RhdGUgaXMgbm90IGRvbmUgaW4gdGhlIGNvbnN0cnVjdG9yIGxpa2UgaXQgcHJvYmFibHkgc2hvdWxkLlxuICogSXQgaXMgbm90IHRlcnJpYmxlIHByYWN0aWNlIGJ5IGFueSBtZWFucyBidXQgaXQgaXMgbm90IGdvb2QgdG8gaGF2ZSBhIHN0YW5kYWxvbmUgY2xhc3NcbiAqIHRoYXQga25vd3MgdGhhdCBpdCBtYXkgYmUgbWl4aW4uICBFdmVuIHdvcnNlIHRoYW4gdGhhdCB3b3VsZCBiZSBhIG1peGluIHRoYXQgbmVlZHNcbiAqIHRvIGJlIGluaXRlZCBieSB0aGUgZGVmaW5pbmcgY2xhc3MuICBFbmNhcHN1bGF0aW5nIGxvZ2ljIGluIGEgY2xhc3NcbiAqIGFuZCB1c2luZyBpdCBhbnl3aGVyZSBzZWFtbGVzc2x5IGlzIHdoZXJlIGNvbXBvc2l0aW9ucyBzaGluZS4gTHVjIGNvbWVzIHdpdGggdHdvIGNvbW1vbiBcbiAqIHtAbGluayBMdWMjY29tcG9zaXRpb25FbnVtcyBlbnVtc30gdGhhdCB3ZSBleHBlY3Qgd2lsbCBiZSB1c2VkIG9mdGVuLlxuICogXG4gKiA8YnI+XG4gKiBIZXJlIGlzIGFuIGV4YW1wbGUgb2YgYSBzaW1wbGUgY29tcG9zaXRpb24gc2VlIGhvdyB0aGUgZnVuY3Rpb25hbGl0eSBcbiAqIGlzIGFkZGVkIGJ1dCB3ZSBhcmUgbm90IGluaGVyaXRpbmcgYW5kIHRoaXMuY291bnQgaXNcbiAqIHVuZGVmaW5lZC5cbiAqXG4gICAgICAgICBmdW5jdGlvbiBDb3VudGVyKCkge1xuICAgICAgICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgICAgICB9O1xuXG4gICAgICAgICBDb3VudGVyLnByb3RvdHlwZSA9IHtcbiAgICAgICAgICAgIGdldENvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb3VudDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbmNyZWFzZUNvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9XG5cbiAgICAgICAgIHZhciBDID0gTHVjLmRlZmluZSh7XG4gICAgICAgICAgICAgICAgJGNvbXBvc2l0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnY291bnRlcicsXG4gICAgICAgICAgICAgICAgICAgIENvbnN0cnVjdG9yOiBDb3VudGVyLFxuICAgICAgICAgICAgICAgICAgICBtZXRob2RzOiAnYWxsTWV0aG9kcydcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBjID0gbmV3IEMoKVxuXG4gICAgICAgIGMuaW5jcmVhc2VDb3VudCgpO1xuICAgICAgICBjLmluY3JlYXNlQ291bnQoKTtcbiAgICAgICAgYy5pbmNyZWFzZUNvdW50KCk7XG4gICAgICAgIGMuZ2V0Q291bnQoKTtcbiAgICAgICAgPjNcbiAgICAgICAgYy5jb3VudFxuICAgICAgICA+dW5kZWZpbmVkXG4gKlxuICogTHVjIGNvbWVzIHdpdGggdHdvIGRlZmF1bHQgY29tcG9zaXRpb24gb2JqZWN0cyBMdWMuY29tcG9zaXRpb25FbnVtcy5QbHVnaW5NYW5hZ2VyXG4gKiBhbmQgTHVjLmNvbXBvc2l0aW9uRW51bXMuRXZlbnRFbWl0dGVyLlxuICogXG4gKiBIZXJlIGlzIHRoZSBwbHVnaW4gbWFuYWdlciBlbnVtLCBrZWVwIGluIG1pbmQgdGhhdCB0aGlzXG4gKiBmdW5jdGlvbmFsaXR5IGNhbiBiZSBhZGRlZCB0byBhbnkgY2xhc3MsIG5vdCBqdXN0IG9uZXMgZGVmaW5lZCB3aXRoIFxuICogTHVjLmRlZmluZS4gIENoZWNrIG91dCBMdWMuUGx1Z2luTWFuYWdlciB0byBzZWUgYWxsIG9mIHRoZSBwdWJsaWMgXG4gKiBtZXRob2RzIHRoYXQgZ2V0cyBhZGRlZCB0byB0aGUgZGVmaW5lZCBpbnN0YW5jZS5cbiAgIFxuICAgIGZ1bmN0aW9uIE15Q2xhc3MoKSB7fTtcblxuICAgIGZ1bmN0aW9uIE15UGx1Z2luKCkge1xuICAgICAgICB0aGlzLm15Q29vbE5hbWUgPSAnY29vJztcblxuICAgICAgICB0aGlzLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdpbSBnZXR0aW5nIGluaXR0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdNeVBsdWdpbiBpbnN0YW5jZSBiZWluZyBkZXN0cm95ZWQnKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIEMgPSBMdWMuZGVmaW5lKHtcbiAgICAgICAgJHN1cGVyOiBNeUNsYXNzLFxuICAgICAgICAkY29tcG9zaXRpb25zOiBMdWMuY29tcG9zaXRpb25FbnVtcy5QbHVnaW5NYW5hZ2VyXG4gICAgfSk7XG5cbiAgICB2YXIgYyA9IG5ldyBDKHtcbiAgICAgICAgcGx1Z2luczogW3tcbiAgICAgICAgICAgICAgICBDb25zdHJ1Y3RvcjogTXlQbHVnaW4sXG4gICAgICAgICAgICAgICAgbXlDb29sTmFtZTogJ2NvbydcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0pO1xuICAgID5pbSBnZXR0aW5nIGluaXR0ZWRcbiAgICBjIGluc3RhbmNlb2YgTXlDbGFzc1xuICAgID50cnVlXG5cbiAgICBjLmdldFBsdWdpbih7bXlDb29sTmFtZTogJ2Nvbyd9KSBpbnN0YW5jZW9mIE15UGx1Z2luXG4gICAgPiB0cnVlXG5cblxuICAgIGMuYSA9IDE7XG4gICAgLy9UaGlzIHdpbGwgYmUgdGhlIGRlZmF1bHQgTHVjLlBsdWdpblxuICAgIGMuYWRkUGx1Z2luKHtcbiAgICAgICAgaW5pdDogZnVuY3Rpb24ob3duZXIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG93bmVyLmEpXG4gICAgICAgIH0sXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0ltIGdldHRpbmcgZGVzdHJveWVkJylcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgPjFcblxuICAgIGMuZGVzdHJveUFsbFBsdWdpbnMoKTtcbiAgICA+TXlQbHVnaW4gaW5zdGFuY2UgYmVpbmcgZGVzdHJveWVkXG4gICAgPkknbSBnZXR0aW5nIGRlc3Ryb3llZC5cblxuICAgIGMuZ2V0UGx1Z2luKHtteUNvb2xOYW1lOiAnY29vJ30pXG4gICAgPmZhbHNlXG4gKlxuICogWW91IGNhbiBzZWUgdGhhdCBpdCBjYW4gYWRkIHBsdWdpbiBsaWtlIGJlaGF2aW9yIHRvIGFueSBkZWZpbmluZ1xuICogY2xhc3Mgd2l0aCBMdWMuUGx1Z2luTWFuYWdlciB3aGljaCBpcyBsZXNzIHRoYW4gNzUgU0xPQy5cbiAqLyIsInZhciBhRWFjaCA9IHJlcXVpcmUoJy4uL2FycmF5JykuZWFjaCxcbiAgICBvYmogPSByZXF1aXJlKCcuLi9vYmplY3QnKSxcbiAgICBlbXB0eUZuID0gcmVxdWlyZSgnLi4vZnVuY3Rpb24nKS5lbXB0eUZuLFxuICAgIGFwcGx5ID0gb2JqLmFwcGx5O1xuXG4vKipcbiAqIEBjbGFzcyBMdWMuUGx1Z2luXG4gKiBTaW1wbGUgY2xhc3MgdGhhdCBpcyB0aGUgZGVmYXVsdCBwbHVnaW4gdHlwZSBmb3IgTHVjLlBsdWdpbk1hbmFnZXJcbiAqL1xuZnVuY3Rpb24gUGx1Z2luKGNvbmZpZykge1xuICAgIGFwcGx5KHRoaXMsIGNvbmZpZyk7XG59XG5cblBsdWdpbi5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvd25lciB0aGUgb3duZXIgaW5zdGFuY2VcbiAgICAgKiBTaW1wbGUgaG9vayB0byBpbml0aWFsaXplIHRoZSBwbHVnaW5cbiAgICAgKiBEZWZhdWx0cyB0byBMdWMuZW1wdHlGbi5cbiAgICAgKi9cbiAgICBpbml0OiBlbXB0eUZuLFxuICAgIC8qKlxuICAgICAqIEBtZXRob2QgRGVmYXVsdHMgdG8gTHVjLmVtcHR5Rm4uXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIHBsdWdpbiBpcyBiZWluZyB7QGxpbmsgTHVjLlBsdWdpbk1hbmFnZXIjZGVzdHJveVBsdWdpbiBkZXN0cm95ZWR9LlxuICAgICAqL1xuICAgIGRlc3Ryb3k6IGVtcHR5Rm5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUGx1Z2luO1xuIiwidmFyIFBsdWdpbiA9IHJlcXVpcmUoJy4vcGx1Z2luJyksXG4gICAgaXMgPSByZXF1aXJlKCcuLi9pcycpLFxuICAgIG9iaiA9IHJlcXVpcmUoJy4uL29iamVjdCcpLFxuICAgIGFyciA9IHJlcXVpcmUoJy4uL2FycmF5JyksXG4gICAgYUVhY2ggPSBhcnIuZWFjaCxcbiAgICBtaXggPSBvYmoubWl4LFxuICAgIGFwcGx5ID0gb2JqLmFwcGx5O1xuXG5mdW5jdGlvbiBQbHVnaW5NYW5hZ2VyKGNvbmZpZykge1xuICAgIHRoaXMuX2luaXQoY29uZmlnKTtcbn1cblxuLyoqXG4gKiBAcHJvdGVjdGVkXG4gKiBAY2xhc3MgTHVjLlBsdWdpbk1hbmFnZXJcbiAqIFRoaXMgY2xhc3MgaXMgdXNlZCBieSBMdWMuY29tcG9zaXRpb25FbnVtcyNQbHVnaW5NYW5hZ2VyIHRvIGFkZCBpdHMgZnVuY3Rpb25hbGl0eSBcbiAqIHRvIGFueSBjbGFzcy4gICBCeSB7QGxpbmsgTHVjLmNvbXBvc2l0aW9uRW51bXMjUGx1Z2luTWFuYWdlciBkZWZhdWx0fSBpdCBhZGRzXG4gKiBhbGwgb2YgdGhlc2UgcHVibGljIG1ldGhvZHMgdG8gdGhlIGluc3RhbmNlLlRoaXMgY2xhc3MgaXMgZGVzaWduZWQgdG8gd29yayBhcyBhIGNvbXBvc2l0aW9uLCBcbiAqIGl0IGlzIGV4cG9zZWQgYXMgbm90IHByaXZhdGUgc28gaXQgY2FuIGJlIGV4dGVuZGVkIGlmIG5lZWRlZC4gICBDaGVjayBcInByb3RlY3RlZFwiIHdoaWNoXG4gKiBpcyBhIHBhcnQgb2YgdGhlIFNob3cgdiBkcm9wZG93biBvbiB0aGUgcmlnaHQgdG8gc2VlIHRoZSBwcm90ZWN0ZWQgbWV0aG9kcy5cbiAqXG4gICAgZnVuY3Rpb24gTXlQbHVnaW4oKSB7XG4gICAgICAgIHRoaXMubXlDb29sTmFtZSA9ICdjb28nO1xuXG4gICAgICAgIHRoaXMuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2ltIGdldHRpbmcgaW5pdHRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ015UGx1Z2luIGluc3RhbmNlIGJlaW5nIGRlc3Ryb3llZCcpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgQyA9IEx1Yy5kZWZpbmUoe1xuICAgICAgICAkY29tcG9zaXRpb25zOiBMdWMuY29tcG9zaXRpb25FbnVtcy5QbHVnaW5NYW5hZ2VyXG4gICAgfSk7XG5cbiAgICB2YXIgYyA9IG5ldyBDKHtcbiAgICAgICAgcGx1Z2luczogW3tcbiAgICAgICAgICAgICAgICBDb25zdHJ1Y3RvcjogTXlQbHVnaW4sXG4gICAgICAgICAgICAgICAgbXlDb29sTmFtZTogJ2NvbydcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0pO1xuXG4gICAgPmltIGdldHRpbmcgaW5pdHRlZFxuXG4gICAgdmFyIHBsdWdJbnN0YW5jZSA9IGMuYWRkUGx1Z2luKHtcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnSW0gZ2V0dGluZyBkZXN0cm95ZWQnKVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBjLmdldFBsdWdpbihMdWMuUGx1Z2luKVxuICAgID4gUGx1Z2luIHtkZXN0cm95OiBmdW5jdGlvbiwgb3duZXI6IE15Q2xhc3MsIGluaXQ6IGZ1bmN0aW9uLCBkZXN0cm95OiBmdW5jdGlvbn1cblxuICAgIGMuZ2V0UGx1Z2luKE15UGx1Z2luKVxuICAgID4gTXlQbHVnaW4ge215Q29vbE5hbWU6IFwiY29vXCIsIGluaXQ6IGZ1bmN0aW9uLCBkZXN0cm95OiBmdW5jdGlvbn1cblxuICAgIGMuZGVzdHJveUFsbFBsdWdpbnMoKVxuXG4gICAgPk15UGx1Z2luIGluc3RhbmNlIGJlaW5nIGRlc3Ryb3llZFxuICAgID5JbSBnZXR0aW5nIGRlc3Ryb3llZFxuXG4gICAgYy5nZXRQbHVnaW4oTXlQbHVnaW4pXG4gICAgPmZhbHNlXG5cbiAqL1xuUGx1Z2luTWFuYWdlci5wcm90b3R5cGUgPSB7XG4gICAvKipcbiAgICAqIEBjZmcge0NvbnN0cnVjdG9yfSBkZWZhdWx0UGx1Z2luXG4gICAgKi9cbiAgICBkZWZhdWx0UGx1Z2luOiBQbHVnaW4sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2luaXQ6IGZ1bmN0aW9uKGluc3RhbmNlVmFsdWVzKSB7XG4gICAgICAgIGFwcGx5KHRoaXMsIGluc3RhbmNlVmFsdWVzKTtcbiAgICAgICAgdGhpcy5wbHVnaW5zID0gW107XG4gICAgICAgIHRoaXMuX2NyZWF0ZVBsdWdpbnMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9jcmVhdGVQbHVnaW5zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgYUVhY2godGhpcy5fZ2V0UGx1Z2luQ29uZmlnRnJvbUluc3RhbmNlKCksIGZ1bmN0aW9uKHBsdWdpbkNvbmZpZykge1xuICAgICAgICAgICAgdGhpcy5hZGRQbHVnaW4ocGx1Z2luQ29uZmlnKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfZ2V0UGx1Z2luQ29uZmlnRnJvbUluc3RhbmNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuaW5zdGFuY2VBcmdzWzBdIHx8IHt9O1xuICAgICAgICByZXR1cm4gY29uZmlnLnBsdWdpbnM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBhIHBsdWdpbiB0byB0aGUgaW5zdGFuY2UgYW5kIGluaXQgdGhlIFxuICAgICAqIHBsdWdpbi5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHBsdWdpbkNvbmZpZ1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIGNyZWF0ZWQgcGx1Z2luIGluc3RhbmNlXG4gICAgICovXG4gICAgYWRkUGx1Z2luOiBmdW5jdGlvbihwbHVnaW5Db25maWcpIHtcbiAgICAgICAgdmFyIHBsdWdpbkluc3RhbmNlID0gdGhpcy5fY3JlYXRlUGx1Z2luKHBsdWdpbkNvbmZpZyk7XG5cbiAgICAgICAgdGhpcy5faW5pdFBsdWdpbihwbHVnaW5JbnN0YW5jZSk7XG5cbiAgICAgICAgdGhpcy5wbHVnaW5zLnB1c2gocGx1Z2luSW5zdGFuY2UpO1xuXG4gICAgICAgIHJldHVybiBwbHVnaW5JbnN0YW5jZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9jcmVhdGVQbHVnaW46IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICBjb25maWcub3duZXIgPSB0aGlzLmluc3RhbmNlO1xuXG4gICAgICAgIGlmIChjb25maWcuQ29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIC8vY2FsbCB0aGUgY29uZmlnZWQgQ29uc3RydWN0b3Igd2l0aCB0aGUgXG4gICAgICAgICAgICAvL3Bhc3NlZCBpbiBjb25maWcgYnV0IHRha2Ugb2ZmIHRoZSBDb25zdHJ1Y3RvclxuICAgICAgICAgICAgLy9jb25maWcuXG4gICAgICAgICAgICAgXG4gICAgICAgICAgICAvL1RoZSBwbHVnaW4gQ29uc3RydWN0b3IgXG4gICAgICAgICAgICAvL3Nob3VsZCBub3QgbmVlZCB0byBrbm93IGFib3V0IGl0c2VsZlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBjb25maWcuQ29uc3RydWN0b3IoYXBwbHkoY29uZmlnLCB7XG4gICAgICAgICAgICAgICAgQ29uc3RydWN0b3I6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmRlZmF1bHRQbHVnaW4oY29uZmlnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9pbml0UGx1Z2luOiBmdW5jdGlvbihwbHVnaW4pIHtcbiAgICAgICAgaWYgKGlzLmlzRnVuY3Rpb24ocGx1Z2luLmluaXQpKSB7XG4gICAgICAgICAgICBwbHVnaW4uaW5pdCh0aGlzLmluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxsIGRlc3Ryb3kgb24gYWxsIG9mIHRoZSBwbHVnaW5zXG4gICAgICogYW5kIHJlbW92ZSB0aGVtLlxuICAgICAqL1xuICAgIGRlc3Ryb3lBbGxQbHVnaW5zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5wbHVnaW5zLmZvckVhY2goZnVuY3Rpb24ocGx1Z2luKSB7XG4gICAgICAgICAgICB0aGlzLl9kZXN0cm95UGx1Z2luKHBsdWdpbik7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHRoaXMucGx1Z2lucyA9IFtdO1xuICAgIH0sXG5cbiAgICBfZGVzdHJveVBsdWdpbjogZnVuY3Rpb24ocGx1Z2luKSB7XG4gICAgICAgIGlmIChpcy5pc0Z1bmN0aW9uKHBsdWdpbi5kZXN0cm95KSkge1xuICAgICAgICAgICAgcGx1Z2luLmRlc3Ryb3kodGhpcy5pbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoZSBwbHVnaW4gYW5kIGlmIGZvdW5kIGRlc3Ryb3kgaXQuXG4gICAgICogQHBhcmFtICB7T2JqZWN0L0NvbnN0cnVjdG9yfSBvYmplY3QgdG8gdXNlIHRvIG1hdGNoIFxuICAgICAqIHRoZSBwbHVnaW4gdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIGRlc3Ryb3llZCBwbHVnaW4uXG4gICAgICovXG4gICAgZGVzdHJveVBsdWdpbjogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHZhciBwbHVnaW4gPSB0aGlzLmdldFBsdWdpbihvYmopO1xuXG4gICAgICAgIGlmKHBsdWdpbikge1xuICAgICAgICAgICAgdGhpcy5fZGVzdHJveVBsdWdpbihwbHVnaW4pO1xuICAgICAgICAgICAgYXJyLnJlbW92ZUZpcnN0KHRoaXMucGx1Z2lucywgcGx1Z2luLCB7dHlwZTogJ3N0cmljdCd9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwbHVnaW47XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhIHBsdWdpbiBpbnN0YW5jZS4gIEEgQ29uc3RydWN0b3Igb3IgYW4gb2JqZWN0IGNhbiBiZSB1c2VkXG4gICAgICogdG8gZmluZCBhIHBsdWdpbi5cbiAgICAgKlxuICAgICAgICAgIGMuYWRkUGx1Z2luKHthOjF9KVxuICAgICAgICAgIGMuZ2V0UGx1Z2luKHthOjF9KVxuICAgICAgICAgID5MdWMuUGx1Z2luKHthOjF9KVxuXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBvYmogXG4gICAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgcGx1Z2luIGluc3RhbmNlIGlmIGZvdW5kLlxuICAgICAqL1xuICAgIGdldFBsdWdpbjogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIGlmIChpcy5pc0Z1bmN0aW9uKG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnIuZmluZEZpcnN0SW5zdGFuY2VPZih0aGlzLnBsdWdpbnMsIG9iaik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFyci5maW5kRmlyc3QodGhpcy5wbHVnaW5zLCBvYmosIHt0eXBlOiAnbG9vc2UnfSk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQbHVnaW5NYW5hZ2VyOyIsInZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCcuLi9ldmVudHMvZXZlbnRFbWl0dGVyJyksXG4gICAgUGx1Z2luTWFuYWdlciA9IHJlcXVpcmUoJy4vcGx1Z2luTWFuYWdlcicpO1xuXG4vKipcbiAqIEBjbGFzcyBMdWMuY29tcG9zaXRpb25FbnVtc1xuICogQ29tcG9zaXRpb24gZW51bXMgYXJlIGp1c3QgY29tbW9uIGNvbmZpZyBvYmplY3RzIGZvciBMdWMuQ29tcG9zaXRpb24uXG4gKiBIZXJlIGlzIGFuIGV4YW1wbGUgb2YgYSBjb21wb3NpdGlvbiB0aGF0IHVzZXMgRXZlbnRFbWl0dGVyIGJ1dCBvbmx5XG4gKiBwdXRzIHRoZSBlbWl0IG1ldGhvZCBvbiB0aGUgcHJvdG90eXBlLlxuICpcbiAgICB2YXIgQyA9IEx1Yy5kZWZpbmUoe1xuICAgICAgICAkY29tcG9zaXRpb25zOiB7XG4gICAgICAgICAgICBkZWZhdWx0czogTHVjLmNvbXBvc2l0aW9uRW51bXMuRXZlbnRFbWl0dGVyLFxuICAgICAgICAgICAgbWV0aG9kczogWydlbWl0J11cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIGMgPSBuZXcgQygpO1xuXG4gICAgdHlwZW9mIGMuZW1pdFxuICAgID5cImZ1bmN0aW9uXCJcbiAgICB0eXBlb2YgYy5vblxuICAgIFwidW5kZWZpbmVkXCJcbiAqIFxuICovXG5cbi8qKlxuICogQHByb3BlcnR5IHtPYmplY3R9IEV2ZW50RW1pdHRlclxuICovXG5tb2R1bGUuZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSB7XG4gICAgQ29uc3RydWN0b3I6IEV2ZW50RW1pdHRlcixcbiAgICBuYW1lOiAnZW1pdHRlcicsXG4gICAgbWV0aG9kczogJ2FsbE1ldGhvZHMnXG59O1xuXG5cbi8qKlxuICogQHByb3BlcnR5IHtPYmplY3R9IFBsdWdpbk1hbmFnZXJcbiAqL1xubW9kdWxlLmV4cG9ydHMuUGx1Z2luTWFuYWdlciA9IHtcbiAgICBuYW1lOiAncGx1Z2lucycsXG4gICAgaW5pdEFmdGVyOiB0cnVlLFxuICAgIENvbnN0cnVjdG9yOiBQbHVnaW5NYW5hZ2VyLFxuICAgIGNyZWF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtYW5hZ2VyID0gbmV3IHRoaXMuQ29uc3RydWN0b3Ioe1xuICAgICAgICAgICAgaW5zdGFuY2U6IHRoaXMuaW5zdGFuY2UsXG4gICAgICAgICAgICBpbnN0YW5jZUFyZ3M6IHRoaXMuaW5zdGFuY2VBcmdzXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBtYW5hZ2VyO1xuICAgIH0sXG4gICAgaWdub3JlTWV0aG9kczogJ2RlZmF1bHRQbHVnaW4nLFxuICAgIG1ldGhvZHM6ICdwdWJsaWNNZXRob2RzJ1xufTsiLCIvKiBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBieSBKU0NvdmVyYWdlIC0gZG8gbm90IGVkaXQgKi9cbmlmICh0eXBlb2YgXyRqc2NvdmVyYWdlID09PSAndW5kZWZpbmVkJykgXyRqc2NvdmVyYWdlID0ge307XG5pZiAoISBfJGpzY292ZXJhZ2VbJ2NsYXNzL2NvbXBvc2l0aW9uLmpzJ10pIHtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9jb21wb3NpdGlvbi5qcyddID0gW107XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvY29tcG9zaXRpb24uanMnXVsxXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvY29tcG9zaXRpb24uanMnXVs2Nl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2NvbXBvc2l0aW9uLmpzJ11bNjddID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9jb21wb3NpdGlvbi5qcyddWzcwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvY29tcG9zaXRpb24uanMnXVs3MV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2NvbXBvc2l0aW9uLmpzJ11bNzJdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9jb21wb3NpdGlvbi5qcyddWzc1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvY29tcG9zaXRpb24uanMnXVs3OF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2NvbXBvc2l0aW9uLmpzJ11bMTM5XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvY29tcG9zaXRpb24uanMnXVsxNDBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9jb21wb3NpdGlvbi5qcyddWzE0NF0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2NvbXBvc2l0aW9uLmpzJ11bMTQ4XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvY29tcG9zaXRpb24uanMnXVsxNDldID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9jb21wb3NpdGlvbi5qcyddWzE1MV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2NvbXBvc2l0aW9uLmpzJ11bMTUyXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvY29tcG9zaXRpb24uanMnXVsxNjhdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9jb21wb3NpdGlvbi5qcyddWzE3MV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2NvbXBvc2l0aW9uLmpzJ11bMjMzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvY29tcG9zaXRpb24uanMnXVsyMzRdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9jb21wb3NpdGlvbi5qcyddWzIzNV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2NvbXBvc2l0aW9uLmpzJ11bMjM2XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvY29tcG9zaXRpb24uanMnXVsyMzddID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9jb21wb3NpdGlvbi5qcyddWzI0MV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2NvbXBvc2l0aW9uLmpzJ11bMjQ1XSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvY29tcG9zaXRpb24uanMnXVsyNTBdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9jb21wb3NpdGlvbi5qcyddWzI1MV0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2NvbXBvc2l0aW9uLmpzJ11bMjUzXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvY29tcG9zaXRpb24uanMnXVsyNTVdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9jb21wb3NpdGlvbi5qcyddWzI1Nl0gPSAwO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2NvbXBvc2l0aW9uLmpzJ11bMjYwXSA9IDA7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvY29tcG9zaXRpb24uanMnXVsyNjZdID0gMDtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9jb21wb3NpdGlvbi5qcyddWzI3MF0gPSAwO1xufVxuXyRqc2NvdmVyYWdlWydjbGFzcy9jb21wb3NpdGlvbi5qcyddWzFdKys7XG52YXIgb2JqID0gcmVxdWlyZShcIi4uL29iamVjdFwiKSwgYXJyYXkgPSByZXF1aXJlKFwiLi4vYXJyYXlcIiksIGFwcGx5ID0gb2JqLmFwcGx5LCBtaXggPSBvYmoubWl4LCBvRmlsdGVyID0gb2JqLmZpbHRlciwgZW1wdHlGbiA9IFwiLi4vZnVuY3Rpb25cIi5lbXB0eUZuLCBpcyA9IHJlcXVpcmUoXCIuLi9pc1wiKTtcbl8kanNjb3ZlcmFnZVsnY2xhc3MvY29tcG9zaXRpb24uanMnXVs2Nl0rKztcbmZ1bmN0aW9uIENvbXBvc2l0aW9uKGMpIHtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9jb21wb3NpdGlvbi5qcyddWzY3XSsrO1xuICB2YXIgZGVmYXVsdHMgPSBjLmRlZmF1bHRzLCBjb25maWcgPSBjO1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2NvbXBvc2l0aW9uLmpzJ11bNzBdKys7XG4gIGlmIChkZWZhdWx0cykge1xuICAgIF8kanNjb3ZlcmFnZVsnY2xhc3MvY29tcG9zaXRpb24uanMnXVs3MV0rKztcbiAgICBtaXgoY29uZmlnLCBjb25maWcuZGVmYXVsdHMpO1xuICAgIF8kanNjb3ZlcmFnZVsnY2xhc3MvY29tcG9zaXRpb24uanMnXVs3Ml0rKztcbiAgICBkZWxldGUgY29uZmlnLmRlZmF1bHRzO1xuICB9XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvY29tcG9zaXRpb24uanMnXVs3NV0rKztcbiAgYXBwbHkodGhpcywgY29uZmlnKTtcbn1cbl8kanNjb3ZlcmFnZVsnY2xhc3MvY29tcG9zaXRpb24uanMnXVs3OF0rKztcbkNvbXBvc2l0aW9uLnByb3RvdHlwZSA9IHtjcmVhdGU6IChmdW5jdGlvbiAoKSB7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvY29tcG9zaXRpb24uanMnXVsxMzldKys7XG4gIHZhciBDb25zdHJ1Y3RvciA9IHRoaXMuQ29uc3RydWN0b3I7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvY29tcG9zaXRpb24uanMnXVsxNDBdKys7XG4gIHJldHVybiBuZXcgQ29uc3RydWN0b3IoKTtcbn0pLCBnZXRJbnN0YW5jZTogKGZ1bmN0aW9uICgpIHtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9jb21wb3NpdGlvbi5qcyddWzE0NF0rKztcbiAgcmV0dXJuIHRoaXMuY3JlYXRlKCk7XG59KSwgdmFsaWRhdGU6IChmdW5jdGlvbiAoKSB7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvY29tcG9zaXRpb24uanMnXVsxNDhdKys7XG4gIGlmICh0aGlzLm5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgIF8kanNjb3ZlcmFnZVsnY2xhc3MvY29tcG9zaXRpb24uanMnXVsxNDldKys7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQSBuYW1lIG11c3QgYmUgZGVmaW5lZFwiKTtcbiAgfVxuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2NvbXBvc2l0aW9uLmpzJ11bMTUxXSsrO1xuICBpZiAoISBpcy5pc0Z1bmN0aW9uKHRoaXMuQ29uc3RydWN0b3IpICYmIHRoaXMuY3JlYXRlID09PSBDb21wb3NpdGlvbi5wcm90b3R5cGUuY3JlYXRlKSB7XG4gICAgXyRqc2NvdmVyYWdlWydjbGFzcy9jb21wb3NpdGlvbi5qcyddWzE1Ml0rKztcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgQ29uc3RydWN0b3IgbXVzdCBiZSBmdW5jdGlvbiBpZiBjcmVhdGUgaXMgbm90IG92ZXJyaWRkZW5cIik7XG4gIH1cbn0pLCBmaWx0ZXJNZXRob2RGbnM6IHthbGxNZXRob2RzOiAoZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9jb21wb3NpdGlvbi5qcyddWzE2OF0rKztcbiAgcmV0dXJuIGlzLmlzRnVuY3Rpb24odmFsdWUpO1xufSksIHB1YmxpY01ldGhvZHM6IChmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2NvbXBvc2l0aW9uLmpzJ11bMTcxXSsrO1xuICByZXR1cm4gaXMuaXNGdW5jdGlvbih2YWx1ZSkgJiYga2V5LmNoYXJBdCgwKSAhPT0gXCJfXCI7XG59KX0sIG1ldGhvZHM6IGVtcHR5Rm4sIGlnbm9yZU1ldGhvZHM6IHVuZGVmaW5lZCwgZ2V0T2JqZWN0V2l0aE1ldGhvZHM6IChmdW5jdGlvbiAoKSB7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvY29tcG9zaXRpb24uanMnXVsyMzNdKys7XG4gIHZhciBtZXRob2RzT2JqID0gdGhpcy5Db25zdHJ1Y3RvciAmJiB0aGlzLkNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9jb21wb3NpdGlvbi5qcyddWzIzNF0rKztcbiAgaWYgKHRoaXMuaWdub3JlTWV0aG9kcykge1xuICAgIF8kanNjb3ZlcmFnZVsnY2xhc3MvY29tcG9zaXRpb24uanMnXVsyMzVdKys7XG4gICAgbWV0aG9kc09iaiA9IGFwcGx5KHt9LCBtZXRob2RzT2JqKTtcbiAgICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2NvbXBvc2l0aW9uLmpzJ11bMjM2XSsrO1xuICAgIGFycmF5LmVhY2godGhpcy5pZ25vcmVNZXRob2RzLCAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvY29tcG9zaXRpb24uanMnXVsyMzddKys7XG4gIGRlbGV0ZSBtZXRob2RzT2JqW3ZhbHVlXTtcbn0pKTtcbiAgfVxuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2NvbXBvc2l0aW9uLmpzJ11bMjQxXSsrO1xuICByZXR1cm4gbWV0aG9kc09iajtcbn0pLCBnZXRNZXRob2RzVG9Db21wb3NlOiAoZnVuY3Rpb24gKCkge1xuICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2NvbXBvc2l0aW9uLmpzJ11bMjQ1XSsrO1xuICB2YXIgbWV0aG9kcyA9IHRoaXMubWV0aG9kcywgcGFpcnNUb0FkZCwgZmlsdGVyRm47XG4gIF8kanNjb3ZlcmFnZVsnY2xhc3MvY29tcG9zaXRpb24uanMnXVsyNTBdKys7XG4gIGlmIChpcy5pc0FycmF5KG1ldGhvZHMpKSB7XG4gICAgXyRqc2NvdmVyYWdlWydjbGFzcy9jb21wb3NpdGlvbi5qcyddWzI1MV0rKztcbiAgICBwYWlyc1RvQWRkID0gbWV0aG9kcztcbiAgfVxuICBlbHNlIHtcbiAgICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2NvbXBvc2l0aW9uLmpzJ11bMjUzXSsrO1xuICAgIGZpbHRlckZuID0gbWV0aG9kcztcbiAgICBfJGpzY292ZXJhZ2VbJ2NsYXNzL2NvbXBvc2l0aW9uLmpzJ11bMjU1XSsrO1xuICAgIGlmIChpcy5pc1N0cmluZyhtZXRob2RzKSkge1xuICAgICAgXyRqc2NvdmVyYWdlWydjbGFzcy9jb21wb3NpdGlvbi5qcyddWzI1Nl0rKztcbiAgICAgIGZpbHRlckZuID0gdGhpcy5maWx0ZXJNZXRob2RGbnNbbWV0aG9kc107XG4gICAgfVxuICAgIF8kanNjb3ZlcmFnZVsnY2xhc3MvY29tcG9zaXRpb24uanMnXVsyNjBdKys7XG4gICAgcGFpcnNUb0FkZCA9IG9GaWx0ZXIodGhpcy5nZXRPYmplY3RXaXRoTWV0aG9kcygpLCBmaWx0ZXJGbiwgdGhpcywge293blByb3BlcnRpZXM6IGZhbHNlLCBrZXlzOiB0cnVlfSk7XG4gIH1cbiAgXyRqc2NvdmVyYWdlWydjbGFzcy9jb21wb3NpdGlvbi5qcyddWzI2Nl0rKztcbiAgcmV0dXJuIHBhaXJzVG9BZGQ7XG59KX07XG5fJGpzY292ZXJhZ2VbJ2NsYXNzL2NvbXBvc2l0aW9uLmpzJ11bMjcwXSsrO1xubW9kdWxlLmV4cG9ydHMgPSBDb21wb3NpdGlvbjtcbl8kanNjb3ZlcmFnZVsnY2xhc3MvY29tcG9zaXRpb24uanMnXS5zb3VyY2UgPSBbXCJ2YXIgb2JqID0gcmVxdWlyZSgnLi4vb2JqZWN0JyksXCIsXCIgICAgYXJyYXkgPSByZXF1aXJlKCcuLi9hcnJheScpLFwiLFwiICAgIGFwcGx5ID0gb2JqLmFwcGx5LFwiLFwiICAgIG1peCA9IG9iai5taXgsXCIsXCIgICAgb0ZpbHRlciA9IG9iai5maWx0ZXIsXCIsXCIgICAgZW1wdHlGbiA9ICgnLi4vZnVuY3Rpb24nKS5lbXB0eUZuLFwiLFwiICAgIGlzID0gcmVxdWlyZSgnLi4vaXMnKTtcIixcIlwiLFwiLyoqXCIsXCIgKiBAY2xhc3MgIEx1Yy5Db21wb3NpdGlvblwiLFwiICogQHByb3RlY3RlZFwiLFwiICogQ2xhc3MgdGhhdCB3cmFwcyB7QGxpbmsgTHVjLmRlZmluZSMkY29tcG9zaXRpb25zIGNvbXBvc2l0aW9ufSBjb25maWcgb2JqZWN0c1wiLFwiICogdG8gY29uZm9ybSB0byBhbiBhcGkuIFRoaXMgY2xhc3MgaXMgbm90IGF2YWlsYWJsZSBleHRlcm5hbGx5LiAgVGhlIGNvbmZpZyBvYmplY3RcIixcIiAqIHdpbGwgb3ZlcnJpZGUgYW55IHByb3RlY3RlZCBtZXRob2RzIGFuZCBkZWZhdWx0IGNvbmZpZ3MuICBEZWZhdWx0c1wiLFwiICogY2FuIGJlIHVzZWQgZm9yIG9mdGVuIHVzZWQgY29uZmlncywga2V5cyB0aGF0IGFyZSBub3QgZGVmYXVsdHMgd2lsbFwiLFwiICogb3ZlcnJpZGUgdGhlIGRlZmF1bHRzLlwiLFwiICpcIixcIiAgICB2YXIgQyA9IEx1Yy5kZWZpbmUoe1wiLFwiICAgICAgICAkY29tcG9zaXRpb25zOiB7XCIsXCIgICAgICAgICAgICBkZWZhdWx0czogTHVjLmNvbXBvc2l0aW9uRW51bXMuRXZlbnRFbWl0dGVyLFwiLFwiICAgICAgICAgICAgbWV0aG9kczogWydlbWl0J11cIixcIiAgICAgICAgfVwiLFwiICAgIH0pO1wiLFwiXCIsXCIgICAgdmFyIGMgPSBuZXcgQygpXCIsXCIgICAgdHlwZW9mIGMuZW1pdFwiLFwiICAgICZndDtcXFwiZnVuY3Rpb25cXFwiXCIsXCIgICAgdHlwZW9mIGMub25cIixcIiAgICAmZ3Q7XFxcInVuZGVmaW5lZFxcXCJcIixcIiAqXCIsXCIgKiBJZiB5b3Ugd2FudCB0byBhZGQgeW91ciBvd24gY29tcG9zaXRpb24gYWxsIHlvdSBuZWVkIHRvIGhhdmUgaXNcIixcIiAqIGEgbmFtZSBhbmQgYSBDb25zdHJ1Y3RvciwgdGhlIHJlc3Qgb2YgdGhlIGNvbmZpZ3Mgb2YgdGhpcyBjbGFzcyBhbmQgTHVjLkNvbXBvc2l0aW9uLmNyZWF0ZVwiLFwiICogY2FuIGJlIHVzZWQgdG8gaW5qZWN0IGJlaGF2aW9yIGlmIG5lZWRlZC5cIixcIiAqIFwiLFwiICAgICBmdW5jdGlvbiBDb3VudGVyKCkge1wiLFwiICAgICAgICB0aGlzLmNvdW50ID0gMDtcIixcIiAgICAgfTtcIixcIlwiLFwiICAgICBDb3VudGVyLnByb3RvdHlwZSA9IHtcIixcIiAgICAgICAgZ2V0Q291bnQ6IGZ1bmN0aW9uKCkge1wiLFwiICAgICAgICAgICAgcmV0dXJuIHRoaXMuY291bnQ7XCIsXCIgICAgICAgIH0sXCIsXCIgICAgICAgIGluY3JlYXNlQ291bnQ6IGZ1bmN0aW9uKCkge1wiLFwiICAgICAgICAgICAgdGhpcy5jb3VudCsrO1wiLFwiICAgICAgICB9XCIsXCIgICAgIH1cIixcIlwiLFwiICAgICB2YXIgQyA9IEx1Yy5kZWZpbmUoe1wiLFwiICAgICAgICAgICAgJGNvbXBvc2l0aW9uczoge1wiLFwiICAgICAgICAgICAgICAgIG5hbWU6ICdjb3VudGVyJyxcIixcIiAgICAgICAgICAgICAgICBDb25zdHJ1Y3RvcjogQ291bnRlcixcIixcIiAgICAgICAgICAgICAgICBtZXRob2RzOiAnYWxsTWV0aG9kcydcIixcIiAgICAgICAgICAgIH1cIixcIiAgICB9KTtcIixcIlwiLFwiICAgIHZhciBjID0gbmV3IEMoKVwiLFwiXCIsXCIgICAgYy5pbmNyZWFzZUNvdW50KCk7XCIsXCIgICAgYy5pbmNyZWFzZUNvdW50KCk7XCIsXCIgICAgYy5pbmNyZWFzZUNvdW50KCk7XCIsXCIgICAgYy5nZXRDb3VudCgpO1wiLFwiICAgICZndDszXCIsXCIgICAgYy5jb3VudFwiLFwiICAgICZndDt1bmRlZmluZWRcIixcIiAqL1wiLFwiZnVuY3Rpb24gQ29tcG9zaXRpb24oYykge1wiLFwiICAgIHZhciBkZWZhdWx0cyA9IGMuZGVmYXVsdHMsXCIsXCIgICAgICAgIGNvbmZpZyA9IGM7XCIsXCJcIixcIiAgICBpZihkZWZhdWx0cykge1wiLFwiICAgICAgICBtaXgoY29uZmlnLCBjb25maWcuZGVmYXVsdHMpO1wiLFwiICAgICAgICBkZWxldGUgY29uZmlnLmRlZmF1bHRzO1wiLFwiICAgIH1cIixcIlwiLFwiICAgIGFwcGx5KHRoaXMsIGNvbmZpZyk7XCIsXCJ9XCIsXCJcIixcIkNvbXBvc2l0aW9uLnByb3RvdHlwZSA9IHtcIixcIiAgICAvKipcIixcIiAgICAgKiBAY2ZnIHtTdHJpbmd9IG5hbWUgKHJlcXVpcmVkKSB0aGUgbmFtZVwiLFwiICAgICAqL1wiLFwiICAgIFwiLFwiICAgIC8qKlwiLFwiICAgICAqIEBjZmcge09iamVjdH0gZGVmYXVsdHNcIixcIiAgICAgKi9cIixcIiAgICBcIixcIiAgICAvKipcIixcIiAgICAgKiBAY2ZnIHtCb29sZWFufSBpbml0QWZ0ZXIgIGRlZmF1bHRzIHRvIGZhbHNlXCIsXCIgICAgICogcGFzcyBpbiB0cnVlIHRvIGluaXQgdGhlIGNvbXBvc2l0aW9uIGluc3RhbmNlIGFmdGVyIHRoZSBcIixcIiAgICAgKiBzdXBlcmNsYXNzIGhhcyBiZWVuIGNhbGxlZC5cIixcIiAgICAgKi9cIixcIlwiLFwiICAgIC8qKlwiLFwiICAgICAqIEBjZmcge0Z1bmN0aW9ufSBDb25zdHJ1Y3RvciAocmVxdWlyZWQpIHRoZSBDb25zdHJ1Y3RvclwiLFwiICAgICAqIHRvIHVzZSB3aGVuIGNyZWF0aW5nIHRoZSBjb21wb3NpdGlvbiBpbnN0YW5jZS4gIFRoaXNcIixcIiAgICAgKiBpcyByZXF1aXJlZCBpZiBMdWMuQ29tcG9zaXRpb24uY3JlYXRlIGlzIG5vdCBvdmVyd3JpdHRlbiBieVwiLFwiICAgICAqIHRoZSBwYXNzZWQgaW4gY29tcG9zaXRpb24gY29uZmlnIG9iamVjdC5cIixcIiAgICAgKi9cIixcIiAgICBcIixcIiAgICAvKipcIixcIiAgICAgKiBAcHJvdGVjdGVkXCIsXCIgICAgICogQnkgZGVmYXVsdCBqdXN0IHJldHVybiBhIG5ld2x5IGNyZWF0ZWQgQ29uc3RydWN0b3IgaW5zdGFuY2UuXCIsXCIgICAgICogXCIsXCIgICAgICogV2hlbiBjcmVhdGUgaXMgY2FsbGVkIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBjYW4gYmUgdXNlZCA6XCIsXCIgICAgICogXCIsXCIgICAgICogdGhpcy5pbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBpcyBjcmVhdGluZ1wiLFwiICAgICAqIHRoZSBjb21wb3NpdGlvbi5cIixcIiAgICAgKiBcIixcIiAgICAgKiB0aGlzLkNvbnN0cnVjdG9yIHRoZSBjb25zdHJ1Y3RvciB0aGF0IGlzIHBhc3NlZCBpbiBmcm9tXCIsXCIgICAgICogdGhlIGNvbXBvc2l0aW9uIGNvbmZpZy4gXCIsXCIgICAgICpcIixcIiAgICAgKiB0aGlzLmluc3RhbmNlQXJncyB0aGUgYXJndW1lbnRzIHBhc3NlZCBpbnRvIHRoZSBpbnN0YW5jZSB3aGVuIGl0IFwiLFwiICAgICAqIGlzIGJlaW5nIGNyZWF0ZWQuICBGb3IgZXhhbXBsZVwiLFwiXCIsXCIgICAgICAgIG5ldyBNeUNsYXNzV2l0aEFDb21wb3NpdGlvbih7cGx1Z2luczogW119KVwiLFwiICAgICAgICAvL2luc2lkZSBvZiB0aGUgY3JlYXRlIG1ldGhvZFwiLFwiICAgICAgICB0aGlzLmluc3RhbmNlQXJnc1wiLFwiICAgICAgICAmZ3Q7W3twbHVnaW5zOiBbXX1dXCIsXCJcIixcIiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFwiLFwiICAgICAqIHRoZSBjb21wb3NpdGlvbiBpbnN0YW5jZS5cIixcIiAgICAgKlwiLFwiICAgICAqIEZvciBleGFtcGxlIHNldCB0aGUgZW1pdHRlcnMgbWF4TGlzdGVuZXJzXCIsXCIgICAgICogdG8gd2hhdCB0aGUgaW5zdGFuY2UgaGFzIGNvbmZpZ2VkLlwiLFwiICAgICAgXCIsXCIgICAgICAgIG1heExpc3RlbmVyczogMTAwLFwiLFwiICAgICAgICAkY29tcG9zaXRpb25zOiB7XCIsXCIgICAgICAgICAgICBDb25zdHJ1Y3RvcjogTHVjLkV2ZW50RW1pdHRlcixcIixcIiAgICAgICAgICAgIGNyZWF0ZTogZnVuY3Rpb24oKSB7XCIsXCIgICAgICAgICAgICAgICAgdmFyIGVtaXR0ZXIgPSBuZXcgdGhpcy5Db25zdHJ1Y3RvcigpO1wiLFwiICAgICAgICAgICAgICAgIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKHRoaXMuaW5zdGFuY2UubWF4TGlzdGVuZXJzKTtcIixcIiAgICAgICAgICAgICAgICByZXR1cm4gZW1pdHRlcjtcIixcIiAgICAgICAgICAgIH0sXCIsXCIgICAgICAgICAgICBuYW1lOiAnZW1pdHRlcidcIixcIiAgICAgICAgfVwiLFwiXCIsXCIgICAgICovXCIsXCIgICAgY3JlYXRlOiBmdW5jdGlvbigpIHtcIixcIiAgICAgICAgdmFyIENvbnN0cnVjdG9yID0gdGhpcy5Db25zdHJ1Y3RvcjtcIixcIiAgICAgICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvcigpO1wiLFwiICAgIH0sXCIsXCJcIixcIiAgICBnZXRJbnN0YW5jZTogZnVuY3Rpb24oKSB7XCIsXCIgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZSgpO1wiLFwiICAgIH0sXCIsXCJcIixcIiAgICB2YWxpZGF0ZTogZnVuY3Rpb24oKSB7XCIsXCIgICAgICAgIGlmKHRoaXMubmFtZSAgPT09IHVuZGVmaW5lZCkge1wiLFwiICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIG5hbWUgbXVzdCBiZSBkZWZpbmVkJyk7XCIsXCIgICAgICAgIH1cIixcIiAgICAgICAgaWYoIWlzLmlzRnVuY3Rpb24odGhpcy5Db25zdHJ1Y3RvcikgJmFtcDsmYW1wOyB0aGlzLmNyZWF0ZSA9PT0gQ29tcG9zaXRpb24ucHJvdG90eXBlLmNyZWF0ZSkge1wiLFwiICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgQ29uc3RydWN0b3IgbXVzdCBiZSBmdW5jdGlvbiBpZiBjcmVhdGUgaXMgbm90IG92ZXJyaWRkZW4nKTtcIixcIiAgICAgICAgfVwiLFwiICAgIH0sXCIsXCJcIixcIiAgICAvKipcIixcIiAgICAgKiBAcHJvcGVydHkgZmlsdGVyTWV0aG9kRm5zXCIsXCIgICAgICogQHR5cGUge09iamVjdH1cIixcIiAgICAgKiBAcHJvcGVydHkgZmlsdGVyTWV0aG9kRm5zLmFsbE1ldGhvZHMgcmV0dXJuIGFsbCBtZXRob2RzIGZyb20gdGhlXCIsXCIgICAgICogY29uc3RydWN0b3JzIHByb3RvdHlwZVwiLFwiICAgICAqIEBwcm9wZXJ0eSBmaWx0ZXJNZXRob2RGbnMucHVibGljIHJldHVybiBhbGwgbWV0aG9kcyB0aGF0IGRvbid0XCIsXCIgICAgICogc3RhcnQgd2l0aCBfLiAgV2Uga25vdyBub3QgZXZlcnlvbmUgZm9sbG93cyB0aGlzIGNvbnZlbnRpb24sIGJ1dCB3ZVwiLFwiICAgICAqIGRvIGFuZCBzbyBkbyBtYW55IG90aGVycy5cIixcIiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XCIsXCIgICAgICovXCIsXCIgICAgZmlsdGVyTWV0aG9kRm5zOiB7XCIsXCIgICAgICAgIGFsbE1ldGhvZHM6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcIixcIiAgICAgICAgICAgIHJldHVybiBpcy5pc0Z1bmN0aW9uKHZhbHVlKTtcIixcIiAgICAgICAgfSxcIixcIiAgICAgICAgcHVibGljTWV0aG9kczogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1wiLFwiICAgICAgICAgICAgcmV0dXJuIGlzLmlzRnVuY3Rpb24odmFsdWUpICZhbXA7JmFtcDsga2V5LmNoYXJBdCgwKSAhPT0gJ18nO1wiLFwiICAgICAgICB9XCIsXCIgICAgfSxcIixcIlwiLFwiICAgIC8qKlwiLFwiICAgICAqIEBjZmcge0Z1bmN0aW9uL1N0cmluZy9BcnJheVtdfSBtZXRob2RzXCIsXCIgICAgICogVGhlIGtleXMgdG8gYWRkIHRvIHRoZSBkZWZpbmVycyBwcm90b3R5cGUgdGhhdCB3aWxsIGluIHR1cm4gY2FsbFwiLFwiICAgICAqIHRoZSBjb21wb3NpdGlvbnMgbWV0aG9kLlwiLFwiICAgICAqIFwiLFwiICAgICAqIERlZmF1bHRzIHRvIEx1Yy5lbXB0eUZuLiBcIixcIiAgICAgKiBJZiBhbiBhcnJheSBpcyBwYXNzZWQgaXQgd2lsbCBqdXN0IHVzZSB0aGF0IEFycmF5LlwiLFwiICAgICAqIFwiLFwiICAgICAqIElmIGEgc3RyaW5nIGlzIHBhc3NlZCBhbmQgbWF0Y2hlcyBhIG1ldGhvZCBmcm9tIFwiLFwiICAgICAqIEx1Yy5Db21wb3NpdGlvbi5maWx0ZXJNZXRob2RGbnMgaXQgd2lsbCBjYWxsIHRoYXQgaW5zdGVhZC5cIixcIiAgICAgKiBcIixcIiAgICAgKiBJZiBhIGZ1bmN0aW9uIGlzIGRlZmluZWQgaXRcIixcIiAgICAgKiB3aWxsIGdldCBjYWxsZWQgd2hpbGUgaXRlcmF0aW5nIG92ZXIgZWFjaCBrZXkgdmFsdWUgcGFpciBvZiB0aGUgXCIsXCIgICAgICogQ29uc3RydWN0b3IncyBwcm90b3R5cGUsIGlmIGEgdHJ1dGh5IHZhbHVlIGlzIFwiLFwiICAgICAqIHJldHVybmVkIHRoZSBwcm9wZXJ0eSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBkZWZpbmluZ1wiLFwiICAgICAqIGNsYXNzZXMgcHJvdG90eXBlLlwiLFwiICAgICAqIFwiLFwiICAgICAqIEZvciBleGFtcGxlIHRoaXMgY29uZmlnIHdpbGwgb25seSBleHBvc2UgdGhlIGVtaXQgbWV0aG9kIFwiLFwiICAgICAqIHRvIHRoZSBkZWZpbmluZyBjbGFzc1wiLFwiICAgICBcIixcIiAgICAgICAgJGNvbXBvc2l0aW9uczoge1wiLFwiICAgICAgICAgICAgQ29uc3RydWN0b3I6IEx1Yy5FdmVudEVtaXR0ZXIsXCIsXCIgICAgICAgICAgICBtZXRob2RzOiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XCIsXCIgICAgICAgICAgICAgICAgcmV0dXJuIGtleSA9PT0gJ2VtaXQnO1wiLFwiICAgICAgICAgICAgfSxcIixcIiAgICAgICAgICAgIG5hbWU6ICdlbWl0dGVyJ1wiLFwiICAgICAgICB9XCIsXCIgICAgICogdGhpcyBpcyBhbHNvIGEgdmFsaWQgY29uZmlnXCIsXCIgICAgICogXCIsXCIgICAgICAgICRjb21wb3NpdGlvbnM6IHtcIixcIiAgICAgICAgICAgIENvbnN0cnVjdG9yOiBMdWMuRXZlbnRFbWl0dGVyLFwiLFwiICAgICAgICAgICAgbWV0aG9kczogWydlbWl0dGVyJ10sXCIsXCIgICAgICAgICAgICBuYW1lOiAnZW1pdHRlcidcIixcIiAgICAgICAgfVwiLFwiICAgICAqIFwiLFwiICAgICAqL1wiLFwiICAgIG1ldGhvZHM6IGVtcHR5Rm4sXCIsXCJcIixcIiAgICAvKipcIixcIiAgICAgKiBAY2ZnIHtTdHJpbmdbXS9TdHJpbmd9IGlnbm9yZU1ldGhvZHMgbWV0aG9kcyB0aGF0IHdpbGwgYWx3YXlzXCIsXCIgICAgICogYmUgaWdub3JlZCBpZiBtZXRob2RzIGlzIG5vdCBhbiBBcnJheS5cIixcIiAgICAgKlwiLFwiICAgICAgICBcIixcIiAgICAgICAgdmFyIEMgPSBMdWMuZGVmaW5lKHtcIixcIiAgICAgICAgICAgICAgICAkY29tcG9zaXRpb25zOiB7XCIsXCIgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRzOiBMdWMuY29tcG9zaXRpb25FbnVtcy5FdmVudEVtaXR0ZXIsXCIsXCIgICAgICAgICAgICAgICAgICAgIG1ldGhvZHM6ICdhbGxNZXRob2RzJyxcIixcIiAgICAgICAgICAgICAgICAgICAgaWdub3JlTWV0aG9kczogWydlbWl0J11cIixcIiAgICAgICAgICAgICAgICB9XCIsXCIgICAgICAgICAgICB9KTtcIixcIlwiLFwiICAgICAgICAgICAgdmFyIGMgPSBuZXcgQygpO1wiLFwiICAgICAgICAgICAgdHlwZW9mIGMuZW1pdFwiLFwiICAgICAgICAgICAgJmd0O1xcXCJ1bmRlZmluZWRcXFwiXCIsXCIgICAgICovXCIsXCIgICAgaWdub3JlTWV0aG9kczogdW5kZWZpbmVkLFwiLFwiXCIsXCIgICAgZ2V0T2JqZWN0V2l0aE1ldGhvZHM6IGZ1bmN0aW9uKCkge1wiLFwiICAgICAgICB2YXIgbWV0aG9kc09iaiA9IHRoaXMuQ29uc3RydWN0b3IgJmFtcDsmYW1wOyB0aGlzLkNvbnN0cnVjdG9yLnByb3RvdHlwZTtcIixcIiAgICAgICAgaWYgKHRoaXMuaWdub3JlTWV0aG9kcykge1wiLFwiICAgICAgICAgICAgbWV0aG9kc09iaiA9IGFwcGx5KHt9LCBtZXRob2RzT2JqKTtcIixcIiAgICAgICAgICAgIGFycmF5LmVhY2godGhpcy5pZ25vcmVNZXRob2RzLCBmdW5jdGlvbih2YWx1ZSkge1wiLFwiICAgICAgICAgICAgICAgIGRlbGV0ZSBtZXRob2RzT2JqW3ZhbHVlXTtcIixcIiAgICAgICAgICAgIH0pO1wiLFwiICAgICAgICB9XCIsXCJcIixcIiAgICAgICAgcmV0dXJuIG1ldGhvZHNPYmo7XCIsXCIgICAgfSxcIixcIlwiLFwiICAgIGdldE1ldGhvZHNUb0NvbXBvc2U6IGZ1bmN0aW9uKCkge1wiLFwiICAgICAgICB2YXIgbWV0aG9kcyA9IHRoaXMubWV0aG9kcyxcIixcIiAgICAgICAgICAgIHBhaXJzVG9BZGQsXCIsXCIgICAgICAgICAgICBmaWx0ZXJGbjtcIixcIlwiLFwiXCIsXCIgICAgICAgIGlmIChpcy5pc0FycmF5KG1ldGhvZHMpKSB7XCIsXCIgICAgICAgICAgICBwYWlyc1RvQWRkID0gbWV0aG9kcztcIixcIiAgICAgICAgfSBlbHNlIHtcIixcIiAgICAgICAgICAgIGZpbHRlckZuID0gbWV0aG9kcztcIixcIlwiLFwiICAgICAgICAgICAgaWYgKGlzLmlzU3RyaW5nKG1ldGhvZHMpKSB7XCIsXCIgICAgICAgICAgICAgICAgZmlsdGVyRm4gPSB0aGlzLmZpbHRlck1ldGhvZEZuc1ttZXRob2RzXTtcIixcIiAgICAgICAgICAgIH1cIixcIlwiLFwiICAgICAgICAgICAgLy9Db25zdHJ1Y3RvcnMgYXJlIG5vdCBuZWVkZWQgaWYgY3JlYXRlIGlzIG92ZXJ3cml0dGVuXCIsXCIgICAgICAgICAgICBwYWlyc1RvQWRkID0gb0ZpbHRlcih0aGlzLmdldE9iamVjdFdpdGhNZXRob2RzKCksIGZpbHRlckZuLCB0aGlzLCB7XCIsXCIgICAgICAgICAgICAgICAgb3duUHJvcGVydGllczogZmFsc2UsXCIsXCIgICAgICAgICAgICAgICAga2V5czogdHJ1ZVwiLFwiICAgICAgICAgICAgfSk7XCIsXCIgICAgICAgIH1cIixcIlwiLFwiICAgICAgICByZXR1cm4gcGFpcnNUb0FkZDtcIixcIiAgICB9XCIsXCJ9O1wiLFwiXCIsXCJtb2R1bGUuZXhwb3J0cyA9IENvbXBvc2l0aW9uO1wiXTtcbiIsIihmdW5jdGlvbigpey8vIENvcHlyaWdodCAyMDA5LTIwMTIgYnkgY29udHJpYnV0b3JzLCBNSVQgTGljZW5zZVxuLy8gdmltOiB0cz00IHN0cz00IHN3PTQgZXhwYW5kdGFiXG5cbi8vIE1vZHVsZSBzeXN0ZW1zIG1hZ2ljIGRhbmNlXG4oZnVuY3Rpb24gKGRlZmluaXRpb24pIHtcbiAgICAvLyBSZXF1aXJlSlNcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgZGVmaW5lKGRlZmluaXRpb24pO1xuICAgIC8vIFlVSTNcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBZVUkgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIFlVSS5hZGQoXCJlczVcIiwgZGVmaW5pdGlvbik7XG4gICAgLy8gQ29tbW9uSlMgYW5kIDxzY3JpcHQ+XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZGVmaW5pdGlvbigpO1xuICAgIH1cbn0pKGZ1bmN0aW9uICgpIHtcblxuLyoqXG4gKiBCcmluZ3MgYW4gZW52aXJvbm1lbnQgYXMgY2xvc2UgdG8gRUNNQVNjcmlwdCA1IGNvbXBsaWFuY2VcbiAqIGFzIGlzIHBvc3NpYmxlIHdpdGggdGhlIGZhY2lsaXRpZXMgb2YgZXJzdHdoaWxlIGVuZ2luZXMuXG4gKlxuICogQW5ub3RhdGVkIEVTNTogaHR0cDovL2VzNS5naXRodWIuY29tLyAoc3BlY2lmaWMgbGlua3MgYmVsb3cpXG4gKiBFUzUgU3BlYzogaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL3B1YmxpY2F0aW9ucy9maWxlcy9FQ01BLVNUL0VjbWEtMjYyLnBkZlxuICogUmVxdWlyZWQgcmVhZGluZzogaHR0cDovL2phdmFzY3JpcHR3ZWJsb2cud29yZHByZXNzLmNvbS8yMDExLzEyLzA1L2V4dGVuZGluZy1qYXZhc2NyaXB0LW5hdGl2ZXMvXG4gKi9cblxuLy9cbi8vIEZ1bmN0aW9uXG4vLyA9PT09PT09PVxuLy9cblxuLy8gRVMtNSAxNS4zLjQuNVxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMy40LjVcblxuZnVuY3Rpb24gRW1wdHkoKSB7fVxuXG5pZiAoIUZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kKSB7XG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiBiaW5kKHRoYXQpIHsgLy8gLmxlbmd0aCBpcyAxXG4gICAgICAgIC8vIDEuIExldCBUYXJnZXQgYmUgdGhlIHRoaXMgdmFsdWUuXG4gICAgICAgIHZhciB0YXJnZXQgPSB0aGlzO1xuICAgICAgICAvLyAyLiBJZiBJc0NhbGxhYmxlKFRhcmdldCkgaXMgZmFsc2UsIHRocm93IGEgVHlwZUVycm9yIGV4Y2VwdGlvbi5cbiAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgY2FsbGVkIG9uIGluY29tcGF0aWJsZSBcIiArIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gMy4gTGV0IEEgYmUgYSBuZXcgKHBvc3NpYmx5IGVtcHR5KSBpbnRlcm5hbCBsaXN0IG9mIGFsbCBvZiB0aGVcbiAgICAgICAgLy8gICBhcmd1bWVudCB2YWx1ZXMgcHJvdmlkZWQgYWZ0ZXIgdGhpc0FyZyAoYXJnMSwgYXJnMiBldGMpLCBpbiBvcmRlci5cbiAgICAgICAgLy8gWFhYIHNsaWNlZEFyZ3Mgd2lsbCBzdGFuZCBpbiBmb3IgXCJBXCIgaWYgdXNlZFxuICAgICAgICB2YXIgYXJncyA9IF9BcnJheV9zbGljZV8uY2FsbChhcmd1bWVudHMsIDEpOyAvLyBmb3Igbm9ybWFsIGNhbGxcbiAgICAgICAgLy8gNC4gTGV0IEYgYmUgYSBuZXcgbmF0aXZlIEVDTUFTY3JpcHQgb2JqZWN0LlxuICAgICAgICAvLyAxMS4gU2V0IHRoZSBbW1Byb3RvdHlwZV1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgdG8gdGhlIHN0YW5kYXJkXG4gICAgICAgIC8vICAgYnVpbHQtaW4gRnVuY3Rpb24gcHJvdG90eXBlIG9iamVjdCBhcyBzcGVjaWZpZWQgaW4gMTUuMy4zLjEuXG4gICAgICAgIC8vIDEyLiBTZXQgdGhlIFtbQ2FsbF1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgYXMgZGVzY3JpYmVkIGluXG4gICAgICAgIC8vICAgMTUuMy40LjUuMS5cbiAgICAgICAgLy8gMTMuIFNldCB0aGUgW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIGFzIGRlc2NyaWJlZCBpblxuICAgICAgICAvLyAgIDE1LjMuNC41LjIuXG4gICAgICAgIC8vIDE0LiBTZXQgdGhlIFtbSGFzSW5zdGFuY2VdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIGFzIGRlc2NyaWJlZCBpblxuICAgICAgICAvLyAgIDE1LjMuNC41LjMuXG4gICAgICAgIHZhciBib3VuZCA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkge1xuICAgICAgICAgICAgICAgIC8vIDE1LjMuNC41LjIgW1tDb25zdHJ1Y3RdXVxuICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIFtbQ29uc3RydWN0XV0gaW50ZXJuYWwgbWV0aG9kIG9mIGEgZnVuY3Rpb24gb2JqZWN0LFxuICAgICAgICAgICAgICAgIC8vIEYgdGhhdCB3YXMgY3JlYXRlZCB1c2luZyB0aGUgYmluZCBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCBhXG4gICAgICAgICAgICAgICAgLy8gbGlzdCBvZiBhcmd1bWVudHMgRXh0cmFBcmdzLCB0aGUgZm9sbG93aW5nIHN0ZXBzIGFyZSB0YWtlbjpcbiAgICAgICAgICAgICAgICAvLyAxLiBMZXQgdGFyZ2V0IGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tUYXJnZXRGdW5jdGlvbl1dXG4gICAgICAgICAgICAgICAgLy8gICBpbnRlcm5hbCBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyAyLiBJZiB0YXJnZXQgaGFzIG5vIFtbQ29uc3RydWN0XV0gaW50ZXJuYWwgbWV0aG9kLCBhXG4gICAgICAgICAgICAgICAgLy8gICBUeXBlRXJyb3IgZXhjZXB0aW9uIGlzIHRocm93bi5cbiAgICAgICAgICAgICAgICAvLyAzLiBMZXQgYm91bmRBcmdzIGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tCb3VuZEFyZ3NdXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAgIC8vICAgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgLy8gNC4gTGV0IGFyZ3MgYmUgYSBuZXcgbGlzdCBjb250YWluaW5nIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGVcbiAgICAgICAgICAgICAgICAvLyAgIGxpc3QgYm91bmRBcmdzIGluIHRoZSBzYW1lIG9yZGVyIGZvbGxvd2VkIGJ5IHRoZSBzYW1lXG4gICAgICAgICAgICAgICAgLy8gICB2YWx1ZXMgYXMgdGhlIGxpc3QgRXh0cmFBcmdzIGluIHRoZSBzYW1lIG9yZGVyLlxuICAgICAgICAgICAgICAgIC8vIDUuIFJldHVybiB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIFtbQ29uc3RydWN0XV0gaW50ZXJuYWxcbiAgICAgICAgICAgICAgICAvLyAgIG1ldGhvZCBvZiB0YXJnZXQgcHJvdmlkaW5nIGFyZ3MgYXMgdGhlIGFyZ3VtZW50cy5cblxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3MuY29uY2F0KF9BcnJheV9zbGljZV8uY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdChyZXN1bHQpID09PSByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gMTUuMy40LjUuMSBbW0NhbGxdXVxuICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIFtbQ2FsbF1dIGludGVybmFsIG1ldGhvZCBvZiBhIGZ1bmN0aW9uIG9iamVjdCwgRixcbiAgICAgICAgICAgICAgICAvLyB3aGljaCB3YXMgY3JlYXRlZCB1c2luZyB0aGUgYmluZCBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCBhXG4gICAgICAgICAgICAgICAgLy8gdGhpcyB2YWx1ZSBhbmQgYSBsaXN0IG9mIGFyZ3VtZW50cyBFeHRyYUFyZ3MsIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICAgICAgICAvLyBzdGVwcyBhcmUgdGFrZW46XG4gICAgICAgICAgICAgICAgLy8gMS4gTGV0IGJvdW5kQXJncyBiZSB0aGUgdmFsdWUgb2YgRidzIFtbQm91bmRBcmdzXV0gaW50ZXJuYWxcbiAgICAgICAgICAgICAgICAvLyAgIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIDIuIExldCBib3VuZFRoaXMgYmUgdGhlIHZhbHVlIG9mIEYncyBbW0JvdW5kVGhpc11dIGludGVybmFsXG4gICAgICAgICAgICAgICAgLy8gICBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyAzLiBMZXQgdGFyZ2V0IGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tUYXJnZXRGdW5jdGlvbl1dIGludGVybmFsXG4gICAgICAgICAgICAgICAgLy8gICBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyA0LiBMZXQgYXJncyBiZSBhIG5ldyBsaXN0IGNvbnRhaW5pbmcgdGhlIHNhbWUgdmFsdWVzIGFzIHRoZVxuICAgICAgICAgICAgICAgIC8vICAgbGlzdCBib3VuZEFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIgZm9sbG93ZWQgYnkgdGhlIHNhbWVcbiAgICAgICAgICAgICAgICAvLyAgIHZhbHVlcyBhcyB0aGUgbGlzdCBFeHRyYUFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIuXG4gICAgICAgICAgICAgICAgLy8gNS4gUmV0dXJuIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgW1tDYWxsXV0gaW50ZXJuYWwgbWV0aG9kXG4gICAgICAgICAgICAgICAgLy8gICBvZiB0YXJnZXQgcHJvdmlkaW5nIGJvdW5kVGhpcyBhcyB0aGUgdGhpcyB2YWx1ZSBhbmRcbiAgICAgICAgICAgICAgICAvLyAgIHByb3ZpZGluZyBhcmdzIGFzIHRoZSBhcmd1bWVudHMuXG5cbiAgICAgICAgICAgICAgICAvLyBlcXVpdjogdGFyZ2V0LmNhbGwodGhpcywgLi4uYm91bmRBcmdzLCAuLi5hcmdzKVxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICAgICAgICAgIHRoYXQsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3MuY29uY2F0KF9BcnJheV9zbGljZV8uY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9O1xuICAgICAgICBpZih0YXJnZXQucHJvdG90eXBlKSB7XG4gICAgICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSB0YXJnZXQucHJvdG90eXBlO1xuICAgICAgICAgICAgYm91bmQucHJvdG90eXBlID0gbmV3IEVtcHR5KCk7XG4gICAgICAgICAgICAvLyBDbGVhbiB1cCBkYW5nbGluZyByZWZlcmVuY2VzLlxuICAgICAgICAgICAgRW1wdHkucHJvdG90eXBlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBYWFggYm91bmQubGVuZ3RoIGlzIG5ldmVyIHdyaXRhYmxlLCBzbyBkb24ndCBldmVuIHRyeVxuICAgICAgICAvL1xuICAgICAgICAvLyAxNS4gSWYgdGhlIFtbQ2xhc3NdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBUYXJnZXQgaXMgXCJGdW5jdGlvblwiLCB0aGVuXG4gICAgICAgIC8vICAgICBhLiBMZXQgTCBiZSB0aGUgbGVuZ3RoIHByb3BlcnR5IG9mIFRhcmdldCBtaW51cyB0aGUgbGVuZ3RoIG9mIEEuXG4gICAgICAgIC8vICAgICBiLiBTZXQgdGhlIGxlbmd0aCBvd24gcHJvcGVydHkgb2YgRiB0byBlaXRoZXIgMCBvciBMLCB3aGljaGV2ZXIgaXNcbiAgICAgICAgLy8gICAgICAgbGFyZ2VyLlxuICAgICAgICAvLyAxNi4gRWxzZSBzZXQgdGhlIGxlbmd0aCBvd24gcHJvcGVydHkgb2YgRiB0byAwLlxuICAgICAgICAvLyAxNy4gU2V0IHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBsZW5ndGggb3duIHByb3BlcnR5IG9mIEYgdG8gdGhlIHZhbHVlc1xuICAgICAgICAvLyAgIHNwZWNpZmllZCBpbiAxNS4zLjUuMS5cblxuICAgICAgICAvLyBUT0RPXG4gICAgICAgIC8vIDE4LiBTZXQgdGhlIFtbRXh0ZW5zaWJsZV1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgdG8gdHJ1ZS5cblxuICAgICAgICAvLyBUT0RPXG4gICAgICAgIC8vIDE5LiBMZXQgdGhyb3dlciBiZSB0aGUgW1tUaHJvd1R5cGVFcnJvcl1dIGZ1bmN0aW9uIE9iamVjdCAoMTMuMi4zKS5cbiAgICAgICAgLy8gMjAuIENhbGwgdGhlIFtbRGVmaW5lT3duUHJvcGVydHldXSBpbnRlcm5hbCBtZXRob2Qgb2YgRiB3aXRoXG4gICAgICAgIC8vICAgYXJndW1lbnRzIFwiY2FsbGVyXCIsIFByb3BlcnR5RGVzY3JpcHRvciB7W1tHZXRdXTogdGhyb3dlciwgW1tTZXRdXTpcbiAgICAgICAgLy8gICB0aHJvd2VyLCBbW0VudW1lcmFibGVdXTogZmFsc2UsIFtbQ29uZmlndXJhYmxlXV06IGZhbHNlfSwgYW5kXG4gICAgICAgIC8vICAgZmFsc2UuXG4gICAgICAgIC8vIDIxLiBDYWxsIHRoZSBbW0RlZmluZU93blByb3BlcnR5XV0gaW50ZXJuYWwgbWV0aG9kIG9mIEYgd2l0aFxuICAgICAgICAvLyAgIGFyZ3VtZW50cyBcImFyZ3VtZW50c1wiLCBQcm9wZXJ0eURlc2NyaXB0b3Ige1tbR2V0XV06IHRocm93ZXIsXG4gICAgICAgIC8vICAgW1tTZXRdXTogdGhyb3dlciwgW1tFbnVtZXJhYmxlXV06IGZhbHNlLCBbW0NvbmZpZ3VyYWJsZV1dOiBmYWxzZX0sXG4gICAgICAgIC8vICAgYW5kIGZhbHNlLlxuXG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgLy8gTk9URSBGdW5jdGlvbiBvYmplY3RzIGNyZWF0ZWQgdXNpbmcgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgZG8gbm90XG4gICAgICAgIC8vIGhhdmUgYSBwcm90b3R5cGUgcHJvcGVydHkgb3IgdGhlIFtbQ29kZV1dLCBbW0Zvcm1hbFBhcmFtZXRlcnNdXSwgYW5kXG4gICAgICAgIC8vIFtbU2NvcGVdXSBpbnRlcm5hbCBwcm9wZXJ0aWVzLlxuICAgICAgICAvLyBYWFggY2FuJ3QgZGVsZXRlIHByb3RvdHlwZSBpbiBwdXJlLWpzLlxuXG4gICAgICAgIC8vIDIyLiBSZXR1cm4gRi5cbiAgICAgICAgcmV0dXJuIGJvdW5kO1xuICAgIH07XG59XG5cbi8vIFNob3J0Y3V0IHRvIGFuIG9mdGVuIGFjY2Vzc2VkIHByb3BlcnRpZXMsIGluIG9yZGVyIHRvIGF2b2lkIG11bHRpcGxlXG4vLyBkZXJlZmVyZW5jZSB0aGF0IGNvc3RzIHVuaXZlcnNhbGx5LlxuLy8gX1BsZWFzZSBub3RlOiBTaG9ydGN1dHMgYXJlIGRlZmluZWQgYWZ0ZXIgYEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kYCBhcyB3ZVxuLy8gdXMgaXQgaW4gZGVmaW5pbmcgc2hvcnRjdXRzLlxudmFyIGNhbGwgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbDtcbnZhciBwcm90b3R5cGVPZkFycmF5ID0gQXJyYXkucHJvdG90eXBlO1xudmFyIHByb3RvdHlwZU9mT2JqZWN0ID0gT2JqZWN0LnByb3RvdHlwZTtcbnZhciBfQXJyYXlfc2xpY2VfID0gcHJvdG90eXBlT2ZBcnJheS5zbGljZTtcbi8vIEhhdmluZyBhIHRvU3RyaW5nIGxvY2FsIHZhcmlhYmxlIG5hbWUgYnJlYWtzIGluIE9wZXJhIHNvIHVzZSBfdG9TdHJpbmcuXG52YXIgX3RvU3RyaW5nID0gY2FsbC5iaW5kKHByb3RvdHlwZU9mT2JqZWN0LnRvU3RyaW5nKTtcbnZhciBvd25zID0gY2FsbC5iaW5kKHByb3RvdHlwZU9mT2JqZWN0Lmhhc093blByb3BlcnR5KTtcblxuLy8gSWYgSlMgZW5naW5lIHN1cHBvcnRzIGFjY2Vzc29ycyBjcmVhdGluZyBzaG9ydGN1dHMuXG52YXIgZGVmaW5lR2V0dGVyO1xudmFyIGRlZmluZVNldHRlcjtcbnZhciBsb29rdXBHZXR0ZXI7XG52YXIgbG9va3VwU2V0dGVyO1xudmFyIHN1cHBvcnRzQWNjZXNzb3JzO1xuaWYgKChzdXBwb3J0c0FjY2Vzc29ycyA9IG93bnMocHJvdG90eXBlT2ZPYmplY3QsIFwiX19kZWZpbmVHZXR0ZXJfX1wiKSkpIHtcbiAgICBkZWZpbmVHZXR0ZXIgPSBjYWxsLmJpbmQocHJvdG90eXBlT2ZPYmplY3QuX19kZWZpbmVHZXR0ZXJfXyk7XG4gICAgZGVmaW5lU2V0dGVyID0gY2FsbC5iaW5kKHByb3RvdHlwZU9mT2JqZWN0Ll9fZGVmaW5lU2V0dGVyX18pO1xuICAgIGxvb2t1cEdldHRlciA9IGNhbGwuYmluZChwcm90b3R5cGVPZk9iamVjdC5fX2xvb2t1cEdldHRlcl9fKTtcbiAgICBsb29rdXBTZXR0ZXIgPSBjYWxsLmJpbmQocHJvdG90eXBlT2ZPYmplY3QuX19sb29rdXBTZXR0ZXJfXyk7XG59XG5cbi8vXG4vLyBBcnJheVxuLy8gPT09PT1cbi8vXG5cbi8vIEVTNSAxNS40LjQuMTJcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuNC4xMlxuLy8gRGVmYXVsdCB2YWx1ZSBmb3Igc2Vjb25kIHBhcmFtXG4vLyBbYnVnZml4LCBpZWx0OSwgb2xkIGJyb3dzZXJzXVxuLy8gSUUgPCA5IGJ1ZzogWzEsMl0uc3BsaWNlKDApLmpvaW4oXCJcIikgPT0gXCJcIiBidXQgc2hvdWxkIGJlIFwiMTJcIlxuaWYgKFsxLDJdLnNwbGljZSgwKS5sZW5ndGggIT0gMikge1xuICAgIHZhciBhcnJheV9zcGxpY2UgPSBBcnJheS5wcm90b3R5cGUuc3BsaWNlO1xuXG4gICAgaWYoZnVuY3Rpb24oKSB7IC8vIHRlc3QgSUUgPCA5IHRvIHNwbGljZSBidWcgLSBzZWUgaXNzdWUgIzEzOFxuICAgICAgICBmdW5jdGlvbiBtYWtlQXJyYXkobCkge1xuICAgICAgICAgICAgdmFyIGEgPSBbXTtcbiAgICAgICAgICAgIHdoaWxlIChsLS0pIHtcbiAgICAgICAgICAgICAgICBhLnVuc2hpZnQobClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYXJyYXkgPSBbXVxuICAgICAgICAgICAgLCBsZW5ndGhCZWZvcmVcbiAgICAgICAgO1xuXG4gICAgICAgIGFycmF5LnNwbGljZS5iaW5kKGFycmF5LCAwLCAwKS5hcHBseShudWxsLCBtYWtlQXJyYXkoMjApKTtcbiAgICAgICAgYXJyYXkuc3BsaWNlLmJpbmQoYXJyYXksIDAsIDApLmFwcGx5KG51bGwsIG1ha2VBcnJheSgyNikpO1xuXG4gICAgICAgIGxlbmd0aEJlZm9yZSA9IGFycmF5Lmxlbmd0aDsgLy8yMFxuICAgICAgICBhcnJheS5zcGxpY2UoNSwgMCwgXCJYWFhcIik7IC8vIGFkZCBvbmUgZWxlbWVudFxuXG4gICAgICAgIGlmKGxlbmd0aEJlZm9yZSArIDEgPT0gYXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTsvLyBoYXMgcmlnaHQgc3BsaWNlIGltcGxlbWVudGF0aW9uIHdpdGhvdXQgYnVnc1xuICAgICAgICB9XG4gICAgICAgIC8vIGVsc2Uge1xuICAgICAgICAvLyAgICBJRTggYnVnXG4gICAgICAgIC8vIH1cbiAgICB9KCkpIHsvL0lFIDYvN1xuICAgICAgICBBcnJheS5wcm90b3R5cGUuc3BsaWNlID0gZnVuY3Rpb24oc3RhcnQsIGRlbGV0ZUNvdW50KSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheV9zcGxpY2UuYXBwbHkodGhpcywgW1xuICAgICAgICAgICAgICAgICAgICBzdGFydCA9PT0gdm9pZCAwID8gMCA6IHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBkZWxldGVDb3VudCA9PT0gdm9pZCAwID8gKHRoaXMubGVuZ3RoIC0gc3RhcnQpIDogZGVsZXRlQ291bnRcbiAgICAgICAgICAgICAgICBdLmNvbmNhdChfQXJyYXlfc2xpY2VfLmNhbGwoYXJndW1lbnRzLCAyKSkpXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Ugey8vSUU4XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5zcGxpY2UgPSBmdW5jdGlvbihzdGFydCwgZGVsZXRlQ291bnQpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHRcbiAgICAgICAgICAgICAgICAsIGFyZ3MgPSBfQXJyYXlfc2xpY2VfLmNhbGwoYXJndW1lbnRzLCAyKVxuICAgICAgICAgICAgICAgICwgYWRkRWxlbWVudHNDb3VudCA9IGFyZ3MubGVuZ3RoXG4gICAgICAgICAgICA7XG5cbiAgICAgICAgICAgIGlmKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihzdGFydCA9PT0gdm9pZCAwKSB7IC8vIGRlZmF1bHRcbiAgICAgICAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihkZWxldGVDb3VudCA9PT0gdm9pZCAwKSB7IC8vIGRlZmF1bHRcbiAgICAgICAgICAgICAgICBkZWxldGVDb3VudCA9IHRoaXMubGVuZ3RoIC0gc3RhcnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGFkZEVsZW1lbnRzQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYoZGVsZXRlQ291bnQgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZihzdGFydCA9PSB0aGlzLmxlbmd0aCkgeyAvLyB0aW55IG9wdGltaXNhdGlvbiAjMVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoc3RhcnQgPT0gMCkgeyAvLyB0aW55IG9wdGltaXNhdGlvbiAjMlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51bnNoaWZ0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQXJyYXkucHJvdG90eXBlLnNwbGljZSBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9BcnJheV9zbGljZV8uY2FsbCh0aGlzLCBzdGFydCwgc3RhcnQgKyBkZWxldGVDb3VudCk7Ly8gZGVsZXRlIHBhcnRcbiAgICAgICAgICAgICAgICBhcmdzLnB1c2guYXBwbHkoYXJncywgX0FycmF5X3NsaWNlXy5jYWxsKHRoaXMsIHN0YXJ0ICsgZGVsZXRlQ291bnQsIHRoaXMubGVuZ3RoKSk7Ly8gcmlnaHQgcGFydFxuICAgICAgICAgICAgICAgIGFyZ3MudW5zaGlmdC5hcHBseShhcmdzLCBfQXJyYXlfc2xpY2VfLmNhbGwodGhpcywgMCwgc3RhcnQpKTsvLyBsZWZ0IHBhcnRcblxuICAgICAgICAgICAgICAgIC8vIGRlbGV0ZSBhbGwgaXRlbXMgZnJvbSB0aGlzIGFycmF5IGFuZCByZXBsYWNlIGl0IHRvICdsZWZ0IHBhcnQnICsgX0FycmF5X3NsaWNlXy5jYWxsKGFyZ3VtZW50cywgMikgKyAncmlnaHQgcGFydCdcbiAgICAgICAgICAgICAgICBhcmdzLnVuc2hpZnQoMCwgdGhpcy5sZW5ndGgpO1xuXG4gICAgICAgICAgICAgICAgYXJyYXlfc3BsaWNlLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGFycmF5X3NwbGljZS5jYWxsKHRoaXMsIHN0YXJ0LCBkZWxldGVDb3VudCk7XG4gICAgICAgIH1cblxuICAgIH1cbn1cblxuLy8gRVM1IDE1LjQuNC4xMlxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC40LjEzXG4vLyBSZXR1cm4gbGVuK2FyZ0NvdW50LlxuLy8gW2J1Z2ZpeCwgaWVsdDhdXG4vLyBJRSA8IDggYnVnOiBbXS51bnNoaWZ0KDApID09IHVuZGVmaW5lZCBidXQgc2hvdWxkIGJlIFwiMVwiXG5pZiAoW10udW5zaGlmdCgwKSAhPSAxKSB7XG4gICAgdmFyIGFycmF5X3Vuc2hpZnQgPSBBcnJheS5wcm90b3R5cGUudW5zaGlmdDtcbiAgICBBcnJheS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBhcnJheV91bnNoaWZ0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aDtcbiAgICB9O1xufVxuXG4vLyBFUzUgMTUuNC4zLjJcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuMy4yXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pc0FycmF5XG5pZiAoIUFycmF5LmlzQXJyYXkpIHtcbiAgICBBcnJheS5pc0FycmF5ID0gZnVuY3Rpb24gaXNBcnJheShvYmopIHtcbiAgICAgICAgcmV0dXJuIF90b1N0cmluZyhvYmopID09IFwiW29iamVjdCBBcnJheV1cIjtcbiAgICB9O1xufVxuXG4vLyBUaGUgSXNDYWxsYWJsZSgpIGNoZWNrIGluIHRoZSBBcnJheSBmdW5jdGlvbnNcbi8vIGhhcyBiZWVuIHJlcGxhY2VkIHdpdGggYSBzdHJpY3QgY2hlY2sgb24gdGhlXG4vLyBpbnRlcm5hbCBjbGFzcyBvZiB0aGUgb2JqZWN0IHRvIHRyYXAgY2FzZXMgd2hlcmVcbi8vIHRoZSBwcm92aWRlZCBmdW5jdGlvbiB3YXMgYWN0dWFsbHkgYSByZWd1bGFyXG4vLyBleHByZXNzaW9uIGxpdGVyYWwsIHdoaWNoIGluIFY4IGFuZFxuLy8gSmF2YVNjcmlwdENvcmUgaXMgYSB0eXBlb2YgXCJmdW5jdGlvblwiLiAgT25seSBpblxuLy8gVjggYXJlIHJlZ3VsYXIgZXhwcmVzc2lvbiBsaXRlcmFscyBwZXJtaXR0ZWQgYXNcbi8vIHJlZHVjZSBwYXJhbWV0ZXJzLCBzbyBpdCBpcyBkZXNpcmFibGUgaW4gdGhlXG4vLyBnZW5lcmFsIGNhc2UgZm9yIHRoZSBzaGltIHRvIG1hdGNoIHRoZSBtb3JlXG4vLyBzdHJpY3QgYW5kIGNvbW1vbiBiZWhhdmlvciBvZiByZWplY3RpbmcgcmVndWxhclxuLy8gZXhwcmVzc2lvbnMuXG5cbi8vIEVTNSAxNS40LjQuMThcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuNC4xOFxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvYXJyYXkvZm9yRWFjaFxuXG4vLyBDaGVjayBmYWlsdXJlIG9mIGJ5LWluZGV4IGFjY2VzcyBvZiBzdHJpbmcgY2hhcmFjdGVycyAoSUUgPCA5KVxuLy8gYW5kIGZhaWx1cmUgb2YgYDAgaW4gYm94ZWRTdHJpbmdgIChSaGlubylcbnZhciBib3hlZFN0cmluZyA9IE9iamVjdChcImFcIiksXG4gICAgc3BsaXRTdHJpbmcgPSBib3hlZFN0cmluZ1swXSAhPSBcImFcIiB8fCAhKDAgaW4gYm94ZWRTdHJpbmcpO1xuXG5pZiAoIUFycmF5LnByb3RvdHlwZS5mb3JFYWNoKSB7XG4gICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKGZ1biAvKiwgdGhpc3AqLykge1xuICAgICAgICB2YXIgb2JqZWN0ID0gdG9PYmplY3QodGhpcyksXG4gICAgICAgICAgICBzZWxmID0gc3BsaXRTdHJpbmcgJiYgX3RvU3RyaW5nKHRoaXMpID09IFwiW29iamVjdCBTdHJpbmddXCIgP1xuICAgICAgICAgICAgICAgIHRoaXMuc3BsaXQoXCJcIikgOlxuICAgICAgICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICAgIHRoaXNwID0gYXJndW1lbnRzWzFdLFxuICAgICAgICAgICAgaSA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gc2VsZi5sZW5ndGggPj4+IDA7XG5cbiAgICAgICAgLy8gSWYgbm8gY2FsbGJhY2sgZnVuY3Rpb24gb3IgaWYgY2FsbGJhY2sgaXMgbm90IGEgY2FsbGFibGUgZnVuY3Rpb25cbiAgICAgICAgaWYgKF90b1N0cmluZyhmdW4pICE9IFwiW29iamVjdCBGdW5jdGlvbl1cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpOyAvLyBUT0RPIG1lc3NhZ2VcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlICgrK2kgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChpIGluIHNlbGYpIHtcbiAgICAgICAgICAgICAgICAvLyBJbnZva2UgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGggY2FsbCwgcGFzc2luZyBhcmd1bWVudHM6XG4gICAgICAgICAgICAgICAgLy8gY29udGV4dCwgcHJvcGVydHkgdmFsdWUsIHByb3BlcnR5IGtleSwgdGhpc0FyZyBvYmplY3RcbiAgICAgICAgICAgICAgICAvLyBjb250ZXh0XG4gICAgICAgICAgICAgICAgZnVuLmNhbGwodGhpc3AsIHNlbGZbaV0sIGksIG9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vLyBFUzUgMTUuNC40LjE5XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMTlcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0NvcmVfSmF2YVNjcmlwdF8xLjVfUmVmZXJlbmNlL09iamVjdHMvQXJyYXkvbWFwXG5pZiAoIUFycmF5LnByb3RvdHlwZS5tYXApIHtcbiAgICBBcnJheS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gbWFwKGZ1biAvKiwgdGhpc3AqLykge1xuICAgICAgICB2YXIgb2JqZWN0ID0gdG9PYmplY3QodGhpcyksXG4gICAgICAgICAgICBzZWxmID0gc3BsaXRTdHJpbmcgJiYgX3RvU3RyaW5nKHRoaXMpID09IFwiW29iamVjdCBTdHJpbmddXCIgP1xuICAgICAgICAgICAgICAgIHRoaXMuc3BsaXQoXCJcIikgOlxuICAgICAgICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICAgIGxlbmd0aCA9IHNlbGYubGVuZ3RoID4+PiAwLFxuICAgICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKSxcbiAgICAgICAgICAgIHRoaXNwID0gYXJndW1lbnRzWzFdO1xuXG4gICAgICAgIC8vIElmIG5vIGNhbGxiYWNrIGZ1bmN0aW9uIG9yIGlmIGNhbGxiYWNrIGlzIG5vdCBhIGNhbGxhYmxlIGZ1bmN0aW9uXG4gICAgICAgIGlmIChfdG9TdHJpbmcoZnVuKSAhPSBcIltvYmplY3QgRnVuY3Rpb25dXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoZnVuICsgXCIgaXMgbm90IGEgZnVuY3Rpb25cIik7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSBpbiBzZWxmKVxuICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IGZ1bi5jYWxsKHRoaXNwLCBzZWxmW2ldLCBpLCBvYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn1cblxuLy8gRVM1IDE1LjQuNC4yMFxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC40LjIwXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9Db3JlX0phdmFTY3JpcHRfMS41X1JlZmVyZW5jZS9PYmplY3RzL0FycmF5L2ZpbHRlclxuaWYgKCFBcnJheS5wcm90b3R5cGUuZmlsdGVyKSB7XG4gICAgQXJyYXkucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIGZpbHRlcihmdW4gLyosIHRoaXNwICovKSB7XG4gICAgICAgIHZhciBvYmplY3QgPSB0b09iamVjdCh0aGlzKSxcbiAgICAgICAgICAgIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBfdG9TdHJpbmcodGhpcykgPT0gXCJbb2JqZWN0IFN0cmluZ11cIiA/XG4gICAgICAgICAgICAgICAgdGhpcy5zcGxpdChcIlwiKSA6XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICAgIGxlbmd0aCA9IHNlbGYubGVuZ3RoID4+PiAwLFxuICAgICAgICAgICAgcmVzdWx0ID0gW10sXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIHRoaXNwID0gYXJndW1lbnRzWzFdO1xuXG4gICAgICAgIC8vIElmIG5vIGNhbGxiYWNrIGZ1bmN0aW9uIG9yIGlmIGNhbGxiYWNrIGlzIG5vdCBhIGNhbGxhYmxlIGZ1bmN0aW9uXG4gICAgICAgIGlmIChfdG9TdHJpbmcoZnVuKSAhPSBcIltvYmplY3QgRnVuY3Rpb25dXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoZnVuICsgXCIgaXMgbm90IGEgZnVuY3Rpb25cIik7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSBpbiBzZWxmKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBzZWxmW2ldO1xuICAgICAgICAgICAgICAgIGlmIChmdW4uY2FsbCh0aGlzcCwgdmFsdWUsIGksIG9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59XG5cbi8vIEVTNSAxNS40LjQuMTZcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuNC4xNlxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZXZlcnlcbmlmICghQXJyYXkucHJvdG90eXBlLmV2ZXJ5KSB7XG4gICAgQXJyYXkucHJvdG90eXBlLmV2ZXJ5ID0gZnVuY3Rpb24gZXZlcnkoZnVuIC8qLCB0aGlzcCAqLykge1xuICAgICAgICB2YXIgb2JqZWN0ID0gdG9PYmplY3QodGhpcyksXG4gICAgICAgICAgICBzZWxmID0gc3BsaXRTdHJpbmcgJiYgX3RvU3RyaW5nKHRoaXMpID09IFwiW29iamVjdCBTdHJpbmddXCIgP1xuICAgICAgICAgICAgICAgIHRoaXMuc3BsaXQoXCJcIikgOlxuICAgICAgICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICAgIGxlbmd0aCA9IHNlbGYubGVuZ3RoID4+PiAwLFxuICAgICAgICAgICAgdGhpc3AgPSBhcmd1bWVudHNbMV07XG5cbiAgICAgICAgLy8gSWYgbm8gY2FsbGJhY2sgZnVuY3Rpb24gb3IgaWYgY2FsbGJhY2sgaXMgbm90IGEgY2FsbGFibGUgZnVuY3Rpb25cbiAgICAgICAgaWYgKF90b1N0cmluZyhmdW4pICE9IFwiW29iamVjdCBGdW5jdGlvbl1cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihmdW4gKyBcIiBpcyBub3QgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpIGluIHNlbGYgJiYgIWZ1bi5jYWxsKHRoaXNwLCBzZWxmW2ldLCBpLCBvYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG5cbi8vIEVTNSAxNS40LjQuMTdcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuNC4xN1xuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc29tZVxuaWYgKCFBcnJheS5wcm90b3R5cGUuc29tZSkge1xuICAgIEFycmF5LnByb3RvdHlwZS5zb21lID0gZnVuY3Rpb24gc29tZShmdW4gLyosIHRoaXNwICovKSB7XG4gICAgICAgIHZhciBvYmplY3QgPSB0b09iamVjdCh0aGlzKSxcbiAgICAgICAgICAgIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBfdG9TdHJpbmcodGhpcykgPT0gXCJbb2JqZWN0IFN0cmluZ11cIiA/XG4gICAgICAgICAgICAgICAgdGhpcy5zcGxpdChcIlwiKSA6XG4gICAgICAgICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgICAgbGVuZ3RoID0gc2VsZi5sZW5ndGggPj4+IDAsXG4gICAgICAgICAgICB0aGlzcCA9IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICAvLyBJZiBubyBjYWxsYmFjayBmdW5jdGlvbiBvciBpZiBjYWxsYmFjayBpcyBub3QgYSBjYWxsYWJsZSBmdW5jdGlvblxuICAgICAgICBpZiAoX3RvU3RyaW5nKGZ1bikgIT0gXCJbb2JqZWN0IEZ1bmN0aW9uXVwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGZ1biArIFwiIGlzIG5vdCBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgaW4gc2VsZiAmJiBmdW4uY2FsbCh0aGlzcCwgc2VsZltpXSwgaSwgb2JqZWN0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xufVxuXG4vLyBFUzUgMTUuNC40LjIxXG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMjFcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0NvcmVfSmF2YVNjcmlwdF8xLjVfUmVmZXJlbmNlL09iamVjdHMvQXJyYXkvcmVkdWNlXG5pZiAoIUFycmF5LnByb3RvdHlwZS5yZWR1Y2UpIHtcbiAgICBBcnJheS5wcm90b3R5cGUucmVkdWNlID0gZnVuY3Rpb24gcmVkdWNlKGZ1biAvKiwgaW5pdGlhbCovKSB7XG4gICAgICAgIHZhciBvYmplY3QgPSB0b09iamVjdCh0aGlzKSxcbiAgICAgICAgICAgIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBfdG9TdHJpbmcodGhpcykgPT0gXCJbb2JqZWN0IFN0cmluZ11cIiA/XG4gICAgICAgICAgICAgICAgdGhpcy5zcGxpdChcIlwiKSA6XG4gICAgICAgICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgICAgbGVuZ3RoID0gc2VsZi5sZW5ndGggPj4+IDA7XG5cbiAgICAgICAgLy8gSWYgbm8gY2FsbGJhY2sgZnVuY3Rpb24gb3IgaWYgY2FsbGJhY2sgaXMgbm90IGEgY2FsbGFibGUgZnVuY3Rpb25cbiAgICAgICAgaWYgKF90b1N0cmluZyhmdW4pICE9IFwiW29iamVjdCBGdW5jdGlvbl1cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihmdW4gKyBcIiBpcyBub3QgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vIHZhbHVlIHRvIHJldHVybiBpZiBubyBpbml0aWFsIHZhbHVlIGFuZCBhbiBlbXB0eSBhcnJheVxuICAgICAgICBpZiAoIWxlbmd0aCAmJiBhcmd1bWVudHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJyZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWYgKGkgaW4gc2VsZikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBzZWxmW2krK107XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGlmIGFycmF5IGNvbnRhaW5zIG5vIHZhbHVlcywgbm8gaW5pdGlhbCB2YWx1ZSB0byByZXR1cm5cbiAgICAgICAgICAgICAgICBpZiAoKytpID49IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwicmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlICh0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpIGluIHNlbGYpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmdW4uY2FsbCh2b2lkIDAsIHJlc3VsdCwgc2VsZltpXSwgaSwgb2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn1cblxuLy8gRVM1IDE1LjQuNC4yMlxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC40LjIyXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9Db3JlX0phdmFTY3JpcHRfMS41X1JlZmVyZW5jZS9PYmplY3RzL0FycmF5L3JlZHVjZVJpZ2h0XG5pZiAoIUFycmF5LnByb3RvdHlwZS5yZWR1Y2VSaWdodCkge1xuICAgIEFycmF5LnByb3RvdHlwZS5yZWR1Y2VSaWdodCA9IGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KGZ1biAvKiwgaW5pdGlhbCovKSB7XG4gICAgICAgIHZhciBvYmplY3QgPSB0b09iamVjdCh0aGlzKSxcbiAgICAgICAgICAgIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBfdG9TdHJpbmcodGhpcykgPT0gXCJbb2JqZWN0IFN0cmluZ11cIiA/XG4gICAgICAgICAgICAgICAgdGhpcy5zcGxpdChcIlwiKSA6XG4gICAgICAgICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgICAgbGVuZ3RoID0gc2VsZi5sZW5ndGggPj4+IDA7XG5cbiAgICAgICAgLy8gSWYgbm8gY2FsbGJhY2sgZnVuY3Rpb24gb3IgaWYgY2FsbGJhY2sgaXMgbm90IGEgY2FsbGFibGUgZnVuY3Rpb25cbiAgICAgICAgaWYgKF90b1N0cmluZyhmdW4pICE9IFwiW29iamVjdCBGdW5jdGlvbl1cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihmdW4gKyBcIiBpcyBub3QgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vIHZhbHVlIHRvIHJldHVybiBpZiBubyBpbml0aWFsIHZhbHVlLCBlbXB0eSBhcnJheVxuICAgICAgICBpZiAoIWxlbmd0aCAmJiBhcmd1bWVudHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJyZWR1Y2VSaWdodCBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWVcIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0LCBpID0gbGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgcmVzdWx0ID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGlmIChpIGluIHNlbGYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gc2VsZltpLS1dO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpZiBhcnJheSBjb250YWlucyBubyB2YWx1ZXMsIG5vIGluaXRpYWwgdmFsdWUgdG8gcmV0dXJuXG4gICAgICAgICAgICAgICAgaWYgKC0taSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInJlZHVjZVJpZ2h0IG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlICh0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChpIGluIHRoaXMpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmdW4uY2FsbCh2b2lkIDAsIHJlc3VsdCwgc2VsZltpXSwgaSwgb2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoaS0tKTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59XG5cbi8vIEVTNSAxNS40LjQuMTRcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuNC4xNFxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaW5kZXhPZlxuaWYgKCFBcnJheS5wcm90b3R5cGUuaW5kZXhPZiB8fCAoWzAsIDFdLmluZGV4T2YoMSwgMikgIT0gLTEpKSB7XG4gICAgQXJyYXkucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mKHNvdWdodCAvKiwgZnJvbUluZGV4ICovICkge1xuICAgICAgICB2YXIgc2VsZiA9IHNwbGl0U3RyaW5nICYmIF90b1N0cmluZyh0aGlzKSA9PSBcIltvYmplY3QgU3RyaW5nXVwiID9cbiAgICAgICAgICAgICAgICB0aGlzLnNwbGl0KFwiXCIpIDpcbiAgICAgICAgICAgICAgICB0b09iamVjdCh0aGlzKSxcbiAgICAgICAgICAgIGxlbmd0aCA9IHNlbGYubGVuZ3RoID4+PiAwO1xuXG4gICAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgaSA9IHRvSW50ZWdlcihhcmd1bWVudHNbMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaGFuZGxlIG5lZ2F0aXZlIGluZGljZXNcbiAgICAgICAgaSA9IGkgPj0gMCA/IGkgOiBNYXRoLm1heCgwLCBsZW5ndGggKyBpKTtcbiAgICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgaW4gc2VsZiAmJiBzZWxmW2ldID09PSBzb3VnaHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcbn1cblxuLy8gRVM1IDE1LjQuNC4xNVxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC40LjE1XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9sYXN0SW5kZXhPZlxuaWYgKCFBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YgfHwgKFswLCAxXS5sYXN0SW5kZXhPZigwLCAtMykgIT0gLTEpKSB7XG4gICAgQXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2Yoc291Z2h0IC8qLCBmcm9tSW5kZXggKi8pIHtcbiAgICAgICAgdmFyIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBfdG9TdHJpbmcodGhpcykgPT0gXCJbb2JqZWN0IFN0cmluZ11cIiA/XG4gICAgICAgICAgICAgICAgdGhpcy5zcGxpdChcIlwiKSA6XG4gICAgICAgICAgICAgICAgdG9PYmplY3QodGhpcyksXG4gICAgICAgICAgICBsZW5ndGggPSBzZWxmLmxlbmd0aCA+Pj4gMDtcblxuICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpID0gbGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBpID0gTWF0aC5taW4oaSwgdG9JbnRlZ2VyKGFyZ3VtZW50c1sxXSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGhhbmRsZSBuZWdhdGl2ZSBpbmRpY2VzXG4gICAgICAgIGkgPSBpID49IDAgPyBpIDogbGVuZ3RoIC0gTWF0aC5hYnMoaSk7XG4gICAgICAgIGZvciAoOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKGkgaW4gc2VsZiAmJiBzb3VnaHQgPT09IHNlbGZbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcbn1cblxuLy9cbi8vIE9iamVjdFxuLy8gPT09PT09XG4vL1xuXG4vLyBFUzUgMTUuMi4zLjE0XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS4yLjMuMTRcbmlmICghT2JqZWN0LmtleXMpIHtcbiAgICAvLyBodHRwOi8vd2hhdHRoZWhlYWRzYWlkLmNvbS8yMDEwLzEwL2Etc2FmZXItb2JqZWN0LWtleXMtY29tcGF0aWJpbGl0eS1pbXBsZW1lbnRhdGlvblxuICAgIHZhciBoYXNEb250RW51bUJ1ZyA9IHRydWUsXG4gICAgICAgIGRvbnRFbnVtcyA9IFtcbiAgICAgICAgICAgIFwidG9TdHJpbmdcIixcbiAgICAgICAgICAgIFwidG9Mb2NhbGVTdHJpbmdcIixcbiAgICAgICAgICAgIFwidmFsdWVPZlwiLFxuICAgICAgICAgICAgXCJoYXNPd25Qcm9wZXJ0eVwiLFxuICAgICAgICAgICAgXCJpc1Byb3RvdHlwZU9mXCIsXG4gICAgICAgICAgICBcInByb3BlcnR5SXNFbnVtZXJhYmxlXCIsXG4gICAgICAgICAgICBcImNvbnN0cnVjdG9yXCJcbiAgICAgICAgXSxcbiAgICAgICAgZG9udEVudW1zTGVuZ3RoID0gZG9udEVudW1zLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGtleSBpbiB7XCJ0b1N0cmluZ1wiOiBudWxsfSkge1xuICAgICAgICBoYXNEb250RW51bUJ1ZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIE9iamVjdC5rZXlzID0gZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICAodHlwZW9mIG9iamVjdCAhPSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmplY3QgIT0gXCJmdW5jdGlvblwiKSB8fFxuICAgICAgICAgICAgb2JqZWN0ID09PSBudWxsXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdC5rZXlzIGNhbGxlZCBvbiBhIG5vbi1vYmplY3RcIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIga2V5cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG93bnMob2JqZWN0LCBuYW1lKSkge1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNEb250RW51bUJ1Zykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gZG9udEVudW1zTGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBkb250RW51bSA9IGRvbnRFbnVtc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAob3ducyhvYmplY3QsIGRvbnRFbnVtKSkge1xuICAgICAgICAgICAgICAgICAgICBrZXlzLnB1c2goZG9udEVudW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5cztcbiAgICB9O1xuXG59XG5cbi8vXG4vLyBEYXRlXG4vLyA9PT09XG4vL1xuXG4vLyBFUzUgMTUuOS41LjQzXG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS45LjUuNDNcbi8vIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIFN0cmluZyB2YWx1ZSByZXByZXNlbnQgdGhlIGluc3RhbmNlIGluIHRpbWVcbi8vIHJlcHJlc2VudGVkIGJ5IHRoaXMgRGF0ZSBvYmplY3QuIFRoZSBmb3JtYXQgb2YgdGhlIFN0cmluZyBpcyB0aGUgRGF0ZSBUaW1lXG4vLyBzdHJpbmcgZm9ybWF0IGRlZmluZWQgaW4gMTUuOS4xLjE1LiBBbGwgZmllbGRzIGFyZSBwcmVzZW50IGluIHRoZSBTdHJpbmcuXG4vLyBUaGUgdGltZSB6b25lIGlzIGFsd2F5cyBVVEMsIGRlbm90ZWQgYnkgdGhlIHN1ZmZpeCBaLiBJZiB0aGUgdGltZSB2YWx1ZSBvZlxuLy8gdGhpcyBvYmplY3QgaXMgbm90IGEgZmluaXRlIE51bWJlciBhIFJhbmdlRXJyb3IgZXhjZXB0aW9uIGlzIHRocm93bi5cbnZhciBuZWdhdGl2ZURhdGUgPSAtNjIxOTg3NTUyMDAwMDAsXG4gICAgbmVnYXRpdmVZZWFyU3RyaW5nID0gXCItMDAwMDAxXCI7XG5pZiAoXG4gICAgIURhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nIHx8XG4gICAgKG5ldyBEYXRlKG5lZ2F0aXZlRGF0ZSkudG9JU09TdHJpbmcoKS5pbmRleE9mKG5lZ2F0aXZlWWVhclN0cmluZykgPT09IC0xKVxuKSB7XG4gICAgRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcgPSBmdW5jdGlvbiB0b0lTT1N0cmluZygpIHtcbiAgICAgICAgdmFyIHJlc3VsdCwgbGVuZ3RoLCB2YWx1ZSwgeWVhciwgbW9udGg7XG4gICAgICAgIGlmICghaXNGaW5pdGUodGhpcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcgY2FsbGVkIG9uIG5vbi1maW5pdGUgdmFsdWUuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgeWVhciA9IHRoaXMuZ2V0VVRDRnVsbFllYXIoKTtcblxuICAgICAgICBtb250aCA9IHRoaXMuZ2V0VVRDTW9udGgoKTtcbiAgICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9rcmlza293YWwvZXM1LXNoaW0vaXNzdWVzLzExMVxuICAgICAgICB5ZWFyICs9IE1hdGguZmxvb3IobW9udGggLyAxMik7XG4gICAgICAgIG1vbnRoID0gKG1vbnRoICUgMTIgKyAxMikgJSAxMjtcblxuICAgICAgICAvLyB0aGUgZGF0ZSB0aW1lIHN0cmluZyBmb3JtYXQgaXMgc3BlY2lmaWVkIGluIDE1LjkuMS4xNS5cbiAgICAgICAgcmVzdWx0ID0gW21vbnRoICsgMSwgdGhpcy5nZXRVVENEYXRlKCksXG4gICAgICAgICAgICB0aGlzLmdldFVUQ0hvdXJzKCksIHRoaXMuZ2V0VVRDTWludXRlcygpLCB0aGlzLmdldFVUQ1NlY29uZHMoKV07XG4gICAgICAgIHllYXIgPSAoXG4gICAgICAgICAgICAoeWVhciA8IDAgPyBcIi1cIiA6ICh5ZWFyID4gOTk5OSA/IFwiK1wiIDogXCJcIikpICtcbiAgICAgICAgICAgIChcIjAwMDAwXCIgKyBNYXRoLmFicyh5ZWFyKSlcbiAgICAgICAgICAgIC5zbGljZSgwIDw9IHllYXIgJiYgeWVhciA8PSA5OTk5ID8gLTQgOiAtNilcbiAgICAgICAgKTtcblxuICAgICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0W2xlbmd0aF07XG4gICAgICAgICAgICAvLyBwYWQgbW9udGhzLCBkYXlzLCBob3VycywgbWludXRlcywgYW5kIHNlY29uZHMgdG8gaGF2ZSB0d29cbiAgICAgICAgICAgIC8vIGRpZ2l0cy5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IDEwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2xlbmd0aF0gPSBcIjBcIiArIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHBhZCBtaWxsaXNlY29uZHMgdG8gaGF2ZSB0aHJlZSBkaWdpdHMuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB5ZWFyICsgXCItXCIgKyByZXN1bHQuc2xpY2UoMCwgMikuam9pbihcIi1cIikgK1xuICAgICAgICAgICAgXCJUXCIgKyByZXN1bHQuc2xpY2UoMikuam9pbihcIjpcIikgKyBcIi5cIiArXG4gICAgICAgICAgICAoXCIwMDBcIiArIHRoaXMuZ2V0VVRDTWlsbGlzZWNvbmRzKCkpLnNsaWNlKC0zKSArIFwiWlwiXG4gICAgICAgICk7XG4gICAgfTtcbn1cblxuXG4vLyBFUzUgMTUuOS41LjQ0XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS45LjUuNDRcbi8vIFRoaXMgZnVuY3Rpb24gcHJvdmlkZXMgYSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBEYXRlIG9iamVjdCBmb3IgdXNlIGJ5XG4vLyBKU09OLnN0cmluZ2lmeSAoMTUuMTIuMykuXG52YXIgZGF0ZVRvSlNPTklzU3VwcG9ydGVkID0gZmFsc2U7XG50cnkge1xuICAgIGRhdGVUb0pTT05Jc1N1cHBvcnRlZCA9IChcbiAgICAgICAgRGF0ZS5wcm90b3R5cGUudG9KU09OICYmXG4gICAgICAgIG5ldyBEYXRlKE5hTikudG9KU09OKCkgPT09IG51bGwgJiZcbiAgICAgICAgbmV3IERhdGUobmVnYXRpdmVEYXRlKS50b0pTT04oKS5pbmRleE9mKG5lZ2F0aXZlWWVhclN0cmluZykgIT09IC0xICYmXG4gICAgICAgIERhdGUucHJvdG90eXBlLnRvSlNPTi5jYWxsKHsgLy8gZ2VuZXJpY1xuICAgICAgICAgICAgdG9JU09TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICApO1xufSBjYXRjaCAoZSkge1xufVxuaWYgKCFkYXRlVG9KU09OSXNTdXBwb3J0ZWQpIHtcbiAgICBEYXRlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oa2V5KSB7XG4gICAgICAgIC8vIFdoZW4gdGhlIHRvSlNPTiBtZXRob2QgaXMgY2FsbGVkIHdpdGggYXJndW1lbnQga2V5LCB0aGUgZm9sbG93aW5nXG4gICAgICAgIC8vIHN0ZXBzIGFyZSB0YWtlbjpcblxuICAgICAgICAvLyAxLiAgTGV0IE8gYmUgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIFRvT2JqZWN0LCBnaXZpbmcgaXQgdGhlIHRoaXNcbiAgICAgICAgLy8gdmFsdWUgYXMgaXRzIGFyZ3VtZW50LlxuICAgICAgICAvLyAyLiBMZXQgdHYgYmUgdG9QcmltaXRpdmUoTywgaGludCBOdW1iZXIpLlxuICAgICAgICB2YXIgbyA9IE9iamVjdCh0aGlzKSxcbiAgICAgICAgICAgIHR2ID0gdG9QcmltaXRpdmUobyksXG4gICAgICAgICAgICB0b0lTTztcbiAgICAgICAgLy8gMy4gSWYgdHYgaXMgYSBOdW1iZXIgYW5kIGlzIG5vdCBmaW5pdGUsIHJldHVybiBudWxsLlxuICAgICAgICBpZiAodHlwZW9mIHR2ID09PSBcIm51bWJlclwiICYmICFpc0Zpbml0ZSh0dikpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIDQuIExldCB0b0lTTyBiZSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIFtbR2V0XV0gaW50ZXJuYWwgbWV0aG9kIG9mXG4gICAgICAgIC8vIE8gd2l0aCBhcmd1bWVudCBcInRvSVNPU3RyaW5nXCIuXG4gICAgICAgIHRvSVNPID0gby50b0lTT1N0cmluZztcbiAgICAgICAgLy8gNS4gSWYgSXNDYWxsYWJsZSh0b0lTTykgaXMgZmFsc2UsIHRocm93IGEgVHlwZUVycm9yIGV4Y2VwdGlvbi5cbiAgICAgICAgaWYgKHR5cGVvZiB0b0lTTyAhPSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJ0b0lTT1N0cmluZyBwcm9wZXJ0eSBpcyBub3QgY2FsbGFibGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNi4gUmV0dXJuIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgW1tDYWxsXV0gaW50ZXJuYWwgbWV0aG9kIG9mXG4gICAgICAgIC8vICB0b0lTTyB3aXRoIE8gYXMgdGhlIHRoaXMgdmFsdWUgYW5kIGFuIGVtcHR5IGFyZ3VtZW50IGxpc3QuXG4gICAgICAgIHJldHVybiB0b0lTTy5jYWxsKG8pO1xuXG4gICAgICAgIC8vIE5PVEUgMSBUaGUgYXJndW1lbnQgaXMgaWdub3JlZC5cblxuICAgICAgICAvLyBOT1RFIDIgVGhlIHRvSlNPTiBmdW5jdGlvbiBpcyBpbnRlbnRpb25hbGx5IGdlbmVyaWM7IGl0IGRvZXMgbm90XG4gICAgICAgIC8vIHJlcXVpcmUgdGhhdCBpdHMgdGhpcyB2YWx1ZSBiZSBhIERhdGUgb2JqZWN0LiBUaGVyZWZvcmUsIGl0IGNhbiBiZVxuICAgICAgICAvLyB0cmFuc2ZlcnJlZCB0byBvdGhlciBraW5kcyBvZiBvYmplY3RzIGZvciB1c2UgYXMgYSBtZXRob2QuIEhvd2V2ZXIsXG4gICAgICAgIC8vIGl0IGRvZXMgcmVxdWlyZSB0aGF0IGFueSBzdWNoIG9iamVjdCBoYXZlIGEgdG9JU09TdHJpbmcgbWV0aG9kLiBBblxuICAgICAgICAvLyBvYmplY3QgaXMgZnJlZSB0byB1c2UgdGhlIGFyZ3VtZW50IGtleSB0byBmaWx0ZXIgaXRzXG4gICAgICAgIC8vIHN0cmluZ2lmaWNhdGlvbi5cbiAgICB9O1xufVxuXG4vLyBFUzUgMTUuOS40LjJcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjkuNC4yXG4vLyBiYXNlZCBvbiB3b3JrIHNoYXJlZCBieSBEYW5pZWwgRnJpZXNlbiAoZGFudG1hbilcbi8vIGh0dHA6Ly9naXN0LmdpdGh1Yi5jb20vMzAzMjQ5XG5pZiAoIURhdGUucGFyc2UgfHwgXCJEYXRlLnBhcnNlIGlzIGJ1Z2d5XCIpIHtcbiAgICAvLyBYWFggZ2xvYmFsIGFzc2lnbm1lbnQgd29uJ3Qgd29yayBpbiBlbWJlZGRpbmdzIHRoYXQgdXNlXG4gICAgLy8gYW4gYWx0ZXJuYXRlIG9iamVjdCBmb3IgdGhlIGNvbnRleHQuXG4gICAgRGF0ZSA9IChmdW5jdGlvbihOYXRpdmVEYXRlKSB7XG5cbiAgICAgICAgLy8gRGF0ZS5sZW5ndGggPT09IDdcbiAgICAgICAgZnVuY3Rpb24gRGF0ZShZLCBNLCBELCBoLCBtLCBzLCBtcykge1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIE5hdGl2ZURhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0ZSA9IGxlbmd0aCA9PSAxICYmIFN0cmluZyhZKSA9PT0gWSA/IC8vIGlzU3RyaW5nKFkpXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGV4cGxpY2l0bHkgcGFzcyBpdCB0aHJvdWdoIHBhcnNlOlxuICAgICAgICAgICAgICAgICAgICBuZXcgTmF0aXZlRGF0ZShEYXRlLnBhcnNlKFkpKSA6XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gbWFudWFsbHkgbWFrZSBjYWxscyBkZXBlbmRpbmcgb24gYXJndW1lbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gbGVuZ3RoIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID49IDcgPyBuZXcgTmF0aXZlRGF0ZShZLCBNLCBELCBoLCBtLCBzLCBtcykgOlxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPj0gNiA/IG5ldyBOYXRpdmVEYXRlKFksIE0sIEQsIGgsIG0sIHMpIDpcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID49IDUgPyBuZXcgTmF0aXZlRGF0ZShZLCBNLCBELCBoLCBtKSA6XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA+PSA0ID8gbmV3IE5hdGl2ZURhdGUoWSwgTSwgRCwgaCkgOlxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPj0gMyA/IG5ldyBOYXRpdmVEYXRlKFksIE0sIEQpIDpcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID49IDIgPyBuZXcgTmF0aXZlRGF0ZShZLCBNKSA6XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA+PSAxID8gbmV3IE5hdGl2ZURhdGUoWSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBOYXRpdmVEYXRlKCk7XG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCBtaXh1cHMgd2l0aCB1bmZpeGVkIERhdGUgb2JqZWN0XG4gICAgICAgICAgICAgICAgZGF0ZS5jb25zdHJ1Y3RvciA9IERhdGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTmF0aXZlRGF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIDE1LjkuMS4xNSBEYXRlIFRpbWUgU3RyaW5nIEZvcm1hdC5cbiAgICAgICAgdmFyIGlzb0RhdGVFeHByZXNzaW9uID0gbmV3IFJlZ0V4cChcIl5cIiArXG4gICAgICAgICAgICBcIihcXFxcZHs0fXxbXFwrXFwtXVxcXFxkezZ9KVwiICsgLy8gZm91ci1kaWdpdCB5ZWFyIGNhcHR1cmUgb3Igc2lnbiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDYtZGlnaXQgZXh0ZW5kZWQgeWVhclxuICAgICAgICAgICAgXCIoPzotKFxcXFxkezJ9KVwiICsgLy8gb3B0aW9uYWwgbW9udGggY2FwdHVyZVxuICAgICAgICAgICAgXCIoPzotKFxcXFxkezJ9KVwiICsgLy8gb3B0aW9uYWwgZGF5IGNhcHR1cmVcbiAgICAgICAgICAgIFwiKD86XCIgKyAvLyBjYXB0dXJlIGhvdXJzOm1pbnV0ZXM6c2Vjb25kcy5taWxsaXNlY29uZHNcbiAgICAgICAgICAgICAgICBcIlQoXFxcXGR7Mn0pXCIgKyAvLyBob3VycyBjYXB0dXJlXG4gICAgICAgICAgICAgICAgXCI6KFxcXFxkezJ9KVwiICsgLy8gbWludXRlcyBjYXB0dXJlXG4gICAgICAgICAgICAgICAgXCIoPzpcIiArIC8vIG9wdGlvbmFsIDpzZWNvbmRzLm1pbGxpc2Vjb25kc1xuICAgICAgICAgICAgICAgICAgICBcIjooXFxcXGR7Mn0pXCIgKyAvLyBzZWNvbmRzIGNhcHR1cmVcbiAgICAgICAgICAgICAgICAgICAgXCIoPzooXFxcXC5cXFxcZHsxLH0pKT9cIiArIC8vIG1pbGxpc2Vjb25kcyBjYXB0dXJlXG4gICAgICAgICAgICAgICAgXCIpP1wiICtcbiAgICAgICAgICAgIFwiKFwiICsgLy8gY2FwdHVyZSBVVEMgb2Zmc2V0IGNvbXBvbmVudFxuICAgICAgICAgICAgICAgIFwiWnxcIiArIC8vIFVUQyBjYXB0dXJlXG4gICAgICAgICAgICAgICAgXCIoPzpcIiArIC8vIG9mZnNldCBzcGVjaWZpZXIgKy8taG91cnM6bWludXRlc1xuICAgICAgICAgICAgICAgICAgICBcIihbLStdKVwiICsgLy8gc2lnbiBjYXB0dXJlXG4gICAgICAgICAgICAgICAgICAgIFwiKFxcXFxkezJ9KVwiICsgLy8gaG91cnMgb2Zmc2V0IGNhcHR1cmVcbiAgICAgICAgICAgICAgICAgICAgXCI6KFxcXFxkezJ9KVwiICsgLy8gbWludXRlcyBvZmZzZXQgY2FwdHVyZVxuICAgICAgICAgICAgICAgIFwiKVwiICtcbiAgICAgICAgICAgIFwiKT8pPyk/KT9cIiArXG4gICAgICAgIFwiJFwiKTtcblxuICAgICAgICB2YXIgbW9udGhzID0gW1xuICAgICAgICAgICAgMCwgMzEsIDU5LCA5MCwgMTIwLCAxNTEsIDE4MSwgMjEyLCAyNDMsIDI3MywgMzA0LCAzMzQsIDM2NVxuICAgICAgICBdO1xuXG4gICAgICAgIGZ1bmN0aW9uIGRheUZyb21Nb250aCh5ZWFyLCBtb250aCkge1xuICAgICAgICAgICAgdmFyIHQgPSBtb250aCA+IDEgPyAxIDogMDtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgbW9udGhzW21vbnRoXSArXG4gICAgICAgICAgICAgICAgTWF0aC5mbG9vcigoeWVhciAtIDE5NjkgKyB0KSAvIDQpIC1cbiAgICAgICAgICAgICAgICBNYXRoLmZsb29yKCh5ZWFyIC0gMTkwMSArIHQpIC8gMTAwKSArXG4gICAgICAgICAgICAgICAgTWF0aC5mbG9vcigoeWVhciAtIDE2MDEgKyB0KSAvIDQwMCkgK1xuICAgICAgICAgICAgICAgIDM2NSAqICh5ZWFyIC0gMTk3MClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb3B5IGFueSBjdXN0b20gbWV0aG9kcyBhIDNyZCBwYXJ0eSBsaWJyYXJ5IG1heSBoYXZlIGFkZGVkXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBOYXRpdmVEYXRlKSB7XG4gICAgICAgICAgICBEYXRlW2tleV0gPSBOYXRpdmVEYXRlW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb3B5IFwibmF0aXZlXCIgbWV0aG9kcyBleHBsaWNpdGx5OyB0aGV5IG1heSBiZSBub24tZW51bWVyYWJsZVxuICAgICAgICBEYXRlLm5vdyA9IE5hdGl2ZURhdGUubm93O1xuICAgICAgICBEYXRlLlVUQyA9IE5hdGl2ZURhdGUuVVRDO1xuICAgICAgICBEYXRlLnByb3RvdHlwZSA9IE5hdGl2ZURhdGUucHJvdG90eXBlO1xuICAgICAgICBEYXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERhdGU7XG5cbiAgICAgICAgLy8gVXBncmFkZSBEYXRlLnBhcnNlIHRvIGhhbmRsZSBzaW1wbGlmaWVkIElTTyA4NjAxIHN0cmluZ3NcbiAgICAgICAgRGF0ZS5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKHN0cmluZykge1xuICAgICAgICAgICAgdmFyIG1hdGNoID0gaXNvRGF0ZUV4cHJlc3Npb24uZXhlYyhzdHJpbmcpO1xuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgLy8gcGFyc2UgbW9udGhzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgYW5kIG1pbGxpc2Vjb25kc1xuICAgICAgICAgICAgICAgIC8vIHByb3ZpZGUgZGVmYXVsdCB2YWx1ZXMgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgICAgICAgLy8gcGFyc2UgdGhlIFVUQyBvZmZzZXQgY29tcG9uZW50XG4gICAgICAgICAgICAgICAgdmFyIHllYXIgPSBOdW1iZXIobWF0Y2hbMV0pLFxuICAgICAgICAgICAgICAgICAgICBtb250aCA9IE51bWJlcihtYXRjaFsyXSB8fCAxKSAtIDEsXG4gICAgICAgICAgICAgICAgICAgIGRheSA9IE51bWJlcihtYXRjaFszXSB8fCAxKSAtIDEsXG4gICAgICAgICAgICAgICAgICAgIGhvdXIgPSBOdW1iZXIobWF0Y2hbNF0gfHwgMCksXG4gICAgICAgICAgICAgICAgICAgIG1pbnV0ZSA9IE51bWJlcihtYXRjaFs1XSB8fCAwKSxcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kID0gTnVtYmVyKG1hdGNoWzZdIHx8IDApLFxuICAgICAgICAgICAgICAgICAgICBtaWxsaXNlY29uZCA9IE1hdGguZmxvb3IoTnVtYmVyKG1hdGNoWzddIHx8IDApICogMTAwMCksXG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gdGltZSB6b25lIGlzIG1pc3NlZCwgbG9jYWwgb2Zmc2V0IHNob3VsZCBiZSB1c2VkXG4gICAgICAgICAgICAgICAgICAgIC8vIChFUyA1LjEgYnVnKVxuICAgICAgICAgICAgICAgICAgICAvLyBzZWUgaHR0cHM6Ly9idWdzLmVjbWFzY3JpcHQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMTJcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gIW1hdGNoWzRdIHx8IG1hdGNoWzhdID9cbiAgICAgICAgICAgICAgICAgICAgICAgIDAgOiBOdW1iZXIobmV3IE5hdGl2ZURhdGUoMTk3MCwgMCkpLFxuICAgICAgICAgICAgICAgICAgICBzaWduT2Zmc2V0ID0gbWF0Y2hbOV0gPT09IFwiLVwiID8gMSA6IC0xLFxuICAgICAgICAgICAgICAgICAgICBob3VyT2Zmc2V0ID0gTnVtYmVyKG1hdGNoWzEwXSB8fCAwKSxcbiAgICAgICAgICAgICAgICAgICAgbWludXRlT2Zmc2V0ID0gTnVtYmVyKG1hdGNoWzExXSB8fCAwKSxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgaG91ciA8IChcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbnV0ZSA+IDAgfHwgc2Vjb25kID4gMCB8fCBtaWxsaXNlY29uZCA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICAgMjQgOiAyNVxuICAgICAgICAgICAgICAgICAgICApICYmXG4gICAgICAgICAgICAgICAgICAgIG1pbnV0ZSA8IDYwICYmIHNlY29uZCA8IDYwICYmIG1pbGxpc2Vjb25kIDwgMTAwMCAmJlxuICAgICAgICAgICAgICAgICAgICBtb250aCA+IC0xICYmIG1vbnRoIDwgMTIgJiYgaG91ck9mZnNldCA8IDI0ICYmXG4gICAgICAgICAgICAgICAgICAgIG1pbnV0ZU9mZnNldCA8IDYwICYmIC8vIGRldGVjdCBpbnZhbGlkIG9mZnNldHNcbiAgICAgICAgICAgICAgICAgICAgZGF5ID4gLTEgJiZcbiAgICAgICAgICAgICAgICAgICAgZGF5IDwgKFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF5RnJvbU1vbnRoKHllYXIsIG1vbnRoICsgMSkgLVxuICAgICAgICAgICAgICAgICAgICAgICAgZGF5RnJvbU1vbnRoKHllYXIsIG1vbnRoKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IChcbiAgICAgICAgICAgICAgICAgICAgICAgIChkYXlGcm9tTW9udGgoeWVhciwgbW9udGgpICsgZGF5KSAqIDI0ICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvdXIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgaG91ck9mZnNldCAqIHNpZ25PZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgKSAqIDYwO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSAoXG4gICAgICAgICAgICAgICAgICAgICAgICAocmVzdWx0ICsgbWludXRlICsgbWludXRlT2Zmc2V0ICogc2lnbk9mZnNldCkgKiA2MCArXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmRcbiAgICAgICAgICAgICAgICAgICAgKSAqIDEwMDAgKyBtaWxsaXNlY29uZCArIG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKC04LjY0ZTE1IDw9IHJlc3VsdCAmJiByZXN1bHQgPD0gOC42NGUxNSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE5hdGl2ZURhdGUucGFyc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gRGF0ZTtcbiAgICB9KShEYXRlKTtcbn1cblxuLy8gRVM1IDE1LjkuNC40XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS45LjQuNFxuaWYgKCFEYXRlLm5vdykge1xuICAgIERhdGUubm93ID0gZnVuY3Rpb24gbm93KCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgfTtcbn1cblxuXG4vL1xuLy8gTnVtYmVyXG4vLyA9PT09PT1cbi8vXG5cbi8vIEVTNS4xIDE1LjcuNC41XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS43LjQuNVxuaWYgKCFOdW1iZXIucHJvdG90eXBlLnRvRml4ZWQgfHwgKDAuMDAwMDgpLnRvRml4ZWQoMykgIT09ICcwLjAwMCcgfHwgKDAuOSkudG9GaXhlZCgwKSA9PT0gJzAnIHx8ICgxLjI1NSkudG9GaXhlZCgyKSAhPT0gJzEuMjUnIHx8ICgxMDAwMDAwMDAwMDAwMDAwMTI4KS50b0ZpeGVkKDApICE9PSBcIjEwMDAwMDAwMDAwMDAwMDAxMjhcIikge1xuICAgIC8vIEhpZGUgdGhlc2UgdmFyaWFibGVzIGFuZCBmdW5jdGlvbnNcbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYmFzZSwgc2l6ZSwgZGF0YSwgaTtcblxuICAgICAgICBiYXNlID0gMWU3O1xuICAgICAgICBzaXplID0gNjtcbiAgICAgICAgZGF0YSA9IFswLCAwLCAwLCAwLCAwLCAwXTtcblxuICAgICAgICBmdW5jdGlvbiBtdWx0aXBseShuLCBjKSB7XG4gICAgICAgICAgICB2YXIgaSA9IC0xO1xuICAgICAgICAgICAgd2hpbGUgKCsraSA8IHNpemUpIHtcbiAgICAgICAgICAgICAgICBjICs9IG4gKiBkYXRhW2ldO1xuICAgICAgICAgICAgICAgIGRhdGFbaV0gPSBjICUgYmFzZTtcbiAgICAgICAgICAgICAgICBjID0gTWF0aC5mbG9vcihjIC8gYmFzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBkaXZpZGUobikge1xuICAgICAgICAgICAgdmFyIGkgPSBzaXplLCBjID0gMDtcbiAgICAgICAgICAgIHdoaWxlICgtLWkgPj0gMCkge1xuICAgICAgICAgICAgICAgIGMgKz0gZGF0YVtpXTtcbiAgICAgICAgICAgICAgICBkYXRhW2ldID0gTWF0aC5mbG9vcihjIC8gbik7XG4gICAgICAgICAgICAgICAgYyA9IChjICUgbikgKiBiYXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICB2YXIgaSA9IHNpemU7XG4gICAgICAgICAgICB2YXIgcyA9ICcnO1xuICAgICAgICAgICAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHMgIT09ICcnIHx8IGkgPT09IDAgfHwgZGF0YVtpXSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IFN0cmluZyhkYXRhW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzID0gdDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgKz0gJzAwMDAwMDAnLnNsaWNlKDAsIDcgLSB0Lmxlbmd0aCkgKyB0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwb3coeCwgbiwgYWNjKSB7XG4gICAgICAgICAgICByZXR1cm4gKG4gPT09IDAgPyBhY2MgOiAobiAlIDIgPT09IDEgPyBwb3coeCwgbiAtIDEsIGFjYyAqIHgpIDogcG93KHggKiB4LCBuIC8gMiwgYWNjKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbG9nKHgpIHtcbiAgICAgICAgICAgIHZhciBuID0gMDtcbiAgICAgICAgICAgIHdoaWxlICh4ID49IDQwOTYpIHtcbiAgICAgICAgICAgICAgICBuICs9IDEyO1xuICAgICAgICAgICAgICAgIHggLz0gNDA5NjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlICh4ID49IDIpIHtcbiAgICAgICAgICAgICAgICBuICs9IDE7XG4gICAgICAgICAgICAgICAgeCAvPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIH1cblxuICAgICAgICBOdW1iZXIucHJvdG90eXBlLnRvRml4ZWQgPSBmdW5jdGlvbiAoZnJhY3Rpb25EaWdpdHMpIHtcbiAgICAgICAgICAgIHZhciBmLCB4LCBzLCBtLCBlLCB6LCBqLCBrO1xuXG4gICAgICAgICAgICAvLyBUZXN0IGZvciBOYU4gYW5kIHJvdW5kIGZyYWN0aW9uRGlnaXRzIGRvd25cbiAgICAgICAgICAgIGYgPSBOdW1iZXIoZnJhY3Rpb25EaWdpdHMpO1xuICAgICAgICAgICAgZiA9IGYgIT09IGYgPyAwIDogTWF0aC5mbG9vcihmKTtcblxuICAgICAgICAgICAgaWYgKGYgPCAwIHx8IGYgPiAyMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTnVtYmVyLnRvRml4ZWQgY2FsbGVkIHdpdGggaW52YWxpZCBudW1iZXIgb2YgZGVjaW1hbHNcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHggPSBOdW1iZXIodGhpcyk7XG5cbiAgICAgICAgICAgIC8vIFRlc3QgZm9yIE5hTlxuICAgICAgICAgICAgaWYgKHggIT09IHgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJOYU5cIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgaXQgaXMgdG9vIGJpZyBvciBzbWFsbCwgcmV0dXJuIHRoZSBzdHJpbmcgdmFsdWUgb2YgdGhlIG51bWJlclxuICAgICAgICAgICAgaWYgKHggPD0gLTFlMjEgfHwgeCA+PSAxZTIxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZyh4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcyA9IFwiXCI7XG5cbiAgICAgICAgICAgIGlmICh4IDwgMCkge1xuICAgICAgICAgICAgICAgIHMgPSBcIi1cIjtcbiAgICAgICAgICAgICAgICB4ID0gLXg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG0gPSBcIjBcIjtcblxuICAgICAgICAgICAgaWYgKHggPiAxZS0yMSkge1xuICAgICAgICAgICAgICAgIC8vIDFlLTIxIDwgeCA8IDFlMjFcbiAgICAgICAgICAgICAgICAvLyAtNzAgPCBsb2cyKHgpIDwgNzBcbiAgICAgICAgICAgICAgICBlID0gbG9nKHggKiBwb3coMiwgNjksIDEpKSAtIDY5O1xuICAgICAgICAgICAgICAgIHogPSAoZSA8IDAgPyB4ICogcG93KDIsIC1lLCAxKSA6IHggLyBwb3coMiwgZSwgMSkpO1xuICAgICAgICAgICAgICAgIHogKj0gMHgxMDAwMDAwMDAwMDAwMDsgLy8gTWF0aC5wb3coMiwgNTIpO1xuICAgICAgICAgICAgICAgIGUgPSA1MiAtIGU7XG5cbiAgICAgICAgICAgICAgICAvLyAtMTggPCBlIDwgMTIyXG4gICAgICAgICAgICAgICAgLy8geCA9IHogLyAyIF4gZVxuICAgICAgICAgICAgICAgIGlmIChlID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBtdWx0aXBseSgwLCB6KTtcbiAgICAgICAgICAgICAgICAgICAgaiA9IGY7XG5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGogPj0gNykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlwbHkoMWU3LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGogLT0gNztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG11bHRpcGx5KHBvdygxMCwgaiwgMSksIDApO1xuICAgICAgICAgICAgICAgICAgICBqID0gZSAtIDE7XG5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGogPj0gMjMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpdmlkZSgxIDw8IDIzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGogLT0gMjM7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBkaXZpZGUoMSA8PCBqKTtcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlwbHkoMSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGRpdmlkZSgyKTtcbiAgICAgICAgICAgICAgICAgICAgbSA9IHRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlwbHkoMCwgeik7XG4gICAgICAgICAgICAgICAgICAgIG11bHRpcGx5KDEgPDwgKC1lKSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIG0gPSB0b1N0cmluZygpICsgJzAuMDAwMDAwMDAwMDAwMDAwMDAwMDAnLnNsaWNlKDIsIDIgKyBmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmID4gMCkge1xuICAgICAgICAgICAgICAgIGsgPSBtLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIGlmIChrIDw9IGYpIHtcbiAgICAgICAgICAgICAgICAgICAgbSA9IHMgKyAnMC4wMDAwMDAwMDAwMDAwMDAwMDAwJy5zbGljZSgwLCBmIC0gayArIDIpICsgbTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtID0gcyArIG0uc2xpY2UoMCwgayAtIGYpICsgJy4nICsgbS5zbGljZShrIC0gZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtID0gcyArIG07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICB9XG4gICAgfSgpKTtcbn1cblxuXG4vL1xuLy8gU3RyaW5nXG4vLyA9PT09PT1cbi8vXG5cblxuLy8gRVM1IDE1LjUuNC4xNFxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNS40LjE0XG5cbi8vIFtidWdmaXgsIElFIGx0IDksIGZpcmVmb3ggNCwgS29ucXVlcm9yLCBPcGVyYSwgb2JzY3VyZSBicm93c2Vyc11cbi8vIE1hbnkgYnJvd3NlcnMgZG8gbm90IHNwbGl0IHByb3Blcmx5IHdpdGggcmVndWxhciBleHByZXNzaW9ucyBvciB0aGV5XG4vLyBkbyBub3QgcGVyZm9ybSB0aGUgc3BsaXQgY29ycmVjdGx5IHVuZGVyIG9ic2N1cmUgY29uZGl0aW9ucy5cbi8vIFNlZSBodHRwOi8vYmxvZy5zdGV2ZW5sZXZpdGhhbi5jb20vYXJjaGl2ZXMvY3Jvc3MtYnJvd3Nlci1zcGxpdFxuLy8gSSd2ZSB0ZXN0ZWQgaW4gbWFueSBicm93c2VycyBhbmQgdGhpcyBzZWVtcyB0byBjb3ZlciB0aGUgZGV2aWFudCBvbmVzOlxuLy8gICAgJ2FiJy5zcGxpdCgvKD86YWIpKi8pIHNob3VsZCBiZSBbXCJcIiwgXCJcIl0sIG5vdCBbXCJcIl1cbi8vICAgICcuJy5zcGxpdCgvKC4/KSguPykvKSBzaG91bGQgYmUgW1wiXCIsIFwiLlwiLCBcIlwiLCBcIlwiXSwgbm90IFtcIlwiLCBcIlwiXVxuLy8gICAgJ3Rlc3N0Jy5zcGxpdCgvKHMpKi8pIHNob3VsZCBiZSBbXCJ0XCIsIHVuZGVmaW5lZCwgXCJlXCIsIFwic1wiLCBcInRcIl0sIG5vdFxuLy8gICAgICAgW3VuZGVmaW5lZCwgXCJ0XCIsIHVuZGVmaW5lZCwgXCJlXCIsIC4uLl1cbi8vICAgICcnLnNwbGl0KC8uPy8pIHNob3VsZCBiZSBbXSwgbm90IFtcIlwiXVxuLy8gICAgJy4nLnNwbGl0KC8oKSgpLykgc2hvdWxkIGJlIFtcIi5cIl0sIG5vdCBbXCJcIiwgXCJcIiwgXCIuXCJdXG5cbnZhciBzdHJpbmdfc3BsaXQgPSBTdHJpbmcucHJvdG90eXBlLnNwbGl0O1xuaWYgKFxuICAgICdhYicuc3BsaXQoLyg/OmFiKSovKS5sZW5ndGggIT09IDIgfHxcbiAgICAnLicuc3BsaXQoLyguPykoLj8pLykubGVuZ3RoICE9PSA0IHx8XG4gICAgJ3Rlc3N0Jy5zcGxpdCgvKHMpKi8pWzFdID09PSBcInRcIiB8fFxuICAgICcnLnNwbGl0KC8uPy8pLmxlbmd0aCA9PT0gMCB8fFxuICAgICcuJy5zcGxpdCgvKCkoKS8pLmxlbmd0aCA+IDFcbikge1xuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb21wbGlhbnRFeGVjTnBjZyA9IC8oKT8/Ly5leGVjKFwiXCIpWzFdID09PSB2b2lkIDA7IC8vIE5QQ0c6IG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3VwXG5cbiAgICAgICAgU3RyaW5nLnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICAgICAgICB2YXIgc3RyaW5nID0gdGhpcztcbiAgICAgICAgICAgIGlmIChzZXBhcmF0b3IgPT09IHZvaWQgMCAmJiBsaW1pdCA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG5cbiAgICAgICAgICAgIC8vIElmIGBzZXBhcmF0b3JgIGlzIG5vdCBhIHJlZ2V4LCB1c2UgbmF0aXZlIHNwbGl0XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHNlcGFyYXRvcikgIT09IFwiW29iamVjdCBSZWdFeHBdXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nX3NwbGl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSBbXSxcbiAgICAgICAgICAgICAgICBmbGFncyA9IChzZXBhcmF0b3IuaWdub3JlQ2FzZSA/IFwiaVwiIDogXCJcIikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5tdWx0aWxpbmUgID8gXCJtXCIgOiBcIlwiKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLmV4dGVuZGVkICAgPyBcInhcIiA6IFwiXCIpICsgLy8gUHJvcG9zZWQgZm9yIEVTNlxuICAgICAgICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5zdGlja3kgICAgID8gXCJ5XCIgOiBcIlwiKSwgLy8gRmlyZWZveCAzK1xuICAgICAgICAgICAgICAgIGxhc3RMYXN0SW5kZXggPSAwLFxuICAgICAgICAgICAgICAgIC8vIE1ha2UgYGdsb2JhbGAgYW5kIGF2b2lkIGBsYXN0SW5kZXhgIGlzc3VlcyBieSB3b3JraW5nIHdpdGggYSBjb3B5XG4gICAgICAgICAgICAgICAgc2VwYXJhdG9yID0gbmV3IFJlZ0V4cChzZXBhcmF0b3Iuc291cmNlLCBmbGFncyArIFwiZ1wiKSxcbiAgICAgICAgICAgICAgICBzZXBhcmF0b3IyLCBtYXRjaCwgbGFzdEluZGV4LCBsYXN0TGVuZ3RoO1xuICAgICAgICAgICAgc3RyaW5nICs9IFwiXCI7IC8vIFR5cGUtY29udmVydFxuICAgICAgICAgICAgaWYgKCFjb21wbGlhbnRFeGVjTnBjZykge1xuICAgICAgICAgICAgICAgIC8vIERvZXNuJ3QgbmVlZCBmbGFncyBneSwgYnV0IHRoZXkgZG9uJ3QgaHVydFxuICAgICAgICAgICAgICAgIHNlcGFyYXRvcjIgPSBuZXcgUmVnRXhwKFwiXlwiICsgc2VwYXJhdG9yLnNvdXJjZSArIFwiJCg/IVxcXFxzKVwiLCBmbGFncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBWYWx1ZXMgZm9yIGBsaW1pdGAsIHBlciB0aGUgc3BlYzpcbiAgICAgICAgICAgICAqIElmIHVuZGVmaW5lZDogNDI5NDk2NzI5NSAvLyBNYXRoLnBvdygyLCAzMikgLSAxXG4gICAgICAgICAgICAgKiBJZiAwLCBJbmZpbml0eSwgb3IgTmFOOiAwXG4gICAgICAgICAgICAgKiBJZiBwb3NpdGl2ZSBudW1iZXI6IGxpbWl0ID0gTWF0aC5mbG9vcihsaW1pdCk7IGlmIChsaW1pdCA+IDQyOTQ5NjcyOTUpIGxpbWl0IC09IDQyOTQ5NjcyOTY7XG4gICAgICAgICAgICAgKiBJZiBuZWdhdGl2ZSBudW1iZXI6IDQyOTQ5NjcyOTYgLSBNYXRoLmZsb29yKE1hdGguYWJzKGxpbWl0KSlcbiAgICAgICAgICAgICAqIElmIG90aGVyOiBUeXBlLWNvbnZlcnQsIHRoZW4gdXNlIHRoZSBhYm92ZSBydWxlc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBsaW1pdCA9IGxpbWl0ID09PSB2b2lkIDAgP1xuICAgICAgICAgICAgICAgIC0xID4+PiAwIDogLy8gTWF0aC5wb3coMiwgMzIpIC0gMVxuICAgICAgICAgICAgICAgIGxpbWl0ID4+PiAwOyAvLyBUb1VpbnQzMihsaW1pdClcbiAgICAgICAgICAgIHdoaWxlIChtYXRjaCA9IHNlcGFyYXRvci5leGVjKHN0cmluZykpIHtcbiAgICAgICAgICAgICAgICAvLyBgc2VwYXJhdG9yLmxhc3RJbmRleGAgaXMgbm90IHJlbGlhYmxlIGNyb3NzLWJyb3dzZXJcbiAgICAgICAgICAgICAgICBsYXN0SW5kZXggPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAobGFzdEluZGV4ID4gbGFzdExhc3RJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChzdHJpbmcuc2xpY2UobGFzdExhc3RJbmRleCwgbWF0Y2guaW5kZXgpKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRml4IGJyb3dzZXJzIHdob3NlIGBleGVjYCBtZXRob2RzIGRvbid0IGNvbnNpc3RlbnRseSByZXR1cm4gYHVuZGVmaW5lZGAgZm9yXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3Vwc1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbXBsaWFudEV4ZWNOcGNnICYmIG1hdGNoLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoWzBdLnJlcGxhY2Uoc2VwYXJhdG9yMiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzW2ldID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoW2ldID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoLmxlbmd0aCA+IDEgJiYgbWF0Y2guaW5kZXggPCBzdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShvdXRwdXQsIG1hdGNoLnNsaWNlKDEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsYXN0TGVuZ3RoID0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBsYXN0TGFzdEluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgICAgICAgICAgICAgICBpZiAob3V0cHV0Lmxlbmd0aCA+PSBsaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlcGFyYXRvci5sYXN0SW5kZXggPT09IG1hdGNoLmluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcGFyYXRvci5sYXN0SW5kZXgrKzsgLy8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXN0TGFzdEluZGV4ID09PSBzdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RMZW5ndGggfHwgIXNlcGFyYXRvci50ZXN0KFwiXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKFwiXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goc3RyaW5nLnNsaWNlKGxhc3RMYXN0SW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQubGVuZ3RoID4gbGltaXQgPyBvdXRwdXQuc2xpY2UoMCwgbGltaXQpIDogb3V0cHV0O1xuICAgICAgICB9O1xuICAgIH0oKSk7XG5cbi8vIFtidWdmaXgsIGNocm9tZV1cbi8vIElmIHNlcGFyYXRvciBpcyB1bmRlZmluZWQsIHRoZW4gdGhlIHJlc3VsdCBhcnJheSBjb250YWlucyBqdXN0IG9uZSBTdHJpbmcsXG4vLyB3aGljaCBpcyB0aGUgdGhpcyB2YWx1ZSAoY29udmVydGVkIHRvIGEgU3RyaW5nKS4gSWYgbGltaXQgaXMgbm90IHVuZGVmaW5lZCxcbi8vIHRoZW4gdGhlIG91dHB1dCBhcnJheSBpcyB0cnVuY2F0ZWQgc28gdGhhdCBpdCBjb250YWlucyBubyBtb3JlIHRoYW4gbGltaXRcbi8vIGVsZW1lbnRzLlxuLy8gXCIwXCIuc3BsaXQodW5kZWZpbmVkLCAwKSAtPiBbXVxufSBlbHNlIGlmIChcIjBcIi5zcGxpdCh2b2lkIDAsIDApLmxlbmd0aCkge1xuICAgIFN0cmluZy5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbihzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICAgIGlmIChzZXBhcmF0b3IgPT09IHZvaWQgMCAmJiBsaW1pdCA9PT0gMCkgcmV0dXJuIFtdO1xuICAgICAgICByZXR1cm4gc3RyaW5nX3NwbGl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxufVxuXG5cbi8vIEVDTUEtMjYyLCAzcmQgQi4yLjNcbi8vIE5vdGUgYW4gRUNNQVNjcmlwdCBzdGFuZGFydCwgYWx0aG91Z2ggRUNNQVNjcmlwdCAzcmQgRWRpdGlvbiBoYXMgYVxuLy8gbm9uLW5vcm1hdGl2ZSBzZWN0aW9uIHN1Z2dlc3RpbmcgdW5pZm9ybSBzZW1hbnRpY3MgYW5kIGl0IHNob3VsZCBiZVxuLy8gbm9ybWFsaXplZCBhY3Jvc3MgYWxsIGJyb3dzZXJzXG4vLyBbYnVnZml4LCBJRSBsdCA5XSBJRSA8IDkgc3Vic3RyKCkgd2l0aCBuZWdhdGl2ZSB2YWx1ZSBub3Qgd29ya2luZyBpbiBJRVxuaWYoXCJcIi5zdWJzdHIgJiYgXCIwYlwiLnN1YnN0cigtMSkgIT09IFwiYlwiKSB7XG4gICAgdmFyIHN0cmluZ19zdWJzdHIgPSBTdHJpbmcucHJvdG90eXBlLnN1YnN0cjtcbiAgICAvKipcbiAgICAgKiAgR2V0IHRoZSBzdWJzdHJpbmcgb2YgYSBzdHJpbmdcbiAgICAgKiAgQHBhcmFtICB7aW50ZWdlcn0gIHN0YXJ0ICAgd2hlcmUgdG8gc3RhcnQgdGhlIHN1YnN0cmluZ1xuICAgICAqICBAcGFyYW0gIHtpbnRlZ2VyfSAgbGVuZ3RoICBob3cgbWFueSBjaGFyYWN0ZXJzIHRvIHJldHVyblxuICAgICAqICBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG4gICAgU3RyaW5nLnByb3RvdHlwZS5zdWJzdHIgPSBmdW5jdGlvbihzdGFydCwgbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdfc3Vic3RyLmNhbGwoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgc3RhcnQgPCAwID8gKChzdGFydCA9IHRoaXMubGVuZ3RoICsgc3RhcnQpIDwgMCA/IDAgOiBzdGFydCkgOiBzdGFydCxcbiAgICAgICAgICAgIGxlbmd0aFxuICAgICAgICApO1xuICAgIH1cbn1cblxuLy8gRVM1IDE1LjUuNC4yMFxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNS40LjIwXG52YXIgd3MgPSBcIlxceDA5XFx4MEFcXHgwQlxceDBDXFx4MERcXHgyMFxceEEwXFx1MTY4MFxcdTE4MEVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzXCIgK1xuICAgIFwiXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdTIwMjhcIiArXG4gICAgXCJcXHUyMDI5XFx1RkVGRlwiO1xuaWYgKCFTdHJpbmcucHJvdG90eXBlLnRyaW0gfHwgd3MudHJpbSgpKSB7XG4gICAgLy8gaHR0cDovL2Jsb2cuc3RldmVubGV2aXRoYW4uY29tL2FyY2hpdmVzL2Zhc3Rlci10cmltLWphdmFzY3JpcHRcbiAgICAvLyBodHRwOi8vcGVyZmVjdGlvbmtpbGxzLmNvbS93aGl0ZXNwYWNlLWRldmlhdGlvbnMvXG4gICAgd3MgPSBcIltcIiArIHdzICsgXCJdXCI7XG4gICAgdmFyIHRyaW1CZWdpblJlZ2V4cCA9IG5ldyBSZWdFeHAoXCJeXCIgKyB3cyArIHdzICsgXCIqXCIpLFxuICAgICAgICB0cmltRW5kUmVnZXhwID0gbmV3IFJlZ0V4cCh3cyArIHdzICsgXCIqJFwiKTtcbiAgICBTdHJpbmcucHJvdG90eXBlLnRyaW0gPSBmdW5jdGlvbiB0cmltKCkge1xuICAgICAgICBpZiAodGhpcyA9PT0gdm9pZCAwIHx8IHRoaXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYW4ndCBjb252ZXJ0IFwiK3RoaXMrXCIgdG8gb2JqZWN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTdHJpbmcodGhpcylcbiAgICAgICAgICAgIC5yZXBsYWNlKHRyaW1CZWdpblJlZ2V4cCwgXCJcIilcbiAgICAgICAgICAgIC5yZXBsYWNlKHRyaW1FbmRSZWdleHAsIFwiXCIpO1xuICAgIH07XG59XG5cbi8vXG4vLyBVdGlsXG4vLyA9PT09PT1cbi8vXG5cbi8vIEVTNSA5LjRcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDkuNFxuLy8gaHR0cDovL2pzcGVyZi5jb20vdG8taW50ZWdlclxuXG5mdW5jdGlvbiB0b0ludGVnZXIobikge1xuICAgIG4gPSArbjtcbiAgICBpZiAobiAhPT0gbikgeyAvLyBpc05hTlxuICAgICAgICBuID0gMDtcbiAgICB9IGVsc2UgaWYgKG4gIT09IDAgJiYgbiAhPT0gKDEvMCkgJiYgbiAhPT0gLSgxLzApKSB7XG4gICAgICAgIG4gPSAobiA+IDAgfHwgLTEpICogTWF0aC5mbG9vcihNYXRoLmFicyhuKSk7XG4gICAgfVxuICAgIHJldHVybiBuO1xufVxuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShpbnB1dCkge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIGlucHV0O1xuICAgIHJldHVybiAoXG4gICAgICAgIGlucHV0ID09PSBudWxsIHx8XG4gICAgICAgIHR5cGUgPT09IFwidW5kZWZpbmVkXCIgfHxcbiAgICAgICAgdHlwZSA9PT0gXCJib29sZWFuXCIgfHxcbiAgICAgICAgdHlwZSA9PT0gXCJudW1iZXJcIiB8fFxuICAgICAgICB0eXBlID09PSBcInN0cmluZ1wiXG4gICAgKTtcbn1cblxuZnVuY3Rpb24gdG9QcmltaXRpdmUoaW5wdXQpIHtcbiAgICB2YXIgdmFsLCB2YWx1ZU9mLCB0b1N0cmluZztcbiAgICBpZiAoaXNQcmltaXRpdmUoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gICAgdmFsdWVPZiA9IGlucHV0LnZhbHVlT2Y7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZU9mID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdmFsID0gdmFsdWVPZi5jYWxsKGlucHV0KTtcbiAgICAgICAgaWYgKGlzUHJpbWl0aXZlKHZhbCkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9TdHJpbmcgPSBpbnB1dC50b1N0cmluZztcbiAgICBpZiAodHlwZW9mIHRvU3RyaW5nID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdmFsID0gdG9TdHJpbmcuY2FsbChpbnB1dCk7XG4gICAgICAgIGlmIChpc1ByaW1pdGl2ZSh2YWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbn1cblxuLy8gRVM1IDkuOVxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4OS45XG52YXIgdG9PYmplY3QgPSBmdW5jdGlvbiAobykge1xuICAgIGlmIChvID09IG51bGwpIHsgLy8gdGhpcyBtYXRjaGVzIGJvdGggbnVsbCBhbmQgdW5kZWZpbmVkXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYW4ndCBjb252ZXJ0IFwiK28rXCIgdG8gb2JqZWN0XCIpO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0KG8pO1xufTtcblxufSk7XG5cbn0pKCkiLCIoZnVuY3Rpb24oKXsvLyBDb3B5cmlnaHQgMjAwOS0yMDEyIGJ5IGNvbnRyaWJ1dG9ycywgTUlUIExpY2Vuc2Vcbi8vIHZpbTogdHM9NCBzdHM9NCBzdz00IGV4cGFuZHRhYlxuXG4vLyBNb2R1bGUgc3lzdGVtcyBtYWdpYyBkYW5jZVxuKGZ1bmN0aW9uIChkZWZpbml0aW9uKSB7XG4gICAgLy8gUmVxdWlyZUpTXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGRlZmluZShkZWZpbml0aW9uKTtcbiAgICAvLyBZVUkzXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgWVVJID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBZVUkuYWRkKFwiZXM1LXNoYW1cIiwgZGVmaW5pdGlvbik7XG4gICAgLy8gQ29tbW9uSlMgYW5kIDxzY3JpcHQ+XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZGVmaW5pdGlvbigpO1xuICAgIH1cbn0pKGZ1bmN0aW9uICgpIHtcblxuXG52YXIgY2FsbCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsO1xudmFyIHByb3RvdHlwZU9mT2JqZWN0ID0gT2JqZWN0LnByb3RvdHlwZTtcbnZhciBvd25zID0gY2FsbC5iaW5kKHByb3RvdHlwZU9mT2JqZWN0Lmhhc093blByb3BlcnR5KTtcblxuLy8gSWYgSlMgZW5naW5lIHN1cHBvcnRzIGFjY2Vzc29ycyBjcmVhdGluZyBzaG9ydGN1dHMuXG52YXIgZGVmaW5lR2V0dGVyO1xudmFyIGRlZmluZVNldHRlcjtcbnZhciBsb29rdXBHZXR0ZXI7XG52YXIgbG9va3VwU2V0dGVyO1xudmFyIHN1cHBvcnRzQWNjZXNzb3JzO1xuaWYgKChzdXBwb3J0c0FjY2Vzc29ycyA9IG93bnMocHJvdG90eXBlT2ZPYmplY3QsIFwiX19kZWZpbmVHZXR0ZXJfX1wiKSkpIHtcbiAgICBkZWZpbmVHZXR0ZXIgPSBjYWxsLmJpbmQocHJvdG90eXBlT2ZPYmplY3QuX19kZWZpbmVHZXR0ZXJfXyk7XG4gICAgZGVmaW5lU2V0dGVyID0gY2FsbC5iaW5kKHByb3RvdHlwZU9mT2JqZWN0Ll9fZGVmaW5lU2V0dGVyX18pO1xuICAgIGxvb2t1cEdldHRlciA9IGNhbGwuYmluZChwcm90b3R5cGVPZk9iamVjdC5fX2xvb2t1cEdldHRlcl9fKTtcbiAgICBsb29rdXBTZXR0ZXIgPSBjYWxsLmJpbmQocHJvdG90eXBlT2ZPYmplY3QuX19sb29rdXBTZXR0ZXJfXyk7XG59XG5cbi8vIEVTNSAxNS4yLjMuMlxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMi4zLjJcbmlmICghT2JqZWN0LmdldFByb3RvdHlwZU9mKSB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2tyaXNrb3dhbC9lczUtc2hpbS9pc3N1ZXMjaXNzdWUvMlxuICAgIC8vIGh0dHA6Ly9lam9obi5vcmcvYmxvZy9vYmplY3RnZXRwcm90b3R5cGVvZi9cbiAgICAvLyByZWNvbW1lbmRlZCBieSBmc2NoYWVmZXIgb24gZ2l0aHViXG4gICAgT2JqZWN0LmdldFByb3RvdHlwZU9mID0gZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2Yob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBvYmplY3QuX19wcm90b19fIHx8IChcbiAgICAgICAgICAgIG9iamVjdC5jb25zdHJ1Y3RvclxuICAgICAgICAgICAgICAgID8gb2JqZWN0LmNvbnN0cnVjdG9yLnByb3RvdHlwZVxuICAgICAgICAgICAgICAgIDogcHJvdG90eXBlT2ZPYmplY3RcbiAgICAgICAgKTtcbiAgICB9O1xufVxuXG4vL0VTNSAxNS4yLjMuM1xuLy9odHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS4yLjMuM1xuXG5mdW5jdGlvbiBkb2VzR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yV29yayhvYmplY3QpIHtcbiAgICB0cnkge1xuICAgICAgICBvYmplY3Quc2VudGluZWwgPSAwO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcbiAgICAgICAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgICAgICAgXCJzZW50aW5lbFwiXG4gICAgICAgICkudmFsdWUgPT09IDA7XG4gICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgIC8vIHJldHVybnMgZmFsc3lcbiAgICB9XG59XG5cbi8vY2hlY2sgd2hldGhlciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Igd29ya3MgaWYgaXQncyBnaXZlbi4gT3RoZXJ3aXNlLFxuLy9zaGltIHBhcnRpYWxseS5cbmlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHtcbiAgICB2YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yV29ya3NPbk9iamVjdCA9IFxuICAgICAgICBkb2VzR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yV29yayh7fSk7XG4gICAgdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvcldvcmtzT25Eb20gPSB0eXBlb2YgZG9jdW1lbnQgPT0gXCJ1bmRlZmluZWRcIiB8fFxuICAgIGRvZXNHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JXb3JrKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xuICAgIGlmICghZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yV29ya3NPbkRvbSB8fCBcbiAgICAgICAgICAgICFnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JXb3Jrc09uT2JqZWN0XG4gICAgKSB7XG4gICAgICAgIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JGYWxsYmFjayA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICAgfVxufVxuXG5pZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgfHwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yRmFsbGJhY2spIHtcbiAgICB2YXIgRVJSX05PTl9PQkpFQ1QgPSBcIk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgY2FsbGVkIG9uIGEgbm9uLW9iamVjdDogXCI7XG5cbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICAgICAgaWYgKCh0eXBlb2Ygb2JqZWN0ICE9IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iamVjdCAhPSBcImZ1bmN0aW9uXCIpIHx8IG9iamVjdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihFUlJfTk9OX09CSkVDVCArIG9iamVjdCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtYWtlIGEgdmFsaWFudCBhdHRlbXB0IHRvIHVzZSB0aGUgcmVhbCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JcbiAgICAgICAgLy8gZm9yIEk4J3MgRE9NIGVsZW1lbnRzLlxuICAgICAgICBpZiAoZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yRmFsbGJhY2spIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldE93blByb3BlcnR5RGVzY3JpcHRvckZhbGxiYWNrLmNhbGwoT2JqZWN0LCBvYmplY3QsIHByb3BlcnR5KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIHRyeSB0aGUgc2hpbSBpZiB0aGUgcmVhbCBvbmUgZG9lc24ndCB3b3JrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBvYmplY3QgZG9lcyBub3Qgb3ducyBwcm9wZXJ0eSByZXR1cm4gdW5kZWZpbmVkIGltbWVkaWF0ZWx5LlxuICAgICAgICBpZiAoIW93bnMob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIG9iamVjdCBoYXMgYSBwcm9wZXJ0eSB0aGVuIGl0J3MgZm9yIHN1cmUgYm90aCBgZW51bWVyYWJsZWAgYW5kXG4gICAgICAgIC8vIGBjb25maWd1cmFibGVgLlxuICAgICAgICB2YXIgZGVzY3JpcHRvciA9ICB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9O1xuXG4gICAgICAgIC8vIElmIEpTIGVuZ2luZSBzdXBwb3J0cyBhY2Nlc3NvciBwcm9wZXJ0aWVzIHRoZW4gcHJvcGVydHkgbWF5IGJlIGFcbiAgICAgICAgLy8gZ2V0dGVyIG9yIHNldHRlci5cbiAgICAgICAgaWYgKHN1cHBvcnRzQWNjZXNzb3JzKSB7XG4gICAgICAgICAgICAvLyBVbmZvcnR1bmF0ZWx5IGBfX2xvb2t1cEdldHRlcl9fYCB3aWxsIHJldHVybiBhIGdldHRlciBldmVuXG4gICAgICAgICAgICAvLyBpZiBvYmplY3QgaGFzIG93biBub24gZ2V0dGVyIHByb3BlcnR5IGFsb25nIHdpdGggYSBzYW1lIG5hbWVkXG4gICAgICAgICAgICAvLyBpbmhlcml0ZWQgZ2V0dGVyLiBUbyBhdm9pZCBtaXNiZWhhdmlvciB3ZSB0ZW1wb3JhcnkgcmVtb3ZlXG4gICAgICAgICAgICAvLyBgX19wcm90b19fYCBzbyB0aGF0IGBfX2xvb2t1cEdldHRlcl9fYCB3aWxsIHJldHVybiBnZXR0ZXIgb25seVxuICAgICAgICAgICAgLy8gaWYgaXQncyBvd25lZCBieSBhbiBvYmplY3QuXG4gICAgICAgICAgICB2YXIgcHJvdG90eXBlID0gb2JqZWN0Ll9fcHJvdG9fXztcbiAgICAgICAgICAgIG9iamVjdC5fX3Byb3RvX18gPSBwcm90b3R5cGVPZk9iamVjdDtcblxuICAgICAgICAgICAgdmFyIGdldHRlciA9IGxvb2t1cEdldHRlcihvYmplY3QsIHByb3BlcnR5KTtcbiAgICAgICAgICAgIHZhciBzZXR0ZXIgPSBsb29rdXBTZXR0ZXIob2JqZWN0LCBwcm9wZXJ0eSk7XG5cbiAgICAgICAgICAgIC8vIE9uY2Ugd2UgaGF2ZSBnZXR0ZXIgYW5kIHNldHRlciB3ZSBjYW4gcHV0IHZhbHVlcyBiYWNrLlxuICAgICAgICAgICAgb2JqZWN0Ll9fcHJvdG9fXyA9IHByb3RvdHlwZTtcblxuICAgICAgICAgICAgaWYgKGdldHRlciB8fCBzZXR0ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0dGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0b3IuZ2V0ID0gZ2V0dGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2V0dGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0b3Iuc2V0ID0gc2V0dGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiBpdCB3YXMgYWNjZXNzb3IgcHJvcGVydHkgd2UncmUgZG9uZSBhbmQgcmV0dXJuIGhlcmVcbiAgICAgICAgICAgICAgICAvLyBpbiBvcmRlciB0byBhdm9pZCBhZGRpbmcgYHZhbHVlYCB0byB0aGUgZGVzY3JpcHRvci5cbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpcHRvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHdlIGdvdCB0aGlzIGZhciB3ZSBrbm93IHRoYXQgb2JqZWN0IGhhcyBhbiBvd24gcHJvcGVydHkgdGhhdCBpc1xuICAgICAgICAvLyBub3QgYW4gYWNjZXNzb3Igc28gd2Ugc2V0IGl0IGFzIGEgdmFsdWUgYW5kIHJldHVybiBkZXNjcmlwdG9yLlxuICAgICAgICBkZXNjcmlwdG9yLnZhbHVlID0gb2JqZWN0W3Byb3BlcnR5XTtcbiAgICAgICAgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICAgIHJldHVybiBkZXNjcmlwdG9yO1xuICAgIH07XG59XG5cbi8vIEVTNSAxNS4yLjMuNFxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMi4zLjRcbmlmICghT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMpIHtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmplY3QpO1xuICAgIH07XG59XG5cbi8vIEVTNSAxNS4yLjMuNVxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMi4zLjVcbmlmICghT2JqZWN0LmNyZWF0ZSkge1xuXG4gICAgLy8gQ29udHJpYnV0ZWQgYnkgQnJhbmRvbiBCZW52aWUsIE9jdG9iZXIsIDIwMTJcbiAgICB2YXIgY3JlYXRlRW1wdHk7XG4gICAgdmFyIHN1cHBvcnRzUHJvdG8gPSBPYmplY3QucHJvdG90eXBlLl9fcHJvdG9fXyA9PT0gbnVsbDtcbiAgICBpZiAoc3VwcG9ydHNQcm90byB8fCB0eXBlb2YgZG9jdW1lbnQgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY3JlYXRlRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4geyBcIl9fcHJvdG9fX1wiOiBudWxsIH07XG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSW4gb2xkIElFIF9fcHJvdG9fXyBjYW4ndCBiZSB1c2VkIHRvIG1hbnVhbGx5IHNldCBgbnVsbGAsIG5vciBkb2VzXG4gICAgICAgIC8vIGFueSBvdGhlciBtZXRob2QgZXhpc3QgdG8gbWFrZSBhbiBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIG5vdGhpbmcsXG4gICAgICAgIC8vIGFzaWRlIGZyb20gT2JqZWN0LnByb3RvdHlwZSBpdHNlbGYuIEluc3RlYWQsIGNyZWF0ZSBhIG5ldyBnbG9iYWxcbiAgICAgICAgLy8gb2JqZWN0IGFuZCAqc3RlYWwqIGl0cyBPYmplY3QucHJvdG90eXBlIGFuZCBzdHJpcCBpdCBiYXJlLiBUaGlzIGlzXG4gICAgICAgIC8vIHVzZWQgYXMgdGhlIHByb3RvdHlwZSB0byBjcmVhdGUgbnVsbGFyeSBvYmplY3RzLlxuICAgICAgICBjcmVhdGVFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBkb2N1bWVudC5ib2R5IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgICAgIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgICAgICAgICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JztcbiAgICAgICAgICAgIHZhciBlbXB0eSA9IGlmcmFtZS5jb250ZW50V2luZG93Lk9iamVjdC5wcm90b3R5cGU7XG4gICAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgICAgICAgICAgIGlmcmFtZSA9IG51bGw7XG4gICAgICAgICAgICBkZWxldGUgZW1wdHkuY29uc3RydWN0b3I7XG4gICAgICAgICAgICBkZWxldGUgZW1wdHkuaGFzT3duUHJvcGVydHk7XG4gICAgICAgICAgICBkZWxldGUgZW1wdHkucHJvcGVydHlJc0VudW1lcmFibGU7XG4gICAgICAgICAgICBkZWxldGUgZW1wdHkuaXNQcm90b3R5cGVPZjtcbiAgICAgICAgICAgIGRlbGV0ZSBlbXB0eS50b0xvY2FsZVN0cmluZztcbiAgICAgICAgICAgIGRlbGV0ZSBlbXB0eS50b1N0cmluZztcbiAgICAgICAgICAgIGRlbGV0ZSBlbXB0eS52YWx1ZU9mO1xuICAgICAgICAgICAgZW1wdHkuX19wcm90b19fID0gbnVsbDtcblxuICAgICAgICAgICAgZnVuY3Rpb24gRW1wdHkoKSB7fVxuICAgICAgICAgICAgRW1wdHkucHJvdG90eXBlID0gZW1wdHk7XG4gICAgICAgICAgICAvLyBzaG9ydC1jaXJjdWl0IGZ1dHVyZSBjYWxsc1xuICAgICAgICAgICAgY3JlYXRlRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFbXB0eSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRW1wdHkoKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBPYmplY3QuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3RvdHlwZSwgcHJvcGVydGllcykge1xuXG4gICAgICAgIHZhciBvYmplY3Q7XG4gICAgICAgIGZ1bmN0aW9uIFR5cGUoKSB7fSAgLy8gQW4gZW1wdHkgY29uc3RydWN0b3IuXG5cbiAgICAgICAgaWYgKHByb3RvdHlwZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgb2JqZWN0ID0gY3JlYXRlRW1wdHkoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvdG90eXBlICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBwcm90b3R5cGUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIC8vIEluIHRoZSBuYXRpdmUgaW1wbGVtZW50YXRpb24gYHBhcmVudGAgY2FuIGJlIGBudWxsYFxuICAgICAgICAgICAgICAgIC8vIE9SICphbnkqIGBpbnN0YW5jZW9mIE9iamVjdGAgIChPYmplY3R8RnVuY3Rpb258QXJyYXl8UmVnRXhwfGV0YylcbiAgICAgICAgICAgICAgICAvLyBVc2UgYHR5cGVvZmAgdGhvLCBiL2MgaW4gb2xkIElFLCBET00gZWxlbWVudHMgYXJlIG5vdCBgaW5zdGFuY2VvZiBPYmplY3RgXG4gICAgICAgICAgICAgICAgLy8gbGlrZSB0aGV5IGFyZSBpbiBtb2Rlcm4gYnJvd3NlcnMuIFVzaW5nIGBPYmplY3QuY3JlYXRlYCBvbiBET00gZWxlbWVudHNcbiAgICAgICAgICAgICAgICAvLyBpcy4uLmVyci4uLnByb2JhYmx5IGluYXBwcm9wcmlhdGUsIGJ1dCB0aGUgbmF0aXZlIHZlcnNpb24gYWxsb3dzIGZvciBpdC5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IHByb3RvdHlwZSBtYXkgb25seSBiZSBhbiBPYmplY3Qgb3IgbnVsbFwiKTsgLy8gc2FtZSBtc2cgYXMgQ2hyb21lXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBUeXBlLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgICAgICAgICAgIG9iamVjdCA9IG5ldyBUeXBlKCk7XG4gICAgICAgICAgICAvLyBJRSBoYXMgbm8gYnVpbHQtaW4gaW1wbGVtZW50YXRpb24gb2YgYE9iamVjdC5nZXRQcm90b3R5cGVPZmBcbiAgICAgICAgICAgIC8vIG5laXRoZXIgYF9fcHJvdG9fX2AsIGJ1dCB0aGlzIG1hbnVhbGx5IHNldHRpbmcgYF9fcHJvdG9fX2Agd2lsbFxuICAgICAgICAgICAgLy8gZ3VhcmFudGVlIHRoYXQgYE9iamVjdC5nZXRQcm90b3R5cGVPZmAgd2lsbCB3b3JrIGFzIGV4cGVjdGVkIHdpdGhcbiAgICAgICAgICAgIC8vIG9iamVjdHMgY3JlYXRlZCB1c2luZyBgT2JqZWN0LmNyZWF0ZWBcbiAgICAgICAgICAgIG9iamVjdC5fX3Byb3RvX18gPSBwcm90b3R5cGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvcGVydGllcyAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhvYmplY3QsIHByb3BlcnRpZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9O1xufVxuXG4vLyBFUzUgMTUuMi4zLjZcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjIuMy42XG5cbi8vIFBhdGNoIGZvciBXZWJLaXQgYW5kIElFOCBzdGFuZGFyZCBtb2RlXG4vLyBEZXNpZ25lZCBieSBoYXggPGhheC5naXRodWIuY29tPlxuLy8gcmVsYXRlZCBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2tyaXNrb3dhbC9lczUtc2hpbS9pc3N1ZXMjaXNzdWUvNVxuLy8gSUU4IFJlZmVyZW5jZTpcbi8vICAgICBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvZGQyODI5MDAuYXNweFxuLy8gICAgIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9kZDIyOTkxNi5hc3B4XG4vLyBXZWJLaXQgQnVnczpcbi8vICAgICBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MzY0MjNcblxuZnVuY3Rpb24gZG9lc0RlZmluZVByb3BlcnR5V29yayhvYmplY3QpIHtcbiAgICB0cnkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBcInNlbnRpbmVsXCIsIHt9KTtcbiAgICAgICAgcmV0dXJuIFwic2VudGluZWxcIiBpbiBvYmplY3Q7XG4gICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgIC8vIHJldHVybnMgZmFsc3lcbiAgICB9XG59XG5cbi8vIGNoZWNrIHdoZXRoZXIgZGVmaW5lUHJvcGVydHkgd29ya3MgaWYgaXQncyBnaXZlbi4gT3RoZXJ3aXNlLFxuLy8gc2hpbSBwYXJ0aWFsbHkuXG5pZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7XG4gICAgdmFyIGRlZmluZVByb3BlcnR5V29ya3NPbk9iamVjdCA9IGRvZXNEZWZpbmVQcm9wZXJ0eVdvcmsoe30pO1xuICAgIHZhciBkZWZpbmVQcm9wZXJ0eVdvcmtzT25Eb20gPSB0eXBlb2YgZG9jdW1lbnQgPT0gXCJ1bmRlZmluZWRcIiB8fFxuICAgICAgICBkb2VzRGVmaW5lUHJvcGVydHlXb3JrKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xuICAgIGlmICghZGVmaW5lUHJvcGVydHlXb3Jrc09uT2JqZWN0IHx8ICFkZWZpbmVQcm9wZXJ0eVdvcmtzT25Eb20pIHtcbiAgICAgICAgdmFyIGRlZmluZVByb3BlcnR5RmFsbGJhY2sgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksXG4gICAgICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzRmFsbGJhY2sgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbiAgICB9XG59XG5cbmlmICghT2JqZWN0LmRlZmluZVByb3BlcnR5IHx8IGRlZmluZVByb3BlcnR5RmFsbGJhY2spIHtcbiAgICB2YXIgRVJSX05PTl9PQkpFQ1RfREVTQ1JJUFRPUiA9IFwiUHJvcGVydHkgZGVzY3JpcHRpb24gbXVzdCBiZSBhbiBvYmplY3Q6IFwiO1xuICAgIHZhciBFUlJfTk9OX09CSkVDVF9UQVJHRVQgPSBcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eSBjYWxsZWQgb24gbm9uLW9iamVjdDogXCJcbiAgICB2YXIgRVJSX0FDQ0VTU09SU19OT1RfU1VQUE9SVEVEID0gXCJnZXR0ZXJzICYgc2V0dGVycyBjYW4gbm90IGJlIGRlZmluZWQgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm9uIHRoaXMgamF2YXNjcmlwdCBlbmdpbmVcIjtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIGRlc2NyaXB0b3IpIHtcbiAgICAgICAgaWYgKCh0eXBlb2Ygb2JqZWN0ICE9IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iamVjdCAhPSBcImZ1bmN0aW9uXCIpIHx8IG9iamVjdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihFUlJfTk9OX09CSkVDVF9UQVJHRVQgKyBvYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgodHlwZW9mIGRlc2NyaXB0b3IgIT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgZGVzY3JpcHRvciAhPSBcImZ1bmN0aW9uXCIpIHx8IGRlc2NyaXB0b3IgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRVJSX05PTl9PQkpFQ1RfREVTQ1JJUFRPUiArIGRlc2NyaXB0b3IpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1ha2UgYSB2YWxpYW50IGF0dGVtcHQgdG8gdXNlIHRoZSByZWFsIGRlZmluZVByb3BlcnR5XG4gICAgICAgIC8vIGZvciBJOCdzIERPTSBlbGVtZW50cy5cbiAgICAgICAgaWYgKGRlZmluZVByb3BlcnR5RmFsbGJhY2spIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmluZVByb3BlcnR5RmFsbGJhY2suY2FsbChPYmplY3QsIG9iamVjdCwgcHJvcGVydHksIGRlc2NyaXB0b3IpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gdHJ5IHRoZSBzaGltIGlmIHRoZSByZWFsIG9uZSBkb2Vzbid0IHdvcmtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGl0J3MgYSBkYXRhIHByb3BlcnR5LlxuICAgICAgICBpZiAob3ducyhkZXNjcmlwdG9yLCBcInZhbHVlXCIpKSB7XG4gICAgICAgICAgICAvLyBmYWlsIHNpbGVudGx5IGlmIFwid3JpdGFibGVcIiwgXCJlbnVtZXJhYmxlXCIsIG9yIFwiY29uZmlndXJhYmxlXCJcbiAgICAgICAgICAgIC8vIGFyZSByZXF1ZXN0ZWQgYnV0IG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAvLyBhbHRlcm5hdGUgYXBwcm9hY2g6XG4gICAgICAgICAgICBpZiAoIC8vIGNhbid0IGltcGxlbWVudCB0aGVzZSBmZWF0dXJlczsgYWxsb3cgZmFsc2UgYnV0IG5vdCB0cnVlXG4gICAgICAgICAgICAgICAgIShvd25zKGRlc2NyaXB0b3IsIFwid3JpdGFibGVcIikgPyBkZXNjcmlwdG9yLndyaXRhYmxlIDogdHJ1ZSkgfHxcbiAgICAgICAgICAgICAgICAhKG93bnMoZGVzY3JpcHRvciwgXCJlbnVtZXJhYmxlXCIpID8gZGVzY3JpcHRvci5lbnVtZXJhYmxlIDogdHJ1ZSkgfHxcbiAgICAgICAgICAgICAgICAhKG93bnMoZGVzY3JpcHRvciwgXCJjb25maWd1cmFibGVcIikgPyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA6IHRydWUpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiVGhpcyBpbXBsZW1lbnRhdGlvbiBvZiBPYmplY3QuZGVmaW5lUHJvcGVydHkgZG9lcyBub3QgXCIgK1xuICAgICAgICAgICAgICAgICAgICBcInN1cHBvcnQgY29uZmlndXJhYmxlLCBlbnVtZXJhYmxlLCBvciB3cml0YWJsZS5cIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICBpZiAoc3VwcG9ydHNBY2Nlc3NvcnMgJiYgKGxvb2t1cEdldHRlcihvYmplY3QsIHByb3BlcnR5KSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb29rdXBTZXR0ZXIob2JqZWN0LCBwcm9wZXJ0eSkpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIEFzIGFjY2Vzc29ycyBhcmUgc3VwcG9ydGVkIG9ubHkgb24gZW5naW5lcyBpbXBsZW1lbnRpbmdcbiAgICAgICAgICAgICAgICAvLyBgX19wcm90b19fYCB3ZSBjYW4gc2FmZWx5IG92ZXJyaWRlIGBfX3Byb3RvX19gIHdoaWxlIGRlZmluaW5nXG4gICAgICAgICAgICAgICAgLy8gYSBwcm9wZXJ0eSB0byBtYWtlIHN1cmUgdGhhdCB3ZSBkb24ndCBoaXQgYW4gaW5oZXJpdGVkXG4gICAgICAgICAgICAgICAgLy8gYWNjZXNzb3IuXG4gICAgICAgICAgICAgICAgdmFyIHByb3RvdHlwZSA9IG9iamVjdC5fX3Byb3RvX187XG4gICAgICAgICAgICAgICAgb2JqZWN0Ll9fcHJvdG9fXyA9IHByb3RvdHlwZU9mT2JqZWN0O1xuICAgICAgICAgICAgICAgIC8vIERlbGV0aW5nIGEgcHJvcGVydHkgYW55d2F5IHNpbmNlIGdldHRlciAvIHNldHRlciBtYXkgYmVcbiAgICAgICAgICAgICAgICAvLyBkZWZpbmVkIG9uIG9iamVjdCBpdHNlbGYuXG4gICAgICAgICAgICAgICAgZGVsZXRlIG9iamVjdFtwcm9wZXJ0eV07XG4gICAgICAgICAgICAgICAgb2JqZWN0W3Byb3BlcnR5XSA9IGRlc2NyaXB0b3IudmFsdWU7XG4gICAgICAgICAgICAgICAgLy8gU2V0dGluZyBvcmlnaW5hbCBgX19wcm90b19fYCBiYWNrIG5vdy5cbiAgICAgICAgICAgICAgICBvYmplY3QuX19wcm90b19fID0gcHJvdG90eXBlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvYmplY3RbcHJvcGVydHldID0gZGVzY3JpcHRvci52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghc3VwcG9ydHNBY2Nlc3NvcnMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEVSUl9BQ0NFU1NPUlNfTk9UX1NVUFBPUlRFRCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB3ZSBnb3QgdGhhdCBmYXIgdGhlbiBnZXR0ZXJzIGFuZCBzZXR0ZXJzIGNhbiBiZSBkZWZpbmVkICEhXG4gICAgICAgICAgICBpZiAob3ducyhkZXNjcmlwdG9yLCBcImdldFwiKSkge1xuICAgICAgICAgICAgICAgIGRlZmluZUdldHRlcihvYmplY3QsIHByb3BlcnR5LCBkZXNjcmlwdG9yLmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3ducyhkZXNjcmlwdG9yLCBcInNldFwiKSkge1xuICAgICAgICAgICAgICAgIGRlZmluZVNldHRlcihvYmplY3QsIHByb3BlcnR5LCBkZXNjcmlwdG9yLnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9O1xufVxuXG4vLyBFUzUgMTUuMi4zLjdcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjIuMy43XG5pZiAoIU9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIHx8IGRlZmluZVByb3BlcnRpZXNGYWxsYmFjaykge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhvYmplY3QsIHByb3BlcnRpZXMpIHtcbiAgICAgICAgLy8gbWFrZSBhIHZhbGlhbnQgYXR0ZW1wdCB0byB1c2UgdGhlIHJlYWwgZGVmaW5lUHJvcGVydGllc1xuICAgICAgICBpZiAoZGVmaW5lUHJvcGVydGllc0ZhbGxiYWNrKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0aWVzRmFsbGJhY2suY2FsbChPYmplY3QsIG9iamVjdCwgcHJvcGVydGllcyk7XG4gICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICAvLyB0cnkgdGhlIHNoaW0gaWYgdGhlIHJlYWwgb25lIGRvZXNuJ3Qgd29ya1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gcHJvcGVydGllcykge1xuICAgICAgICAgICAgaWYgKG93bnMocHJvcGVydGllcywgcHJvcGVydHkpICYmIHByb3BlcnR5ICE9IFwiX19wcm90b19fXCIpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSwgcHJvcGVydGllc1twcm9wZXJ0eV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfTtcbn1cblxuLy8gRVM1IDE1LjIuMy44XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS4yLjMuOFxuaWYgKCFPYmplY3Quc2VhbCkge1xuICAgIE9iamVjdC5zZWFsID0gZnVuY3Rpb24gc2VhbChvYmplY3QpIHtcbiAgICAgICAgLy8gdGhpcyBpcyBtaXNsZWFkaW5nIGFuZCBicmVha3MgZmVhdHVyZS1kZXRlY3Rpb24sIGJ1dFxuICAgICAgICAvLyBhbGxvd3MgXCJzZWN1cmFibGVcIiBjb2RlIHRvIFwiZ3JhY2VmdWxseVwiIGRlZ3JhZGUgdG8gd29ya2luZ1xuICAgICAgICAvLyBidXQgaW5zZWN1cmUgY29kZS5cbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9O1xufVxuXG4vLyBFUzUgMTUuMi4zLjlcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjIuMy45XG5pZiAoIU9iamVjdC5mcmVlemUpIHtcbiAgICBPYmplY3QuZnJlZXplID0gZnVuY3Rpb24gZnJlZXplKG9iamVjdCkge1xuICAgICAgICAvLyB0aGlzIGlzIG1pc2xlYWRpbmcgYW5kIGJyZWFrcyBmZWF0dXJlLWRldGVjdGlvbiwgYnV0XG4gICAgICAgIC8vIGFsbG93cyBcInNlY3VyYWJsZVwiIGNvZGUgdG8gXCJncmFjZWZ1bGx5XCIgZGVncmFkZSB0byB3b3JraW5nXG4gICAgICAgIC8vIGJ1dCBpbnNlY3VyZSBjb2RlLlxuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH07XG59XG5cbi8vIGRldGVjdCBhIFJoaW5vIGJ1ZyBhbmQgcGF0Y2ggaXRcbnRyeSB7XG4gICAgT2JqZWN0LmZyZWV6ZShmdW5jdGlvbiAoKSB7fSk7XG59IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICBPYmplY3QuZnJlZXplID0gKGZ1bmN0aW9uIGZyZWV6ZShmcmVlemVPYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGZyZWV6ZShvYmplY3QpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0ID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmcmVlemVPYmplY3Qob2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KShPYmplY3QuZnJlZXplKTtcbn1cblxuLy8gRVM1IDE1LjIuMy4xMFxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMi4zLjEwXG5pZiAoIU9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucykge1xuICAgIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyA9IGZ1bmN0aW9uIHByZXZlbnRFeHRlbnNpb25zKG9iamVjdCkge1xuICAgICAgICAvLyB0aGlzIGlzIG1pc2xlYWRpbmcgYW5kIGJyZWFrcyBmZWF0dXJlLWRldGVjdGlvbiwgYnV0XG4gICAgICAgIC8vIGFsbG93cyBcInNlY3VyYWJsZVwiIGNvZGUgdG8gXCJncmFjZWZ1bGx5XCIgZGVncmFkZSB0byB3b3JraW5nXG4gICAgICAgIC8vIGJ1dCBpbnNlY3VyZSBjb2RlLlxuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH07XG59XG5cbi8vIEVTNSAxNS4yLjMuMTFcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjIuMy4xMVxuaWYgKCFPYmplY3QuaXNTZWFsZWQpIHtcbiAgICBPYmplY3QuaXNTZWFsZWQgPSBmdW5jdGlvbiBpc1NlYWxlZChvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG59XG5cbi8vIEVTNSAxNS4yLjMuMTJcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjIuMy4xMlxuaWYgKCFPYmplY3QuaXNGcm96ZW4pIHtcbiAgICBPYmplY3QuaXNGcm96ZW4gPSBmdW5jdGlvbiBpc0Zyb3plbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG59XG5cbi8vIEVTNSAxNS4yLjMuMTNcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjIuMy4xM1xuaWYgKCFPYmplY3QuaXNFeHRlbnNpYmxlKSB7XG4gICAgT2JqZWN0LmlzRXh0ZW5zaWJsZSA9IGZ1bmN0aW9uIGlzRXh0ZW5zaWJsZShvYmplY3QpIHtcbiAgICAgICAgLy8gMS4gSWYgVHlwZShPKSBpcyBub3QgT2JqZWN0IHRocm93IGEgVHlwZUVycm9yIGV4Y2VwdGlvbi5cbiAgICAgICAgaWYgKE9iamVjdChvYmplY3QpICE9PSBvYmplY3QpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTsgLy8gVE9ETyBtZXNzYWdlXG4gICAgICAgIH1cbiAgICAgICAgLy8gMi4gUmV0dXJuIHRoZSBCb29sZWFuIHZhbHVlIG9mIHRoZSBbW0V4dGVuc2libGVdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBPLlxuICAgICAgICB2YXIgbmFtZSA9ICcnO1xuICAgICAgICB3aGlsZSAob3ducyhvYmplY3QsIG5hbWUpKSB7XG4gICAgICAgICAgICBuYW1lICs9ICc/JztcbiAgICAgICAgfVxuICAgICAgICBvYmplY3RbbmFtZV0gPSB0cnVlO1xuICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSBvd25zKG9iamVjdCwgbmFtZSk7XG4gICAgICAgIGRlbGV0ZSBvYmplY3RbbmFtZV07XG4gICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICB9O1xufVxuXG59KTtcblxufSkoKSIsInZhciBvYmogPSByZXF1aXJlKCcuLi9vYmplY3QnKSxcbiAgICBhcnJheSA9IHJlcXVpcmUoJy4uL2FycmF5JyksXG4gICAgYXBwbHkgPSBvYmouYXBwbHksXG4gICAgbWl4ID0gb2JqLm1peCxcbiAgICBvRmlsdGVyID0gb2JqLmZpbHRlcixcbiAgICBlbXB0eUZuID0gKCcuLi9mdW5jdGlvbicpLmVtcHR5Rm4sXG4gICAgaXMgPSByZXF1aXJlKCcuLi9pcycpO1xuXG4vKipcbiAqIEBjbGFzcyAgTHVjLkNvbXBvc2l0aW9uXG4gKiBAcHJvdGVjdGVkXG4gKiBDbGFzcyB0aGF0IHdyYXBzIHtAbGluayBMdWMuZGVmaW5lIyRjb21wb3NpdGlvbnMgY29tcG9zaXRpb259IGNvbmZpZyBvYmplY3RzXG4gKiB0byBjb25mb3JtIHRvIGFuIGFwaS4gVGhpcyBjbGFzcyBpcyBub3QgYXZhaWxhYmxlIGV4dGVybmFsbHkuICBUaGUgY29uZmlnIG9iamVjdFxuICogd2lsbCBvdmVycmlkZSBhbnkgcHJvdGVjdGVkIG1ldGhvZHMgYW5kIGRlZmF1bHQgY29uZmlncy4gIERlZmF1bHRzXG4gKiBjYW4gYmUgdXNlZCBmb3Igb2Z0ZW4gdXNlZCBjb25maWdzLCBrZXlzIHRoYXQgYXJlIG5vdCBkZWZhdWx0cyB3aWxsXG4gKiBvdmVycmlkZSB0aGUgZGVmYXVsdHMuXG4gKlxuICAgIHZhciBDID0gTHVjLmRlZmluZSh7XG4gICAgICAgICRjb21wb3NpdGlvbnM6IHtcbiAgICAgICAgICAgIGRlZmF1bHRzOiBMdWMuY29tcG9zaXRpb25FbnVtcy5FdmVudEVtaXR0ZXIsXG4gICAgICAgICAgICBtZXRob2RzOiBbJ2VtaXQnXVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgYyA9IG5ldyBDKClcbiAgICB0eXBlb2YgYy5lbWl0XG4gICAgPlwiZnVuY3Rpb25cIlxuICAgIHR5cGVvZiBjLm9uXG4gICAgPlwidW5kZWZpbmVkXCJcbiAqXG4gKiBJZiB5b3Ugd2FudCB0byBhZGQgeW91ciBvd24gY29tcG9zaXRpb24gYWxsIHlvdSBuZWVkIHRvIGhhdmUgaXNcbiAqIGEgbmFtZSBhbmQgYSBDb25zdHJ1Y3RvciwgdGhlIHJlc3Qgb2YgdGhlIGNvbmZpZ3Mgb2YgdGhpcyBjbGFzcyBhbmQgTHVjLkNvbXBvc2l0aW9uLmNyZWF0ZVxuICogY2FuIGJlIHVzZWQgdG8gaW5qZWN0IGJlaGF2aW9yIGlmIG5lZWRlZC5cbiAqIFxuICAgICBmdW5jdGlvbiBDb3VudGVyKCkge1xuICAgICAgICB0aGlzLmNvdW50ID0gMDtcbiAgICAgfTtcblxuICAgICBDb3VudGVyLnByb3RvdHlwZSA9IHtcbiAgICAgICAgZ2V0Q291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY291bnQ7XG4gICAgICAgIH0sXG4gICAgICAgIGluY3JlYXNlQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5jb3VudCsrO1xuICAgICAgICB9XG4gICAgIH1cblxuICAgICB2YXIgQyA9IEx1Yy5kZWZpbmUoe1xuICAgICAgICAgICAgJGNvbXBvc2l0aW9uczoge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdjb3VudGVyJyxcbiAgICAgICAgICAgICAgICBDb25zdHJ1Y3RvcjogQ291bnRlcixcbiAgICAgICAgICAgICAgICBtZXRob2RzOiAnYWxsTWV0aG9kcydcbiAgICAgICAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBjID0gbmV3IEMoKVxuXG4gICAgYy5pbmNyZWFzZUNvdW50KCk7XG4gICAgYy5pbmNyZWFzZUNvdW50KCk7XG4gICAgYy5pbmNyZWFzZUNvdW50KCk7XG4gICAgYy5nZXRDb3VudCgpO1xuICAgID4zXG4gICAgYy5jb3VudFxuICAgID51bmRlZmluZWRcbiAqL1xuZnVuY3Rpb24gQ29tcG9zaXRpb24oYykge1xuICAgIHZhciBkZWZhdWx0cyA9IGMuZGVmYXVsdHMsXG4gICAgICAgIGNvbmZpZyA9IGM7XG5cbiAgICBpZihkZWZhdWx0cykge1xuICAgICAgICBtaXgoY29uZmlnLCBjb25maWcuZGVmYXVsdHMpO1xuICAgICAgICBkZWxldGUgY29uZmlnLmRlZmF1bHRzO1xuICAgIH1cblxuICAgIGFwcGx5KHRoaXMsIGNvbmZpZyk7XG59XG5cbkNvbXBvc2l0aW9uLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBAY2ZnIHtTdHJpbmd9IG5hbWUgKHJlcXVpcmVkKSB0aGUgbmFtZSB3aGljaCB0aGUgY29tcG9zaXRpb25cbiAgICAgKiB3aWxsIGJlIHJlZmVycmVkIHRvIGJ5IHRoZSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBcbiAgICAvKipcbiAgICAgKiBAY2ZnIHtPYmplY3R9IGRlZmF1bHRzXG4gICAgICovXG4gICAgXG4gICAgLyoqXG4gICAgICogQGNmZyB7Qm9vbGVhbn0gaW5pdEFmdGVyICBkZWZhdWx0cyB0byBmYWxzZVxuICAgICAqIHBhc3MgaW4gdHJ1ZSB0byBpbml0IHRoZSBjb21wb3NpdGlvbiBpbnN0YW5jZSBhZnRlciB0aGUgXG4gICAgICogc3VwZXJjbGFzcyBoYXMgYmVlbiBjYWxsZWQuXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAY2ZnIHtGdW5jdGlvbn0gQ29uc3RydWN0b3IgKHJlcXVpcmVkKSB0aGUgQ29uc3RydWN0b3JcbiAgICAgKiB0byB1c2Ugd2hlbiBjcmVhdGluZyB0aGUgY29tcG9zaXRpb24gaW5zdGFuY2UuICBUaGlzXG4gICAgICogaXMgcmVxdWlyZWQgaWYgTHVjLkNvbXBvc2l0aW9uLmNyZWF0ZSBpcyBub3Qgb3ZlcndyaXR0ZW4gYnlcbiAgICAgKiB0aGUgcGFzc2VkIGluIGNvbXBvc2l0aW9uIGNvbmZpZyBvYmplY3QuXG4gICAgICovXG4gICAgXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEJ5IGRlZmF1bHQganVzdCByZXR1cm4gYSBuZXdseSBjcmVhdGVkIENvbnN0cnVjdG9yIGluc3RhbmNlLlxuICAgICAqIFxuICAgICAqIFdoZW4gY3JlYXRlIGlzIGNhbGxlZCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMgY2FuIGJlIHVzZWQgOlxuICAgICAqIFxuICAgICAqIHRoaXMuaW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgaXMgY3JlYXRpbmdcbiAgICAgKiB0aGUgY29tcG9zaXRpb24uXG4gICAgICogXG4gICAgICogdGhpcy5Db25zdHJ1Y3RvciB0aGUgY29uc3RydWN0b3IgdGhhdCBpcyBwYXNzZWQgaW4gZnJvbVxuICAgICAqIHRoZSBjb21wb3NpdGlvbiBjb25maWcuIFxuICAgICAqXG4gICAgICogdGhpcy5pbnN0YW5jZUFyZ3MgdGhlIGFyZ3VtZW50cyBwYXNzZWQgaW50byB0aGUgaW5zdGFuY2Ugd2hlbiBpdCBcbiAgICAgKiBpcyBiZWluZyBjcmVhdGVkLiAgRm9yIGV4YW1wbGVcblxuICAgICAgICBuZXcgTXlDbGFzc1dpdGhBQ29tcG9zaXRpb24oe3BsdWdpbnM6IFtdfSlcbiAgICAgICAgLy9pbnNpZGUgb2YgdGhlIGNyZWF0ZSBtZXRob2RcbiAgICAgICAgdGhpcy5pbnN0YW5jZUFyZ3NcbiAgICAgICAgPlt7cGx1Z2luczogW119XVxuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBcbiAgICAgKiB0aGUgY29tcG9zaXRpb24gaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBGb3IgZXhhbXBsZSBzZXQgdGhlIGVtaXR0ZXJzIG1heExpc3RlbmVyc1xuICAgICAqIHRvIHdoYXQgdGhlIGluc3RhbmNlIGhhcyBjb25maWdlZC5cbiAgICAgIFxuICAgICAgICBtYXhMaXN0ZW5lcnM6IDEwMCxcbiAgICAgICAgJGNvbXBvc2l0aW9uczoge1xuICAgICAgICAgICAgQ29uc3RydWN0b3I6IEx1Yy5FdmVudEVtaXR0ZXIsXG4gICAgICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBlbWl0dGVyID0gbmV3IHRoaXMuQ29uc3RydWN0b3IoKTtcbiAgICAgICAgICAgICAgICBlbWl0dGVyLnNldE1heExpc3RlbmVycyh0aGlzLmluc3RhbmNlLm1heExpc3RlbmVycyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVtaXR0ZXI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmFtZTogJ2VtaXR0ZXInXG4gICAgICAgIH1cblxuICAgICAqL1xuICAgIGNyZWF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBDb25zdHJ1Y3RvciA9IHRoaXMuQ29uc3RydWN0b3I7XG4gICAgICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IoKTtcbiAgICB9LFxuXG4gICAgZ2V0SW5zdGFuY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGUoKTtcbiAgICB9LFxuXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZih0aGlzLm5hbWUgID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQSBuYW1lIG11c3QgYmUgZGVmaW5lZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmKCFpcy5pc0Z1bmN0aW9uKHRoaXMuQ29uc3RydWN0b3IpICYmIHRoaXMuY3JlYXRlID09PSBDb21wb3NpdGlvbi5wcm90b3R5cGUuY3JlYXRlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBDb25zdHJ1Y3RvciBtdXN0IGJlIGZ1bmN0aW9uIGlmIGNyZWF0ZSBpcyBub3Qgb3ZlcnJpZGRlbicpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBmaWx0ZXJNZXRob2RGbnNcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSBmaWx0ZXJNZXRob2RGbnMuYWxsTWV0aG9kcyByZXR1cm4gYWxsIG1ldGhvZHMgZnJvbSB0aGVcbiAgICAgKiBjb25zdHJ1Y3RvcnMgcHJvdG90eXBlXG4gICAgICogQHByb3BlcnR5IGZpbHRlck1ldGhvZEZucy5wdWJsaWMgcmV0dXJuIGFsbCBtZXRob2RzIHRoYXQgZG9uJ3RcbiAgICAgKiBzdGFydCB3aXRoIF8uICBXZSBrbm93IG5vdCBldmVyeW9uZSBmb2xsb3dzIHRoaXMgY29udmVudGlvbiwgYnV0IHdlXG4gICAgICogZG8gYW5kIHNvIGRvIG1hbnkgb3RoZXJzLlxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBmaWx0ZXJNZXRob2RGbnM6IHtcbiAgICAgICAgYWxsTWV0aG9kczogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzLmlzRnVuY3Rpb24odmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBwdWJsaWNNZXRob2RzOiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gaXMuaXNGdW5jdGlvbih2YWx1ZSkgJiYga2V5LmNoYXJBdCgwKSAhPT0gJ18nO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBjZmcge0Z1bmN0aW9uL1N0cmluZy9BcnJheVtdfSBtZXRob2RzXG4gICAgICogVGhlIGtleXMgdG8gYWRkIHRvIHRoZSBkZWZpbmVycyBwcm90b3R5cGUgdGhhdCB3aWxsIGluIHR1cm4gY2FsbFxuICAgICAqIHRoZSBjb21wb3NpdGlvbnMgbWV0aG9kLlxuICAgICAqIFxuICAgICAqIERlZmF1bHRzIHRvIEx1Yy5lbXB0eUZuLiBcbiAgICAgKiBJZiBhbiBhcnJheSBpcyBwYXNzZWQgaXQgd2lsbCBqdXN0IHVzZSB0aGF0IEFycmF5LlxuICAgICAqIFxuICAgICAqIElmIGEgc3RyaW5nIGlzIHBhc3NlZCBhbmQgbWF0Y2hlcyBhIG1ldGhvZCBmcm9tIFxuICAgICAqIEx1Yy5Db21wb3NpdGlvbi5maWx0ZXJNZXRob2RGbnMgaXQgd2lsbCBjYWxsIHRoYXQgaW5zdGVhZC5cbiAgICAgKiBcbiAgICAgKiBJZiBhIGZ1bmN0aW9uIGlzIGRlZmluZWQgaXRcbiAgICAgKiB3aWxsIGdldCBjYWxsZWQgd2hpbGUgaXRlcmF0aW5nIG92ZXIgZWFjaCBrZXkgdmFsdWUgcGFpciBvZiB0aGUgXG4gICAgICogQ29uc3RydWN0b3IncyBwcm90b3R5cGUsIGlmIGEgdHJ1dGh5IHZhbHVlIGlzIFxuICAgICAqIHJldHVybmVkIHRoZSBwcm9wZXJ0eSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBkZWZpbmluZ1xuICAgICAqIGNsYXNzZXMgcHJvdG90eXBlLlxuICAgICAqIFxuICAgICAqIEZvciBleGFtcGxlIHRoaXMgY29uZmlnIHdpbGwgb25seSBleHBvc2UgdGhlIGVtaXQgbWV0aG9kIFxuICAgICAqIHRvIHRoZSBkZWZpbmluZyBjbGFzc1xuICAgICBcbiAgICAgICAgJGNvbXBvc2l0aW9uczoge1xuICAgICAgICAgICAgQ29uc3RydWN0b3I6IEx1Yy5FdmVudEVtaXR0ZXIsXG4gICAgICAgICAgICBtZXRob2RzOiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleSA9PT0gJ2VtaXQnO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5hbWU6ICdlbWl0dGVyJ1xuICAgICAgICB9XG4gICAgICogdGhpcyBpcyBhbHNvIGEgdmFsaWQgY29uZmlnXG4gICAgICogXG4gICAgICAgICRjb21wb3NpdGlvbnM6IHtcbiAgICAgICAgICAgIENvbnN0cnVjdG9yOiBMdWMuRXZlbnRFbWl0dGVyLFxuICAgICAgICAgICAgbWV0aG9kczogWydlbWl0dGVyJ10sXG4gICAgICAgICAgICBuYW1lOiAnZW1pdHRlcidcbiAgICAgICAgfVxuICAgICAqIFxuICAgICAqL1xuICAgIG1ldGhvZHM6IGVtcHR5Rm4sXG5cbiAgICAvKipcbiAgICAgKiBAY2ZnIHtTdHJpbmdbXS9TdHJpbmd9IGlnbm9yZU1ldGhvZHMgbWV0aG9kcyB0aGF0IHdpbGwgYWx3YXlzXG4gICAgICogYmUgaWdub3JlZCBpZiBtZXRob2RzIGlzIG5vdCBhbiBBcnJheS5cbiAgICAgKlxuICAgICAgICBcbiAgICAgICAgdmFyIEMgPSBMdWMuZGVmaW5lKHtcbiAgICAgICAgICAgICAgICAkY29tcG9zaXRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRzOiBMdWMuY29tcG9zaXRpb25FbnVtcy5FdmVudEVtaXR0ZXIsXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZHM6ICdhbGxNZXRob2RzJyxcbiAgICAgICAgICAgICAgICAgICAgaWdub3JlTWV0aG9kczogWydlbWl0J11cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIGMgPSBuZXcgQygpO1xuICAgICAgICAgICAgdHlwZW9mIGMuZW1pdFxuICAgICAgICAgICAgPlwidW5kZWZpbmVkXCJcbiAgICAgKi9cbiAgICBpZ25vcmVNZXRob2RzOiB1bmRlZmluZWQsXG5cbiAgICBnZXRPYmplY3RXaXRoTWV0aG9kczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtZXRob2RzT2JqID0gdGhpcy5Db25zdHJ1Y3RvciAmJiB0aGlzLkNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgICAgICAgaWYgKHRoaXMuaWdub3JlTWV0aG9kcykge1xuICAgICAgICAgICAgbWV0aG9kc09iaiA9IGFwcGx5KHt9LCBtZXRob2RzT2JqKTtcbiAgICAgICAgICAgIGFycmF5LmVhY2godGhpcy5pZ25vcmVNZXRob2RzLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBtZXRob2RzT2JqW3ZhbHVlXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1ldGhvZHNPYmo7XG4gICAgfSxcblxuICAgIGdldE1ldGhvZHNUb0NvbXBvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbWV0aG9kcyA9IHRoaXMubWV0aG9kcyxcbiAgICAgICAgICAgIHBhaXJzVG9BZGQsXG4gICAgICAgICAgICBmaWx0ZXJGbjtcblxuXG4gICAgICAgIGlmIChpcy5pc0FycmF5KG1ldGhvZHMpKSB7XG4gICAgICAgICAgICBwYWlyc1RvQWRkID0gbWV0aG9kcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZpbHRlckZuID0gbWV0aG9kcztcblxuICAgICAgICAgICAgaWYgKGlzLmlzU3RyaW5nKG1ldGhvZHMpKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyRm4gPSB0aGlzLmZpbHRlck1ldGhvZEZuc1ttZXRob2RzXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9Db25zdHJ1Y3RvcnMgYXJlIG5vdCBuZWVkZWQgaWYgY3JlYXRlIGlzIG92ZXJ3cml0dGVuXG4gICAgICAgICAgICBwYWlyc1RvQWRkID0gb0ZpbHRlcih0aGlzLmdldE9iamVjdFdpdGhNZXRob2RzKCksIGZpbHRlckZuLCB0aGlzLCB7XG4gICAgICAgICAgICAgICAgb3duUHJvcGVydGllczogZmFsc2UsXG4gICAgICAgICAgICAgICAga2V5czogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFpcnNUb0FkZDtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvc2l0aW9uOyJdfQ==
;